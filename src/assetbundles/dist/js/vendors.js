(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors"],{

/***/ "./node_modules/apexcharts/dist/apexcharts.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/apexcharts/dist/apexcharts.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate, module) {/*!\n * ApexCharts v3.6.8\n * (c) 2018-2019 Juned Chhipa\n * Released under the MIT License.\n */\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/*\n ** Generic functions which are not dependent on ApexCharts\n */\nvar Utils =\n/*#__PURE__*/\nfunction () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, [{\n    key: \"shadeRGBColor\",\n    value: function shadeRGBColor(percent, color) {\n      var f = color.split(','),\n          t = percent < 0 ? 0 : 255,\n          p = percent < 0 ? percent * -1 : percent,\n          R = parseInt(f[0].slice(4)),\n          G = parseInt(f[1]),\n          B = parseInt(f[2]);\n      return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';\n    }\n  }, {\n    key: \"shadeHexColor\",\n    value: function shadeHexColor(percent, color) {\n      var f = parseInt(color.slice(1), 16),\n          t = percent < 0 ? 0 : 255,\n          p = percent < 0 ? percent * -1 : percent,\n          R = f >> 16,\n          G = f >> 8 & 0x00ff,\n          B = f & 0x0000ff;\n      return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);\n    } // beautiful color shading blending code\n    // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n\n  }, {\n    key: \"shadeColor\",\n    value: function shadeColor(p, color) {\n      if (color.length > 7) return this.shadeRGBColor(p, color);else return this.shadeHexColor(p, color);\n    }\n  }], [{\n    key: \"bind\",\n    value: function bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    }\n  }, {\n    key: \"isObject\",\n    value: function isObject(item) {\n      return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;\n    }\n  }, {\n    key: \"listToArray\",\n    value: function listToArray(list) {\n      var i,\n          array = [];\n\n      for (i = 0; i < list.length; i++) {\n        array[i] = list[i];\n      }\n\n      return array;\n    } // to extend defaults with user options\n    // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873\n\n  }, {\n    key: \"extend\",\n    value: function extend(target, source) {\n      var _this = this;\n\n      if (typeof Object.assign !== 'function') {\n\n        (function () {\n          Object.assign = function (target) {\n\n            if (target === undefined || target === null) {\n              throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n\n            for (var index = 1; index < arguments.length; index++) {\n              var _source = arguments[index];\n\n              if (_source !== undefined && _source !== null) {\n                for (var nextKey in _source) {\n                  if (_source.hasOwnProperty(nextKey)) {\n                    output[nextKey] = _source[nextKey];\n                  }\n                }\n              }\n            }\n\n            return output;\n          };\n        })();\n      }\n\n      var output = Object.assign({}, target);\n\n      if (this.isObject(target) && this.isObject(source)) {\n        Object.keys(source).forEach(function (key) {\n          if (_this.isObject(source[key])) {\n            if (!(key in target)) {\n              Object.assign(output, _defineProperty({}, key, source[key]));\n            } else {\n              output[key] = _this.extend(target[key], source[key]);\n            }\n          } else {\n            Object.assign(output, _defineProperty({}, key, source[key]));\n          }\n        });\n      }\n\n      return output;\n    }\n  }, {\n    key: \"extendArray\",\n    value: function extendArray(arrToExtend, resultArr) {\n      var extendedArr = [];\n      arrToExtend.map(function (item) {\n        extendedArr.push(Utils.extend(resultArr, item));\n      });\n      arrToExtend = extendedArr;\n      return arrToExtend;\n    } // If month counter exceeds 12, it starts again from 1\n\n  }, {\n    key: \"monthMod\",\n    value: function monthMod(month) {\n      return month % 12;\n    }\n  }, {\n    key: \"addProps\",\n    value: function addProps(obj, arr, val) {\n      if (typeof arr === 'string') {\n        arr = arr.split('.');\n      }\n\n      obj[arr[0]] = obj[arr[0]] || {};\n      var tmpObj = obj[arr[0]];\n\n      if (arr.length > 1) {\n        arr.shift();\n        this.addProps(tmpObj, arr, val);\n      } else {\n        obj[arr[0]] = val;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(source) {\n      if (Object.prototype.toString.call(source) === '[object Array]') {\n        var cloneResult = [];\n\n        for (var i = 0; i < source.length; i++) {\n          cloneResult[i] = this.clone(source[i]);\n        }\n\n        return cloneResult;\n      } else if (_typeof(source) === 'object') {\n        var _cloneResult = {};\n\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            _cloneResult[prop] = this.clone(source[prop]);\n          }\n        }\n\n        return _cloneResult;\n      } else {\n        return source;\n      }\n    }\n  }, {\n    key: \"log10\",\n    value: function log10(x) {\n      return Math.log(x) / Math.LN10;\n    }\n  }, {\n    key: \"roundToBase10\",\n    value: function roundToBase10(x) {\n      return Math.pow(10, Math.floor(Math.log10(x)));\n    }\n  }, {\n    key: \"roundToBase\",\n    value: function roundToBase(x, base) {\n      return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));\n    }\n  }, {\n    key: \"parseNumber\",\n    value: function parseNumber(val) {\n      if (val === null) return val;\n      return parseFloat(val);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions(el) {\n      var computedStyle = getComputedStyle(el);\n      var ret = [];\n      var elementHeight = el.clientHeight;\n      var elementWidth = el.clientWidth;\n      elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n      elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n      ret.push(elementWidth);\n      ret.push(elementHeight);\n      return ret;\n    }\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect(element) {\n      var rect = element.getBoundingClientRect();\n      return {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        x: rect.x,\n        y: rect.y\n      };\n    } // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275\n\n  }, {\n    key: \"hexToRgba\",\n    value: function hexToRgba() {\n      var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';\n      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;\n\n      if (hex.substring(0, 1) !== '#') {\n        hex = '#999999';\n      }\n\n      var h = hex.replace('#', '');\n      h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));\n\n      for (var i = 0; i < h.length; i++) {\n        h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);\n      }\n\n      if (typeof opacity !== 'undefined') h.push(opacity);\n      return 'rgba(' + h.join(',') + ')';\n    }\n  }, {\n    key: \"getOpacityFromRGBA\",\n    value: function getOpacityFromRGBA(rgba) {\n      rgba = rgba.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n      return rgba[3];\n    }\n  }, {\n    key: \"rgb2hex\",\n    value: function rgb2hex(rgb) {\n      rgb = rgb.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n      return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n    }\n  }, {\n    key: \"isColorHex\",\n    value: function isColorHex(color) {\n      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);\n    }\n  }, {\n    key: \"polarToCartesian\",\n    value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n      return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians)\n      };\n    }\n  }, {\n    key: \"escapeString\",\n    value: function escapeString(str) {\n      var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n      var newStr = str.toString().slice();\n      newStr = newStr.replace(/[` ~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, escapeWith);\n      return newStr;\n    }\n  }, {\n    key: \"negToZero\",\n    value: function negToZero(val) {\n      return val < 0 ? 0 : val;\n    }\n  }, {\n    key: \"moveIndexInArray\",\n    value: function moveIndexInArray(arr, old_index, new_index) {\n      if (new_index >= arr.length) {\n        var k = new_index - arr.length + 1;\n\n        while (k--) {\n          arr.push(undefined);\n        }\n      }\n\n      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\n      return arr;\n    }\n  }, {\n    key: \"extractNumber\",\n    value: function extractNumber(s) {\n      return parseFloat(s.replace(/[^\\d\\.]*/g, ''));\n    }\n  }, {\n    key: \"randomString\",\n    value: function randomString(len) {\n      var text = '';\n      var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n      for (var i = 0; i < len; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n      }\n\n      return text;\n    }\n  }, {\n    key: \"findAncestor\",\n    value: function findAncestor(el, cls) {\n      while ((el = el.parentElement) && !el.classList.contains(cls)) {\n      }\n\n      return el;\n    }\n  }, {\n    key: \"setELstyles\",\n    value: function setELstyles(el, styles) {\n      for (var key in styles) {\n        if (styles.hasOwnProperty(key)) {\n          el.style.key = styles[key];\n        }\n      }\n    }\n  }, {\n    key: \"isNumber\",\n    value: function isNumber(value) {\n      return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));\n    }\n  }, {\n    key: \"isFloat\",\n    value: function isFloat(n) {\n      return Number(n) === n && n % 1 !== 0;\n    }\n  }, {\n    key: \"isSafari\",\n    value: function isSafari() {\n      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    }\n  }, {\n    key: \"isFirefox\",\n    value: function isFirefox() {\n      return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n    }\n  }, {\n    key: \"isIE11\",\n    value: function isIE11() {\n      if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) {\n        return true;\n      }\n    }\n  }, {\n    key: \"isIE\",\n    value: function isIE() {\n      var ua = window.navigator.userAgent;\n      var msie = ua.indexOf('MSIE ');\n\n      if (msie > 0) {\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n      }\n\n      var trident = ua.indexOf('Trident/');\n\n      if (trident > 0) {\n        // IE 11 => return version number\n        var rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n      }\n\n      var edge = ua.indexOf('Edge/');\n\n      if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n      } // other browser\n\n\n      return false;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/**\n * ApexCharts Filters Class for setting hover/active states on the paths.\n *\n * @module Formatters\n **/\n\nvar Filters =\n/*#__PURE__*/\nfunction () {\n  function Filters(ctx) {\n    _classCallCheck(this, Filters);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // create a re-usable filter which can be appended other filter effects and applied to multiple elements\n\n\n  _createClass(Filters, [{\n    key: \"getDefaultFilter\",\n    value: function getDefaultFilter(el) {\n      var w = this.w;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n\n      if (w.config.states.normal.filter !== 'none') {\n        this.applyFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);\n      } else {\n        if (w.config.chart.dropShadow.enabled) {\n          this.dropShadow(el, w.config.chart.dropShadow);\n        }\n      }\n    }\n  }, {\n    key: \"addNormalFilter\",\n    value: function addNormalFilter(el) {\n      var w = this.w;\n\n      if (w.config.chart.dropShadow.enabled) {\n        this.dropShadow(el, w.config.chart.dropShadow);\n      }\n    }\n  }, {\n    key: \"addDesaturateFilter\",\n    value: function addDesaturateFilter(el) {\n      var _this = this;\n\n      var w = this.w;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.colorMatrix('matrix', [0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 1.0, 0]).colorMatrix('saturate', 0);\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addLightenFilter\",\n    value: function addLightenFilter(el, attrs) {\n      var _this2 = this;\n\n      var w = this.w;\n      var intensity = attrs.intensity;\n\n      if (Utils.isFirefox()) {\n        return;\n      }\n\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this2.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.componentTransfer({\n          rgb: {\n            type: 'linear',\n            slope: 1.5,\n            intercept: intensity\n          }\n        });\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addDarkenFilter\",\n    value: function addDarkenFilter(el, attrs) {\n      var _this3 = this;\n\n      var w = this.w;\n      var intensity = attrs.intensity;\n\n      if (Utils.isFirefox()) {\n        return;\n      }\n\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this3.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.componentTransfer({\n          rgb: {\n            type: 'linear',\n            slope: intensity\n          }\n        });\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    }\n  }, {\n    key: \"applyFilter\",\n    value: function applyFilter(el, filter) {\n      var intensity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n\n      switch (filter) {\n        case 'none':\n          {\n            this.addNormalFilter(el);\n            break;\n          }\n\n        case 'lighten':\n          {\n            this.addLightenFilter(el, {\n              intensity: intensity\n            });\n            break;\n          }\n\n        case 'darken':\n          {\n            this.addDarkenFilter(el, {\n              intensity: intensity\n            });\n            break;\n          }\n\n        case 'desaturate':\n          {\n            this.addDesaturateFilter(el);\n            break;\n          }\n\n        default:\n          // do nothing\n          break;\n      }\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addShadow\",\n    value: function addShadow(add, attrs) {\n      var blur = attrs.blur,\n          top = attrs.top,\n          left = attrs.left,\n          color = attrs.color,\n          opacity = attrs.opacity;\n      var shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n      return add.blend(add.source, shadowBlur);\n    } // directly adds dropShadow to the element and returns the same element.\n    // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow\n\n  }, {\n    key: \"dropShadow\",\n    value: function dropShadow(el, attrs) {\n      var top = attrs.top,\n          left = attrs.left,\n          blur = attrs.blur,\n          color = attrs.color,\n          opacity = attrs.opacity,\n          noUserSpaceOnUse = attrs.noUserSpaceOnUse;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowBlur = null;\n\n        if (Utils.isSafari() || Utils.isFirefox() || Utils.isIE()) {\n          // safari/firefox has some alternative way to use this filter\n          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur);\n        } else {\n          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n        }\n\n        add.blend(add.source, shadowBlur);\n      });\n\n      if (!noUserSpaceOnUse) {\n        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n      }\n\n      return el;\n    }\n  }, {\n    key: \"setSelectionFilter\",\n    value: function setSelectionFilter(el, realIndex, dataPointIndex) {\n      var w = this.w;\n\n      if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {\n        if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {\n          el.node.setAttribute('selected', true);\n          var activeFilter = w.config.states.active.filter;\n\n          if (activeFilter !== 'none') {\n            this.applyFilter(el, activeFilter.type, activeFilter.value);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Filters;\n}();\n\n/**\n * ApexCharts Animation Class.\n *\n * @module Animations\n **/\n\nvar Animations =\n/*#__PURE__*/\nfunction () {\n  function Animations(ctx) {\n    _classCallCheck(this, Animations);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.setEasingFunctions();\n  }\n\n  _createClass(Animations, [{\n    key: \"setEasingFunctions\",\n    value: function setEasingFunctions() {\n      var easing;\n      var userDefinedEasing = this.w.config.chart.animations.easing;\n\n      switch (userDefinedEasing) {\n        case 'linear':\n          {\n            easing = '-';\n            break;\n          }\n\n        case 'easein':\n          {\n            easing = '<';\n            break;\n          }\n\n        case 'easeout':\n          {\n            easing = '>';\n            break;\n          }\n\n        case 'easeinout':\n          {\n            easing = '<>';\n            break;\n          }\n\n        case 'swing':\n          {\n            easing = function easing(pos) {\n              var s = 1.70158;\n              return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;\n            };\n\n            break;\n          }\n\n        case 'bounce':\n          {\n            easing = function easing(pos) {\n              if (pos < 1 / 2.75) {\n                return 7.5625 * pos * pos;\n              } else if (pos < 2 / 2.75) {\n                return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;\n              } else if (pos < 2.5 / 2.75) {\n                return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;\n              } else {\n                return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;\n              }\n            };\n\n            break;\n          }\n\n        case 'elastic':\n          {\n            easing = function easing(pos) {\n              if (pos === !!pos) return pos;\n              return Math.pow(2, -10 * pos) * Math.sin((pos - 0.075) * (2 * Math.PI) / 0.3) + 1;\n            };\n\n            break;\n          }\n\n        default:\n          {\n            easing = '<>';\n          }\n      }\n\n      this.w.globals.easing = easing;\n    }\n  }, {\n    key: \"animateLine\",\n    value: function animateLine(el, from, to, speed) {\n      el.attr(from).animate(speed).attr(to);\n    }\n    /*\n     ** Animate radius of a circle element\n     */\n\n  }, {\n    key: \"animateCircleRadius\",\n    value: function animateCircleRadius(el, from, to, speed, easing) {\n      if (!from) from = 0;\n      el.attr({\n        r: from\n      }).animate(speed, easing).attr({\n        r: to\n      });\n    }\n    /*\n     ** Animate radius and position of a circle element\n     */\n\n  }, {\n    key: \"animateCircle\",\n    value: function animateCircle(el, from, to, speed, easing) {\n      el.attr({\n        r: from.r,\n        cx: from.cx,\n        cy: from.cy\n      }).animate(speed, easing).attr({\n        r: to.r,\n        cx: to.cx,\n        cy: to.cy\n      });\n    }\n    /*\n     ** Animate rect properties\n     */\n\n  }, {\n    key: \"animateRect\",\n    value: function animateRect(el, from, to, speed, fn) {\n      el.attr(from).animate(speed).attr(to).afterAll(function () {\n        fn();\n      });\n    }\n  }, {\n    key: \"animatePathsGradually\",\n    value: function animatePathsGradually(params) {\n      var el = params.el,\n          j = params.j,\n          pathFrom = params.pathFrom,\n          pathTo = params.pathTo,\n          speed = params.speed,\n          delay = params.delay,\n          strokeWidth = params.strokeWidth;\n      var me = this;\n      var w = this.w;\n      var delayFactor = 0;\n\n      if (w.config.chart.animations.animateGradually.enabled) {\n        delayFactor = w.config.chart.animations.animateGradually.delay;\n      }\n\n      if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged) {\n        delayFactor = 0;\n      }\n\n      me.morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay * delayFactor);\n    }\n  }, {\n    key: \"showDelayedElements\",\n    value: function showDelayedElements() {\n      this.w.globals.delayedElements.forEach(function (d) {\n        var ele = d.el;\n        ele.classList.remove('hidden');\n      });\n    } // SVG.js animation for morphing one path to another\n\n  }, {\n    key: \"morphSVG\",\n    value: function morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay) {\n      var _this = this;\n\n      var w = this.w;\n\n      if (!pathFrom) {\n        pathFrom = el.attr('pathFrom');\n      }\n\n      if (!pathTo) {\n        pathTo = el.attr('pathTo');\n      }\n\n      if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {\n        pathFrom = \"M 0 \".concat(w.globals.gridHeight);\n        speed = 1;\n      }\n\n      if (pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {\n        pathTo = \"M 0 \".concat(w.globals.gridHeight);\n        speed = 1;\n      }\n\n      if (!w.globals.shouldAnimate) {\n        speed = 1;\n      }\n\n      el.plot(pathFrom).animate(1, w.globals.easing, delay).plot(pathFrom).animate(speed, w.globals.easing, delay).plot(pathTo).afterAll(function () {\n        // a flag to indicate that the original mount function can return true now as animation finished here\n        if (Utils.isNumber(j)) {\n          if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {\n            w.globals.animationEnded = true;\n          }\n        } else if (w.globals.shouldAnimate) {\n          w.globals.animationEnded = true;\n\n          if (typeof w.config.chart.events.animationEnd === 'function') {\n            w.config.chart.events.animationEnd(_this.ctx, w);\n          }\n        }\n\n        _this.showDelayedElements();\n      });\n    }\n  }]);\n\n  return Animations;\n}();\n\n/**\n * ApexCharts Graphics Class for all drawing operations.\n *\n * @module Graphics\n **/\n\nvar Graphics =\n/*#__PURE__*/\nfunction () {\n  function Graphics(ctx) {\n    _classCallCheck(this, Graphics);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Graphics, [{\n    key: \"drawLine\",\n    value: function drawLine(x1, y1, x2, y2) {\n      var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';\n      var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n      var w = this.w;\n      var line = w.globals.dom.Paper.line().attr({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        stroke: lineColor,\n        'stroke-dasharray': dashArray,\n        'stroke-width': strokeWidth\n      });\n      return line;\n    }\n  }, {\n    key: \"drawRect\",\n    value: function drawRect() {\n      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';\n      var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n      var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n      var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n      var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n      var w = this.w;\n      var rect = w.globals.dom.Paper.rect();\n      rect.attr({\n        x: x1,\n        y: y1,\n        width: x2 > 0 ? x2 : 0,\n        height: y2 > 0 ? y2 : 0,\n        rx: radius,\n        ry: radius,\n        fill: color,\n        opacity: opacity,\n        'stroke-width': strokeWidth !== null ? strokeWidth : 0,\n        stroke: strokeColor !== null ? strokeColor : 'none',\n        'stroke-dasharray': strokeDashArray\n      });\n      return rect;\n    }\n  }, {\n    key: \"drawPolygon\",\n    value: function drawPolygon(polygonString) {\n      var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';\n      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n      var w = this.w;\n      var polygon = w.globals.dom.Paper.polygon(polygonString).attr({\n        fill: fill,\n        stroke: stroke\n      });\n      return polygon;\n    }\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(radius) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var w = this.w;\n      var c = w.globals.dom.Paper.circle(radius * 2);\n\n      if (attrs !== null) {\n        c.attr(attrs);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(_ref) {\n      var _ref$d = _ref.d,\n          d = _ref$d === void 0 ? '' : _ref$d,\n          _ref$stroke = _ref.stroke,\n          stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,\n          _ref$strokeWidth = _ref.strokeWidth,\n          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,\n          fill = _ref.fill,\n          _ref$fillOpacity = _ref.fillOpacity,\n          fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,\n          _ref$strokeOpacity = _ref.strokeOpacity,\n          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,\n          classes = _ref.classes,\n          _ref$strokeLinecap = _ref.strokeLinecap,\n          strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,\n          _ref$strokeDashArray = _ref.strokeDashArray,\n          strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;\n      var w = this.w;\n\n      if (strokeLinecap === null) {\n        strokeLinecap = w.config.stroke.lineCap;\n      }\n\n      if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {\n        d = \"M 0 \".concat(w.globals.gridHeight);\n      }\n\n      var p = w.globals.dom.Paper.path(d).attr({\n        fill: fill,\n        'fill-opacity': fillOpacity,\n        stroke: stroke,\n        'stroke-opacity': strokeOpacity,\n        'stroke-linecap': strokeLinecap,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': strokeDashArray,\n        class: classes\n      });\n      return p;\n    }\n  }, {\n    key: \"group\",\n    value: function group() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var w = this.w;\n      var g = w.globals.dom.Paper.group();\n\n      if (attrs !== null) {\n        g.attr(attrs);\n      }\n\n      return g;\n    }\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      var move = ['M', x, y].join(' ');\n      return move;\n    }\n  }, {\n    key: \"line\",\n    value: function line(x, y) {\n      var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var line = null;\n\n      if (hORv === null) {\n        line = ['L', x, y].join(' ');\n      } else if (hORv === 'H') {\n        line = ['H', x].join(' ');\n      } else if (hORv === 'V') {\n        line = ['V', y].join(' ');\n      }\n\n      return line;\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(x1, y1, x2, y2, x, y) {\n      var curve = ['C', x1, y1, x2, y2, x, y].join(' ');\n      return curve;\n    }\n  }, {\n    key: \"quadraticCurve\",\n    value: function quadraticCurve(x1, y1, x, y) {\n      var curve = ['Q', x1, y1, x, y].join(' ');\n      return curve;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {\n      var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      var coord = 'A';\n      if (relative) coord = 'a';\n      var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');\n      return arc;\n    }\n    /**\n     * @memberof Graphics\n     * @param {object}\n     *  i = series's index\n     *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating \"i\" may change in loops, but realIndex doesn't\n     *  pathFrom = existing pathFrom to animateTo\n     *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo\n     *  stroke = line Color\n     *  strokeWidth = width of path Line\n     *  fill = it can be gradient, single color, pattern or image\n     *  animationDelay = how much to delay when starting animation (in milliseconds)\n     *  dataChangeSpeed = for dynamic animations, when data changes\n     *  className = class attribute to add\n     * @return {object} svg.js path object\n     **/\n\n  }, {\n    key: \"renderPaths\",\n    value: function renderPaths(_ref2) {\n      var i = _ref2.i,\n          j = _ref2.j,\n          realIndex = _ref2.realIndex,\n          pathFrom = _ref2.pathFrom,\n          pathTo = _ref2.pathTo,\n          stroke = _ref2.stroke,\n          strokeWidth = _ref2.strokeWidth,\n          strokeLinecap = _ref2.strokeLinecap,\n          fill = _ref2.fill,\n          animationDelay = _ref2.animationDelay,\n          initialSpeed = _ref2.initialSpeed,\n          dataChangeSpeed = _ref2.dataChangeSpeed,\n          className = _ref2.className,\n          id = _ref2.id,\n          _ref2$shouldClipToGri = _ref2.shouldClipToGrid,\n          shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,\n          _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,\n          bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat;\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var anim = new Animations(this.ctx);\n      var initialAnim = this.w.config.chart.animations.enabled;\n      var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n      var d;\n      var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);\n\n      if (shouldAnimate) {\n        d = pathFrom;\n      } else {\n        d = pathTo;\n        this.w.globals.animationEnded = true;\n      }\n\n      var strokeDashArrayOpt = w.config.stroke.dashArray;\n      var strokeDashArray = 0;\n\n      if (Array.isArray(strokeDashArrayOpt)) {\n        strokeDashArray = strokeDashArrayOpt[realIndex];\n      } else {\n        strokeDashArray = w.config.stroke.dashArray;\n      }\n\n      var el = this.drawPath({\n        d: d,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        fill: fill,\n        fillOpacity: 1,\n        classes: className,\n        strokeLinecap: strokeLinecap,\n        strokeDashArray: strokeDashArray\n      });\n      el.attr('id', \"\".concat(id, \"-\").concat(i));\n      el.attr('index', realIndex);\n\n      if (shouldClipToGrid) {\n        el.attr({\n          'clip-path': \"url(#gridRectMask\".concat(w.globals.cuid, \")\")\n        });\n      } // const defaultFilter = el.filterer\n\n\n      if (w.config.states.normal.filter.type !== 'none') {\n        filters.getDefaultFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);\n      } else {\n        if (w.config.chart.dropShadow.enabled) {\n          if (!w.config.chart.dropShadow.enabledSeries || w.config.chart.dropShadow.enabledSeries && w.config.chart.dropShadow.enabledSeries.indexOf(realIndex) !== -1) {\n            var shadow = w.config.chart.dropShadow;\n            filters.dropShadow(el, shadow);\n          }\n        }\n      }\n\n      if (bindEventsOnPaths) {\n        el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));\n        el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));\n        el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));\n      }\n\n      el.attr({\n        pathTo: pathTo,\n        pathFrom: pathFrom\n      });\n      var defaultAnimateOpts = {\n        el: el,\n        j: j,\n        pathFrom: pathFrom,\n        pathTo: pathTo,\n        strokeWidth: strokeWidth\n      };\n\n      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {\n          speed: initialSpeed,\n          delay: animationDelay\n        }));\n      } else {\n        if (w.globals.resized || !w.globals.dataChanged) {\n          anim.showDelayedElements();\n        }\n      }\n\n      if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {\n        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {\n          speed: dataChangeSpeed\n        }));\n      }\n\n      return el;\n    }\n  }, {\n    key: \"drawPattern\",\n    value: function drawPattern(style, width, height) {\n      var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';\n      var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var w = this.w;\n      var p = w.globals.dom.Paper.pattern(width, height, function (add) {\n        if (style === 'horizontalLines') {\n          add.line(0, 0, height, 0).stroke({\n            color: stroke,\n            width: strokeWidth + 1\n          });\n        } else if (style === 'verticalLines') {\n          add.line(0, 0, 0, width).stroke({\n            color: stroke,\n            width: strokeWidth + 1\n          });\n        } else if (style === 'slantedLines') {\n          add.line(0, 0, width, height).stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        } else if (style === 'squares') {\n          add.rect(width, height).fill('none').stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        } else if (style === 'circles') {\n          add.circle(width).fill('none').stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        }\n      });\n      return p;\n    }\n  }, {\n    key: \"drawGradient\",\n    value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {\n      var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n      var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n      var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n      var w = this.w;\n      var g;\n      gfrom = Utils.hexToRgba(gfrom, opacityFrom);\n      gto = Utils.hexToRgba(gto, opacityTo);\n      var stop1 = 0;\n      var stop2 = 1;\n      var stop3 = 1;\n      var stop4 = null;\n\n      if (stops !== null) {\n        stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;\n        stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;\n        stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;\n        stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;\n      }\n\n      var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'bubble');\n\n      if (colorStops === null || colorStops.length === 0) {\n        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n          stop.at(stop1, gfrom, opacityFrom);\n          stop.at(stop2, gto, opacityTo);\n          stop.at(stop3, gto, opacityTo);\n\n          if (stop4 !== null) {\n            stop.at(stop4, gfrom, opacityFrom);\n          }\n        });\n      } else {\n        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n          var stops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;\n          stops.forEach(function (s) {\n            stop.at(s.offset / 100, s.color, s.opacity);\n          });\n        });\n      }\n\n      if (!radial) {\n        if (style === 'vertical') {\n          g.from(0, 0).to(0, 1);\n        } else if (style === 'diagonal') {\n          g.from(0, 0).to(1, 1);\n        } else if (style === 'horizontal') {\n          g.from(0, 1).to(1, 1);\n        } else if (style === 'diagonal2') {\n          g.from(0, 1).to(2, 2);\n        }\n      } else {\n        var offx = w.globals.gridWidth / 2;\n        var offy = w.globals.gridHeight / 2;\n\n        if (w.config.chart.type !== 'bubble') {\n          g.attr({\n            gradientUnits: 'userSpaceOnUse',\n            cx: offx,\n            cy: offy,\n            r: size\n          });\n        } else {\n          g.attr({\n            cx: 0.5,\n            cy: 0.5,\n            r: 0.8,\n            fx: 0.2,\n            fy: 0.2\n          });\n        }\n      }\n\n      return g;\n    }\n  }, {\n    key: \"drawText\",\n    value: function drawText(opts) {\n      var w = this.w;\n      var x = opts.x,\n          y = opts.y,\n          text = opts.text,\n          textAnchor = opts.textAnchor,\n          fontSize = opts.fontSize,\n          fontFamily = opts.fontFamily,\n          foreColor = opts.foreColor,\n          opacity = opts.opacity;\n\n      if (!textAnchor) {\n        textAnchor = 'start';\n      }\n\n      if (!foreColor) {\n        foreColor = w.config.chart.foreColor;\n      }\n\n      fontFamily = fontFamily || w.config.chart.fontFamily;\n      var elText;\n\n      if (Array.isArray(text)) {\n        elText = w.globals.dom.Paper.text(function (add) {\n          for (var i = 0; i < text.length; i++) {\n            add.tspan(text[i]);\n          }\n        });\n      } else {\n        elText = w.globals.dom.Paper.plain(text);\n      }\n\n      elText.attr({\n        x: x,\n        y: y,\n        'text-anchor': textAnchor,\n        'dominant-baseline': 'auto',\n        'font-size': fontSize,\n        'font-family': fontFamily,\n        fill: foreColor,\n        class:  true ? opts.cssClass : undefined\n      });\n      elText.node.style.fontFamily = fontFamily;\n      elText.node.style.opacity = opacity;\n      return elText;\n    }\n  }, {\n    key: \"addTspan\",\n    value: function addTspan(textEl, text, fontFamily) {\n      var tspan = textEl.tspan(text);\n\n      if (!fontFamily) {\n        fontFamily = this.w.config.chart.fontFamily;\n      }\n\n      tspan.node.style.fontFamily = fontFamily;\n    }\n  }, {\n    key: \"drawMarker\",\n    value: function drawMarker(x, y, opts) {\n      x = x || 0;\n      var size = opts.pSize || 0;\n      var elPoint = null;\n\n      if (opts.shape === 'square') {\n        var radius = opts.pRadius === undefined ? size / 2 : opts.pRadius;\n\n        if (y === null) {\n          size = 0;\n          radius = 0;\n        }\n\n        var nSize = size * 1.2 + radius;\n        var p = this.drawRect(nSize, nSize, nSize, nSize, radius);\n        p.attr({\n          x: x - nSize / 2,\n          y: y - nSize / 2,\n          cx: x,\n          cy: y,\n          class: opts.class ? opts.class : '',\n          fill: opts.pointFillColor,\n          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n          stroke: opts.pointStrokeColor,\n          'stroke-width': opts.pWidth ? opts.pWidth : 0,\n          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n        });\n        elPoint = p;\n      } else if (opts.shape === 'circle') {\n        if (!Utils.isNumber(y)) {\n          size = 0;\n          y = 0;\n        } // let nSize = size - opts.pRadius / 2 < 0 ? 0 : size - opts.pRadius / 2\n\n\n        elPoint = this.drawCircle(size, {\n          cx: x,\n          cy: y,\n          class: opts.class ? opts.class : '',\n          stroke: opts.pointStrokeColor,\n          fill: opts.pointFillColor,\n          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n          'stroke-width': opts.pWidth ? opts.pWidth : 0,\n          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n        });\n      }\n\n      return elPoint;\n    }\n  }, {\n    key: \"pathMouseEnter\",\n    value: function pathMouseEnter(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n\n      if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {\n        w.config.chart.events.dataPointMouseEnter(e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointMouseEnter', [e, this.ctx, {\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]);\n\n      if (w.config.states.active.filter.type !== 'none') {\n        if (path.node.getAttribute('selected') === 'true') {\n          return;\n        }\n      }\n\n      if (w.config.states.hover.filter.type !== 'none') {\n        if (w.config.states.active.filter.type !== 'none' && !w.globals.isTouchDevice) {\n          var hoverFilter = w.config.states.hover.filter;\n          filters.applyFilter(path, hoverFilter.type, hoverFilter.value);\n        }\n      }\n    }\n  }, {\n    key: \"pathMouseLeave\",\n    value: function pathMouseLeave(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n\n      if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {\n        w.config.chart.events.dataPointMouseLeave(e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointMouseLeave', [e, this.ctx, {\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]);\n\n      if (w.config.states.active.filter.type !== 'none') {\n        if (path.node.getAttribute('selected') === 'true') {\n          return;\n        }\n      }\n\n      if (w.config.states.hover.filter.type !== 'none') {\n        filters.getDefaultFilter(path);\n      }\n    }\n  }, {\n    key: \"pathMouseDown\",\n    value: function pathMouseDown(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n      var selected = 'false';\n\n      if (path.node.getAttribute('selected') === 'true') {\n        path.node.setAttribute('selected', 'false');\n\n        if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {\n          var index = w.globals.selectedDataPoints[i].indexOf(j);\n          w.globals.selectedDataPoints[i].splice(index, 1);\n        }\n      } else {\n        if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {\n          w.globals.selectedDataPoints = [];\n          var elPaths = w.globals.dom.Paper.select('.apexcharts-series path').members;\n          var elCircles = w.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members;\n          elPaths.forEach(function (elPath) {\n            elPath.node.setAttribute('selected', 'false');\n            filters.getDefaultFilter(elPath);\n          });\n          elCircles.forEach(function (circle) {\n            circle.node.setAttribute('selected', 'false');\n            filters.getDefaultFilter(circle);\n          });\n        }\n\n        path.node.setAttribute('selected', 'true');\n        selected = 'true';\n\n        if (typeof w.globals.selectedDataPoints[i] === 'undefined') {\n          w.globals.selectedDataPoints[i] = [];\n        }\n\n        w.globals.selectedDataPoints[i].push(j);\n      }\n\n      if (selected === 'true') {\n        var activeFilter = w.config.states.active.filter;\n\n        if (activeFilter !== 'none') {\n          filters.applyFilter(path, activeFilter.type, activeFilter.value);\n        }\n      } else {\n        if (w.config.states.active.filter.type !== 'none') {\n          filters.getDefaultFilter(path);\n        }\n      }\n\n      if (typeof w.config.chart.events.dataPointSelection === 'function') {\n        w.config.chart.events.dataPointSelection(e, this.ctx, {\n          selectedDataPoints: w.globals.selectedDataPoints,\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointSelection', [e, this.ctx, {\n        selectedDataPoints: w.globals.selectedDataPoints,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]); // if (this.w.config.chart.selection.selectedPoints !== undefined) {\n      //   this.w.config.chart.selection.selectedPoints(w.globals.selectedDataPoints)\n      // }\n    }\n  }, {\n    key: \"rotateAroundCenter\",\n    value: function rotateAroundCenter(el) {\n      var coord = el.getBBox();\n      var x = coord.x + coord.width / 2;\n      var y = coord.y + coord.height / 2;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"getTextRects\",\n    value: function getTextRects(text, fontSize, fontFamily, transform) {\n      var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var w = this.w;\n      var virtualText = this.drawText({\n        x: -200,\n        y: -200,\n        text: text,\n        textAnchor: 'start',\n        fontSize: fontSize,\n        fontFamily: fontFamily,\n        foreColor: '#fff',\n        opacity: 0\n      });\n\n      if (transform) {\n        virtualText.attr('transform', transform);\n      }\n\n      w.globals.dom.Paper.add(virtualText);\n      var rect = virtualText.bbox();\n\n      if (!useBBox) {\n        rect = virtualText.node.getBoundingClientRect();\n      }\n\n      virtualText.remove();\n      return {\n        width: rect.width,\n        height: rect.height\n      };\n    }\n    /**\n     * append ... to long text\n     * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg\n     * @memberof Graphics\n     **/\n\n  }, {\n    key: \"placeTextWithEllipsis\",\n    value: function placeTextWithEllipsis(textObj, textString, width) {\n      textObj.textContent = textString;\n\n      if (textString.length > 0) {\n        // ellipsis is needed\n        if (textObj.getSubStringLength(0, textString.length) >= width) {\n          for (var x = textString.length - 3; x > 0; x -= 3) {\n            if (textObj.getSubStringLength(0, x) <= width) {\n              textObj.textContent = textString.substring(0, x) + '...';\n              return;\n            }\n          }\n\n          textObj.textContent = '...'; // can't place at all\n        }\n      }\n    }\n  }], [{\n    key: \"setAttrs\",\n    value: function setAttrs(el, attrs) {\n      for (var key in attrs) {\n        if (attrs.hasOwnProperty(key)) {\n          el.setAttribute(key, attrs[key]);\n        }\n      }\n    }\n  }]);\n\n  return Graphics;\n}();\n\nconst name = \"en\";\nconst options = {\n\tmonths: [\n\t\t\"January\",\n\t\t\"February\",\n\t\t\"March\",\n\t\t\"April\",\n\t\t\"May\",\n\t\t\"June\",\n\t\t\"July\",\n\t\t\"August\",\n\t\t\"September\",\n\t\t\"October\",\n\t\t\"November\",\n\t\t\"December\"\n\t],\n\tshortMonths: [\n\t\t\"Jan\",\n\t\t\"Feb\",\n\t\t\"Mar\",\n\t\t\"Apr\",\n\t\t\"May\",\n\t\t\"Jun\",\n\t\t\"Jul\",\n\t\t\"Aug\",\n\t\t\"Sep\",\n\t\t\"Oct\",\n\t\t\"Nov\",\n\t\t\"Dec\"\n\t],\n\tdays: [\n\t\t\"Sunday\",\n\t\t\"Monday\",\n\t\t\"Tuesday\",\n\t\t\"Wednesday\",\n\t\t\"Thursday\",\n\t\t\"Friday\",\n\t\t\"Saturday\"\n\t],\n\tshortDays: [\n\t\t\"Sun\",\n\t\t\"Mon\",\n\t\t\"Tue\",\n\t\t\"Wed\",\n\t\t\"Thu\",\n\t\t\"Fri\",\n\t\t\"Sat\"\n\t],\n\ttoolbar: {\n\t\texportToSVG: \"Download SVG\",\n\t\texportToPNG: \"Download PNG\",\n\t\tmenu: \"Menu\",\n\t\tselection: \"Selection\",\n\t\tselectionZoom: \"Selection Zoom\",\n\t\tzoomIn: \"Zoom In\",\n\t\tzoomOut: \"Zoom Out\",\n\t\tpan: \"Panning\",\n\t\treset: \"Reset Zoom\"\n\t}\n};\nvar en = {\n\tname: name,\n\toptions: options\n};\n\nvar Options =\n/*#__PURE__*/\nfunction () {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    this.yAxis = {\n      show: true,\n      showAlways: false,\n      seriesName: undefined,\n      opposite: false,\n      reversed: false,\n      logarithmic: false,\n      tickAmount: undefined,\n      forceNiceScale: false,\n      max: undefined,\n      min: undefined,\n      floating: false,\n      decimalsInFloat: 2,\n      labels: {\n        show: true,\n        minWidth: 0,\n        maxWidth: 160,\n        offsetX: 0,\n        offsetY: 0,\n        align: undefined,\n        rotate: 0,\n        padding: 20,\n        style: {\n          colors: [],\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: ''\n        },\n        formatter: undefined\n      },\n      axisBorder: {\n        show: false,\n        color: '#78909C',\n        offsetX: 0,\n        offsetY: 0\n      },\n      axisTicks: {\n        show: false,\n        color: '#78909C',\n        width: 6,\n        offsetX: 0,\n        offsetY: 0\n      },\n      title: {\n        text: undefined,\n        rotate: 90,\n        offsetY: 0,\n        offsetX: 0,\n        style: {\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: ''\n        }\n      },\n      tooltip: {\n        enabled: false,\n        offsetX: 0\n      },\n      crosshairs: {\n        show: true,\n        position: 'front',\n        stroke: {\n          color: '#b6b6b6',\n          width: 1,\n          dashArray: 0\n        }\n      }\n    };\n    this.xAxisAnnotation = {\n      x: 0,\n      x2: null,\n      strokeDashArray: 1,\n      fillColor: '#c2c2c2',\n      borderColor: '#c2c2c2',\n      opacity: 0.3,\n      offsetX: 0,\n      offsetY: 0,\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'middle',\n        orientation: 'vertical',\n        position: 'top',\n        offsetX: 0,\n        offsetY: 0,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 2,\n            bottom: 2\n          }\n        }\n      }\n    };\n    this.yAxisAnnotation = {\n      y: 0,\n      y2: null,\n      strokeDashArray: 1,\n      fillColor: '#c2c2c2',\n      borderColor: '#c2c2c2',\n      opacity: 0.3,\n      offsetX: 0,\n      offsetY: 0,\n      yAxisIndex: 0,\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'end',\n        position: 'right',\n        offsetX: 0,\n        offsetY: -3,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 0,\n            bottom: 2\n          }\n        }\n      }\n    };\n    this.pointAnnotation = {\n      x: 0,\n      y: null,\n      yAxisIndex: 0,\n      seriesIndex: 0,\n      marker: {\n        size: 0,\n        fillColor: '#fff',\n        strokeWidth: 2,\n        strokeColor: '#333',\n        shape: 'circle',\n        offsetX: 0,\n        offsetY: 0,\n        radius: 2,\n        cssClass: ''\n      },\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'middle',\n        offsetX: 0,\n        offsetY: -15,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 0,\n            bottom: 2\n          }\n        }\n      },\n      customSVG: {\n        SVG: undefined,\n        cssClass: undefined,\n        offsetX: 0,\n        offsetY: 0\n      }\n    };\n  }\n\n  _createClass(Options, [{\n    key: \"init\",\n    value: function init() {\n      return {\n        annotations: {\n          position: 'front',\n          yaxis: [this.yAxisAnnotation],\n          xaxis: [this.xAxisAnnotation],\n          points: [this.pointAnnotation]\n        },\n        chart: {\n          animations: {\n            enabled: true,\n            easing: 'easeinout',\n            // linear, easeout, easein, easeinout, swing, bounce, elastic\n            speed: 800,\n            animateGradually: {\n              delay: 150,\n              enabled: true\n            },\n            dynamicAnimation: {\n              enabled: true,\n              speed: 350\n            }\n          },\n          background: 'transparent',\n          locales: [en],\n          defaultLocale: 'en',\n          dropShadow: {\n            enabled: false,\n            enabledSeries: undefined,\n            top: 2,\n            left: 2,\n            blur: 4,\n            color: '#000',\n            opacity: 0.35\n          },\n          events: {\n            animationEnd: undefined,\n            beforeMount: undefined,\n            mounted: undefined,\n            updated: undefined,\n            click: undefined,\n            legendClick: undefined,\n            markerClick: undefined,\n            selection: undefined,\n            dataPointSelection: undefined,\n            dataPointMouseEnter: undefined,\n            dataPointMouseLeave: undefined,\n            beforeZoom: undefined,\n            zoomed: undefined,\n            scrolled: undefined\n          },\n          foreColor: '#373d3f',\n          fontFamily: 'Helvetica, Arial, sans-serif',\n          height: 'auto',\n          parentHeightOffset: 15,\n          id: undefined,\n          group: undefined,\n          offsetX: 0,\n          offsetY: 0,\n          selection: {\n            enabled: false,\n            type: 'x',\n            // selectedPoints: undefined, // default datapoints that should be selected automatically\n            fill: {\n              color: '#24292e',\n              opacity: 0.1\n            },\n            stroke: {\n              width: 1,\n              color: '#24292e',\n              opacity: 0.4,\n              dashArray: 3\n            },\n            xaxis: {\n              min: undefined,\n              max: undefined\n            },\n            yaxis: {\n              min: undefined,\n              max: undefined\n            }\n          },\n          sparkline: {\n            enabled: false\n          },\n          brush: {\n            enabled: false,\n            autoScaleYaxis: false,\n            target: undefined\n          },\n          stacked: false,\n          stackType: 'normal',\n          toolbar: {\n            show: true,\n            tools: {\n              download: true,\n              selection: true,\n              zoom: true,\n              zoomin: true,\n              zoomout: true,\n              pan: true,\n              reset: true,\n              customIcons: []\n            },\n            autoSelected: 'zoom' // accepts -> zoom, pan, selection\n\n          },\n          type: 'line',\n          width: '100%',\n          zoom: {\n            enabled: true,\n            type: 'x',\n            // autoScaleYaxis: false, // TODO: rewrite the autoScaleY function\n            zoomedArea: {\n              fill: {\n                color: '#90CAF9',\n                opacity: 0.4\n              },\n              stroke: {\n                color: '#0D47A1',\n                opacity: 0.4,\n                width: 1\n              }\n            }\n          }\n        },\n        plotOptions: {\n          bar: {\n            horizontal: false,\n            columnWidth: '70%',\n            // should be in percent 0 - 100\n            barHeight: '70%',\n            // should be in percent 0 - 100\n            distributed: false,\n            endingShape: 'flat',\n            colors: {\n              ranges: [],\n              backgroundBarColors: [],\n              backgroundBarOpacity: 1\n            },\n            dataLabels: {\n              maxItems: 100,\n              position: 'top' // top, center, bottom\n              // TODO: provide stackedLabels for stacked charts which gives additions of values\n\n            }\n          },\n          candlestick: {\n            colors: {\n              upward: '#00B746',\n              downward: '#EF403C'\n            },\n            wick: {\n              useFillColor: true\n            }\n          },\n          heatmap: {\n            radius: 2,\n            enableShades: true,\n            shadeIntensity: 0.5,\n            distributed: false,\n            colorScale: {\n              inverse: false,\n              ranges: [],\n              min: undefined,\n              max: undefined\n            }\n          },\n          radialBar: {\n            size: undefined,\n            inverseOrder: false,\n            startAngle: 0,\n            endAngle: 360,\n            offsetX: 0,\n            offsetY: 0,\n            hollow: {\n              margin: 5,\n              size: '50%',\n              background: 'transparent',\n              image: undefined,\n              imageWidth: 150,\n              imageHeight: 150,\n              imageOffsetX: 0,\n              imageOffsetY: 0,\n              imageClipped: true,\n              position: 'front',\n              dropShadow: {\n                enabled: false,\n                top: 0,\n                left: 0,\n                blur: 3,\n                color: '#000',\n                opacity: 0.5\n              }\n            },\n            track: {\n              show: true,\n              startAngle: undefined,\n              endAngle: undefined,\n              background: '#f2f2f2',\n              strokeWidth: '97%',\n              opacity: 1,\n              margin: 5,\n              // margin is in pixels\n              dropShadow: {\n                enabled: false,\n                top: 0,\n                left: 0,\n                blur: 3,\n                color: '#000',\n                opacity: 0.5\n              }\n            },\n            dataLabels: {\n              show: true,\n              name: {\n                show: true,\n                fontSize: '16px',\n                fontFamily: undefined,\n                color: undefined,\n                offsetY: 0\n              },\n              value: {\n                show: true,\n                fontSize: '14px',\n                fontFamily: undefined,\n                color: undefined,\n                offsetY: 16,\n                formatter: function formatter(val) {\n                  return val + '%';\n                }\n              },\n              total: {\n                show: false,\n                label: 'Total',\n                color: undefined,\n                formatter: function formatter(w) {\n                  return w.globals.seriesTotals.reduce(function (a, b) {\n                    return a + b;\n                  }, 0) / w.globals.series.length + '%';\n                }\n              }\n            }\n          },\n          rangeBar: {},\n          pie: {\n            size: undefined,\n            customScale: 1,\n            offsetX: 0,\n            offsetY: 0,\n            expandOnClick: true,\n            dataLabels: {\n              // These are the percentage values which are displayed on slice\n              offset: 0,\n              // offset by which labels will move outside\n              minAngleToShowLabel: 15\n            },\n            donut: {\n              size: '65%',\n              background: 'transparent',\n              labels: {\n                // These are the inner labels appearing inside donut\n                show: false,\n                name: {\n                  show: true,\n                  fontSize: '16px',\n                  fontFamily: undefined,\n                  color: undefined,\n                  offsetY: -10\n                },\n                value: {\n                  show: true,\n                  fontSize: '20px',\n                  fontFamily: undefined,\n                  color: undefined,\n                  offsetY: 10,\n                  formatter: function formatter(val) {\n                    return val;\n                  }\n                },\n                total: {\n                  show: false,\n                  label: 'Total',\n                  color: undefined,\n                  formatter: function formatter(w) {\n                    return w.globals.seriesTotals.reduce(function (a, b) {\n                      return a + b;\n                    }, 0);\n                  }\n                }\n              }\n            }\n          },\n          radar: {\n            size: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            polygons: {\n              // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2\n              strokeColors: '#e8e8e8',\n              connectorColors: '#e8e8e8',\n              fill: {\n                colors: undefined\n              }\n            }\n          }\n        },\n        colors: undefined,\n        dataLabels: {\n          enabled: true,\n          enabledOnSeries: undefined,\n          formatter: function formatter(val) {\n            return val;\n          },\n          textAnchor: 'middle',\n          offsetX: 0,\n          offsetY: 0,\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined,\n            colors: undefined\n          },\n          dropShadow: {\n            enabled: false,\n            top: 1,\n            left: 1,\n            blur: 1,\n            color: '#000',\n            opacity: 0.45\n          }\n        },\n        fill: {\n          type: 'solid',\n          colors: undefined,\n          // array of colors\n          opacity: 0.85,\n          gradient: {\n            shade: 'dark',\n            type: 'horizontal',\n            shadeIntensity: 0.5,\n            gradientToColors: undefined,\n            inverseColors: true,\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [0, 50, 100],\n            colorStops: []\n          },\n          image: {\n            src: [],\n            width: undefined,\n            // optional\n            height: undefined // optional\n\n          },\n          pattern: {\n            style: 'sqaures',\n            // String | Array of Strings\n            width: 6,\n            height: 6,\n            strokeWidth: 2\n          }\n        },\n        grid: {\n          show: true,\n          borderColor: '#e0e0e0',\n          strokeDashArray: 0,\n          position: 'back',\n          xaxis: {\n            lines: {\n              show: false,\n              animate: false\n            }\n          },\n          yaxis: {\n            lines: {\n              show: true,\n              animate: true\n            }\n          },\n          row: {\n            colors: undefined,\n            // takes as array which will be repeated on rows\n            opacity: 0.5\n          },\n          column: {\n            colors: undefined,\n            // takes an array which will be repeated on columns\n            opacity: 0.5\n          },\n          padding: {\n            top: 0,\n            right: 10,\n            bottom: 0,\n            left: 12\n          }\n        },\n        labels: [],\n        legend: {\n          show: true,\n          showForSingleSeries: false,\n          showForNullSeries: true,\n          showForZeroSeries: true,\n          floating: false,\n          position: 'bottom',\n          // whether to position legends in 1 of 4\n          // direction - top, bottom, left, right\n          horizontalAlign: 'center',\n          // when position top/bottom, you can specify whether to align legends left, right or center\n          fontSize: '12px',\n          fontFamily: undefined,\n          width: undefined,\n          height: undefined,\n          formatter: undefined,\n          offsetX: -20,\n          offsetY: 0,\n          labels: {\n            colors: undefined,\n            useSeriesColors: false\n          },\n          markers: {\n            width: 12,\n            height: 12,\n            strokeWidth: 0,\n            strokeColor: '#fff',\n            radius: 12,\n            customHTML: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            onClick: undefined\n          },\n          itemMargin: {\n            horizontal: 0,\n            vertical: 5\n          },\n          onItemClick: {\n            toggleDataSeries: true\n          },\n          onItemHover: {\n            highlightDataSeries: true\n          }\n        },\n        markers: {\n          discrete: [],\n          size: 0,\n          colors: undefined,\n          //strokeColor: '#fff', // TODO: deprecate in major version 4.0\n          strokeColors: '#fff',\n          strokeWidth: 2,\n          strokeOpacity: 0.9,\n          fillOpacity: 1,\n          shape: 'circle',\n          radius: 2,\n          offsetX: 0,\n          offsetY: 0,\n          hover: {\n            size: undefined,\n            sizeOffset: 3\n          }\n        },\n        noData: {\n          text: undefined,\n          align: 'center',\n          verticalAlign: 'middle',\n          offsetX: 0,\n          offsetY: 0,\n          style: {\n            color: undefined,\n            fontSize: '14px',\n            fontFamily: undefined\n          }\n        },\n        responsive: [],\n        // breakpoints should follow ascending order 400, then 700, then 1000\n        series: undefined,\n        states: {\n          normal: {\n            filter: {\n              type: 'none',\n              value: 0\n            }\n          },\n          hover: {\n            filter: {\n              type: 'lighten',\n              value: 0.15\n            }\n          },\n          active: {\n            allowMultipleDataPointsSelection: false,\n            filter: {\n              type: 'darken',\n              value: 0.65\n            }\n          }\n        },\n        title: {\n          text: undefined,\n          align: 'left',\n          margin: 10,\n          offsetX: 0,\n          offsetY: 0,\n          floating: false,\n          style: {\n            fontSize: '14px',\n            fontFamily: undefined,\n            color: undefined\n          }\n        },\n        subtitle: {\n          text: undefined,\n          align: 'left',\n          margin: 10,\n          offsetX: 0,\n          offsetY: 30,\n          floating: false,\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined,\n            color: undefined\n          }\n        },\n        stroke: {\n          show: true,\n          curve: 'smooth',\n          // \"smooth\" / \"straight\" / \"stepline\"\n          lineCap: 'butt',\n          // round, butt , square\n          width: 2,\n          colors: undefined,\n          // array of colors\n          dashArray: 0 // single value or array of values\n\n        },\n        tooltip: {\n          enabled: true,\n          shared: true,\n          followCursor: false,\n          // when disabled, the tooltip will show on top of the series instead of mouse position\n          intersect: false,\n          // when enabled, tooltip will only show when user directly hovers over point\n          inverseOrder: false,\n          custom: undefined,\n          fillSeriesColor: false,\n          theme: 'light',\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined\n          },\n          onDatasetHover: {\n            highlightDataSeries: false\n          },\n          x: {\n            // x value\n            show: true,\n            format: 'dd MMM',\n            // dd/MM, dd MMM yy, dd MMM yyyy\n            formatter: undefined // a custom user supplied formatter function\n\n          },\n          y: {\n            formatter: undefined,\n            title: {\n              formatter: function formatter(seriesName) {\n                return seriesName;\n              }\n            }\n          },\n          z: {\n            formatter: undefined,\n            title: 'Size: '\n          },\n          marker: {\n            show: true\n          },\n          items: {\n            display: 'flex'\n          },\n          fixed: {\n            enabled: false,\n            position: 'topRight',\n            // topRight, topLeft, bottomRight, bottomLeft\n            offsetX: 0,\n            offsetY: 0\n          }\n        },\n        xaxis: {\n          type: 'category',\n          categories: [],\n          offsetX: 0,\n          offsetY: 0,\n          labels: {\n            show: true,\n            rotate: -45,\n            rotateAlways: false,\n            hideOverlappingLabels: true,\n            trim: true,\n            minHeight: undefined,\n            maxHeight: 120,\n            showDuplicates: true,\n            style: {\n              colors: [],\n              fontSize: '12px',\n              fontFamily: undefined,\n              cssClass: ''\n            },\n            offsetX: 0,\n            offsetY: 0,\n            format: undefined,\n            formatter: undefined,\n            // custom formatter function which will override format\n            datetimeFormatter: {\n              year: 'yyyy',\n              month: \"MMM 'yy\",\n              day: 'dd MMM',\n              hour: 'HH:mm',\n              minute: 'HH:mm:ss'\n            }\n          },\n          axisBorder: {\n            show: true,\n            color: '#78909C',\n            width: '100%',\n            height: 1,\n            offsetX: 0,\n            offsetY: 0\n          },\n          axisTicks: {\n            show: true,\n            color: '#78909C',\n            height: 6,\n            offsetX: 0,\n            offsetY: 0\n          },\n          tickAmount: undefined,\n          tickPlacement: 'on',\n          min: undefined,\n          max: undefined,\n          range: undefined,\n          floating: false,\n          position: 'bottom',\n          title: {\n            text: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            style: {\n              color: undefined,\n              fontSize: '12px',\n              fontFamily: undefined,\n              cssClass: ''\n            }\n          },\n          crosshairs: {\n            show: true,\n            width: 1,\n            // tickWidth/barWidth or an integer\n            position: 'back',\n            opacity: 0.9,\n            stroke: {\n              color: '#b6b6b6',\n              width: 1,\n              dashArray: 3\n            },\n            fill: {\n              type: 'solid',\n              // solid, gradient\n              color: '#B1B9C4',\n              gradient: {\n                colorFrom: '#D8E3F0',\n                colorTo: '#BED1E6',\n                stops: [0, 100],\n                opacityFrom: 0.4,\n                opacityTo: 0.5\n              }\n            },\n            dropShadow: {\n              enabled: false,\n              left: 0,\n              top: 0,\n              blur: 1,\n              opacity: 0.4\n            }\n          },\n          tooltip: {\n            enabled: true,\n            offsetY: 0,\n            formatter: undefined,\n            style: {\n              fontSize: '12px',\n              fontFamily: undefined\n            }\n          }\n        },\n        yaxis: this.yAxis,\n        theme: {\n          mode: 'light',\n          palette: 'palette1',\n          // If defined, it will overwrite globals.colors variable\n          monochrome: {\n            // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)\n            enabled: false,\n            color: '#008FFB',\n            shadeTo: 'light',\n            shadeIntensity: 0.65\n          }\n        }\n      };\n    }\n  }]);\n\n  return Options;\n}();\n\n/**\n * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.\n *\n * @module Annotations\n **/\n\nvar Annotations =\n/*#__PURE__*/\nfunction () {\n  function Annotations(ctx) {\n    _classCallCheck(this, Annotations);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.graphics = new Graphics(this.ctx);\n\n    if (this.w.globals.isBarHorizontal) {\n      this.invertAxis = true;\n    }\n\n    this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;\n  }\n\n  _createClass(Annotations, [{\n    key: \"drawAnnotations\",\n    value: function drawAnnotations() {\n      var w = this.w;\n\n      if (w.globals.axisCharts) {\n        var yAnnotations = this.drawYAxisAnnotations();\n        var xAnnotations = this.drawXAxisAnnotations();\n        var pointAnnotations = this.drawPointAnnotations();\n        var initialAnim = w.config.chart.animations.enabled;\n        var annoArray = [yAnnotations, xAnnotations, pointAnnotations];\n        var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];\n\n        for (var i = 0; i < 3; i++) {\n          w.globals.dom.elGraphical.add(annoArray[i]);\n\n          if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n            annoElArray[i].classList.add('hidden');\n          }\n\n          w.globals.delayedElements.push({\n            el: annoElArray[i],\n            index: 0\n          });\n        } // after placing the annotations on svg, set any vertically placed annotations\n\n\n        this.setOrientations(w.config.annotations.xaxis); // background sizes needs to be calculated after text is drawn, so calling them last\n\n        this.annotationsBackground();\n      }\n    }\n  }, {\n    key: \"addXaxisAnnotation\",\n    value: function addXaxisAnnotation(anno, parent, index) {\n      var w = this.w;\n      var min = this.invertAxis ? w.globals.minY : w.globals.minX;\n      var range = this.invertAxis ? w.globals.yRange[0] : w.globals.xRange;\n      var x1 = (anno.x - min) / (range / w.globals.gridWidth);\n\n      if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {\n        var catIndex = w.globals.labels.indexOf(anno.x);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n\n        if (xLabel) {\n          x1 = parseFloat(xLabel.getAttribute('x'));\n        }\n      }\n\n      var strokeDashArray = anno.strokeDashArray;\n      if (x1 < 0 || x1 > w.globals.gridWidth) return;\n\n      if (anno.x2 === null) {\n        var line = this.graphics.drawLine(x1 + anno.offsetX, // x1\n        0 + anno.offsetY, // y1\n        x1 + anno.offsetX, // x2\n        w.globals.gridHeight + anno.offsetY, // y2\n        anno.borderColor, // lineColor\n        strokeDashArray //dashArray\n        );\n        parent.appendChild(line.node);\n      } else {\n        var x2 = (anno.x2 - min) / (range / w.globals.gridWidth);\n\n        if (x2 < x1) {\n          var temp = x1;\n          x1 = x2;\n          x2 = temp;\n        }\n\n        var rect = this.graphics.drawRect(x1 + anno.offsetX, // x1\n        0 + anno.offsetY, // y1\n        x2 - x1, // x2\n        w.globals.gridHeight + anno.offsetY, // y2\n        0, // radius\n        anno.fillColor, // color\n        anno.opacity, // opacity,\n        1, // strokeWidth\n        anno.borderColor, // strokeColor\n        strokeDashArray // stokeDashArray\n        );\n        parent.appendChild(rect.node);\n      }\n\n      var textY = anno.label.position === 'top' ? -3 : w.globals.gridHeight;\n      var text = anno.label.text ? anno.label.text : '';\n      var elText = this.graphics.drawText({\n        x: x1 + anno.label.offsetX,\n        y: textY + anno.label.offsetY,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-xaxis-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n    }\n  }, {\n    key: \"drawXAxisAnnotations\",\n    value: function drawXAxisAnnotations() {\n      var _this = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-xaxis-annotations'\n      });\n      w.config.annotations.xaxis.map(function (anno, index) {\n        _this.addXaxisAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"addYaxisAnnotation\",\n    value: function addYaxisAnnotation(anno, parent, index) {\n      var w = this.w;\n      var strokeDashArray = anno.strokeDashArray;\n      var y1;\n      var y2;\n\n      if (this.invertAxis) {\n        var catIndex = w.globals.labels.indexOf(anno.y);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n\n        if (xLabel) {\n          y1 = parseFloat(xLabel.getAttribute('y'));\n        }\n      } else {\n        y1 = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {\n          y1 = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      }\n\n      var text = anno.label.text ? anno.label.text : '';\n\n      if (anno.y2 === null) {\n        var line = this.graphics.drawLine(0 + anno.offsetX, // x1\n        y1 + anno.offsetY, // y1\n        w.globals.gridWidth + anno.offsetX, // x2\n        y1 + anno.offsetY, // y2\n        anno.borderColor, // lineColor\n        strokeDashArray // dashArray\n        );\n        parent.appendChild(line.node);\n      } else {\n        if (this.invertAxis) {\n          var _catIndex = w.globals.labels.indexOf(anno.y2);\n\n          var _xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (_catIndex + 1) + ')');\n\n          if (_xLabel) {\n            y2 = parseFloat(_xLabel.getAttribute('y'));\n          }\n        } else {\n          y2 = w.globals.gridHeight - (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n          if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {\n            y2 = (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n          }\n        }\n\n        if (y2 > y1) {\n          var temp = y1;\n          y1 = y2;\n          y2 = temp;\n        }\n\n        var rect = this.graphics.drawRect(0 + anno.offsetX, // x1\n        y2 + anno.offsetY, // y1\n        w.globals.gridWidth + anno.offsetX, // x2\n        y1 - y2, // y2\n        0, // radius\n        anno.fillColor, // color\n        anno.opacity, // opacity,\n        1, // strokeWidth\n        anno.borderColor, // strokeColor\n        strokeDashArray // stokeDashArray\n        );\n        parent.appendChild(rect.node);\n      }\n\n      var textX = anno.label.position === 'right' ? w.globals.gridWidth : 0;\n      var elText = this.graphics.drawText({\n        x: textX + anno.label.offsetX,\n        y: (y2 || y1) + anno.label.offsetY - 3,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-yaxis-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n    }\n  }, {\n    key: \"drawYAxisAnnotations\",\n    value: function drawYAxisAnnotations() {\n      var _this2 = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-yaxis-annotations'\n      });\n      w.config.annotations.yaxis.map(function (anno, index) {\n        _this2.addYaxisAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"clearAnnotations\",\n    value: function clearAnnotations(ctx) {\n      var w = ctx.w;\n      var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations');\n      annos = Utils.listToArray(annos);\n      annos.forEach(function (a) {\n        while (a.firstChild) {\n          a.removeChild(a.firstChild);\n        }\n      });\n    }\n  }, {\n    key: \"addPointAnnotation\",\n    value: function addPointAnnotation(anno, parent, index) {\n      var w = this.w;\n      var x = 0;\n      var y = 0;\n      var pointY = 0;\n\n      if (this.invertAxis) {\n        console.warn('Point annotation is not supported in horizontal bar charts.');\n      }\n\n      if (typeof anno.x === 'string') {\n        var catIndex = w.globals.labels.indexOf(anno.x);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n        var xPos = parseFloat(xLabel.getAttribute('x'));\n        x = xPos;\n        var annoY = anno.y;\n\n        if (anno.y === null) {\n          annoY = w.globals.series[anno.seriesIndex][catIndex];\n        }\n\n        y = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n        pointY = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {\n          y = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) + parseInt(anno.label.style.fontSize) + anno.marker.size;\n          pointY = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      } else {\n        x = (anno.x - w.globals.minX) / (w.globals.xRange / w.globals.gridWidth);\n        y = w.globals.gridHeight - (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n        pointY = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex] && w.config.yaxis[anno.yAxisIndex].reversed) {\n          y = (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n          pointY = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      }\n\n      if (x < 0 || x > w.globals.gridWidth) return;\n      var optsPoints = {\n        pSize: anno.marker.size,\n        pWidth: anno.marker.strokeWidth,\n        pointFillColor: anno.marker.fillColor,\n        pointStrokeColor: anno.marker.strokeColor,\n        shape: anno.marker.shape,\n        radius: anno.marker.radius,\n        class: 'apexcharts-point-annotation-marker ' + anno.marker.cssClass\n      };\n      var point = this.graphics.drawMarker(x + anno.marker.offsetX, pointY + anno.marker.offsetY, optsPoints);\n      parent.appendChild(point.node);\n      var text = anno.label.text ? anno.label.text : '';\n      var elText = this.graphics.drawText({\n        x: x + anno.label.offsetX,\n        y: y + anno.label.offsetY,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-point-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n\n      if (anno.customSVG.SVG) {\n        var g = this.graphics.group({\n          class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass\n        });\n        g.attr({\n          transform: \"translate(\".concat(x + anno.customSVG.offsetX, \", \").concat(y + anno.customSVG.offsetY, \")\")\n        });\n        g.node.innerHTML = anno.customSVG.SVG;\n        parent.appendChild(g.node);\n      }\n    }\n  }, {\n    key: \"drawPointAnnotations\",\n    value: function drawPointAnnotations() {\n      var _this3 = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-point-annotations'\n      });\n      w.config.annotations.points.map(function (anno, index) {\n        _this3.addPointAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"setOrientations\",\n    value: function setOrientations(annos) {\n      var _this4 = this;\n\n      var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var w = this.w;\n      annos.map(function (anno, index) {\n        if (anno.label.orientation === 'vertical') {\n          var i = annoIndex !== null ? annoIndex : index;\n          var xAnno = w.globals.dom.baseEl.querySelector(\".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='\".concat(i, \"']\"));\n\n          if (xAnno !== null) {\n            var xAnnoCoord = xAnno.getBoundingClientRect();\n            xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);\n\n            if (anno.label.position === 'top') {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + xAnnoCoord.width);\n            } else {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) - xAnnoCoord.width);\n            }\n\n            var annoRotatingCenter = _this4.graphics.rotateAroundCenter(xAnno);\n\n            var x = annoRotatingCenter.x;\n            var y = annoRotatingCenter.y;\n            xAnno.setAttribute('transform', \"rotate(-90 \".concat(x, \" \").concat(y, \")\"));\n          }\n        }\n      });\n    }\n  }, {\n    key: \"addBackgroundToAnno\",\n    value: function addBackgroundToAnno(annoEl, anno) {\n      var w = this.w;\n      var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();\n      var coords = annoEl.getBoundingClientRect();\n      var pleft = anno.label.style.padding.left;\n      var pright = anno.label.style.padding.right;\n      var ptop = anno.label.style.padding.top;\n      var pbottom = anno.label.style.padding.bottom;\n\n      if (anno.label.orientation === 'vertical') {\n        ptop = anno.label.style.padding.left;\n        pbottom = anno.label.style.padding.right;\n        pleft = anno.label.style.padding.top;\n        pright = anno.label.style.padding.bottom;\n      }\n\n      var x1 = coords.left - elGridRect.left - pleft;\n      var y1 = coords.top - elGridRect.top - ptop;\n      var elRect = this.graphics.drawRect(x1, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, 0, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);\n      return elRect;\n    }\n  }, {\n    key: \"annotationsBackground\",\n    value: function annotationsBackground() {\n      var _this5 = this;\n\n      var w = this.w;\n\n      var add = function add(anno, i, type) {\n        var annoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(i, \"']\"));\n\n        if (annoLabel) {\n          var parent = annoLabel.parentNode;\n\n          var elRect = _this5.addBackgroundToAnno(annoLabel, anno);\n\n          parent.insertBefore(elRect.node, annoLabel);\n        }\n      };\n\n      w.config.annotations.xaxis.map(function (anno, i) {\n        add(anno, i, 'xaxis');\n      });\n      w.config.annotations.yaxis.map(function (anno, i) {\n        add(anno, i, 'yaxis');\n      });\n      w.config.annotations.points.map(function (anno, i) {\n        add(anno, i, 'point');\n      });\n    }\n  }, {\n    key: \"addText\",\n    value: function addText(params, pushToMemory, context) {\n      var x = params.x,\n          y = params.y,\n          text = params.text,\n          textAnchor = params.textAnchor,\n          _params$appendTo = params.appendTo,\n          appendTo = _params$appendTo === void 0 ? '.apexcharts-inner' : _params$appendTo,\n          foreColor = params.foreColor,\n          fontSize = params.fontSize,\n          fontFamily = params.fontFamily,\n          cssClass = params.cssClass,\n          backgroundColor = params.backgroundColor,\n          borderWidth = params.borderWidth,\n          strokeDashArray = params.strokeDashArray,\n          radius = params.radius,\n          borderColor = params.borderColor,\n          _params$paddingLeft = params.paddingLeft,\n          paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,\n          _params$paddingRight = params.paddingRight,\n          paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,\n          _params$paddingBottom = params.paddingBottom,\n          paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,\n          _params$paddingTop = params.paddingTop,\n          paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;\n      var me = context;\n      var w = me.w;\n      var parentNode = w.globals.dom.baseEl.querySelector(appendTo);\n      var elText = this.graphics.drawText({\n        x: x,\n        y: y,\n        text: text,\n        textAnchor: textAnchor || 'start',\n        fontSize: fontSize || '12px',\n        fontFamily: fontFamily || w.config.chart.fontFamily,\n        foreColor: foreColor || w.config.chart.foreColor,\n        cssClass:  true ? cssClass : undefined\n      });\n      parentNode.appendChild(elText.node);\n      var textRect = elText.bbox();\n      var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, radius, backgroundColor, 1, borderWidth, borderColor, strokeDashArray);\n      elText.before(elRect);\n\n      if (pushToMemory) {\n        w.globals.memory.methodsToExec.push({\n          context: me,\n          method: me.addText,\n          params: {\n            x: x,\n            y: y,\n            text: text,\n            textAnchor: textAnchor,\n            appendTo: appendTo,\n            foreColor: foreColor,\n            fontSize: fontSize,\n            cssClass: cssClass,\n            backgroundColor: backgroundColor,\n            borderWidth: borderWidth,\n            strokeDashArray: strokeDashArray,\n            radius: radius,\n            borderColor: borderColor,\n            paddingLeft: paddingLeft,\n            paddingRight: paddingRight,\n            paddingBottom: paddingBottom,\n            paddingTop: paddingTop\n          }\n        });\n      }\n\n      return context;\n    }\n  }, {\n    key: \"addPointAnnotationExternal\",\n    value: function addPointAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'point',\n        contextMethod: context.addPointAnnotation\n      });\n      return context;\n    }\n  }, {\n    key: \"addYaxisAnnotationExternal\",\n    value: function addYaxisAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'yaxis',\n        contextMethod: context.addYaxisAnnotation\n      });\n      return context;\n    } // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method\n\n  }, {\n    key: \"addXaxisAnnotationExternal\",\n    value: function addXaxisAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'xaxis',\n        contextMethod: context.addXaxisAnnotation\n      });\n      return context;\n    }\n  }, {\n    key: \"addAnnotationExternal\",\n    value: function addAnnotationExternal(_ref) {\n      var params = _ref.params,\n          pushToMemory = _ref.pushToMemory,\n          context = _ref.context,\n          type = _ref.type,\n          contextMethod = _ref.contextMethod;\n      var me = context;\n      var w = me.w;\n      var parent = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations\"));\n      var index = parent.childNodes.length + 1;\n      var opt = new Options();\n      var axesAnno = Object.assign({}, type === 'xaxis' ? opt.xAxisAnnotation : type === 'yaxis' ? opt.yAxisAnnotation : opt.pointAnnotation);\n      var anno = Utils.extend(axesAnno, params);\n\n      switch (type) {\n        case 'xaxis':\n          this.addXaxisAnnotation(anno, parent, index);\n          break;\n\n        case 'yaxis':\n          this.addYaxisAnnotation(anno, parent, index);\n          break;\n\n        case 'point':\n          this.addPointAnnotation(anno, parent, index);\n          break;\n      } // add background\n\n\n      var axesAnnoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(index, \"']\"));\n      var elRect = this.addBackgroundToAnno(axesAnnoLabel, anno);\n      parent.insertBefore(elRect.node, axesAnnoLabel);\n\n      if (pushToMemory) {\n        w.globals.memory.methodsToExec.push({\n          context: me,\n          method: contextMethod,\n          params: params\n        });\n      }\n\n      return context;\n    }\n  }]);\n\n  return Annotations;\n}();\n\n/**\n * DateTime Class to manipulate datetime values.\n *\n * @module DateTime\n **/\n\nvar DateTime =\n/*#__PURE__*/\nfunction () {\n  function DateTime(ctx) {\n    _classCallCheck(this, DateTime);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.months31 = [1, 3, 5, 7, 8, 10, 12];\n    this.months30 = [2, 4, 6, 9, 11];\n    this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n  }\n\n  _createClass(DateTime, [{\n    key: \"isValidDate\",\n    value: function isValidDate(date) {\n      return !isNaN(this.parseDate(date));\n    }\n  }, {\n    key: \"getUTCTimeStamp\",\n    value: function getUTCTimeStamp(dateStr) {\n      if (!Date.parse(dateStr)) {\n        return dateStr;\n      }\n\n      return new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();\n    }\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(dateStr) {\n      var parsed = Date.parse(dateStr);\n\n      if (!isNaN(parsed)) {\n        return this.getUTCTimeStamp(dateStr);\n      }\n\n      var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));\n      output = this.getUTCTimeStamp(output);\n      return output;\n    } // https://stackoverflow.com/a/11252167/6495043\n\n  }, {\n    key: \"treatAsUtc\",\n    value: function treatAsUtc(dateStr) {\n      var result = new Date(dateStr);\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset());\n      return result;\n    } // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191\n\n  }, {\n    key: \"formatDate\",\n    value: function formatDate(date, format) {\n      var utc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var convertToUTC = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var locale = this.w.globals.locale;\n      var MMMM = ['\\x00'].concat(_toConsumableArray(locale.months));\n      var MMM = ['\\x01'].concat(_toConsumableArray(locale.shortMonths));\n      var dddd = ['\\x02'].concat(_toConsumableArray(locale.days));\n      var ddd = ['\\x03'].concat(_toConsumableArray(locale.shortDays));\n\n      function ii(i, len) {\n        var s = i + '';\n        len = len || 2;\n\n        while (s.length < len) {\n          s = '0' + s;\n        }\n\n        return s;\n      }\n\n      if (convertToUTC) {\n        date = this.treatAsUtc(date);\n      }\n\n      var y = utc ? date.getUTCFullYear() : date.getFullYear();\n      format = format.replace(/(^|[^\\\\])yyyy+/g, '$1' + y);\n      format = format.replace(/(^|[^\\\\])yy/g, '$1' + y.toString().substr(2, 2));\n      format = format.replace(/(^|[^\\\\])y/g, '$1' + y);\n      var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n      format = format.replace(/(^|[^\\\\])MMMM+/g, '$1' + MMMM[0]);\n      format = format.replace(/(^|[^\\\\])MMM/g, '$1' + MMM[0]);\n      format = format.replace(/(^|[^\\\\])MM/g, '$1' + ii(M));\n      format = format.replace(/(^|[^\\\\])M/g, '$1' + M);\n      var d = utc ? date.getUTCDate() : date.getDate();\n      format = format.replace(/(^|[^\\\\])dddd+/g, '$1' + dddd[0]);\n      format = format.replace(/(^|[^\\\\])ddd/g, '$1' + ddd[0]);\n      format = format.replace(/(^|[^\\\\])dd/g, '$1' + ii(d));\n      format = format.replace(/(^|[^\\\\])d/g, '$1' + d);\n      var H = utc ? date.getUTCHours() : date.getHours();\n      format = format.replace(/(^|[^\\\\])HH+/g, '$1' + ii(H));\n      format = format.replace(/(^|[^\\\\])H/g, '$1' + H);\n      var h = H > 12 ? H - 12 : H === 0 ? 12 : H;\n      format = format.replace(/(^|[^\\\\])hh+/g, '$1' + ii(h));\n      format = format.replace(/(^|[^\\\\])h/g, '$1' + h);\n      var m = utc ? date.getUTCMinutes() : date.getMinutes();\n      format = format.replace(/(^|[^\\\\])mm+/g, '$1' + ii(m));\n      format = format.replace(/(^|[^\\\\])m/g, '$1' + m);\n      var s = utc ? date.getUTCSeconds() : date.getSeconds();\n      format = format.replace(/(^|[^\\\\])ss+/g, '$1' + ii(s));\n      format = format.replace(/(^|[^\\\\])s/g, '$1' + s);\n      var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n      format = format.replace(/(^|[^\\\\])fff+/g, '$1' + ii(f, 3));\n      f = Math.round(f / 10);\n      format = format.replace(/(^|[^\\\\])ff/g, '$1' + ii(f));\n      f = Math.round(f / 10);\n      format = format.replace(/(^|[^\\\\])f/g, '$1' + f);\n      var T = H < 12 ? 'AM' : 'PM';\n      format = format.replace(/(^|[^\\\\])TT+/g, '$1' + T);\n      format = format.replace(/(^|[^\\\\])T/g, '$1' + T.charAt(0));\n      var t = T.toLowerCase();\n      format = format.replace(/(^|[^\\\\])tt+/g, '$1' + t);\n      format = format.replace(/(^|[^\\\\])t/g, '$1' + t.charAt(0));\n      var tz = -date.getTimezoneOffset();\n      var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';\n\n      if (!utc) {\n        tz = Math.abs(tz);\n        var tzHrs = Math.floor(tz / 60);\n        var tzMin = tz % 60;\n        K += ii(tzHrs) + ':' + ii(tzMin);\n      }\n\n      format = format.replace(/(^|[^\\\\])K/g, '$1' + K);\n      var day = (utc ? date.getUTCDay() : date.getDay()) + 1;\n      format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);\n      format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);\n      format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);\n      format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);\n      format = format.replace(/\\\\(.)/g, '$1');\n      return format;\n    }\n  }, {\n    key: \"getTimeUnitsfromTimestamp\",\n    value: function getTimeUnitsfromTimestamp(minX, maxX) {\n      var w = this.w;\n\n      if (w.config.xaxis.min !== undefined) {\n        minX = w.config.xaxis.min;\n      }\n\n      if (w.config.xaxis.max !== undefined) {\n        maxX = w.config.xaxis.max;\n      }\n\n      var minYear = new Date(minX).getFullYear();\n      var maxYear = new Date(maxX).getFullYear();\n      var minMonth = new Date(minX).getMonth();\n      var maxMonth = new Date(maxX).getMonth();\n      var minDate = new Date(minX).getDate();\n      var maxDate = new Date(maxX).getDate();\n      var minHour = new Date(minX).getHours();\n      var maxHour = new Date(maxX).getHours();\n      var minMinute = new Date(minX).getMinutes();\n      var maxMinute = new Date(maxX).getMinutes();\n      return {\n        minMinute: minMinute,\n        maxMinute: maxMinute,\n        minHour: minHour,\n        maxHour: maxHour,\n        minDate: minDate,\n        maxDate: maxDate,\n        minMonth: minMonth,\n        maxMonth: maxMonth,\n        minYear: minYear,\n        maxYear: maxYear\n      };\n    }\n  }, {\n    key: \"isLeapYear\",\n    value: function isLeapYear(year) {\n      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    }\n  }, {\n    key: \"calculcateLastDaysOfMonth\",\n    value: function calculcateLastDaysOfMonth(month, year, subtract) {\n      var days = this.determineDaysOfMonths(month, year); // whatever days we get, subtract the number of days asked\n\n      return days - subtract;\n    }\n  }, {\n    key: \"determineDaysOfYear\",\n    value: function determineDaysOfYear(year) {\n      var days = 365;\n\n      if (this.isLeapYear(year)) {\n        days = 366;\n      }\n\n      return days;\n    }\n  }, {\n    key: \"determineRemainingDaysOfYear\",\n    value: function determineRemainingDaysOfYear(year, month, date) {\n      var dayOfYear = this.daysCntOfYear[month] + date;\n      if (month > 1 && this.isLeapYear()) dayOfYear++;\n      return dayOfYear;\n    }\n  }, {\n    key: \"determineDaysOfMonths\",\n    value: function determineDaysOfMonths(month, year) {\n      var days = 30;\n      month = Utils.monthMod(month);\n\n      switch (true) {\n        case this.months30.indexOf(month) > -1:\n          if (month === 2) {\n            if (this.isLeapYear(year)) {\n              days = 29;\n            } else {\n              days = 28;\n            }\n          }\n\n          break;\n\n        case this.months31.indexOf(month) > -1:\n          days = 31;\n          break;\n\n        default:\n          days = 31;\n          break;\n      }\n\n      return days;\n    }\n  }]);\n\n  return DateTime;\n}();\n\n/**\n * ApexCharts Default Class for setting default options for all chart types.\n *\n * @module Defaults\n **/\n\nvar Defaults =\n/*#__PURE__*/\nfunction () {\n  function Defaults(opts) {\n    _classCallCheck(this, Defaults);\n\n    this.opts = opts;\n  }\n\n  _createClass(Defaults, [{\n    key: \"line\",\n    value: function line() {\n      return {\n        chart: {\n          animations: {\n            easing: 'swing'\n          }\n        },\n        dataLabels: {\n          enabled: false\n        },\n        stroke: {\n          width: 5,\n          curve: 'straight'\n        },\n        markers: {\n          size: 0,\n          hover: {\n            sizeOffset: 6\n          }\n        },\n        xaxis: {\n          crosshairs: {\n            width: 1\n          }\n        }\n      };\n    }\n  }, {\n    key: \"sparkline\",\n    value: function sparkline(defaults) {\n      this.opts.yaxis[0].labels.show = false;\n      this.opts.yaxis[0].floating = true;\n      var ret = {\n        grid: {\n          show: false,\n          padding: {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n          }\n        },\n        legend: {\n          show: false\n        },\n        xaxis: {\n          labels: {\n            show: false\n          },\n          tooltip: {\n            enabled: false\n          },\n          axisBorder: {\n            show: false\n          }\n        },\n        chart: {\n          toolbar: {\n            show: false\n          },\n          zoom: {\n            enabled: false\n          }\n        },\n        dataLabels: {\n          enabled: false\n        }\n      };\n      return Utils.extend(defaults, ret);\n    }\n  }, {\n    key: \"bar\",\n    value: function bar() {\n      return {\n        chart: {\n          stacked: false,\n          animations: {\n            easing: 'swing'\n          }\n        },\n        plotOptions: {\n          bar: {\n            dataLabels: {\n              position: 'center'\n            }\n          }\n        },\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        stroke: {\n          width: 0\n        },\n        fill: {\n          opacity: 0.85\n        },\n        legend: {\n          markers: {\n            shape: 'square',\n            radius: 2,\n            size: 8\n          }\n        },\n        tooltip: {\n          shared: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          },\n          crosshairs: {\n            width: 'barWidth',\n            position: 'back',\n            fill: {\n              type: 'gradient'\n            },\n            dropShadow: {\n              enabled: false\n            },\n            stroke: {\n              width: 0\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"candlestick\",\n    value: function candlestick() {\n      return {\n        stroke: {\n          width: 1,\n          colors: ['#333']\n        },\n        dataLabels: {\n          enabled: false\n        },\n        tooltip: {\n          shared: true,\n          custom: function custom(_ref) {\n            var seriesIndex = _ref.seriesIndex,\n                dataPointIndex = _ref.dataPointIndex,\n                w = _ref.w;\n            var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];\n            var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];\n            var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];\n            var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];\n            return '<div class=\"apexcharts-tooltip-candlestick\">' + '<div>Open: <span class=\"value\">' + o + '</span></div>' + '<div>High: <span class=\"value\">' + h + '</span></div>' + '<div>Low: <span class=\"value\">' + l + '</span></div>' + '<div>Close: <span class=\"value\">' + c + '</span></div>' + '</div>';\n          }\n        },\n        states: {\n          active: {\n            filter: {\n              type: 'none'\n            }\n          }\n        },\n        xaxis: {\n          crosshairs: {\n            width: 1\n          }\n        }\n      };\n    }\n  }, {\n    key: \"rangeBar\",\n    value: function rangeBar() {\n      return {\n        stroke: {\n          width: 0\n        },\n        tooltip: {\n          shared: false,\n          followCursor: true,\n          custom: function custom(_ref2) {\n            var ctx = _ref2.ctx,\n                seriesIndex = _ref2.seriesIndex,\n                dataPointIndex = _ref2.dataPointIndex,\n                w = _ref2.w;\n            var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];\n            var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];\n            var startVal = '';\n            var endVal = '';\n            var color = w.globals.colors[seriesIndex];\n\n            if (w.config.tooltip.x.formatter === undefined) {\n              var datetimeObj = new DateTime(ctx);\n              startVal = datetimeObj.formatDate(new Date(start), w.config.tooltip.x.format, true, true);\n              endVal = datetimeObj.formatDate(new Date(end), w.config.tooltip.x.format, true, true);\n            } else {\n              startVal = w.config.tooltip.x.formatter(start);\n              endVal = w.config.tooltip.x.formatter(end);\n            }\n\n            var ylabel = w.globals.labels[dataPointIndex];\n            return '<div class=\"apexcharts-tooltip-rangebar\">' + '<div> <span class=\"series-name\" style=\"color: ' + color + '\">' + (w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : '') + '</span></div>' + '<div> <span class=\"category\">' + ylabel + ': </span> <span class=\"value start-value\">' + startVal + '</span> <span class=\"separator\">-</span> <span class=\"value end-value\">' + endVal + '</span></div>' + '</div>';\n          }\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          },\n          crosshairs: {\n            stroke: {\n              width: 0\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"area\",\n    value: function area() {\n      return {\n        stroke: {\n          width: 4\n        },\n        fill: {\n          type: 'gradient',\n          gradient: {\n            inverseColors: false,\n            shade: 'light',\n            type: 'vertical',\n            opacityFrom: 0.65,\n            opacityTo: 0.5,\n            stops: [0, 100, 100]\n          }\n        },\n        markers: {\n          size: 0,\n          hover: {\n            sizeOffset: 6\n          }\n        },\n        tooltip: {\n          followCursor: false\n        }\n      };\n    }\n  }, {\n    key: \"brush\",\n    value: function brush(defaults) {\n      var ret = {\n        chart: {\n          toolbar: {\n            autoSelected: 'selection',\n            show: false\n          },\n          zoom: {\n            enabled: false\n          }\n        },\n        dataLabels: {\n          enabled: false\n        },\n        stroke: {\n          width: 1\n        },\n        tooltip: {\n          enabled: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          }\n        }\n      };\n      return Utils.extend(defaults, ret);\n    }\n  }, {\n    key: \"stacked100\",\n    value: function stacked100() {\n      var _this = this;\n\n      this.opts.dataLabels = this.opts.dataLabels || {};\n      this.opts.dataLabels.formatter = this.opts.dataLabels.formatter || undefined;\n      var existingDataLabelFormatter = this.opts.dataLabels.formatter;\n      this.opts.yaxis.forEach(function (yaxe, index) {\n        _this.opts.yaxis[index].min = 0;\n        _this.opts.yaxis[index].max = 100;\n      });\n      var isBar = this.opts.chart.type === 'bar';\n\n      if (isBar) {\n        this.opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {\n          if (typeof val === 'number') {\n            return val ? val.toFixed(0) + '%' : val;\n          }\n\n          return val;\n        };\n      }\n    } // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area\n\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      return {\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        tooltip: {\n          shared: false,\n          intersect: true\n        },\n        xaxis: {\n          crosshairs: {\n            width: 0\n          }\n        },\n        fill: {\n          type: 'solid',\n          gradient: {\n            shade: 'light',\n            inverse: true,\n            shadeIntensity: 0.55,\n            opacityFrom: 0.4,\n            opacityTo: 0.8\n          }\n        }\n      };\n    }\n  }, {\n    key: \"scatter\",\n    value: function scatter() {\n      return {\n        dataLabels: {\n          enabled: false\n        },\n        tooltip: {\n          shared: false,\n          intersect: true\n        },\n        markers: {\n          size: 6,\n          strokeWidth: 2,\n          hover: {\n            sizeOffset: 2\n          }\n        }\n      };\n    }\n  }, {\n    key: \"heatmap\",\n    value: function heatmap() {\n      return {\n        chart: {\n          stacked: false,\n          zoom: {\n            enabled: false\n          }\n        },\n        fill: {\n          opacity: 1\n        },\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        tooltip: {\n          followCursor: true,\n          marker: {\n            show: false\n          },\n          x: {\n            show: false\n          }\n        },\n        legend: {\n          position: 'top',\n          markers: {\n            shape: 'square',\n            size: 10,\n            offsetY: 2\n          }\n        },\n        grid: {\n          padding: {\n            right: 20\n          }\n        }\n      };\n    }\n  }, {\n    key: \"pie\",\n    value: function pie() {\n      return {\n        chart: {\n          toolbar: {\n            show: false\n          }\n        },\n        plotOptions: {\n          pie: {\n            donut: {\n              labels: {\n                show: false\n              }\n            }\n          }\n        },\n        dataLabels: {\n          formatter: function formatter(val) {\n            return val.toFixed(1) + '%';\n          },\n          style: {\n            colors: ['#fff']\n          },\n          dropShadow: {\n            enabled: true\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        fill: {\n          opacity: 1,\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.35,\n            inverseColors: false,\n            stops: [0, 100, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        tooltip: {\n          theme: 'dark',\n          fillSeriesColor: true\n        },\n        legend: {\n          position: 'right'\n        }\n      };\n    }\n  }, {\n    key: \"donut\",\n    value: function donut() {\n      return {\n        chart: {\n          toolbar: {\n            show: false\n          }\n        },\n        dataLabels: {\n          formatter: function formatter(val) {\n            return val.toFixed(1) + '%';\n          },\n          style: {\n            colors: ['#fff']\n          },\n          dropShadow: {\n            enabled: true\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        fill: {\n          opacity: 1,\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.4,\n            inverseColors: false,\n            type: 'vertical',\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [70, 98, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        tooltip: {\n          theme: 'dark',\n          fillSeriesColor: true\n        },\n        legend: {\n          position: 'right'\n        }\n      };\n    }\n  }, {\n    key: \"radar\",\n    value: function radar() {\n      this.opts.yaxis[0].labels.style.fontSize = '13px';\n      this.opts.yaxis[0].labels.offsetY = 6;\n      return {\n        dataLabels: {\n          enabled: true,\n          style: {\n            colors: ['#a8a8a8'],\n            fontSize: '11px'\n          }\n        },\n        stroke: {\n          width: 2\n        },\n        markers: {\n          size: 3,\n          strokeWidth: 1,\n          strokeOpacity: 1\n        },\n        fill: {\n          opacity: 0.2\n        },\n        tooltip: {\n          shared: false,\n          intersect: true,\n          followCursor: true\n        },\n        grid: {\n          show: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          },\n          crosshairs: {\n            show: false\n          }\n        }\n      };\n    }\n  }, {\n    key: \"radialBar\",\n    value: function radialBar() {\n      return {\n        chart: {\n          animations: {\n            dynamicAnimation: {\n              enabled: true,\n              speed: 800\n            }\n          },\n          toolbar: {\n            show: false\n          }\n        },\n        fill: {\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.4,\n            inverseColors: false,\n            type: 'diagonal2',\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [70, 98, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        legend: {\n          show: false,\n          position: 'right'\n        },\n        tooltip: {\n          enabled: false,\n          fillSeriesColor: true\n        }\n      };\n    }\n  }], [{\n    key: \"convertCatToNumeric\",\n    value: function convertCatToNumeric(opts) {\n      opts.xaxis.type = 'numeric';\n      opts.xaxis.convertedCatToNumeric = true;\n      opts.xaxis.labels = opts.xaxis.labels || {};\n\n      opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {\n        return val;\n      };\n\n      opts.chart = opts.chart || {};\n      opts.chart.zoom = opts.chart.zoom || window.Apex.chart && window.Apex.chart.zoom || {};\n      var defaultFormatter = opts.xaxis.labels.formatter;\n      var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;\n\n      if (labels && labels.length) {\n        opts.xaxis.labels.formatter = function (val) {\n          return defaultFormatter(labels[val - 1]);\n        };\n      }\n\n      opts.xaxis.categories = [];\n      opts.labels = [];\n      opts.chart.zoom.enabled = opts.chart.zoom.enabled || false;\n      return opts;\n    }\n  }]);\n\n  return Defaults;\n}();\n\n/*\n ** Util functions which are dependent on ApexCharts instance\n */\nvar CoreUtils =\n/*#__PURE__*/\nfunction () {\n  function CoreUtils(ctx) {\n    _classCallCheck(this, CoreUtils);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(CoreUtils, [{\n    key: \"getStackedSeriesTotals\",\n\n    /**\n     * @memberof CoreUtils\n     * returns the sum of all individual values in a multiple stacked series\n     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n     *  @return [34,36,48,13]\n     **/\n    value: function getStackedSeriesTotals() {\n      var w = this.w;\n      var total = [];\n\n      for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {\n        var t = 0;\n\n        for (var j = 0; j < w.globals.series.length; j++) {\n          t += w.globals.series[j][i];\n        }\n\n        total.push(t);\n      }\n\n      w.globals.stackedSeriesTotals = total;\n      return total;\n    } // get total of the all values inside all series\n\n  }, {\n    key: \"getSeriesTotalByIndex\",\n    value: function getSeriesTotalByIndex() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (index === null) {\n        // non-plot chart types - pie / donut / circle\n        return this.w.config.series.reduce(function (acc, cur) {\n          return acc + cur;\n        }, 0);\n      } else {\n        // axis charts - supporting multiple series\n        return this.w.globals.series[index].reduce(function (acc, cur) {\n          return acc + cur;\n        }, 0);\n      }\n    }\n  }, {\n    key: \"isSeriesNull\",\n    value: function isSeriesNull() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var r = [];\n\n      if (index === null) {\n        // non-plot chart types - pie / donut / circle\n        r = this.w.config.series.filter(function (d) {\n          return d !== null;\n        });\n      } else {\n        // axis charts - supporting multiple series\n        r = this.w.globals.series[index].filter(function (d) {\n          return d !== null;\n        });\n      }\n\n      return r.length === 0;\n    }\n  }, {\n    key: \"seriesHaveSameValues\",\n    value: function seriesHaveSameValues(index) {\n      return this.w.globals.series[index].every(function (val, i, arr) {\n        return val === arr[0];\n      });\n    } // maxValsInArrayIndex is the index of series[] which has the largest number of items\n\n  }, {\n    key: \"getLargestSeries\",\n    value: function getLargestSeries() {\n      var w = this.w;\n      w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {\n        return a.length;\n      }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {\n        return a.length;\n      })));\n    }\n  }, {\n    key: \"getLargestMarkerSize\",\n    value: function getLargestMarkerSize() {\n      var w = this.w;\n      var size = 0;\n      w.globals.markers.size.forEach(function (m) {\n        size = Math.max(size, m);\n      });\n      w.globals.markers.largestSize = size;\n      return size;\n    }\n    /**\n     * @memberof Core\n     * returns the sum of all values in a series\n     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n     *  @return [120, 11]\n     **/\n\n  }, {\n    key: \"getSeriesTotals\",\n    value: function getSeriesTotals() {\n      var w = this.w;\n      w.globals.seriesTotals = w.globals.series.map(function (ser, index) {\n        var total = 0;\n\n        if (Array.isArray(ser)) {\n          for (var j = 0; j < ser.length; j++) {\n            total += ser[j];\n          }\n        } else {\n          // for pie/donuts/gauges\n          total += ser;\n        }\n\n        return total;\n      });\n    }\n  }, {\n    key: \"getSeriesTotalsXRange\",\n    value: function getSeriesTotalsXRange(minX, maxX) {\n      var w = this.w;\n      var seriesTotalsXRange = w.globals.series.map(function (ser, index) {\n        var total = 0;\n\n        for (var j = 0; j < ser.length; j++) {\n          if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {\n            total += ser[j];\n          }\n        }\n\n        return total;\n      });\n      return seriesTotalsXRange;\n    }\n    /**\n     * @memberof CoreUtils\n     * returns the percentage value of all individual values which can be used in a 100% stacked series\n     * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]\n     *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]\n     **/\n\n  }, {\n    key: \"getPercentSeries\",\n    value: function getPercentSeries() {\n      var w = this.w;\n      w.globals.seriesPercent = w.globals.series.map(function (ser, index) {\n        var seriesPercent = [];\n\n        if (Array.isArray(ser)) {\n          for (var j = 0; j < ser.length; j++) {\n            var total = w.globals.stackedSeriesTotals[j];\n            var percent = 100 * ser[j] / total;\n            seriesPercent.push(percent);\n          }\n        } else {\n          var _total = w.globals.seriesTotals.reduce(function (acc, val) {\n            return acc + val;\n          }, 0);\n\n          var _percent = 100 * ser / _total;\n\n          seriesPercent.push(_percent);\n        }\n\n        return seriesPercent;\n      });\n    }\n  }, {\n    key: \"getCalculatedRatios\",\n    value: function getCalculatedRatios() {\n      var gl = this.w.globals;\n      var yRatio = [];\n      var invertedYRatio = 0;\n      var xRatio = 0;\n      var initialXRatio = 0;\n      var invertedXRatio = 0;\n      var zRatio = 0;\n      var baseLineY = [];\n      var baseLineInvertedY = 0.1;\n      var baseLineX = 0;\n      gl.yRange = [];\n\n      if (gl.isMultipleYAxis) {\n        for (var i = 0; i < gl.minYArr.length; i++) {\n          gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));\n          baseLineY.push(0);\n        }\n      } else {\n        gl.yRange.push(Math.abs(gl.minY - gl.maxY));\n      }\n\n      gl.xRange = Math.abs(gl.maxX - gl.minX);\n      gl.zRange = Math.abs(gl.maxZ - gl.minZ); // multiple y axis\n\n      for (var _i = 0; _i < gl.yRange.length; _i++) {\n        yRatio.push(gl.yRange[_i] / gl.gridHeight);\n      }\n\n      xRatio = gl.xRange / gl.gridWidth;\n      initialXRatio = Math.abs(gl.initialmaxX - gl.initialminX) / gl.gridWidth;\n      invertedYRatio = gl.yRange / gl.gridWidth;\n      invertedXRatio = gl.xRange / gl.gridHeight;\n      zRatio = gl.zRange / gl.gridHeight * 16;\n\n      if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {\n        // Negative numbers present in series\n        gl.hasNegs = true;\n      }\n\n      if (gl.isMultipleYAxis) {\n        baseLineY = []; // baseline variables is the 0 of the yaxis which will be needed when there are negatives\n\n        for (var _i2 = 0; _i2 < yRatio.length; _i2++) {\n          baseLineY.push(-gl.minYArr[_i2] / yRatio[_i2]);\n        }\n      } else {\n        baseLineY.push(-gl.minY / yRatio[0]);\n\n        if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {\n          baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart\n\n          baseLineX = gl.minX / xRatio;\n        }\n      }\n\n      return {\n        yRatio: yRatio,\n        invertedYRatio: invertedYRatio,\n        zRatio: zRatio,\n        xRatio: xRatio,\n        initialXRatio: initialXRatio,\n        invertedXRatio: invertedXRatio,\n        baseLineInvertedY: baseLineInvertedY,\n        baseLineY: baseLineY,\n        baseLineX: baseLineX\n      };\n    }\n  }, {\n    key: \"getLogSeries\",\n    value: function getLogSeries(series) {\n      var w = this.w;\n      w.globals.seriesLog = series.map(function (s, i) {\n        if (w.config.yaxis[i] && w.config.yaxis[i].logarithmic) {\n          return s.map(function (d) {\n            if (d === null) return null;\n            var logVal = (Math.log(d) - Math.log(w.globals.minYArr[i])) / (Math.log(w.globals.maxYArr[i]) - Math.log(w.globals.minYArr[i]));\n            return logVal;\n          });\n        } else {\n          return s;\n        }\n      });\n      return w.globals.seriesLog;\n    }\n  }, {\n    key: \"getLogYRatios\",\n    value: function getLogYRatios(yRatio) {\n      var _this = this;\n\n      var w = this.w;\n      var gl = this.w.globals;\n      gl.yLogRatio = yRatio.slice();\n      gl.logYRange = gl.yRange.map(function (yRange, i) {\n        if (w.config.yaxis[i] && _this.w.config.yaxis[i].logarithmic) {\n          var maxY = -Number.MAX_VALUE;\n          var minY = Number.MIN_VALUE;\n          var range = 1;\n          gl.seriesLog.forEach(function (s, si) {\n            s.forEach(function (v) {\n              if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {\n                maxY = Math.max(v, maxY);\n                minY = Math.min(v, minY);\n              }\n            });\n          });\n          range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);\n          gl.yLogRatio[i] = range / gl.gridHeight;\n          return range;\n        }\n      });\n      return gl.yLogRatio;\n    } // Some config objects can be array - and we need to extend them correctly\n\n  }], [{\n    key: \"checkComboSeries\",\n    value: function checkComboSeries(series) {\n      var comboCharts = false;\n      var comboChartsHasBars = false; // if user specified a type in series too, turn on comboCharts flag\n\n      if (series.length && typeof series[0].type !== 'undefined') {\n        comboCharts = true;\n        series.forEach(function (s) {\n          if (s.type === 'bar' || s.type === 'column') {\n            comboChartsHasBars = true;\n          }\n        });\n      }\n\n      return {\n        comboCharts: comboCharts,\n        comboChartsHasBars: comboChartsHasBars\n      };\n    }\n  }, {\n    key: \"extendArrayProps\",\n    value: function extendArrayProps(configInstance, options) {\n      if (options.yaxis) {\n        options = configInstance.extendYAxis(options);\n      }\n\n      if (options.annotations) {\n        if (options.annotations.yaxis) {\n          options = configInstance.extendYAxisAnnotations(options);\n        }\n\n        if (options.annotations.xaxis) {\n          options = configInstance.extendXAxisAnnotations(options);\n        }\n\n        if (options.annotations.points) {\n          options = configInstance.extendPointAnnotations(options);\n        }\n      }\n\n      return options;\n    }\n  }]);\n\n  return CoreUtils;\n}();\n\n/**\n * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.\n *\n * @module Config\n **/\n\nvar Config =\n/*#__PURE__*/\nfunction () {\n  function Config(opts) {\n    _classCallCheck(this, Config);\n\n    this.opts = opts;\n  }\n\n  _createClass(Config, [{\n    key: \"init\",\n    value: function init() {\n      var opts = this.opts;\n      var options = new Options();\n      var defaults = new Defaults(opts);\n      this.chartType = opts.chart.type;\n\n      if (this.chartType === 'histogram') {\n        // technically, a histogram can be drawn by a column chart with no spaces in between\n        opts.chart.type = 'bar';\n        opts = Utils.extend({\n          plotOptions: {\n            bar: {\n              columnWidth: '99.99%'\n            }\n          }\n        }, opts);\n      }\n\n      opts.series = this.checkEmptySeries(opts.series);\n      opts = this.extendYAxis(opts);\n      opts = this.extendAnnotations(opts);\n      var config = options.init();\n      var newDefaults = {};\n\n      if (opts && _typeof(opts) === 'object') {\n        var chartDefaults = {};\n\n        switch (this.chartType) {\n          case 'line':\n            chartDefaults = defaults.line();\n            break;\n\n          case 'area':\n            chartDefaults = defaults.area();\n            break;\n\n          case 'bar':\n            chartDefaults = defaults.bar();\n            break;\n\n          case 'candlestick':\n            chartDefaults = defaults.candlestick();\n            break;\n\n          case 'rangeBar':\n            chartDefaults = defaults.rangeBar();\n            break;\n\n          case 'histogram':\n            chartDefaults = defaults.bar();\n            break;\n\n          case 'bubble':\n            chartDefaults = defaults.bubble();\n            break;\n\n          case 'scatter':\n            chartDefaults = defaults.scatter();\n            break;\n\n          case 'heatmap':\n            chartDefaults = defaults.heatmap();\n            break;\n\n          case 'pie':\n            chartDefaults = defaults.pie();\n            break;\n\n          case 'donut':\n            chartDefaults = defaults.donut();\n            break;\n\n          case 'radar':\n            chartDefaults = defaults.radar();\n            break;\n\n          case 'radialBar':\n            chartDefaults = defaults.radialBar();\n            break;\n\n          default:\n            chartDefaults = defaults.line();\n        }\n\n        if (opts.chart.brush && opts.chart.brush.enabled) {\n          chartDefaults = defaults.brush(chartDefaults);\n        }\n\n        if (opts.chart.stacked && opts.chart.stackType === '100%') {\n          defaults.stacked100();\n        } // If user has specified a dark theme, make the tooltip dark too\n\n\n        this.checkForDarkTheme(window.Apex); // check global window Apex options\n\n        this.checkForDarkTheme(opts); // check locally passed options\n\n        opts.xaxis = opts.xaxis || window.Apex.xaxis || {};\n        var combo = CoreUtils.checkComboSeries(opts.series);\n\n        if ((opts.chart.type === 'line' || opts.chart.type === 'area' || opts.chart.type === 'scatter') && !combo.comboChartsHasBars && opts.xaxis.type !== 'datetime' && opts.xaxis.type !== 'numeric' && opts.xaxis.tickPlacement !== 'between') {\n          opts = Defaults.convertCatToNumeric(opts);\n        }\n\n        if (opts.chart.sparkline && opts.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) {\n          chartDefaults = defaults.sparkline(chartDefaults);\n        }\n\n        newDefaults = Utils.extend(config, chartDefaults);\n      } // config should cascade in this fashion\n      // default-config < global-apex-variable-config < user-defined-config\n      // get GLOBALLY defined options and merge with the default config\n\n\n      var mergedWithDefaultConfig = Utils.extend(newDefaults, window.Apex); // get the merged config and extend with user defined config\n\n      config = Utils.extend(mergedWithDefaultConfig, opts); // some features are not supported. those mismatches should be handled\n\n      config = this.handleUserInputErrors(config);\n      return config;\n    }\n  }, {\n    key: \"extendYAxis\",\n    value: function extendYAxis(opts) {\n      var options = new Options();\n\n      if (typeof opts.yaxis === 'undefined') {\n        opts.yaxis = {};\n      } // extend global yaxis config (only if object is provided / not an array)\n\n\n      if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {\n        opts.yaxis = Utils.extend(opts.yaxis, window.Apex.yaxis);\n      } // as we can't extend nested object's array with extend, we need to do it first\n      // user can provide either an array or object in yaxis config\n\n\n      if (opts.yaxis.constructor !== Array) {\n        // convert the yaxis to array if user supplied object\n        opts.yaxis = [Utils.extend(options.yAxis, opts.yaxis)];\n      } else {\n        opts.yaxis = Utils.extendArray(opts.yaxis, options.yAxis);\n      }\n\n      return opts;\n    } // annotations also accepts array, so we need to extend them manually\n\n  }, {\n    key: \"extendAnnotations\",\n    value: function extendAnnotations(opts) {\n      if (typeof opts.annotations === 'undefined') {\n        opts.annotations = {};\n        opts.annotations.yaxis = [];\n        opts.annotations.xaxis = [];\n        opts.annotations.points = [];\n      }\n\n      opts = this.extendYAxisAnnotations(opts);\n      opts = this.extendXAxisAnnotations(opts);\n      opts = this.extendPointAnnotations(opts);\n      return opts;\n    }\n  }, {\n    key: \"extendYAxisAnnotations\",\n    value: function extendYAxisAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.yaxis = Utils.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"extendXAxisAnnotations\",\n    value: function extendXAxisAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.xaxis = Utils.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"extendPointAnnotations\",\n    value: function extendPointAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.points = Utils.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"checkForDarkTheme\",\n    value: function checkForDarkTheme(opts) {\n      if (opts.theme && opts.theme.mode === 'dark') {\n        if (!opts.tooltip) {\n          opts.tooltip = {};\n        }\n\n        if (opts.tooltip.theme !== 'light') {\n          opts.tooltip.theme = 'dark';\n        }\n\n        if (!opts.chart.foreColor) {\n          opts.chart.foreColor = '#f6f7f8';\n        }\n\n        if (!opts.theme.palette) {\n          opts.theme.palette = 'palette4';\n        }\n      }\n    }\n  }, {\n    key: \"checkEmptySeries\",\n    value: function checkEmptySeries(ser) {\n      if (ser.length === 0) {\n        return [{\n          data: []\n        }];\n      }\n\n      return ser;\n    }\n  }, {\n    key: \"handleUserInputErrors\",\n    value: function handleUserInputErrors(opts) {\n      var config = opts; // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it\n\n      if (config.tooltip.shared && config.tooltip.intersect) {\n        throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');\n      }\n\n      if (config.chart.scroller) {\n        console.warn('Scroller has been deprecated since v2.0.0. Please remove the configuration for chart.scroller');\n      }\n\n      if ((config.chart.type === 'bar' || config.chart.type === 'rangeBar') && config.plotOptions.bar.horizontal) {\n        // No multiple yaxis for bars\n        if (config.yaxis.length > 1) {\n          throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');\n        } // if yaxis is reversed in horizontal bar chart, you should draw the y-axis on right side\n\n\n        if (config.yaxis[0].reversed) {\n          config.yaxis[0].opposite = true;\n        }\n\n        config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n        config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n        config.chart.zoom.enabled = false; // no zooming for horz bars\n      }\n\n      if (config.chart.type === 'bar' || config.chart.type === 'rangeBar') {\n        if (config.tooltip.shared) {\n          if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {\n            console.warn('crosshairs.width = \"barWidth\" is only supported in single series, not in a multi-series barChart.');\n            config.xaxis.crosshairs.width = 'tickWidth';\n          }\n\n          if (config.plotOptions.bar.horizontal) {\n            config.states.hover.type = 'none';\n            config.tooltip.shared = false;\n          }\n\n          if (!config.tooltip.followCursor) {\n            console.warn('followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true', 'color: blue;');\n            config.tooltip.followCursor = true;\n          }\n        }\n      }\n\n      if (config.chart.type === 'candlestick') {\n        if (config.yaxis[0].reversed) {\n          console.warn('Reversed y-axis in candlestick chart is not supported.');\n          config.yaxis[0].reversed = false;\n        }\n      }\n\n      if (config.chart.group && config.yaxis[0].labels.minWidth === 0) {\n        console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.');\n      } // if user supplied array for stroke width, it will only be applicable to line/area charts, for any other charts, revert back to Number\n\n\n      if (Array.isArray(config.stroke.width)) {\n        if (config.chart.type !== 'line' && config.chart.type !== 'area') {\n          console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number');\n          config.stroke.width = config.stroke.width[0];\n        }\n      }\n\n      return config;\n    }\n  }]);\n\n  return Config;\n}();\n\nvar Globals =\n/*#__PURE__*/\nfunction () {\n  function Globals() {\n    _classCallCheck(this, Globals);\n  }\n\n  _createClass(Globals, [{\n    key: \"globalVars\",\n    value: function globalVars(config) {\n      return {\n        chartID: null,\n        // chart ID - apexcharts-cuid\n        cuid: null,\n        // chart ID - random numbers excluding \"apexcharts\" part\n        events: {\n          beforeMount: [],\n          mounted: [],\n          updated: [],\n          clicked: [],\n          selection: [],\n          dataPointSelection: [],\n          zoomed: [],\n          scrolled: []\n        },\n        colors: [],\n        clientX: null,\n        clientY: null,\n        fill: {\n          colors: []\n        },\n        stroke: {\n          colors: []\n        },\n        dataLabels: {\n          style: {\n            colors: []\n          }\n        },\n        radarPolygons: {\n          fill: {\n            colors: []\n          }\n        },\n        markers: {\n          colors: [],\n          size: config.markers.size,\n          largestSize: 0\n        },\n        animationEnded: false,\n        isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,\n        isDirty: false,\n        // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update\n        initialConfig: null,\n        // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it\n        lastXAxis: [],\n        lastYAxis: [],\n        series: [],\n        // the MAIN series array (y values)\n        seriesRangeStart: [],\n        // the clone of series becomes the start in range\n        seriesRangeEnd: [],\n        // the end values in range chart\n        seriesPercent: [],\n        // the percentage values of the given series\n        seriesTotals: [],\n        stackedSeriesTotals: [],\n        seriesX: [],\n        // store the numeric x values in this array (x values)\n        seriesZ: [],\n        // The 3rd \"Z\" dimension for bubbles chart (z values)\n        labels: [],\n        // store the text to draw on x axis\n        // Don't mutate the labels, many things including tooltips depends on it!\n        timelineLabels: [],\n        // store the timeline Labels in another variable\n        invertedTimelineLabels: [],\n        // for rangebar timeline\n        seriesNames: [],\n        // same as labels, used in non axis charts\n        noLabelsProvided: false,\n        // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...\n        allSeriesCollapsed: false,\n        collapsedSeries: [],\n        // when user collapses a series, it goes into this array\n        collapsedSeriesIndices: [],\n        // this stores the index of the collapsedSeries instead of whole object for quick access\n        ancillaryCollapsedSeries: [],\n        // when user collapses an \"alwaysVisible\" series, it goes into this array\n        ancillaryCollapsedSeriesIndices: [],\n        // this stores the index of the collapsedSeries whose y-axis is always visible\n        risingSeries: [],\n        // when user re-opens a collapsed series, it goes here\n        dataFormatXNumeric: false,\n        // boolean value to indicate user has passed numeric x values\n        selectedDataPoints: [],\n        ignoreYAxisIndexes: [],\n        // when series are being collapsed in multiple y axes, ignore certain index\n        padHorizontal: 0,\n        maxValsInArrayIndex: 0,\n        zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,\n        panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,\n        selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,\n        yaxis: null,\n        minY: Number.MIN_VALUE,\n        //  is 5e-324, i.e. the smallest positive number\n        // NOTE: If there are multiple y axis, the first yaxis array element will be considered for all y values calculations. Rest all will be calculated based on that\n        maxY: -Number.MAX_VALUE,\n        // is -1.7976931348623157e+308\n        // NOTE: The above note for minY applies here as well\n        minYArr: [],\n        maxYArr: [],\n        maxX: -Number.MAX_VALUE,\n        // is -1.7976931348623157e+308\n        initialmaxX: -Number.MAX_VALUE,\n        minX: Number.MIN_VALUE,\n        //  is 5e-324, i.e. the smallest positive number\n        initialminX: Number.MIN_VALUE,\n        minZ: Number.MIN_VALUE,\n        // Max Z value in charts with Z axis\n        maxZ: -Number.MAX_VALUE,\n        // Max Z value in charts with Z axis\n        minXDiff: Number.MAX_VALUE,\n        mousedown: false,\n        lastClientPosition: {},\n        // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning\n        visibleXRange: undefined,\n        yRange: [],\n        // this property is the absolute sum of positive and negative values [eg (-100 + 200 = 300)] - yAxis\n        zRange: 0,\n        // zAxis Range (for bubble charts)\n        xRange: 0,\n        // xAxis range\n        yValueDecimal: 0,\n        // are there floating numbers in the series. If yes, this represent the len of the decimals\n        total: 0,\n        SVGNS: 'http://www.w3.org/2000/svg',\n        // svg namespace\n        svgWidth: 0,\n        // the whole svg width\n        svgHeight: 0,\n        // the whole svg height\n        noData: false,\n        // whether there is any data to display or not\n        locale: {},\n        // the current locale values will be preserved here for global access\n        dom: {},\n        // for storing all dom nodes in this particular property\n        // elWrap: null, // the element that wraps everything\n        // elGraphical: null, // this contains lines/areas/bars/pies\n        // elGridRect: null, // paths going outside this area will be clipped\n        // elGridRectMask: null, // clipping will happen with this mask\n        // elGridRectMarkerMask: null, // clipping will happen with this mask\n        // elLegendWrap: null, // the whole legend area\n        // elDefs: null, // [defs] element\n        memory: {\n          methodsToExec: []\n        },\n        shouldAnimate: true,\n        delayedElements: [],\n        // element which appear after animation has finished\n        axisCharts: true,\n        // chart type = line or area or bar\n        // (refer them also as plot charts in the code)\n        isXNumeric: false,\n        // bool: data was provided in a {[x,y], [x,y]} pattern\n        isDataXYZ: false,\n        // bool: data was provided in a {[x,y,z]} pattern\n        resized: false,\n        // bool: user has resized\n        resizeTimer: null,\n        // timeout function to make a small delay before\n        // drawing when user resized\n        comboCharts: false,\n        // bool: whether it's a combination of line/column\n        comboChartsHasBars: false,\n        // bool: whether it's a combination of line/column\n        dataChanged: false,\n        // bool: has data changed dynamically\n        previousPaths: [],\n        // array: when data is changed, it will animate from\n        // previous paths\n        seriesXvalues: [],\n        // we will need this in tooltip (it's x position)\n        // when we will have unequal x values, we will need\n        // some way to get x value depending on mouse pointer\n        seriesYvalues: [],\n        // we will need this when deciding which series\n        // user hovered on\n        seriesCandleO: [],\n        // candle stick open values\n        seriesCandleH: [],\n        // candle stick high values\n        seriesCandleL: [],\n        // candle stick low values\n        seriesCandleC: [],\n        // candle stick close values\n        allSeriesHasEqualX: true,\n        dataPoints: 0,\n        // the longest series length\n        pointsArray: [],\n        // store the points positions here to draw later on hover\n        // format is - [[x,y],[x,y]... [x,y]]\n        dataLabelsRects: [],\n        // store the positions of datalabels to prevent collision\n        lastDrawnDataLabelsIndexes: [],\n        hasNullValues: false,\n        // bool: whether series contains null values\n        easing: null,\n        // function: animation effect to apply\n        zoomed: false,\n        // whether user has zoomed or not\n        gridWidth: 0,\n        // drawable width of actual graphs (series paths)\n        gridHeight: 0,\n        // drawable height of actual graphs (series paths)\n        yAxisScale: [],\n        xAxisScale: null,\n        xAxisTicksPositions: [],\n        timescaleTicks: [],\n        rotateXLabels: false,\n        defaultLabels: false,\n        xLabelFormatter: undefined,\n        // formatter for x axis labels\n        yLabelFormatters: [],\n        xaxisTooltipFormatter: undefined,\n        // formatter for x axis tooltip\n        ttKeyFormatter: undefined,\n        ttVal: undefined,\n        ttZFormatter: undefined,\n        LINE_HEIGHT_RATIO: 1.618,\n        xAxisLabelsHeight: 0,\n        yAxisLabelsWidth: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        translateYAxisX: [],\n        yLabelsCoords: [],\n        yTitleCoords: [],\n        yAxisWidths: [],\n        translateXAxisY: 0,\n        translateXAxisX: 0,\n        tooltip: null,\n        tooltipOpts: null\n      };\n    }\n  }, {\n    key: \"init\",\n    value: function init(config) {\n      var globals = this.globalVars(config);\n      globals.initialConfig = Utils.extend({}, config);\n      globals.initialSeries = JSON.parse(JSON.stringify(globals.initialConfig.series));\n      globals.lastXAxis = JSON.parse(JSON.stringify(globals.initialConfig.xaxis));\n      globals.lastYAxis = JSON.parse(JSON.stringify(globals.initialConfig.yaxis));\n      return globals;\n    }\n  }]);\n\n  return Globals;\n}();\n\n/**\n * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.\n *\n * @module Base\n **/\n\nvar Base =\n/*#__PURE__*/\nfunction () {\n  function Base(opts) {\n    _classCallCheck(this, Base);\n\n    this.opts = opts;\n  }\n\n  _createClass(Base, [{\n    key: \"init\",\n    value: function init() {\n      var config = new Config(this.opts).init();\n      var globals = new Globals().init(config);\n      var w = {\n        config: config,\n        globals: globals\n      };\n      return w;\n    }\n  }]);\n\n  return Base;\n}();\n\n/**\n * ApexCharts Fill Class for setting fill options of the paths.\n *\n * @module Fill\n **/\n\nvar Fill =\n/*#__PURE__*/\nfunction () {\n  function Fill(ctx) {\n    _classCallCheck(this, Fill);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.opts = null;\n    this.seriesIndex = 0;\n  }\n\n  _createClass(Fill, [{\n    key: \"clippedImgArea\",\n    value: function clippedImgArea(params) {\n      var w = this.w;\n      var cnf = w.config;\n      var svgW = parseInt(w.globals.gridWidth);\n      var svgH = parseInt(w.globals.gridHeight);\n      var size = svgW > svgH ? svgW : svgH;\n      var fillImg = params.image;\n      var imgWidth = 0;\n      var imgHeight = 0;\n\n      if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {\n        if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {\n          imgWidth = cnf.fill.image.width + 1;\n          imgHeight = cnf.fill.image.height;\n        } else {\n          imgWidth = size + 1;\n          imgHeight = size;\n        }\n      } else {\n        imgWidth = params.width;\n        imgHeight = params.height;\n      }\n\n      var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');\n      Graphics.setAttrs(elPattern, {\n        id: params.patternID,\n        patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',\n        width: imgWidth + 'px',\n        height: imgHeight + 'px'\n      });\n      var elImage = document.createElementNS(w.globals.SVGNS, 'image');\n      elPattern.appendChild(elImage);\n      elImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', fillImg);\n      Graphics.setAttrs(elImage, {\n        x: 0,\n        y: 0,\n        preserveAspectRatio: 'none',\n        width: imgWidth + 'px',\n        height: imgHeight + 'px'\n      });\n      elImage.style.opacity = params.opacity;\n      w.globals.dom.elDefs.node.appendChild(elPattern);\n    }\n  }, {\n    key: \"getSeriesIndex\",\n    value: function getSeriesIndex(opts) {\n      var w = this.w;\n\n      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap') {\n        this.seriesIndex = opts.seriesNumber;\n      } else {\n        this.seriesIndex = opts.seriesNumber % w.globals.series.length;\n      }\n\n      return this.seriesIndex;\n    }\n  }, {\n    key: \"fillPath\",\n    value: function fillPath(opts) {\n      var w = this.w;\n      this.opts = opts;\n      var cnf = this.w.config;\n      var pathFill;\n      var patternFill, gradientFill;\n      this.seriesIndex = this.getSeriesIndex(opts);\n      var fillColors = this.getFillColors();\n      var fillColor = fillColors[this.seriesIndex];\n      var fillType = this.getFillType(this.seriesIndex);\n      var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;\n      var defaultColor = fillColor;\n\n      if (opts.color) {\n        fillColor = opts.color;\n      }\n\n      if (fillColor.indexOf('rgb') === -1) {\n        defaultColor = Utils.hexToRgba(fillColor, fillOpacity);\n      } else {\n        if (fillColor.indexOf('rgba') > -1) {\n          fillOpacity = 0 + '.' + Utils.getOpacityFromRGBA(fillColors[this.seriesIndex]);\n        }\n      }\n\n      if (fillType === 'pattern') {\n        patternFill = this.handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor);\n      }\n\n      if (fillType === 'gradient') {\n        gradientFill = this.handleGradientFill(gradientFill, fillColor, fillOpacity, this.seriesIndex);\n      }\n\n      if (cnf.fill.image.src.length > 0 && fillType === 'image') {\n        if (opts.seriesNumber < cnf.fill.image.src.length) {\n          this.clippedImgArea({\n            opacity: fillOpacity,\n            image: cnf.fill.image.src[opts.seriesNumber],\n            patternUnits: opts.patternUnits,\n            patternID: \"pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1)\n          });\n          pathFill = \"url(#pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1, \")\");\n        } else {\n          pathFill = defaultColor;\n        }\n      } else if (fillType === 'gradient') {\n        pathFill = gradientFill;\n      } else if (fillType === 'pattern') {\n        pathFill = patternFill;\n      } else {\n        pathFill = defaultColor;\n      } // override pattern/gradient if opts.solid is true\n\n\n      if (opts.solid) {\n        pathFill = defaultColor;\n      }\n\n      return pathFill;\n    }\n  }, {\n    key: \"getFillType\",\n    value: function getFillType(seriesIndex) {\n      var w = this.w;\n\n      if (Array.isArray(w.config.fill.type)) {\n        return w.config.fill.type[seriesIndex];\n      } else {\n        return w.config.fill.type;\n      }\n    }\n  }, {\n    key: \"getFillColors\",\n    value: function getFillColors() {\n      var w = this.w;\n      var cnf = w.config;\n      var opts = this.opts;\n      var fillColors = [];\n\n      if (w.globals.comboCharts) {\n        if (w.config.series[this.seriesIndex].type === 'line') {\n          if (w.globals.stroke.colors instanceof Array) {\n            fillColors = w.globals.stroke.colors;\n          } else {\n            fillColors.push(w.globals.stroke.colors);\n          }\n        } else {\n          if (w.globals.fill.colors instanceof Array) {\n            fillColors = w.globals.fill.colors;\n          } else {\n            fillColors.push(w.globals.fill.colors);\n          }\n        }\n      } else {\n        if (cnf.chart.type === 'line') {\n          if (w.globals.stroke.colors instanceof Array) {\n            fillColors = w.globals.stroke.colors;\n          } else {\n            fillColors.push(w.globals.stroke.colors);\n          }\n        } else {\n          if (w.globals.fill.colors instanceof Array) {\n            fillColors = w.globals.fill.colors;\n          } else {\n            fillColors.push(w.globals.fill.colors);\n          }\n        }\n      } // colors passed in arguments\n\n\n      if (typeof opts.fillColors !== 'undefined') {\n        fillColors = [];\n\n        if (opts.fillColors instanceof Array) {\n          fillColors = opts.fillColors.slice();\n        } else {\n          fillColors.push(opts.fillColors);\n        }\n      }\n\n      return fillColors;\n    }\n  }, {\n    key: \"handlePatternFill\",\n    value: function handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor) {\n      var cnf = this.w.config;\n      var opts = this.opts;\n      var graphics = new Graphics(this.ctx);\n      var patternStrokeWidth = cnf.fill.pattern.strokeWidth === undefined ? Array.isArray(cnf.stroke.width) ? cnf.stroke.width[this.seriesIndex] : cnf.stroke.width : Array.isArray(cnf.fill.pattern.strokeWidth) ? cnf.fill.pattern.strokeWidth[this.seriesIndex] : cnf.fill.pattern.strokeWidth;\n      var patternLineColor = fillColor;\n\n      if (cnf.fill.pattern.style instanceof Array) {\n        if (typeof cnf.fill.pattern.style[opts.seriesNumber] !== 'undefined') {\n          var pf = graphics.drawPattern(cnf.fill.pattern.style[opts.seriesNumber], cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n          patternFill = pf;\n        } else {\n          patternFill = defaultColor;\n        }\n      } else {\n        patternFill = graphics.drawPattern(cnf.fill.pattern.style, cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n      }\n\n      return patternFill;\n    }\n  }, {\n    key: \"handleGradientFill\",\n    value: function handleGradientFill(gradientFill, fillColor, fillOpacity, i) {\n      var cnf = this.w.config;\n      var opts = this.opts;\n      var graphics = new Graphics(this.ctx);\n      var utils = new Utils();\n      var type = cnf.fill.gradient.type;\n      var gradientFrom, gradientTo;\n      var opacityFrom = cnf.fill.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityFrom) ? cnf.fill.gradient.opacityFrom[i] : cnf.fill.gradient.opacityFrom;\n      var opacityTo = cnf.fill.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityTo) ? cnf.fill.gradient.opacityTo[i] : cnf.fill.gradient.opacityTo;\n      gradientFrom = fillColor;\n\n      if (cnf.fill.gradient.gradientToColors === undefined || cnf.fill.gradient.gradientToColors.length === 0) {\n        if (cnf.fill.gradient.shade === 'dark') {\n          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity) * -1, fillColor);\n        } else {\n          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity), fillColor);\n        }\n      } else {\n        gradientTo = cnf.fill.gradient.gradientToColors[opts.seriesNumber];\n      }\n\n      if (cnf.fill.gradient.inverseColors) {\n        var t = gradientFrom;\n        gradientFrom = gradientTo;\n        gradientTo = t;\n      }\n\n      gradientFill = graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, cnf.fill.gradient.stops, cnf.fill.gradient.colorStops, i);\n      return gradientFill;\n    }\n  }]);\n\n  return Fill;\n}();\n\n/**\n * ApexCharts Markers Class for drawing points on y values in axes charts.\n *\n * @module Markers\n **/\n\nvar Markers =\n/*#__PURE__*/\nfunction () {\n  function Markers(ctx, opts) {\n    _classCallCheck(this, Markers);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Markers, [{\n    key: \"setGlobalMarkerSize\",\n    value: function setGlobalMarkerSize() {\n      var w = this.w;\n      w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];\n\n      if (w.globals.markers.size.length > 0) {\n        if (w.globals.markers.size.length < w.globals.series.length + 1) {\n          for (var i = 0; i <= w.globals.series.length; i++) {\n            if (typeof w.globals.markers.size[i] === 'undefined') {\n              w.globals.markers.size.push(w.globals.markers.size[0]);\n            }\n          }\n        }\n      } else {\n        w.globals.markers.size = w.config.series.map(function (s) {\n          return w.config.markers.size;\n        });\n      }\n    }\n  }, {\n    key: \"plotChartMarkers\",\n    value: function plotChartMarkers(pointsPos, seriesIndex, j) {\n      var _this = this;\n\n      var w = this.w;\n      var i = seriesIndex;\n      var p = pointsPos;\n      var elPointsWrap = null;\n      var graphics = new Graphics(this.ctx);\n      var point;\n\n      if (w.globals.markers.size[seriesIndex] > 0) {\n        elPointsWrap = graphics.group({\n          class: 'apexcharts-series-markers'\n        });\n        elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n      }\n\n      if (p.x instanceof Array) {\n        var _loop = function _loop(q) {\n          var dataPointIndex = j; // a small hack as we have 2 points for the first val to connect it\n\n          if (j === 1 && q === 0) dataPointIndex = 0;\n          if (j === 1 && q === 1) dataPointIndex = 1;\n          var PointClasses = 'apexcharts-marker';\n\n          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n            PointClasses += ' no-pointer-events';\n          }\n\n          var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;\n\n          if (shouldMarkerDraw) {\n            if (Utils.isNumber(p.y[q])) {\n              PointClasses += \" w\".concat((Math.random() + 1).toString(36).substring(4));\n            } else {\n              PointClasses = 'apexcharts-nullpoint';\n            }\n\n            var opts = _this.getMarkerConfig(PointClasses, seriesIndex); // discrete markers is an option where user can specify a particular marker with different size and color\n\n\n            w.config.markers.discrete.map(function (marker) {\n              if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {\n                opts.pointStrokeColor = marker.strokeColor;\n                opts.pointFillColor = marker.fillColor;\n                opts.pSize = marker.size;\n              }\n            });\n\n            if (w.config.series[i].data[j]) {\n              if (w.config.series[i].data[j].fillColor) {\n                opts.pointFillColor = w.config.series[i].data[j].fillColor;\n              }\n\n              if (w.config.series[i].data[j].strokeColor) {\n                opts.pointStrokeColor = w.config.series[i].data[j].strokeColor;\n              }\n            }\n\n            point = graphics.drawMarker(p.x[q], p.y[q], opts);\n            point.attr('rel', dataPointIndex);\n            point.attr('j', dataPointIndex);\n            point.attr('index', seriesIndex);\n            point.node.setAttribute('default-marker-size', opts.pSize);\n            var filters = new Filters(_this.ctx);\n            filters.setSelectionFilter(point, seriesIndex, dataPointIndex);\n\n            _this.addEvents(point);\n\n            if (elPointsWrap) {\n              elPointsWrap.add(point);\n            }\n          } else {\n            // dynamic array creation - multidimensional\n            if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];\n            w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);\n          }\n        };\n\n        for (var q = 0; q < p.x.length; q++) {\n          _loop(q);\n        }\n      }\n\n      return elPointsWrap;\n    }\n  }, {\n    key: \"getMarkerConfig\",\n    value: function getMarkerConfig(cssClass, seriesIndex) {\n      var w = this.w;\n      var pStyle = this.getMarkerStyle(seriesIndex);\n      var pSize = w.globals.markers.size[seriesIndex];\n      return {\n        pSize: pSize,\n        pRadius: w.config.markers.radius,\n        pWidth: w.config.markers.strokeWidth,\n        pointStrokeColor: pStyle.pointStrokeColor,\n        pointFillColor: pStyle.pointFillColor,\n        shape: w.config.markers.shape instanceof Array ? w.config.markers.shape[seriesIndex] : w.config.markers.shape,\n        class: cssClass,\n        pointStrokeOpacity: w.config.markers.strokeOpacity,\n        pointFillOpacity: w.config.markers.fillOpacity,\n        seriesIndex: seriesIndex\n      };\n    }\n  }, {\n    key: \"addEvents\",\n    value: function addEvents(circle) {\n      var graphics = new Graphics(this.ctx);\n      circle.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, circle));\n      circle.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, circle));\n      circle.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, circle));\n      circle.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, circle), {\n        passive: true\n      });\n    }\n  }, {\n    key: \"getMarkerStyle\",\n    value: function getMarkerStyle(seriesIndex) {\n      var w = this.w;\n      var colors = w.globals.markers.colors;\n      var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;\n      var pointStrokeColor = strokeColors instanceof Array ? strokeColors[seriesIndex] : strokeColors;\n      var pointFillColor = colors instanceof Array ? colors[seriesIndex] : colors;\n      return {\n        pointStrokeColor: pointStrokeColor,\n        pointFillColor: pointFillColor\n      };\n    }\n  }]);\n\n  return Markers;\n}();\n\n/**\n * ApexCharts Scatter Class.\n * This Class also handles bubbles chart as currently there is no major difference in drawing them,\n * @module Scatter\n **/\n\nvar Scatter =\n/*#__PURE__*/\nfunction () {\n  function Scatter(ctx) {\n    _classCallCheck(this, Scatter);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; // this array will help in centering the label in bubbles\n\n    this.radiusSizes = [];\n  }\n\n  _createClass(Scatter, [{\n    key: \"draw\",\n    value: function draw(elSeries, j, opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var realIndex = opts.realIndex;\n      var pointsPos = opts.pointsPos;\n      var zRatio = opts.zRatio;\n      var elPointsMain = opts.elParent;\n      var elPointsWrap = graphics.group({\n        class: \"apexcharts-series-markers apexcharts-series-\".concat(w.config.chart.type)\n      });\n      elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n\n      if (pointsPos.x instanceof Array) {\n        for (var q = 0; q < pointsPos.x.length; q++) {\n          var dataPointIndex = j + 1;\n          var shouldDraw = true; // a small hack as we have 2 points for the first val to connect it\n\n          if (j === 0 && q === 0) dataPointIndex = 0;\n          if (j === 0 && q === 1) dataPointIndex = 1;\n          var radius = 0;\n          var finishRadius = w.globals.markers.size[realIndex];\n\n          if (zRatio !== Infinity) {\n            // means we have a bubble\n            finishRadius = w.globals.seriesZ[realIndex][dataPointIndex] / zRatio;\n\n            if (typeof this.radiusSizes[realIndex] === 'undefined') {\n              this.radiusSizes.push([]);\n            }\n\n            this.radiusSizes[realIndex].push(finishRadius);\n          }\n\n          if (!w.config.chart.animations.enabled) {\n            radius = finishRadius;\n          }\n\n          var x = pointsPos.x[q];\n          var y = pointsPos.y[q];\n          radius = radius || 0;\n\n          if (x === 0 && y === 0 || y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {\n            shouldDraw = false;\n          }\n\n          if (shouldDraw) {\n            var circle = this.drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j);\n            elPointsWrap.add(circle);\n          }\n\n          elPointsMain.add(elPointsWrap);\n        }\n      }\n    }\n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j) {\n      var w = this.w;\n      var i = realIndex;\n      var anim = new Animations(this.ctx);\n      var filters = new Filters(this.ctx);\n      var fill = new Fill(this.ctx);\n      var markers = new Markers(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var markerConfig = markers.getMarkerConfig('apexcharts-marker', i);\n      var pathFillCircle = fill.fillPath({\n        seriesNumber: realIndex,\n        patternUnits: 'objectBoundingBox'\n      });\n      var circle = graphics.drawCircle(radius);\n\n      if (w.config.series[i].data[dataPointIndex]) {\n        if (w.config.series[i].data[dataPointIndex].fillColor) {\n          pathFillCircle = w.config.series[i].data[dataPointIndex].fillColor;\n        }\n      }\n\n      circle.attr({\n        cx: x,\n        cy: y,\n        fill: pathFillCircle,\n        stroke: markerConfig.pointStrokeColor,\n        strokeWidth: markerConfig.pWidth\n      });\n\n      if (w.config.chart.dropShadow.enabled) {\n        filters.dropShadow(circle, {\n          top: w.config.chart.dropShadow.top,\n          left: w.config.chart.dropShadow.left,\n          blur: w.config.chart.dropShadow.blur,\n          color: w.config.chart.dropShadow.color,\n          opacity: w.config.chart.dropShadow.opacity\n        });\n      }\n\n      if (this.initialAnim && !w.globals.dataChanged) {\n        var speed = 1;\n\n        if (!w.globals.resized) {\n          speed = w.config.chart.animations.speed;\n        }\n\n        anim.animateCircleRadius(circle, 0, finishRadius, speed, w.globals.easing);\n      }\n\n      if (w.globals.dataChanged) {\n        if (this.dynamicAnim) {\n          var _speed = w.config.chart.animations.dynamicAnimation.speed;\n          var prevX, prevY, prevR;\n          var prevPathJ = null;\n          prevPathJ = w.globals.previousPaths[realIndex] && w.globals.previousPaths[realIndex][j];\n\n          if (typeof prevPathJ !== 'undefined' && prevPathJ !== null) {\n            // series containing less elements will ignore these values and revert to 0\n            prevX = prevPathJ.x;\n            prevY = prevPathJ.y;\n            prevR = typeof prevPathJ.r !== 'undefined' ? prevPathJ.r : finishRadius;\n          }\n\n          for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {\n            if (w.globals.collapsedSeries[cs].index === realIndex) {\n              _speed = 1;\n              finishRadius = 0;\n            }\n          }\n\n          if (x === 0 && y === 0) finishRadius = 0;\n          anim.animateCircle(circle, {\n            cx: prevX,\n            cy: prevY,\n            r: prevR\n          }, {\n            cx: x,\n            cy: y,\n            r: finishRadius\n          }, _speed, w.globals.easing);\n        } else {\n          circle.attr({\n            r: finishRadius\n          });\n        }\n      }\n\n      circle.attr({\n        rel: dataPointIndex,\n        j: dataPointIndex,\n        index: realIndex,\n        'default-marker-size': finishRadius\n      });\n      filters.setSelectionFilter(circle, realIndex, dataPointIndex);\n      markers.addEvents(circle);\n      circle.node.classList.add('apexcharts-marker');\n      return circle;\n    }\n  }, {\n    key: \"centerTextInBubble\",\n    value: function centerTextInBubble(y) {\n      var w = this.w;\n      y = y + parseInt(w.config.dataLabels.style.fontSize) / 4;\n      return {\n        y: y\n      };\n    }\n  }]);\n\n  return Scatter;\n}();\n\n/**\n * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.\n *\n * @module DataLabels\n **/\n\nvar DataLabels =\n/*#__PURE__*/\nfunction () {\n  function DataLabels(ctx) {\n    _classCallCheck(this, DataLabels);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that\n  // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again\n\n\n  _createClass(DataLabels, [{\n    key: \"dataLabelsCorrection\",\n    value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var drawnextLabel = false; //\n\n      var textRects = graphics.getTextRects(val, fontSize);\n      var width = textRects.width;\n      var height = textRects.height; // first value in series, so push an empty array\n\n      if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = []; // then start pushing actual rects in that sub-array\n\n      w.globals.dataLabelsRects[i].push({\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n      var len = w.globals.dataLabelsRects[i].length - 2;\n      var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;\n\n      if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {\n        var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];\n\n        if ( // next label forward and x not intersecting\n        x > lastDataLabelRect.x + lastDataLabelRect.width + 2 || y > lastDataLabelRect.y + lastDataLabelRect.height + 2 || x + width < lastDataLabelRect.x // next label is going to be drawn backwards\n        ) {\n            // the 2 indexes don't override, so OK to draw next label\n            drawnextLabel = true;\n          }\n      }\n\n      if (dataPointIndex === 0 || alwaysDrawDataLabel) {\n        drawnextLabel = true;\n      }\n\n      return {\n        x: x,\n        y: y,\n        drawnextLabel: drawnextLabel\n      };\n    }\n  }, {\n    key: \"drawDataLabel\",\n    value: function drawDataLabel(pos, i, j) {\n      var align = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';\n      // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions\n      // all other charts like bars / heatmaps will define their own drawDataLabel routine\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var dataLabelsConfig = w.config.dataLabels;\n      var x = 0;\n      var y = 0;\n      var dataPointIndex = j;\n      var elDataLabelsWrap = null;\n\n      if (!dataLabelsConfig.enabled || pos.x instanceof Array !== true) {\n        return elDataLabelsWrap;\n      }\n\n      elDataLabelsWrap = graphics.group({\n        class: 'apexcharts-data-labels'\n      });\n      elDataLabelsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n\n      for (var q = 0; q < pos.x.length; q++) {\n        x = pos.x[q] + dataLabelsConfig.offsetX;\n        y = pos.y[q] + dataLabelsConfig.offsetY - w.globals.markers.size[i] - 5;\n\n        if (align === 'bottom') {\n          y = y + w.globals.markers.size[i] * 2 + parseInt(dataLabelsConfig.style.fontSize) * 1.4;\n        }\n\n        if (!isNaN(x)) {\n          // a small hack as we have 2 points for the first val to connect it\n          if (j === 1 && q === 0) dataPointIndex = 0;\n          if (j === 1 && q === 1) dataPointIndex = 1;\n          var val = w.globals.series[i][dataPointIndex];\n          var text = '';\n\n          if (w.config.chart.type === 'bubble') {\n            text = w.globals.seriesZ[i][dataPointIndex];\n            y = pos.y[q] + w.config.dataLabels.offsetY;\n            var scatter = new Scatter(this.ctx);\n            var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);\n            y = centerTextInBubbleCoords.y;\n          } else {\n            if (typeof val !== 'undefined') {\n              text = w.config.dataLabels.formatter(val, {\n                seriesIndex: i,\n                dataPointIndex: dataPointIndex,\n                w: w\n              });\n            }\n          }\n\n          if (text === null) text = '';\n          this.plotDataLabelsText({\n            x: x,\n            y: y,\n            text: text,\n            i: i,\n            j: dataPointIndex,\n            parent: elDataLabelsWrap,\n            offsetCorrection: true,\n            dataLabelsConfig: w.config.dataLabels\n          });\n        }\n      }\n\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"plotDataLabelsText\",\n    value: function plotDataLabelsText(opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var x = opts.x,\n          y = opts.y,\n          i = opts.i,\n          j = opts.j,\n          text = opts.text,\n          textAnchor = opts.textAnchor,\n          parent = opts.parent,\n          dataLabelsConfig = opts.dataLabelsConfig,\n          alwaysDrawDataLabel = opts.alwaysDrawDataLabel,\n          offsetCorrection = opts.offsetCorrection;\n\n      if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {\n        if (w.config.dataLabels.enabledOnSeries.indexOf(i) > -1) {\n          return;\n        }\n      }\n\n      var correctedLabels = {\n        x: x,\n        y: y,\n        drawnextLabel: true\n      };\n\n      if (offsetCorrection) {\n        correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize));\n      } // when zoomed, we don't need to correct labels offsets,\n      // but if normally, labels get cropped, correct them\n\n\n      if (!w.globals.zoomed) {\n        x = correctedLabels.x;\n        y = correctedLabels.y;\n      }\n\n      if (correctedLabels.drawnextLabel) {\n        var dataLabelText = graphics.drawText({\n          width: 100,\n          height: parseInt(dataLabelsConfig.style.fontSize),\n          x: x,\n          y: y,\n          foreColor: w.globals.dataLabels.style.colors[i],\n          textAnchor: textAnchor || dataLabelsConfig.textAnchor,\n          text: text,\n          fontSize: dataLabelsConfig.style.fontSize,\n          fontFamily: dataLabelsConfig.style.fontFamily\n        });\n        dataLabelText.attr({\n          class: 'apexcharts-datalabel',\n          cx: x,\n          cy: y\n        });\n\n        if (dataLabelsConfig.dropShadow.enabled) {\n          var textShadow = dataLabelsConfig.dropShadow;\n          var filters = new Filters(this.ctx);\n          filters.dropShadow(dataLabelText, textShadow);\n        }\n\n        parent.add(dataLabelText);\n\n        if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {\n          w.globals.lastDrawnDataLabelsIndexes[i] = [];\n        }\n\n        w.globals.lastDrawnDataLabelsIndexes[i].push(j);\n      }\n    }\n  }]);\n\n  return DataLabels;\n}();\n\n/**\n * ApexCharts Bar Class responsible for drawing both Columns and Bars.\n *\n * @module Bar\n **/\n\nvar Bar =\n/*#__PURE__*/\nfunction () {\n  function Bar(ctx, xyRatios) {\n    _classCallCheck(this, Bar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.barOptions = w.config.plotOptions.bar;\n    this.isHorizontal = this.barOptions.horizontal;\n    this.strokeWidth = w.config.stroke.width;\n    this.isNullValue = false;\n    this.xyRatios = xyRatios;\n\n    if (this.xyRatios !== null) {\n      this.xRatio = xyRatios.xRatio;\n      this.yRatio = xyRatios.yRatio;\n      this.invertedXRatio = xyRatios.invertedXRatio;\n      this.invertedYRatio = xyRatios.invertedYRatio;\n      this.baseLineY = xyRatios.baseLineY;\n      this.baseLineInvertedY = xyRatios.baseLineInvertedY;\n    }\n\n    this.yaxisIndex = 0;\n    this.seriesLen = 0;\n  }\n  /** primary draw method which is called on bar object\n   * @memberof Bar\n   * @param {array} series - user supplied series values\n   * @param {int} seriesIndex - the index by which series will be drawn on the svg\n   * @return {node} element which is supplied to parent chart draw method for appending\n   **/\n\n\n  _createClass(Bar, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var coreUtils = new CoreUtils(this.ctx, w);\n      series = coreUtils.getLogSeries(series);\n      this.series = series;\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.initVariables(series);\n      var ret = graphics.group({\n        class: 'apexcharts-bar-series apexcharts-plot-series'\n      });\n\n      if (w.config.dataLabels.enabled) {\n        if (this.totalItems > w.config.plotOptions.bar.dataLabels.maxItems) {\n          console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.');\n        }\n      }\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var x = void 0,\n            y = void 0,\n            xDivision = void 0,\n            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n        yDivision = void 0,\n            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n        zeroH = void 0,\n            // zeroH is the baseline where 0 meets y axis\n        zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n\n        if (series[i].length > 0) {\n          this.visibleI = this.visibleI + 1;\n        }\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;\n        var initPositions = this.initialPositions();\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        yDivision = initPositions.yDivision;\n        zeroW = initPositions.zeroW;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n\n        if (!this.horizontal) {\n          xArrj.push(x + barWidth / 2);\n        } // eldatalabels\n\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {\n          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {\n            this.isNullValue = true;\n          } else {\n            this.isNullValue = false;\n          }\n\n          if (w.config.stroke.show) {\n            if (this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n            }\n          }\n\n          var paths = null;\n\n          if (this.isHorizontal) {\n            paths = this.drawBarPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              barHeight: barHeight,\n              strokeWidth: strokeWidth,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              zeroW: zeroW,\n              x: x,\n              y: y,\n              yDivision: yDivision,\n              elSeries: elSeries\n            });\n          } else {\n            paths = this.drawColumnPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              xDivision: xDivision,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              barWidth: barWidth,\n              zeroH: zeroH,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            });\n          }\n\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x; // push current X\n\n          if (j > 0) {\n            xArrj.push(x + barWidth / 2);\n          }\n\n          yArrj.push(y);\n          var pathFill = this.getPathFillColor(series, i, j, realIndex);\n          elSeries = this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            visibleSeries: this.visibleI,\n            type: 'bar'\n          });\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj;\n        ret.add(elSeries);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"getPathFillColor\",\n    value: function getPathFillColor(series, i, j, realIndex) {\n      var w = this.w;\n      var fill = new Fill(this.ctx);\n      var fillColor = null;\n      var seriesNumber = this.barOptions.distributed ? j : i;\n\n      if (this.barOptions.colors.ranges.length > 0) {\n        var colorRange = this.barOptions.colors.ranges;\n        colorRange.map(function (range) {\n          if (series[i][j] >= range.from && series[i][j] <= range.to) {\n            fillColor = range.color;\n          }\n        });\n      }\n\n      if (w.config.series[i].data[j] && w.config.series[i].data[j].fillColor) {\n        fillColor = w.config.series[i].data[j].fillColor;\n      }\n\n      var pathFill = fill.fillPath({\n        seriesNumber: this.barOptions.distributed ? seriesNumber : realIndex,\n        color: fillColor\n      });\n      return pathFill;\n    }\n  }, {\n    key: \"renderSeries\",\n    value: function renderSeries(_ref) {\n      var realIndex = _ref.realIndex,\n          pathFill = _ref.pathFill,\n          lineFill = _ref.lineFill,\n          j = _ref.j,\n          i = _ref.i,\n          pathFrom = _ref.pathFrom,\n          pathTo = _ref.pathTo,\n          strokeWidth = _ref.strokeWidth,\n          elSeries = _ref.elSeries,\n          x = _ref.x,\n          y = _ref.y,\n          series = _ref.series,\n          barHeight = _ref.barHeight,\n          barWidth = _ref.barWidth,\n          elDataLabelsWrap = _ref.elDataLabelsWrap,\n          visibleSeries = _ref.visibleSeries,\n          type = _ref.type;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n\n      if (!lineFill) {\n        /* fix apexcharts#341 */\n        lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : w.globals.stroke.colors[realIndex];\n      }\n\n      if (w.config.series[i].data[j] && w.config.series[i].data[j].strokeColor) {\n        lineFill = w.config.series[i].data[j].strokeColor;\n      }\n\n      if (this.isNullValue) {\n        pathFill = 'none';\n      }\n\n      var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;\n      var renderedPath = graphics.renderPaths({\n        i: i,\n        j: j,\n        realIndex: realIndex,\n        pathFrom: pathFrom,\n        pathTo: pathTo,\n        stroke: lineFill,\n        strokeWidth: strokeWidth,\n        strokeLineCap: w.config.stroke.lineCap,\n        fill: pathFill,\n        animationDelay: delay,\n        initialSpeed: w.config.chart.animations.speed,\n        dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n        className: \"apexcharts-\".concat(type, \"-area\"),\n        id: \"apexcharts-\".concat(type, \"-area\")\n      });\n      renderedPath.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n      var filters = new Filters(this.ctx);\n      filters.setSelectionFilter(renderedPath, realIndex, j);\n      elSeries.add(renderedPath);\n      var dataLabels = this.calculateDataLabelsPos({\n        x: x,\n        y: y,\n        i: i,\n        j: j,\n        series: series,\n        realIndex: realIndex,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        renderedPath: renderedPath,\n        visibleSeries: visibleSeries\n      });\n\n      if (dataLabels !== null) {\n        elDataLabelsWrap.add(dataLabels);\n      }\n\n      elSeries.add(elDataLabelsWrap);\n      return elSeries;\n    }\n  }, {\n    key: \"initVariables\",\n    value: function initVariables(series) {\n      var w = this.w;\n      this.series = series;\n      this.totalItems = 0;\n      this.seriesLen = 0;\n      this.visibleI = -1;\n      this.visibleItems = 1; // number of visible bars after user zoomed in/out\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length > 0) {\n          this.seriesLen = this.seriesLen + 1;\n          this.totalItems += series[sl].length;\n        }\n\n        if (w.globals.isXNumeric) {\n          // get max visible items\n          for (var j = 0; j < series[sl].length; j++) {\n            if (w.globals.seriesX[sl][j] > w.globals.minX && w.globals.seriesX[sl][j] < w.globals.maxX) {\n              this.visibleItems++;\n            }\n          }\n        } else {\n          this.visibleItems = w.globals.dataPoints;\n        }\n      }\n\n      if (this.seriesLen === 0) {\n        // A small adjustment when combo charts are used\n        this.seriesLen = 1;\n      }\n    }\n  }, {\n    key: \"initialPositions\",\n    value: function initialPositions() {\n      var w = this.w;\n      var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;\n\n      if (this.isHorizontal) {\n        // height divided into equal parts\n        yDivision = w.globals.gridHeight / w.globals.dataPoints;\n        barHeight = yDivision / this.seriesLen;\n\n        if (w.globals.isXNumeric) {\n          yDivision = w.globals.gridHeight / this.totalItems;\n          barHeight = yDivision / this.seriesLen;\n        }\n\n        barHeight = barHeight * parseInt(this.barOptions.barHeight) / 100;\n        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0);\n        y = (yDivision - barHeight * this.seriesLen) / 2;\n      } else {\n        // width divided into equal parts\n        xDivision = w.globals.gridWidth / this.visibleItems;\n        barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;\n\n        if (w.globals.isXNumeric) {\n          // max barwidth should be equal to minXDiff to avoid overlap\n          xDivision = w.globals.minXDiff / this.xRatio;\n          barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;\n        }\n\n        zeroH = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0);\n        x = w.globals.padHorizontal + (xDivision - barWidth * this.seriesLen) / 2;\n      }\n\n      return {\n        x: x,\n        y: y,\n        yDivision: yDivision,\n        xDivision: xDivision,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        zeroH: zeroH,\n        zeroW: zeroW\n      };\n    }\n  }, {\n    key: \"drawBarPaths\",\n    value: function drawBarPaths(_ref2) {\n      var indexes = _ref2.indexes,\n          barHeight = _ref2.barHeight,\n          strokeWidth = _ref2.strokeWidth,\n          pathTo = _ref2.pathTo,\n          pathFrom = _ref2.pathFrom,\n          zeroW = _ref2.zeroW,\n          x = _ref2.x,\n          y = _ref2.y,\n          yDivision = _ref2.yDivision,\n          elSeries = _ref2.elSeries;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;\n      }\n\n      var barYPosition = y + barHeight * this.visibleI;\n      pathTo = graphics.move(zeroW, barYPosition);\n      pathFrom = graphics.move(zeroW, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        x = zeroW;\n      } else {\n        x = zeroW + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;\n      }\n\n      var endingShapeOpts = {\n        barHeight: barHeight,\n        strokeWidth: strokeWidth,\n        barYPosition: barYPosition,\n        x: x,\n        zeroW: zeroW\n      };\n      var endingShape = this.barEndingShape(w, endingShapeOpts, this.series, i, j);\n      pathTo = pathTo + graphics.line(endingShape.newX, barYPosition) + endingShape.path + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);\n      pathFrom = pathFrom + graphics.line(zeroW, barYPosition) + endingShape.ending_p_from + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);\n\n      if (!w.globals.isXNumeric) {\n        y = y + yDivision;\n      }\n\n      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= this.barOptions.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = this.barOptions.colors.backgroundBarColors[bc];\n        var rect = graphics.drawRect(0, barYPosition - barHeight * this.visibleI, w.globals.gridWidth, barHeight * this.seriesLen, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y,\n        barYPosition: barYPosition\n      };\n    }\n  }, {\n    key: \"drawColumnPaths\",\n    value: function drawColumnPaths(_ref3) {\n      var indexes = _ref3.indexes,\n          x = _ref3.x,\n          y = _ref3.y,\n          xDivision = _ref3.xDivision,\n          pathTo = _ref3.pathTo,\n          pathFrom = _ref3.pathFrom,\n          barWidth = _ref3.barWidth,\n          zeroH = _ref3.zeroH,\n          strokeWidth = _ref3.strokeWidth,\n          elSeries = _ref3.elSeries;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x + barWidth * this.visibleI;\n      pathTo = graphics.move(barXPosition, zeroH);\n      pathFrom = graphics.move(barXPosition, zeroH);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        y = zeroH;\n      } else {\n        y = zeroH - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;\n      }\n\n      var endingShapeOpts = {\n        barWidth: barWidth,\n        strokeWidth: strokeWidth,\n        barXPosition: barXPosition,\n        y: y,\n        zeroH: zeroH\n      };\n      var endingShape = this.barEndingShape(w, endingShapeOpts, this.series, i, j);\n      pathTo = pathTo + graphics.line(barXPosition, endingShape.newY) + endingShape.path + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition - strokeWidth / 2, zeroH);\n      pathFrom = pathFrom + graphics.line(barXPosition, zeroH) + endingShape.ending_p_from + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition - strokeWidth / 2, zeroH);\n\n      if (!w.globals.isXNumeric) {\n        x = x + xDivision;\n      }\n\n      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= this.barOptions.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = this.barOptions.colors.backgroundBarColors[bc];\n        var rect = graphics.drawRect(barXPosition - barWidth * this.visibleI, 0, barWidth * this.seriesLen, w.globals.gridHeight, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y,\n        barXPosition: barXPosition\n      };\n    }\n    /** getPathFrom is a common function for bars/columns which is used to get previous paths when data changes.\n     * @memberof Bar\n     * @param {int} realIndex - current iterating i\n     * @param {int} j - current iterating series's j index\n     * @return {string} pathFrom is the string which will be appended in animations\n     **/\n\n  }, {\n    key: \"getPathFrom\",\n    value: function getPathFrom(realIndex, j) {\n      var w = this.w;\n      var pathFrom;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {\n            pathFrom = w.globals.previousPaths[pp].paths[j].d;\n          }\n        }\n      }\n\n      return pathFrom;\n    }\n    /** calculateBarDataLabels is used to calculate the positions for the data-labels\n     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()\n     * @memberof Bar\n     * @param {object} {barProps} most of the bar properties used throughout the bar\n     * drawing function\n     * @return {object} dataLabels node-element which you can append later\n     **/\n\n  }, {\n    key: \"calculateDataLabelsPos\",\n    value: function calculateDataLabelsPos(_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          i = _ref4.i,\n          j = _ref4.j,\n          realIndex = _ref4.realIndex,\n          series = _ref4.series,\n          barHeight = _ref4.barHeight,\n          barWidth = _ref4.barWidth,\n          visibleSeries = _ref4.visibleSeries,\n          renderedPath = _ref4.renderedPath;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n      var bcx = x + parseFloat(barWidth * visibleSeries);\n      var bcy = y + parseFloat(barHeight * visibleSeries);\n\n      if (w.globals.isXNumeric) {\n        bcx = x + parseFloat(barWidth * (visibleSeries + 1)) - strokeWidth;\n        bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;\n      }\n\n      var dataLabels = null;\n      var dataLabelsX = x;\n      var dataLabelsY = y;\n      var dataLabelsPos = {};\n      var dataLabelsConfig = w.config.dataLabels;\n      var barDataLabelsConfig = this.barOptions.dataLabels;\n      var offX = dataLabelsConfig.offsetX;\n      var offY = dataLabelsConfig.offsetY;\n      var textRects = {\n        width: 0,\n        height: 0\n      };\n\n      if (w.config.dataLabels.enabled) {\n        textRects = graphics.getTextRects(w.globals.yLabelFormatters[0](w.globals.maxY), parseInt(dataLabelsConfig.style.fontSize));\n      }\n\n      if (this.isHorizontal) {\n        dataLabelsPos = this.calculateBarsDataLabelsPosition({\n          x: x,\n          y: y,\n          i: i,\n          j: j,\n          renderedPath: renderedPath,\n          bcy: bcy,\n          barHeight: barHeight,\n          textRects: textRects,\n          strokeWidth: strokeWidth,\n          dataLabelsX: dataLabelsX,\n          dataLabelsY: dataLabelsY,\n          barDataLabelsConfig: barDataLabelsConfig,\n          offX: offX,\n          offY: offY\n        });\n      } else {\n        dataLabelsPos = this.calculateColumnsDataLabelsPosition({\n          x: x,\n          y: y,\n          i: i,\n          j: j,\n          renderedPath: renderedPath,\n          realIndex: realIndex,\n          bcx: bcx,\n          bcy: bcy,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          textRects: textRects,\n          strokeWidth: strokeWidth,\n          dataLabelsY: dataLabelsY,\n          barDataLabelsConfig: barDataLabelsConfig,\n          offX: offX,\n          offY: offY\n        });\n      }\n\n      renderedPath.attr({\n        cy: dataLabelsPos.bcy,\n        cx: dataLabelsPos.bcx,\n        j: j,\n        val: series[i][j],\n        barHeight: barHeight,\n        barWidth: barWidth\n      });\n      dataLabels = this.drawCalculatedDataLabels({\n        x: dataLabelsPos.dataLabelsX,\n        y: dataLabelsPos.dataLabelsY,\n        val: series[i][j],\n        i: realIndex,\n        j: j,\n        barWidth: barWidth,\n        barHeight: barHeight,\n        textRects: textRects,\n        dataLabelsConfig: dataLabelsConfig\n      });\n      return dataLabels;\n    }\n  }, {\n    key: \"calculateColumnsDataLabelsPosition\",\n    value: function calculateColumnsDataLabelsPosition(opts) {\n      var w = this.w;\n      var i = opts.i,\n          j = opts.j,\n          y = opts.y,\n          bcx = opts.bcx,\n          barWidth = opts.barWidth,\n          textRects = opts.textRects,\n          dataLabelsY = opts.dataLabelsY,\n          barDataLabelsConfig = opts.barDataLabelsConfig,\n          strokeWidth = opts.strokeWidth,\n          offX = opts.offX,\n          offY = opts.offY;\n      var dataLabelsX;\n      var barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];\n      var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n      bcx = bcx - strokeWidth / 2;\n\n      if (w.globals.isXNumeric) {\n        dataLabelsX = bcx - barWidth / 2 + offX;\n      } else {\n        dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;\n      }\n\n      var valIsNegative = this.series[i][j] <= 0;\n\n      if (this.isReversed) {\n        y = y - barHeight;\n      }\n\n      switch (barDataLabelsConfig.position) {\n        case 'center':\n          if (valIsNegative) {\n            dataLabelsY = y + barHeight / 2 + textRects.height / 2 + offY;\n          } else {\n            dataLabelsY = y + barHeight / 2 + textRects.height / 2 - offY;\n          }\n\n          break;\n\n        case 'bottom':\n          if (valIsNegative) {\n            dataLabelsY = y + barHeight + textRects.height + strokeWidth + offY;\n          } else {\n            dataLabelsY = y + barHeight - textRects.height / 2 + strokeWidth - offY;\n          }\n\n          break;\n\n        case 'top':\n          if (valIsNegative) {\n            dataLabelsY = y - textRects.height / 2 - offY;\n          } else {\n            dataLabelsY = y + textRects.height + offY;\n          }\n\n          break;\n      }\n\n      return {\n        bcx: bcx,\n        bcy: y,\n        dataLabelsX: dataLabelsX,\n        dataLabelsY: dataLabelsY\n      };\n    }\n  }, {\n    key: \"calculateBarsDataLabelsPosition\",\n    value: function calculateBarsDataLabelsPosition(opts) {\n      var w = this.w;\n      var x = opts.x,\n          i = opts.i,\n          j = opts.j,\n          bcy = opts.bcy,\n          barHeight = opts.barHeight,\n          textRects = opts.textRects,\n          dataLabelsX = opts.dataLabelsX,\n          strokeWidth = opts.strokeWidth,\n          barDataLabelsConfig = opts.barDataLabelsConfig,\n          offX = opts.offX,\n          offY = opts.offY;\n      var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n      var dataLabelsY = bcy - dataPointsDividedHeight + barHeight / 2 + textRects.height / 2 + offY - 3;\n      var barWidth = this.series[i][j] / this.invertedYRatio;\n      var valIsNegative = this.series[i][j] <= 0;\n\n      if (this.isReversed) {\n        x = x + barWidth;\n      }\n\n      switch (barDataLabelsConfig.position) {\n        case 'center':\n          if (valIsNegative) {\n            dataLabelsX = x - barWidth / 2 - offX;\n          } else {\n            dataLabelsX = x - barWidth / 2 + offX;\n          }\n\n          break;\n\n        case 'bottom':\n          if (valIsNegative) {\n            dataLabelsX = x - barWidth - strokeWidth - Math.round(textRects.width / 2) - offX;\n          } else {\n            dataLabelsX = x - barWidth + strokeWidth + Math.round(textRects.width / 2) + offX;\n          }\n\n          break;\n\n        case 'top':\n          if (valIsNegative) {\n            dataLabelsX = x - strokeWidth + Math.round(textRects.width / 2) - offX;\n          } else {\n            dataLabelsX = x - strokeWidth - Math.round(textRects.width / 2) + offX;\n          }\n\n          break;\n      } // commenting below lines as this causes overlaps over other labels\n      // if (dataLabelsX < 0) {\n      //   dataLabelsX = textRects.width + strokeWidth\n      // } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {\n      //   dataLabelsX = dataLabelsX - textRects.width - strokeWidth\n      // }\n\n\n      return {\n        bcx: x,\n        bcy: bcy,\n        dataLabelsX: dataLabelsX,\n        dataLabelsY: dataLabelsY\n      };\n    }\n  }, {\n    key: \"drawCalculatedDataLabels\",\n    value: function drawCalculatedDataLabels(_ref5) {\n      var x = _ref5.x,\n          y = _ref5.y,\n          val = _ref5.val,\n          i = _ref5.i,\n          j = _ref5.j,\n          textRects = _ref5.textRects,\n          barHeight = _ref5.barHeight,\n          barWidth = _ref5.barWidth,\n          dataLabelsConfig = _ref5.dataLabelsConfig;\n      var w = this.w;\n      var dataLabels = new DataLabels(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var formatter = dataLabelsConfig.formatter;\n      var elDataLabelsWrap = null;\n      var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;\n\n      if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {\n        elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-data-labels'\n        });\n        var text = '';\n\n        if (typeof val !== 'undefined' && val !== null) {\n          text = formatter(val, {\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        if (this.isHorizontal) {\n          barWidth = this.series[i][j] / this.yRatio[this.yaxisIndex];\n        } else {\n          barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];\n        }\n\n        if (textRects.width / 1.6 > barWidth || textRects.height > barHeight) {\n          text = '';\n        }\n\n        dataLabels.plotDataLabelsText({\n          x: x,\n          y: y,\n          text: text,\n          i: i,\n          j: j,\n          parent: elDataLabelsWrap,\n          dataLabelsConfig: dataLabelsConfig,\n          alwaysDrawDataLabel: true,\n          offsetCorrection: true\n        });\n      }\n\n      return elDataLabelsWrap;\n    }\n    /** barEndingShape draws the various shapes on top of bars/columns\n     * @memberof Bar\n     * @param {object} w - chart context\n     * @param {object} opts - consists several properties like barHeight/barWidth\n     * @param {array} series - global primary series\n     * @param {int} i - current iterating series's index\n     * @param {int} j - series's j of i\n     * @return {object} path - ending shape whether round/arrow\n     *         ending_p_from - similar to pathFrom\n     *         newY - which is calculated from existing y and new shape's top\n     **/\n\n  }, {\n    key: \"barEndingShape\",\n    value: function barEndingShape(w, opts, series, i, j) {\n      var graphics = new Graphics(this.ctx);\n\n      if (this.isHorizontal) {\n        var endingShape = null;\n        var endingShapeFrom = '';\n        var x = opts.x;\n\n        if (typeof series[i][j] !== 'undefined' || series[i][j] !== null) {\n          var inverse = series[i][j] < 0;\n          var eX = opts.barHeight / 2 - opts.strokeWidth;\n          if (inverse) eX = -opts.barHeight / 2 - opts.strokeWidth;\n\n          if (!w.config.chart.stacked) {\n            if (this.barOptions.endingShape === 'rounded') {\n              x = opts.x - eX / 2;\n            }\n          }\n\n          switch (this.barOptions.endingShape) {\n            case 'flat':\n              endingShape = graphics.line(x, opts.barYPosition + opts.barHeight - opts.strokeWidth);\n              break;\n\n            case 'rounded':\n              endingShape = graphics.quadraticCurve(x + eX, opts.barYPosition + (opts.barHeight - opts.strokeWidth) / 2, x, opts.barYPosition + opts.barHeight - opts.strokeWidth);\n              break;\n          }\n        }\n\n        return {\n          path: endingShape,\n          ending_p_from: endingShapeFrom,\n          newX: x\n        };\n      } else {\n        var _endingShape = null;\n        var _endingShapeFrom = '';\n        var y = opts.y;\n\n        if (typeof series[i][j] !== 'undefined' || series[i][j] !== null) {\n          var _inverse = series[i][j] < 0;\n\n          var eY = opts.barWidth / 2 - opts.strokeWidth;\n          if (_inverse) eY = -opts.barWidth / 2 - opts.strokeWidth;\n\n          if (!w.config.chart.stacked) {\n            // the shape exceeds the chart height, hence reduce y\n            if (this.barOptions.endingShape === 'rounded') {\n              y = y + eY / 2;\n            }\n          }\n\n          switch (this.barOptions.endingShape) {\n            case 'flat':\n              _endingShape = graphics.line(opts.barXPosition + opts.barWidth - opts.strokeWidth, y);\n              break;\n\n            case 'rounded':\n              _endingShape = graphics.quadraticCurve(opts.barXPosition + (opts.barWidth - opts.strokeWidth) / 2, y - eY, opts.barXPosition + opts.barWidth - opts.strokeWidth, y);\n              break;\n          }\n        }\n\n        return {\n          path: _endingShape,\n          ending_p_from: _endingShapeFrom,\n          newY: y\n        };\n      }\n    }\n  }]);\n\n  return Bar;\n}();\n\n/**\n * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.\n *\n * @module BarStacked\n * The whole calculation for stacked bar/column is different from normal bar/column,\n * hence it makes sense to derive a new class for it extending most of the props of Parent Bar\n **/\n\nvar BarStacked =\n/*#__PURE__*/\nfunction (_Bar) {\n  _inherits(BarStacked, _Bar);\n\n  function BarStacked() {\n    _classCallCheck(this, BarStacked);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BarStacked).apply(this, arguments));\n  }\n\n  _createClass(BarStacked, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var w = this.w;\n      this.graphics = new Graphics(this.ctx);\n      this.fill = new Fill(this.ctx);\n      this.bar = new Bar(this.ctx, this.xyRatios);\n      var coreUtils = new CoreUtils(this.ctx, w);\n      series = coreUtils.getLogSeries(series);\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.initVariables(series);\n\n      if (w.config.chart.stackType === '100%') {\n        series = w.globals.seriesPercent.slice();\n      }\n\n      this.series = series;\n      this.totalItems = 0;\n      this.prevY = []; // y position on chart\n\n      this.prevX = []; // x position on chart\n\n      this.prevYF = []; // y position including shapes on chart\n\n      this.prevXF = []; // x position including shapes on chart\n\n      this.prevYVal = []; // y values (series[i][j]) in columns\n\n      this.prevXVal = []; // x values (series[i][j]) in bars\n\n      this.xArrj = []; // xj indicates x position on graph in bars\n\n      this.xArrjF = []; // xjF indicates bar's x position + endingshape's positions in bars\n\n      this.xArrjVal = []; // x val means the actual series's y values in horizontal/bars\n\n      this.yArrj = []; // yj indicates y position on graph in columns\n\n      this.yArrjF = []; // yjF indicates bar's y position + endingshape's positions in columns\n\n      this.yArrjVal = []; // y val means the actual series's y values in columns\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length > 0) {\n          this.totalItems += series[sl].length;\n        }\n      }\n\n      var ret = this.graphics.group({\n        class: 'apexcharts-bar-series apexcharts-plot-series'\n      });\n      var x = 0;\n      var y = 0;\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n\n        var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n\n        var zeroH = void 0; // zeroH is the baseline where 0 meets y axis\n\n        var zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n        var xArrValues = [];\n        var yArrValues = [];\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed; // el to which series will be drawn\n\n        var elSeries = this.graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        }); // eldatalabels\n\n        var elDataLabelsWrap = this.graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n        var initPositions = this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW);\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        yDivision = initPositions.yDivision;\n        zeroW = initPositions.zeroW;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n        this.yArrj = [];\n        this.yArrjF = [];\n        this.yArrjVal = [];\n        this.xArrj = [];\n        this.xArrjF = [];\n        this.xArrjVal = []; // if (!this.horizontal) {\n        // this.xArrj.push(x + barWidth / 2)\n        // }\n\n        for (var j = 0; j < w.globals.dataPoints; j++) {\n          if (w.config.stroke.show) {\n            if (this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n            }\n          }\n\n          var paths = null;\n\n          if (this.isHorizontal) {\n            paths = this.drawBarPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              barHeight: barHeight,\n              strokeWidth: strokeWidth,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              zeroW: zeroW,\n              x: x,\n              y: y,\n              yDivision: yDivision,\n              elSeries: elSeries\n            });\n          } else {\n            paths = this.drawColumnPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              xDivision: xDivision,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              barWidth: barWidth,\n              zeroH: zeroH,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            });\n          }\n\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x;\n          xArrValues.push(x);\n          yArrValues.push(y);\n          var pathFill = this.bar.getPathFillColor(series, i, j, realIndex);\n          elSeries = this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            type: 'bar',\n            visibleSeries: 0\n          });\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrValues;\n        w.globals.seriesYvalues[realIndex] = yArrValues; // push all current y values array to main PrevY Array\n\n        this.prevY.push(this.yArrj);\n        this.prevYF.push(this.yArrjF);\n        this.prevYVal.push(this.yArrjVal);\n        this.prevX.push(this.xArrj);\n        this.prevXF.push(this.xArrjF);\n        this.prevXVal.push(this.xArrjVal);\n        ret.add(elSeries);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"initialPositions\",\n    value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW) {\n      var w = this.w;\n      var barHeight, barWidth;\n\n      if (this.isHorizontal) {\n        // height divided into equal parts\n        yDivision = w.globals.gridHeight / w.globals.dataPoints;\n        barHeight = yDivision;\n        barHeight = barHeight * parseInt(w.config.plotOptions.bar.barHeight) / 100;\n        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0); // initial y position is half of barHeight * half of number of Bars\n\n        y = (yDivision - barHeight) / 2;\n      } else {\n        // width divided into equal parts\n        xDivision = w.globals.gridWidth / w.globals.dataPoints;\n        barWidth = xDivision;\n\n        if (w.globals.isXNumeric) {\n          xDivision = w.globals.minXDiff / this.xRatio;\n          barWidth = xDivision * parseInt(this.barOptions.columnWidth) / 100;\n        } else {\n          barWidth = barWidth * parseInt(w.config.plotOptions.bar.columnWidth) / 100;\n        }\n\n        zeroH = this.baseLineY[this.yaxisIndex] + (this.isReversed ? w.globals.gridHeight : 0) - (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0); // initial x position is one third of barWidth\n\n        x = w.globals.padHorizontal + (xDivision - barWidth) / 2;\n      }\n\n      return {\n        x: x,\n        y: y,\n        yDivision: yDivision,\n        xDivision: xDivision,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        zeroH: zeroH,\n        zeroW: zeroW\n      };\n    }\n  }, {\n    key: \"drawBarPaths\",\n    value: function drawBarPaths(_ref) {\n      var indexes = _ref.indexes,\n          barHeight = _ref.barHeight,\n          strokeWidth = _ref.strokeWidth,\n          pathTo = _ref.pathTo,\n          pathFrom = _ref.pathFrom,\n          zeroW = _ref.zeroW,\n          x = _ref.x,\n          y = _ref.y,\n          yDivision = _ref.yDivision,\n          elSeries = _ref.elSeries;\n      var w = this.w;\n      var barYPosition = y;\n      var barXPosition;\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n      var prevBarW = 0;\n\n      for (var k = 0; k < this.prevXF.length; k++) {\n        prevBarW = prevBarW + this.prevXF[k][j];\n      }\n\n      if (i > 0) {\n        var bXP = zeroW;\n\n        if (this.prevXVal[i - 1][j] < 0) {\n          if (this.series[i][j] >= 0) {\n            bXP = this.prevX[i - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2;\n          } else {\n            bXP = this.prevX[i - 1][j];\n          }\n        } else if (this.prevXVal[i - 1][j] >= 0) {\n          if (this.series[i][j] >= 0) {\n            bXP = this.prevX[i - 1][j];\n          } else {\n            bXP = this.prevX[i - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;\n          }\n        }\n\n        barXPosition = bXP;\n      } else {\n        // the first series will not have prevX values\n        barXPosition = zeroW;\n      }\n\n      if (this.series[i][j] === null) {\n        x = barXPosition;\n      } else {\n        x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;\n      }\n\n      var endingShapeOpts = {\n        barHeight: barHeight,\n        strokeWidth: strokeWidth,\n        invertedYRatio: this.invertedYRatio,\n        barYPosition: barYPosition,\n        x: x\n      };\n      var endingShape = this.bar.barEndingShape(w, endingShapeOpts, this.series, i, j);\n\n      if (this.series.length > 1 && i !== this.endingShapeOnSeriesNumber) {\n        // revert back to flat shape if not last series\n        endingShape.path = this.graphics.line(endingShape.newX, barYPosition + barHeight - strokeWidth);\n      }\n\n      this.xArrj.push(endingShape.newX);\n      this.xArrjF.push(Math.abs(barXPosition - endingShape.newX));\n      this.xArrjVal.push(this.series[i][j]);\n      pathTo = this.graphics.move(barXPosition, barYPosition);\n      pathFrom = this.graphics.move(barXPosition, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.bar.getPathFrom(realIndex, j, false);\n      }\n\n      pathTo = pathTo + this.graphics.line(endingShape.newX, barYPosition) + endingShape.path + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);\n      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);\n\n      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];\n        var rect = this.graphics.drawRect(0, barYPosition, w.globals.gridWidth, barHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      y = y + yDivision;\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"drawColumnPaths\",\n    value: function drawColumnPaths(_ref2) {\n      var indexes = _ref2.indexes,\n          x = _ref2.x,\n          y = _ref2.y,\n          xDivision = _ref2.xDivision,\n          pathTo = _ref2.pathTo,\n          pathFrom = _ref2.pathFrom,\n          barWidth = _ref2.barWidth,\n          zeroH = _ref2.zeroH,\n          strokeWidth = _ref2.strokeWidth,\n          elSeries = _ref2.elSeries;\n      var w = this.w;\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        var seriesVal = w.globals.seriesX[i][j];\n        if (!seriesVal) seriesVal = 0;\n        x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x;\n      var barYPosition;\n      var prevBarH = 0;\n\n      for (var k = 0; k < this.prevYF.length; k++) {\n        prevBarH = prevBarH + this.prevYF[k][j];\n      }\n\n      if (i > 0 && !w.globals.isXNumeric || i > 0 && w.globals.isXNumeric && w.globals.seriesX[i - 1][j] === w.globals.seriesX[i][j]) {\n        var bYP;\n        var prevYValue = this.prevY[i - 1][j];\n\n        if (this.prevYVal[i - 1][j] < 0) {\n          if (this.series[i][j] >= 0) {\n            bYP = prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2;\n          } else {\n            bYP = prevYValue;\n          }\n        } else {\n          if (this.series[i][j] >= 0) {\n            bYP = prevYValue;\n          } else {\n            bYP = prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2;\n          }\n        }\n\n        barYPosition = bYP;\n      } else {\n        // the first series will not have prevY values, also if the prev index's series X doesn't matches the current index's series X, then start from zero\n        barYPosition = w.globals.gridHeight - zeroH;\n      }\n\n      y = barYPosition - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;\n      var endingShapeOpts = {\n        barWidth: barWidth,\n        strokeWidth: strokeWidth,\n        yRatio: this.yRatio[this.yaxisIndex],\n        barXPosition: barXPosition,\n        y: y\n      };\n      var endingShape = this.bar.barEndingShape(w, endingShapeOpts, this.series, i, j);\n      this.yArrj.push(endingShape.newY);\n      this.yArrjF.push(Math.abs(barYPosition - endingShape.newY));\n      this.yArrjVal.push(this.series[i][j]);\n      pathTo = this.graphics.move(barXPosition, barYPosition);\n      pathFrom = this.graphics.move(barXPosition, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.bar.getPathFrom(realIndex, j, false);\n      }\n\n      pathTo = pathTo + this.graphics.line(barXPosition, endingShape.newY) + endingShape.path + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition - strokeWidth / 2, barYPosition);\n      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition - strokeWidth / 2, barYPosition);\n\n      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];\n        var rect = this.graphics.drawRect(barXPosition, 0, barWidth, w.globals.gridHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      x = x + xDivision;\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: w.globals.isXNumeric ? x - xDivision : x,\n        y: y\n      };\n    }\n    /*\n     * When user clicks on legends, the collapsed series will be filled with [0,0,0,...,0]\n     * We need to make sure, that the last series is not [0,0,0,...,0]\n     * as we need to draw shapes on the last series (for stacked bars/columns only)\n     * Hence, we are collecting all inner arrays in series which has [0,0,0...,0]\n     **/\n\n  }, {\n    key: \"checkZeroSeries\",\n    value: function checkZeroSeries(_ref3) {\n      var series = _ref3.series;\n      var w = this.w;\n\n      for (var zs = 0; zs < series.length; zs++) {\n        var total = 0;\n\n        for (var zsj = 0; zsj < series[w.globals.maxValsInArrayIndex].length; zsj++) {\n          total += series[zs][zsj];\n        }\n\n        if (total === 0) {\n          this.zeroSerieses.push(zs);\n        }\n      } // After getting all zeroserieses, we need to ensure whether endingshapeonSeries is not in that zeroseries array\n\n\n      for (var s = series.length - 1; s >= 0; s--) {\n        if (this.zeroSerieses.indexOf(s) > -1 && s === this.endingShapeOnSeriesNumber) {\n          this.endingShapeOnSeriesNumber -= 1;\n        }\n      }\n    }\n  }]);\n\n  return BarStacked;\n}(Bar);\n\n/**\n * ApexCharts CandleStick Class responsible for drawing both Stacked Columns and Bars.\n *\n * @module CandleStick\n **/\n\nvar CandleStick =\n/*#__PURE__*/\nfunction (_Bar) {\n  _inherits(CandleStick, _Bar);\n\n  function CandleStick() {\n    _classCallCheck(this, CandleStick);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CandleStick).apply(this, arguments));\n  }\n\n  _createClass(CandleStick, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      this.candlestickOptions = this.w.config.plotOptions.candlestick;\n      var coreUtils = new CoreUtils(this.ctx, w);\n      series = coreUtils.getLogSeries(series);\n      this.series = series;\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.initVariables(series);\n      var ret = graphics.group({\n        class: 'apexcharts-candlestick-series apexcharts-plot-series'\n      });\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var x = void 0,\n            y = void 0,\n            xDivision = void 0,\n            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n        zeroH = void 0; // zeroH is the baseline where 0 meets y axis\n\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n\n        if (series[i].length > 0) {\n          this.visibleI = this.visibleI + 1;\n        }\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        var initPositions = this.initialPositions();\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n        xArrj.push(x + barWidth / 2); // eldatalabels\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {\n          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {\n            this.isNullValue = true;\n          } else {\n            this.isNullValue = false;\n          }\n\n          if (w.config.stroke.show) {\n            if (this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n            }\n          }\n\n          var color = void 0;\n          var paths = this.drawCandleStickPaths({\n            indexes: {\n              i: i,\n              j: j,\n              realIndex: realIndex,\n              bc: bc\n            },\n            x: x,\n            y: y,\n            xDivision: xDivision,\n            pathTo: pathTo,\n            pathFrom: pathFrom,\n            barWidth: barWidth,\n            zeroH: zeroH,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries\n          });\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x;\n          color = paths.color; // push current X\n\n          if (j > 0) {\n            xArrj.push(x + barWidth / 2);\n          }\n\n          yArrj.push(y);\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex,\n            color: color\n          });\n          var lineFill = this.candlestickOptions.wick.useFillColor ? color : undefined;\n          elSeries = this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            lineFill: lineFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            visibleSeries: this.visibleI,\n            type: 'candlestick'\n          });\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj;\n        ret.add(elSeries);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"drawCandleStickPaths\",\n    value: function drawCandleStickPaths(_ref) {\n      var indexes = _ref.indexes,\n          x = _ref.x,\n          y = _ref.y,\n          xDivision = _ref.xDivision,\n          pathTo = _ref.pathTo,\n          pathFrom = _ref.pathFrom,\n          barWidth = _ref.barWidth,\n          zeroH = _ref.zeroH,\n          strokeWidth = _ref.strokeWidth;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var isPositive = true;\n      var colorPos = w.config.plotOptions.candlestick.colors.upward;\n      var colorNeg = w.config.plotOptions.candlestick.colors.downward;\n      var yRatio = this.yRatio[this.yaxisIndex];\n      var realIndex = indexes.realIndex;\n      var ohlc = this.getOHLCValue(realIndex, j);\n      var l1 = zeroH;\n      var l2 = zeroH;\n\n      if (ohlc.o > ohlc.c) {\n        isPositive = false;\n      }\n\n      var y1 = Math.min(ohlc.o, ohlc.c);\n      var y2 = Math.max(ohlc.o, ohlc.c);\n\n      if (w.globals.isXNumeric) {\n        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x + barWidth * this.visibleI;\n      pathTo = graphics.move(barXPosition, zeroH);\n      pathFrom = graphics.move(barXPosition, zeroH);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j, true);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        y1 = zeroH;\n      } else {\n        y1 = zeroH - y1 / yRatio;\n        y2 = zeroH - y2 / yRatio;\n        l1 = zeroH - ohlc.h / yRatio;\n        l2 = zeroH - ohlc.l / yRatio;\n      }\n\n      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);\n\n      if (!w.globals.isXNumeric) {\n        x = x + xDivision;\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y2,\n        barXPosition: barXPosition,\n        color: isPositive ? colorPos : colorNeg\n      };\n    }\n  }, {\n    key: \"getOHLCValue\",\n    value: function getOHLCValue(i, j) {\n      var w = this.w;\n      return {\n        o: w.globals.seriesCandleO[i][j],\n        h: w.globals.seriesCandleH[i][j],\n        l: w.globals.seriesCandleL[i][j],\n        c: w.globals.seriesCandleC[i][j]\n      };\n    }\n  }]);\n\n  return CandleStick;\n}(Bar);\n\nvar Crosshairs =\n/*#__PURE__*/\nfunction () {\n  function Crosshairs(ctx) {\n    _classCallCheck(this, Crosshairs);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Crosshairs, [{\n    key: \"drawXCrosshairs\",\n    value: function drawXCrosshairs() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var filters = new Filters(this.ctx);\n      var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;\n      var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;\n      var fillType = w.config.xaxis.crosshairs.fill.type;\n      var gradientFrom = crosshairGradient.colorFrom;\n      var gradientTo = crosshairGradient.colorTo;\n      var opacityFrom = crosshairGradient.opacityFrom;\n      var opacityTo = crosshairGradient.opacityTo;\n      var stops = crosshairGradient.stops;\n      var shadow = 'none';\n      var dropShadow = crosshairShadow.enabled;\n      var shadowLeft = crosshairShadow.left;\n      var shadowTop = crosshairShadow.top;\n      var shadowBlur = crosshairShadow.blur;\n      var shadowColor = crosshairShadow.color;\n      var shadowOpacity = crosshairShadow.opacity;\n      var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;\n\n      if (w.config.xaxis.crosshairs.show) {\n        if (fillType === 'gradient') {\n          xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);\n        }\n\n        var xcrosshairs = graphics.drawRect();\n\n        if (w.config.xaxis.crosshairs.width === 1) {\n          // to prevent drawing 2 lines, convert rect to line\n          xcrosshairs = graphics.drawLine();\n        }\n\n        xcrosshairs.attr({\n          class: 'apexcharts-xcrosshairs',\n          x: 0,\n          y: 0,\n          y2: w.globals.gridHeight,\n          width: Utils.isNumber(w.config.xaxis.crosshairs.width) ? w.config.xaxis.crosshairs.width : 0,\n          height: w.globals.gridHeight,\n          fill: xcrosshairsFill,\n          filter: shadow,\n          'fill-opacity': w.config.xaxis.crosshairs.opacity,\n          stroke: w.config.xaxis.crosshairs.stroke.color,\n          'stroke-width': w.config.xaxis.crosshairs.stroke.width,\n          'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray\n        });\n\n        if (dropShadow) {\n          xcrosshairs = filters.dropShadow(xcrosshairs, {\n            left: shadowLeft,\n            top: shadowTop,\n            blur: shadowBlur,\n            color: shadowColor,\n            opacity: shadowOpacity\n          });\n        }\n\n        w.globals.dom.elGraphical.add(xcrosshairs);\n      }\n    }\n  }, {\n    key: \"drawYCrosshairs\",\n    value: function drawYCrosshairs() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var crosshair = w.config.yaxis[0].crosshairs;\n\n      if (w.config.yaxis[0].crosshairs.show) {\n        var ycrosshairs = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);\n        ycrosshairs.attr({\n          class: 'apexcharts-ycrosshairs'\n        });\n        w.globals.dom.elGraphical.add(ycrosshairs);\n      } // draw an invisible crosshair to help in positioning the yaxis tooltip\n\n\n      var ycrosshairsHidden = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, 0, 0);\n      ycrosshairsHidden.attr({\n        class: 'apexcharts-ycrosshairs-hidden'\n      });\n      w.globals.dom.elGraphical.add(ycrosshairsHidden);\n    }\n  }]);\n\n  return Crosshairs;\n}();\n\n/**\n * ApexCharts HeatMap Class.\n * @module HeatMap\n **/\n\nvar HeatMap =\n/*#__PURE__*/\nfunction () {\n  function HeatMap(ctx, xyRatios) {\n    _classCallCheck(this, HeatMap);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.xRatio = xyRatios.xRatio;\n    this.yRatio = xyRatios.yRatio;\n    this.negRange = false;\n    this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;\n    this.rectRadius = this.w.config.plotOptions.heatmap.radius;\n    this.strokeWidth = this.w.config.stroke.width;\n  }\n\n  _createClass(HeatMap, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-heatmap'\n      });\n      ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\")); // width divided into equal parts\n\n      var xDivision = w.globals.gridWidth / w.globals.dataPoints;\n      var yDivision = w.globals.gridHeight / w.globals.series.length;\n      var y1 = 0;\n      var rev = false;\n      this.checkColorRange();\n      var heatSeries = series.slice();\n\n      if (w.config.yaxis[0].reversed) {\n        rev = true;\n        heatSeries.reverse();\n      }\n\n      for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {\n        // el to which series will be drawn\n        var elSeries = graphics.group({\n          class: \"apexcharts-series apexcharts-heatmap-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          rel: i + 1,\n          'data:realIndex': i\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var shadow = w.config.chart.dropShadow;\n          var filters = new Filters(this.ctx);\n          filters.dropShadow(elSeries, shadow);\n        }\n\n        var x1 = 0;\n\n        for (var j = 0; j < heatSeries[i].length; j++) {\n          var colorShadePercent = 1;\n          var heatColorProps = this.determineHeatColor(i, j);\n\n          if (w.globals.hasNegs || this.negRange) {\n            var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;\n\n            if (heatColorProps.percent < 0) {\n              colorShadePercent = 1 - (1 + heatColorProps.percent / 100) * shadeIntensity;\n            } else {\n              colorShadePercent = (1 - heatColorProps.percent / 100) * shadeIntensity;\n            }\n          } else {\n            colorShadePercent = 1 - heatColorProps.percent / 100;\n          }\n\n          var color = heatColorProps.color;\n\n          if (w.config.plotOptions.heatmap.enableShades) {\n            var utils = new Utils();\n            color = Utils.hexToRgba(utils.shadeColor(colorShadePercent, heatColorProps.color), w.config.fill.opacity);\n          }\n\n          var radius = this.rectRadius;\n          var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);\n          rect.attr({\n            cx: x1,\n            cy: y1\n          });\n          rect.node.classList.add('apexcharts-heatmap-rect');\n          elSeries.add(rect);\n          rect.attr({\n            fill: color,\n            i: i,\n            index: i,\n            j: j,\n            val: heatSeries[i][j],\n            'stroke-width': this.strokeWidth,\n            stroke: w.globals.stroke.colors[0],\n            color: color\n          });\n          rect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, rect));\n          rect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, rect));\n          rect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, rect));\n\n          if (w.config.chart.animations.enabled && !w.globals.dataChanged) {\n            var speed = 1;\n\n            if (!w.globals.resized) {\n              speed = w.config.chart.animations.speed;\n            }\n\n            this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);\n          }\n\n          if (w.globals.dataChanged) {\n            var _speed = 1;\n\n            if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {\n              _speed = this.dynamicAnim.speed;\n              var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;\n              if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';\n              this.animateHeatColor(rect, Utils.isColorHex(colorFrom) ? colorFrom : Utils.rgb2hex(colorFrom), Utils.isColorHex(color) ? color : Utils.rgb2hex(color), _speed);\n            }\n          }\n\n          var dataLabels = this.calculateHeatmapDataLabels({\n            x: x1,\n            y: y1,\n            i: i,\n            j: j,\n            series: heatSeries,\n            rectHeight: yDivision,\n            rectWidth: xDivision\n          });\n\n          if (dataLabels !== null) {\n            elSeries.add(dataLabels);\n          }\n\n          x1 = x1 + xDivision;\n        }\n\n        y1 = y1 + yDivision;\n        ret.add(elSeries);\n      } // adjust yaxis labels for heatmap\n\n\n      var yAxisScale = w.globals.yAxisScale[0].result.slice();\n\n      if (w.config.yaxis[0].reversed) {\n        yAxisScale.unshift('');\n      } else {\n        yAxisScale.push('');\n      }\n\n      w.globals.yAxisScale[0].result = yAxisScale;\n      var divisor = w.globals.gridHeight / w.globals.series.length;\n      w.config.yaxis[0].labels.offsetY = -(divisor / 2);\n      return ret;\n    }\n  }, {\n    key: \"checkColorRange\",\n    value: function checkColorRange() {\n      var _this = this;\n\n      var w = this.w;\n      var heatmap = w.config.plotOptions.heatmap;\n\n      if (heatmap.colorScale.ranges.length > 0) {\n        heatmap.colorScale.ranges.map(function (range, index) {\n          if (range.from < 0) {\n            _this.negRange = true;\n          }\n        });\n      }\n    }\n  }, {\n    key: \"determineHeatColor\",\n    value: function determineHeatColor(i, j) {\n      var w = this.w;\n      var val = w.globals.series[i][j];\n      var heatmap = w.config.plotOptions.heatmap;\n      var seriesNumber = heatmap.colorScale.inverse ? j : i;\n      var color = w.globals.colors[seriesNumber];\n      var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));\n      var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));\n\n      if (!heatmap.distributed) {\n        min = w.globals.minY;\n        max = w.globals.maxY;\n      }\n\n      if (typeof heatmap.colorScale.min !== 'undefined') {\n        min = heatmap.colorScale.min < w.globals.minY ? heatmap.colorScale.min : w.globals.minY;\n        max = heatmap.colorScale.max > w.globals.maxY ? heatmap.colorScale.max : w.globals.maxY;\n      }\n\n      var total = Math.abs(max) + Math.abs(min);\n      var percent = 100 * val / (total === 0 ? total - 0.000001 : total);\n\n      if (heatmap.colorScale.ranges.length > 0) {\n        var colorRange = heatmap.colorScale.ranges;\n        colorRange.map(function (range, index) {\n          if (val >= range.from && val <= range.to) {\n            color = range.color;\n            min = range.from;\n            max = range.to;\n\n            var _total = Math.abs(max) + Math.abs(min);\n\n            percent = 100 * val / (_total === 0 ? _total - 0.000001 : _total);\n          }\n        });\n      }\n\n      return {\n        color: color,\n        percent: percent\n      };\n    }\n  }, {\n    key: \"calculateHeatmapDataLabels\",\n    value: function calculateHeatmapDataLabels(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          i = _ref.i,\n          j = _ref.j,\n          series = _ref.series,\n          rectHeight = _ref.rectHeight,\n          rectWidth = _ref.rectWidth;\n      var w = this.w; // let graphics = new Graphics(this.ctx)\n\n      var dataLabelsConfig = w.config.dataLabels;\n      var graphics = new Graphics(this.ctx);\n      var dataLabels = new DataLabels(this.ctx);\n      var formatter = dataLabelsConfig.formatter;\n      var elDataLabelsWrap = null;\n\n      if (dataLabelsConfig.enabled) {\n        elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-data-labels'\n        });\n        var offX = dataLabelsConfig.offsetX;\n        var offY = dataLabelsConfig.offsetY;\n        var dataLabelsX = x + rectWidth / 2 + offX;\n        var dataLabelsY = y + rectHeight / 2 + parseInt(dataLabelsConfig.style.fontSize) / 3 + offY;\n        var text = formatter(w.globals.series[i][j], {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n        dataLabels.plotDataLabelsText({\n          x: dataLabelsX,\n          y: dataLabelsY,\n          text: text,\n          i: i,\n          j: j,\n          parent: elDataLabelsWrap,\n          dataLabelsConfig: dataLabelsConfig\n        });\n      }\n\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"animateHeatMap\",\n    value: function animateHeatMap(el, x, y, width, height, speed) {\n      var _this2 = this;\n\n      var animations = new Animations(this.ctx);\n      animations.animateRect(el, {\n        x: x + width / 2,\n        y: y + height / 2,\n        width: 0,\n        height: 0\n      }, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      }, speed, function () {\n        _this2.w.globals.animationEnded = true;\n      });\n    }\n  }, {\n    key: \"animateHeatColor\",\n    value: function animateHeatColor(el, colorFrom, colorTo, speed) {\n      el.attr({\n        fill: colorFrom\n      }).animate(speed).attr({\n        fill: colorTo\n      });\n    }\n  }]);\n\n  return HeatMap;\n}();\n\n/**\n * ApexCharts Pie Class for drawing Pie / Donut Charts.\n * @module Pie\n **/\n\nvar Pie =\n/*#__PURE__*/\nfunction () {\n  function Pie(ctx) {\n    _classCallCheck(this, Pie);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.chartType = this.w.config.chart.type;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n    this.animBeginArr = [0];\n    this.animDur = 0;\n    this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;\n    var w = this.w;\n    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;\n    this.centerY = this.defaultSize / 2;\n    this.centerX = w.globals.gridWidth / 2;\n    this.fullAngle = 360;\n    this.size = 0;\n    this.donutSize = 0;\n    this.sliceLabels = [];\n    this.prevSectorAngleArr = []; // for dynamic animations\n  }\n\n  _createClass(Pie, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var self = this;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-pie'\n      });\n      var total = 0;\n\n      for (var k = 0; k < series.length; k++) {\n        // CALCULATE THE TOTAL\n        total += Utils.negToZero(series[k]);\n      }\n\n      var sectorAngleArr = []; // el to which series will be drawn\n\n      var elSeries = graphics.group(); // prevent division by zero error if there is no data\n\n      if (total === 0) {\n        total = 0.00001;\n      }\n\n      for (var i = 0; i < series.length; i++) {\n        // CALCULATE THE ANGLES\n        var angle = this.fullAngle * Utils.negToZero(series[i]) / total;\n        sectorAngleArr.push(angle);\n      }\n\n      if (w.globals.dataChanged) {\n        var prevTotal = 0;\n\n        for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {\n          // CALCULATE THE PREV TOTAL\n          prevTotal += Utils.negToZero(w.globals.previousPaths[_k]);\n        }\n\n        var previousAngle;\n\n        for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {\n          // CALCULATE THE PREVIOUS ANGLES\n          previousAngle = this.fullAngle * Utils.negToZero(w.globals.previousPaths[_i]) / prevTotal;\n          this.prevSectorAngleArr.push(previousAngle);\n        }\n      }\n\n      this.size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;\n\n      if (w.config.plotOptions.pie.size !== undefined) {\n        this.size = w.config.plotOptions.pie.size;\n      }\n\n      this.donutSize = this.size * parseInt(w.config.plotOptions.pie.donut.size) / 100;\n      var scaleSize = w.config.plotOptions.pie.customScale;\n      var halfW = w.globals.gridWidth / 2;\n      var halfH = w.globals.gridHeight / 2;\n      var translateX = halfW - w.globals.gridWidth / 2 * scaleSize;\n      var translateY = halfH - w.globals.gridHeight / 2 * scaleSize;\n\n      if (this.donutDataLabels.show) {\n        var dataLabels = this.renderInnerDataLabels(this.donutDataLabels, {\n          hollowSize: this.donutSize,\n          centerX: this.centerX,\n          centerY: this.centerY,\n          opacity: this.donutDataLabels.show,\n          translateX: translateX,\n          translateY: translateY\n        });\n        ret.add(dataLabels);\n      }\n\n      if (w.config.chart.type === 'donut') {\n        // draw the inner circle and add some text to it\n        var circle = graphics.drawCircle(this.donutSize);\n        circle.attr({\n          cx: this.centerX,\n          cy: this.centerY,\n          fill: w.config.plotOptions.pie.donut.background\n        });\n        elSeries.add(circle);\n      }\n\n      var elG = self.drawArcs(sectorAngleArr, series); // add slice dataLabels at the end\n\n      this.sliceLabels.forEach(function (s) {\n        elG.add(s);\n      });\n      elSeries.attr({\n        transform: \"translate(\".concat(translateX, \", \").concat(translateY - 5, \") scale(\").concat(scaleSize, \")\")\n      });\n      ret.attr({\n        'data:innerTranslateX': translateX,\n        'data:innerTranslateY': translateY - 25\n      });\n      elSeries.add(elG);\n      ret.add(elSeries);\n      return ret;\n    } // core function for drawing pie arcs\n\n  }, {\n    key: \"drawArcs\",\n    value: function drawArcs(sectorAngleArr, series) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var g = graphics.group();\n      var startAngle = 0;\n      var prevStartAngle = 0;\n      var endAngle = 0;\n      var prevEndAngle = 0;\n      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;\n\n      for (var i = 0; i < sectorAngleArr.length; i++) {\n        // if(sectorAngleArr[i]>0) {\n        var elPieArc = graphics.group({\n          class: \"apexcharts-series apexcharts-pie-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          id: 'apexcharts-series-' + i,\n          rel: i + 1\n        });\n        g.add(elPieArc);\n        startAngle = endAngle;\n        prevStartAngle = prevEndAngle;\n        endAngle = startAngle + sectorAngleArr[i];\n        prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];\n        var angle = endAngle - startAngle;\n        var pathFill = fill.fillPath({\n          seriesNumber: i,\n          size: this.size\n        }); // additionaly, pass size for gradient drawing in the fillPath function\n\n        var path = this.getChangedPath(prevStartAngle, prevEndAngle);\n        var elPath = graphics.drawPath({\n          d: path,\n          stroke: this.lineColorArr instanceof Array ? this.lineColorArr[i] : this.lineColorArr,\n          strokeWidth: this.strokeWidth,\n          fill: pathFill,\n          fillOpacity: w.config.fill.opacity,\n          classes: 'apexcharts-pie-area'\n        });\n        elPath.attr({\n          id: \"apexcharts-\".concat(w.config.chart.type, \"-slice-\").concat(i),\n          index: 0,\n          j: i\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var shadow = w.config.chart.dropShadow;\n          filters.dropShadow(elPath, shadow);\n        }\n\n        this.addListeners(elPath, this.donutDataLabels);\n        Graphics.setAttrs(elPath.node, {\n          'data:angle': angle,\n          'data:startAngle': startAngle,\n          'data:strokeWidth': this.strokeWidth,\n          'data:value': series[i]\n        });\n        var labelPosition = {\n          x: 0,\n          y: 0\n        };\n\n        if (w.config.chart.type === 'pie') {\n          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, this.size / 1.25 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);\n        } else if (w.config.chart.type === 'donut') {\n          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, (this.size + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);\n        }\n\n        elPieArc.add(elPath); // Animation code starts\n\n        var dur = 0;\n\n        if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / this.fullAngle * w.config.chart.animations.speed;\n          this.animDur = dur + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        } else {\n          this.animBeginArr.push(0);\n        }\n\n        if (this.dynamicAnim && w.globals.dataChanged) {\n          this.animatePaths(elPath, {\n            endAngle: endAngle,\n            startAngle: startAngle,\n            prevStartAngle: prevStartAngle,\n            prevEndAngle: prevEndAngle,\n            animateStartingPos: true,\n            i: i,\n            animBeginArr: this.animBeginArr,\n            dur: w.config.chart.animations.dynamicAnimation.speed\n          });\n        } else {\n          this.animatePaths(elPath, {\n            endAngle: endAngle,\n            startAngle: startAngle,\n            i: i,\n            totalItems: sectorAngleArr.length - 1,\n            animBeginArr: this.animBeginArr,\n            dur: dur\n          });\n        } // animation code ends\n\n\n        if (w.config.plotOptions.pie.expandOnClick) {\n          elPath.click(this.pieClicked.bind(this, i));\n        }\n\n        if (w.config.dataLabels.enabled) {\n          var xPos = labelPosition.x;\n          var yPos = labelPosition.y;\n          var text = 100 * (endAngle - startAngle) / 360 + '%';\n\n          if (angle !== 0 && w.config.plotOptions.pie.dataLabels.minAngleToShowLabel < sectorAngleArr[i]) {\n            var formatter = w.config.dataLabels.formatter;\n\n            if (formatter !== undefined) {\n              text = formatter(w.globals.seriesPercent[i][0], {\n                seriesIndex: i,\n                w: w\n              });\n            }\n\n            var foreColor = w.globals.dataLabels.style.colors[i];\n            var elPieLabel = graphics.drawText({\n              x: xPos,\n              y: yPos,\n              text: text,\n              textAnchor: 'middle',\n              fontSize: w.config.dataLabels.style.fontSize,\n              fontFamily: w.config.dataLabels.style.fontFamily,\n              foreColor: foreColor\n            });\n\n            if (w.config.dataLabels.dropShadow.enabled) {\n              var textShadow = w.config.dataLabels.dropShadow;\n\n              var _filters = new Filters(this.ctx);\n\n              _filters.dropShadow(elPieLabel, textShadow);\n            }\n\n            elPieLabel.node.classList.add('apexcharts-pie-label');\n\n            if (w.config.chart.animations.animate && w.globals.resized === false) {\n              elPieLabel.node.classList.add('apexcharts-pie-label-delay');\n              elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';\n            }\n\n            this.sliceLabels.push(elPieLabel);\n          }\n        } // }\n\n      }\n\n      return g;\n    }\n  }, {\n    key: \"addListeners\",\n    value: function addListeners(elPath, dataLabels) {\n      var graphics = new Graphics(this.ctx); // append filters on mouseenter and mouseleave\n\n      elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));\n      elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n      elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));\n      elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));\n      elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));\n      elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n    } // This function can be used for other circle charts too\n\n  }, {\n    key: \"animatePaths\",\n    value: function animatePaths(el, opts) {\n      var w = this.w;\n      var me = this;\n      var angle = opts.endAngle - opts.startAngle;\n      var prevAngle = angle;\n      var fromStartAngle = opts.startAngle;\n      var toStartAngle = opts.startAngle;\n\n      if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {\n        fromStartAngle = opts.prevEndAngle;\n        prevAngle = opts.prevEndAngle - opts.prevStartAngle;\n      }\n\n      if (opts.i === w.config.series.length - 1) {\n        // some adjustments for the last overlapping paths\n        if (angle + toStartAngle > this.fullAngle) {\n          opts.endAngle = opts.endAngle - (angle + toStartAngle);\n        } else if (angle + toStartAngle < this.fullAngle) {\n          opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));\n        }\n      }\n\n      if (angle === this.fullAngle) angle = this.fullAngle - 0.01;\n      me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);\n    }\n  }, {\n    key: \"animateArc\",\n    value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {\n      var me = this;\n      var w = this.w;\n      var size = me.size;\n\n      if (!size) {\n        size = opts.size;\n      }\n\n      var path;\n\n      if (isNaN(fromStartAngle) || isNaN(prevAngle)) {\n        fromStartAngle = toStartAngle;\n        prevAngle = angle;\n        opts.dur = 0;\n      }\n\n      var currAngle = angle;\n      var startAngle = toStartAngle;\n      var fromAngle = fromStartAngle - toStartAngle;\n\n      if (w.globals.dataChanged && opts.shouldSetPrevPaths) {\n        // to avoid flickering, set prev path first and then we will animate from there\n        path = me.getPiePath({\n          me: me,\n          startAngle: startAngle,\n          angle: prevAngle,\n          size: size\n        });\n        el.attr({\n          d: path\n        });\n      }\n\n      if (opts.dur !== 0) {\n        el.animate(opts.dur, w.globals.easing, opts.animBeginArr[opts.i]).afterAll(function () {\n          if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {\n            this.animate(300).attr({\n              'stroke-width': w.config.stroke.width\n            });\n          }\n\n          w.globals.animationEnded = true;\n        }).during(function (pos) {\n          currAngle = fromAngle + (angle - fromAngle) * pos;\n\n          if (opts.animateStartingPos) {\n            currAngle = prevAngle + (angle - prevAngle) * pos;\n            startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;\n          }\n\n          path = me.getPiePath({\n            me: me,\n            startAngle: startAngle,\n            angle: currAngle,\n            size: size\n          });\n          el.node.setAttribute('data:pathOrig', path);\n          el.attr({\n            d: path\n          });\n        });\n      } else {\n        path = me.getPiePath({\n          me: me,\n          startAngle: startAngle,\n          angle: angle,\n          size: size\n        });\n\n        if (!opts.isTrack) {\n          w.globals.animationEnded = true;\n        }\n\n        el.node.setAttribute('data:pathOrig', path);\n        el.attr({\n          d: path\n        });\n      }\n    }\n  }, {\n    key: \"pieClicked\",\n    value: function pieClicked(i) {\n      var w = this.w;\n      var me = this;\n      var path;\n      var size = me.size + 4;\n      var elPath = w.globals.dom.Paper.select(\"#apexcharts-\".concat(w.config.chart.type.toLowerCase(), \"-slice-\").concat(i)).members[0];\n      var pathFrom = elPath.attr('d');\n\n      if (elPath.attr('data:pieClicked') === 'true') {\n        elPath.attr({\n          'data:pieClicked': 'false'\n        });\n        var origPath = elPath.attr('data:pathOrig');\n        elPath.attr({\n          d: origPath\n        });\n        return;\n      } else {\n        // reset all elems\n        var allEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area');\n        Array.prototype.forEach.call(allEls, function (pieSlice) {\n          pieSlice.setAttribute('data:pieClicked', 'false');\n          var origPath = pieSlice.getAttribute('data:pathOrig');\n          pieSlice.setAttribute('d', origPath);\n        });\n        elPath.attr('data:pieClicked', 'true');\n      }\n\n      var startAngle = parseInt(elPath.attr('data:startAngle'));\n      var angle = parseInt(elPath.attr('data:angle'));\n      path = me.getPiePath({\n        me: me,\n        startAngle: startAngle,\n        angle: angle,\n        size: size\n      });\n      if (angle === 360) return;\n      elPath.plot(path).animate(1).plot(pathFrom).animate(100).plot(path);\n    }\n  }, {\n    key: \"getChangedPath\",\n    value: function getChangedPath(prevStartAngle, prevEndAngle) {\n      var path = '';\n\n      if (this.dynamicAnim && this.w.globals.dataChanged) {\n        path = this.getPiePath({\n          me: this,\n          startAngle: prevStartAngle,\n          angle: prevEndAngle - prevStartAngle,\n          size: this.size\n        });\n      }\n\n      return path;\n    }\n  }, {\n    key: \"getPiePath\",\n    value: function getPiePath(_ref) {\n      var me = _ref.me,\n          startAngle = _ref.startAngle,\n          angle = _ref.angle,\n          size = _ref.size;\n      var w = this.w;\n      var path;\n      var startDeg = startAngle;\n      var startRadians = Math.PI * (startDeg - 90) / 180;\n      var endDeg = angle + startAngle;\n      if (Math.ceil(endDeg) >= 360) endDeg = 359.99;\n      var endRadians = Math.PI * (endDeg - 90) / 180;\n      var x1 = me.centerX + size * Math.cos(startRadians);\n      var y1 = me.centerY + size * Math.sin(startRadians);\n      var x2 = me.centerX + size * Math.cos(endRadians);\n      var y2 = me.centerY + size * Math.sin(endRadians);\n      var startInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);\n      var endInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);\n      var largeArc = angle > 180 ? 1 : 0;\n\n      if (w.config.chart.type === 'donut') {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z'].join(' ');\n      } else if (w.config.chart.type === 'pie') {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', me.centerX, me.centerY, 'L', x1, y1].join(' ');\n      } else {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2].join(' ');\n      }\n\n      return path;\n    }\n  }, {\n    key: \"renderInnerDataLabels\",\n    value: function renderInnerDataLabels(dataLabelsConfig, opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var g = graphics.group({\n        class: 'apexcharts-datalabels-group',\n        transform: \"translate(\".concat(opts.translateX ? opts.translateX : 0, \", \").concat(opts.translateY ? opts.translateY : 0, \")\")\n      });\n      var showTotal = dataLabelsConfig.total.show;\n      g.node.style.opacity = opts.opacity;\n      var x = opts.centerX;\n      var y = opts.centerY;\n      var labelColor, valueColor;\n\n      if (dataLabelsConfig.name.color === undefined) {\n        labelColor = w.globals.colors[0];\n      } else {\n        labelColor = dataLabelsConfig.name.color;\n      }\n\n      if (dataLabelsConfig.value.color === undefined) {\n        valueColor = w.config.chart.foreColor;\n      } else {\n        valueColor = dataLabelsConfig.value.color;\n      }\n\n      var lbFormatter = dataLabelsConfig.value.formatter;\n      var val = '';\n      var name = '';\n\n      if (showTotal) {\n        labelColor = dataLabelsConfig.total.color;\n        name = dataLabelsConfig.total.label;\n        val = dataLabelsConfig.total.formatter(w);\n      } else {\n        if (w.globals.series.length === 1) {\n          val = lbFormatter(w.globals.series[0], w);\n          name = w.globals.seriesNames[0];\n        }\n      }\n\n      if (dataLabelsConfig.name.show) {\n        var elLabel = graphics.drawText({\n          x: x,\n          y: y + parseInt(dataLabelsConfig.name.offsetY),\n          text: name,\n          textAnchor: 'middle',\n          foreColor: labelColor,\n          fontSize: dataLabelsConfig.name.fontSize,\n          fontFamily: dataLabelsConfig.name.fontFamily\n        });\n        elLabel.node.classList.add('apexcharts-datalabel-label');\n        g.add(elLabel);\n      }\n\n      if (dataLabelsConfig.value.show) {\n        var valOffset = dataLabelsConfig.name.show ? parseInt(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;\n        var elValue = graphics.drawText({\n          x: x,\n          y: y + valOffset,\n          text: val,\n          textAnchor: 'middle',\n          foreColor: valueColor,\n          fontSize: dataLabelsConfig.value.fontSize,\n          fontFamily: dataLabelsConfig.value.fontFamily\n        });\n        elValue.node.classList.add('apexcharts-datalabel-value');\n        g.add(elValue);\n      } // for a multi-series circle chart, we need to show total value instead of first series labels\n\n\n      return g;\n    }\n    /**\n     *\n     * @param {string} name - The name of the series\n     * @param {string} val - The value of that series\n     * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total\n     */\n\n  }, {\n    key: \"printInnerLabels\",\n    value: function printInnerLabels(labelsConfig, name, val, el) {\n      var w = this.w;\n      var labelColor;\n\n      if (el) {\n        if (labelsConfig.name.color === undefined) {\n          labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel')) - 1];\n        } else {\n          labelColor = labelsConfig.name.color;\n        }\n      } else {\n        if (w.globals.series.length > 1 && labelsConfig.total.show) {\n          labelColor = labelsConfig.total.color;\n        }\n      }\n\n      var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');\n      var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');\n      var lbFormatter = labelsConfig.value.formatter;\n      val = lbFormatter(val, w); // we need to show Total Val - so get the formatter of it\n\n      if (!el && typeof labelsConfig.total.formatter === 'function') {\n        val = labelsConfig.total.formatter(w);\n      }\n\n      if (elLabel !== null) {\n        elLabel.textContent = name;\n      }\n\n      if (elValue !== null) {\n        elValue.textContent = val;\n      }\n\n      if (elLabel !== null) {\n        elLabel.style.fill = labelColor;\n      }\n    }\n  }, {\n    key: \"printDataLabelsInner\",\n    value: function printDataLabelsInner(el, dataLabelsConfig) {\n      var w = this.w;\n      var val = el.getAttribute('data:value');\n      var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel')) - 1];\n\n      if (w.globals.series.length > 1) {\n        this.printInnerLabels(dataLabelsConfig, name, val, el);\n      }\n\n      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n\n      if (dataLabelsGroup !== null) {\n        dataLabelsGroup.style.opacity = 1;\n      }\n    }\n  }, {\n    key: \"revertDataLabelsInner\",\n    value: function revertDataLabelsInner(el, dataLabelsConfig) {\n      var w = this.w;\n      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n\n      if (dataLabelsConfig.total.show && w.globals.series.length > 1) {\n        var pie = new Pie(this.ctx);\n        pie.printInnerLabels(dataLabelsConfig, dataLabelsConfig.total.label, dataLabelsConfig.total.formatter(w));\n      } else {\n        if (w.globals.selectedDataPoints.length && w.globals.series.length > 1) {\n          if (w.globals.selectedDataPoints[0].length > 0) {\n            var index = w.globals.selectedDataPoints[0];\n\n            var _el = w.globals.dom.baseEl.querySelector(\"#apexcharts-\".concat(w.config.chart.type.toLowerCase(), \"-slice-\").concat(index));\n\n            this.printDataLabelsInner(_el, dataLabelsConfig);\n          } else if (dataLabelsGroup && w.globals.selectedDataPoints.length && w.globals.selectedDataPoints[0].length === 0) {\n            dataLabelsGroup.style.opacity = 0;\n          }\n        } else {\n          if (dataLabelsGroup && w.globals.series.length > 1) {\n            dataLabelsGroup.style.opacity = 0;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Pie;\n}();\n\n/**\n * ApexCharts Radar Class for Spider/Radar Charts.\n * @module Radar\n **/\n\nvar Radar =\n/*#__PURE__*/\nfunction () {\n  function Radar(ctx) {\n    _classCallCheck(this, Radar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.chartType = this.w.config.chart.type;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n    this.animDur = 0;\n    var w = this.w;\n    this.graphics = new Graphics(this.ctx);\n    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;\n    this.maxValue = this.w.globals.maxY;\n    this.polygons = w.config.plotOptions.radar.polygons;\n    this.maxLabelWidth = 20;\n    var longestLabel = w.globals.labels.slice().sort(function (a, b) {\n      return b.length - a.length;\n    })[0];\n    var labelWidth = this.graphics.getTextRects(longestLabel, w.config.dataLabels.style.fontSize);\n    this.size = this.defaultSize / 2.1 - w.config.stroke.width - w.config.chart.dropShadow.blur - labelWidth.width / 1.75;\n\n    if (w.config.plotOptions.radar.size !== undefined) {\n      this.size = w.config.plotOptions.radar.size;\n    }\n\n    this.dataRadiusOfPercent = [];\n    this.dataRadius = [];\n    this.angleArr = [];\n    this.yaxisLabelsTextsPos = [];\n  }\n\n  _createClass(Radar, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var _this = this;\n\n      var w = this.w;\n      var fill = new Fill(this.ctx);\n      var allSeries = [];\n      this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;\n      this.disAngle = Math.PI * 2 / this.dataPointsLen;\n      var halfW = w.globals.gridWidth / 2;\n      var halfH = w.globals.gridHeight / 2;\n      var translateX = halfW;\n      var translateY = halfH;\n      var ret = this.graphics.group({\n        class: 'apexcharts-radar-series',\n        'data:innerTranslateX': translateX,\n        'data:innerTranslateY': translateY - 25,\n        transform: \"translate(\".concat(translateX || 0, \", \").concat(translateY || 0, \")\")\n      });\n      var dataPointsPos = [];\n      var elPointsMain = null;\n      this.yaxisLabels = this.graphics.group({\n        class: 'apexcharts-yaxis'\n      });\n      series.forEach(function (s, i) {\n        // el to which series will be drawn\n        var elSeries = _this.graphics.group().attr({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          rel: i + 1,\n          'data:realIndex': i\n        });\n\n        _this.dataRadiusOfPercent[i] = [];\n        _this.dataRadius[i] = [];\n        _this.angleArr[i] = [];\n        s.forEach(function (dv, j) {\n          _this.dataRadiusOfPercent[i][j] = dv / _this.maxValue;\n          _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;\n          _this.angleArr[i][j] = j * _this.disAngle;\n        });\n        dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);\n\n        var paths = _this.createPaths(dataPointsPos, {\n          x: 0,\n          y: 0\n        }); // points\n\n\n        elPointsMain = _this.graphics.group({\n          class: 'apexcharts-series-markers-wrap hidden'\n        });\n        w.globals.delayedElements.push({\n          el: elPointsMain.node,\n          index: i\n        });\n        var defaultRenderedPathOptions = {\n          i: i,\n          realIndex: i,\n          animationDelay: i,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-radar\",\n          id: \"apexcharts-radar\",\n          shouldClipToGrid: false,\n          bindEventsOnPaths: false,\n          stroke: w.globals.stroke.colors[i],\n          strokeLineCap: w.config.stroke.lineCap\n        };\n        var pathFrom = null;\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = _this.getPathFrom(i);\n        }\n\n        for (var p = 0; p < paths.linePathsTo.length; p++) {\n          var renderedLinePath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n            pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,\n            pathTo: paths.linePathsTo[p],\n            strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width,\n            fill: 'none'\n          }));\n\n          elSeries.add(renderedLinePath);\n          var pathFill = fill.fillPath({\n            seriesNumber: i\n          });\n\n          var renderedAreaPath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n            pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,\n            pathTo: paths.areaPathsTo[p],\n            strokeWidth: 0,\n            fill: pathFill\n          }));\n\n          if (w.config.chart.dropShadow.enabled) {\n            var filters = new Filters(_this.ctx);\n            var shadow = w.config.chart.dropShadow;\n            filters.dropShadow(renderedAreaPath, _objectSpread({}, shadow, {\n              noUserSpaceOnUse: true\n            }));\n          }\n\n          elSeries.add(renderedAreaPath);\n        }\n\n        s.forEach(function (sj, j) {\n          var markers = new Markers(_this.ctx);\n          var opts = markers.getMarkerConfig('apexcharts-marker', i);\n\n          var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);\n\n          point.attr('rel', j);\n          point.attr('j', j);\n          point.attr('index', i);\n          point.node.setAttribute('default-marker-size', opts.pSize);\n\n          var elPointsWrap = _this.graphics.group({\n            class: 'apexcharts-series-markers'\n          });\n\n          if (elPointsWrap) {\n            elPointsWrap.add(point);\n          }\n\n          elPointsMain.add(elPointsWrap);\n          elSeries.add(elPointsMain);\n        });\n        allSeries.push(elSeries);\n      });\n      this.drawPolygons({\n        parent: ret\n      });\n\n      if (w.config.dataLabels.enabled) {\n        var dataLabels = this.drawLabels();\n        ret.add(dataLabels);\n      }\n\n      ret.add(this.yaxisLabels);\n      allSeries.forEach(function (elS) {\n        ret.add(elS);\n      });\n      return ret;\n    }\n  }, {\n    key: \"drawPolygons\",\n    value: function drawPolygons(opts) {\n      var _this2 = this;\n\n      var w = this.w;\n      var parent = opts.parent;\n      var yaxisTexts = w.globals.yAxisScale[0].result.reverse();\n      var layers = yaxisTexts.length;\n      var radiusSizes = [];\n      var layerDis = this.size / (layers - 1);\n\n      for (var i = 0; i < layers; i++) {\n        radiusSizes[i] = layerDis * i;\n      }\n\n      radiusSizes.reverse();\n      var polygonStrings = [];\n      var lines = [];\n      radiusSizes.forEach(function (radiusSize, r) {\n        var polygon = _this2.getPolygonPos(radiusSize);\n\n        var string = '';\n        polygon.forEach(function (p, i) {\n          if (r === 0) {\n            var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);\n\n            lines.push(line);\n          }\n\n          if (i === 0) {\n            _this2.yaxisLabelsTextsPos.push({\n              x: p.x,\n              y: p.y\n            });\n          }\n\n          string += p.x + ',' + p.y + ' ';\n        });\n        polygonStrings.push(string);\n      });\n      polygonStrings.forEach(function (p, i) {\n        var strokeColors = _this2.polygons.strokeColors;\n\n        var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, w.globals.radarPolygons.fill.colors[i]);\n\n        parent.add(polygon);\n      });\n      lines.forEach(function (l) {\n        parent.add(l);\n      });\n\n      if (w.config.yaxis[0].show) {\n        this.yaxisLabelsTextsPos.forEach(function (p, i) {\n          var yText = _this2.drawYAxisText(p.x, p.y, i, yaxisTexts[i]);\n\n          _this2.yaxisLabels.add(yText);\n        });\n      }\n    }\n  }, {\n    key: \"drawYAxisText\",\n    value: function drawYAxisText(x, y, i, text) {\n      var w = this.w;\n      var yaxisConfig = w.config.yaxis[0];\n      var formatter = w.globals.yLabelFormatters[0];\n      var yaxisLabel = this.graphics.drawText({\n        x: x + yaxisConfig.labels.offsetX,\n        y: y + yaxisConfig.labels.offsetY,\n        text: formatter(text, i),\n        textAnchor: 'middle',\n        fontSize: yaxisConfig.labels.style.fontSize,\n        fontFamily: yaxisConfig.labels.style.fontFamily,\n        foreColor: yaxisConfig.labels.style.color\n      });\n      return yaxisLabel;\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels() {\n      var _this3 = this;\n\n      var w = this.w;\n      var limit = 10;\n      var textAnchor = 'middle';\n      var dataLabelsConfig = w.config.dataLabels;\n      var elDataLabelsWrap = this.graphics.group({\n        class: 'apexcharts-datalabels'\n      });\n      var polygonPos = this.getPolygonPos(this.size);\n      var currPosX = 0;\n      var currPosY = 0;\n      w.globals.labels.forEach(function (label, i) {\n        var formatter = dataLabelsConfig.formatter;\n        var dataLabels = new DataLabels(_this3.ctx);\n\n        if (polygonPos[i]) {\n          currPosX = polygonPos[i].x;\n          currPosY = polygonPos[i].y;\n\n          if (Math.abs(polygonPos[i].x) >= limit) {\n            if (polygonPos[i].x > 0) {\n              textAnchor = 'start';\n              currPosX += 10;\n            } else if (polygonPos[i].x < 0) {\n              textAnchor = 'end';\n              currPosX -= 10;\n            }\n          } else {\n            textAnchor = 'middle';\n          }\n\n          if (Math.abs(polygonPos[i].y) >= _this3.size - limit) {\n            if (polygonPos[i].y < 0) {\n              currPosY -= 10;\n            } else if (polygonPos[i].y > 0) {\n              currPosY += 10;\n            }\n          }\n\n          var text = formatter(label, {\n            seriesIndex: -1,\n            dataPointIndex: i,\n            w: w\n          });\n          dataLabels.plotDataLabelsText({\n            x: currPosX,\n            y: currPosY,\n            text: text,\n            textAnchor: textAnchor,\n            i: i,\n            j: i,\n            parent: elDataLabelsWrap,\n            dataLabelsConfig: dataLabelsConfig,\n            offsetCorrection: false\n          });\n        }\n      });\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"createPaths\",\n    value: function createPaths(pos, origin) {\n      var _this4 = this;\n\n      var linePathsTo = [];\n      var linePathsFrom = [];\n      var areaPathsTo = [];\n      var areaPathsFrom = [];\n\n      if (pos.length) {\n        linePathsFrom = [this.graphics.move(origin.x, origin.y)];\n        areaPathsFrom = [this.graphics.move(origin.x, origin.y)];\n        var linePathTo = this.graphics.move(pos[0].x, pos[0].y);\n        var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);\n        pos.forEach(function (p, i) {\n          linePathTo += _this4.graphics.line(p.x, p.y);\n          areaPathTo += _this4.graphics.line(p.x, p.y);\n\n          if (i === pos.length - 1) {\n            linePathTo += 'Z';\n            areaPathTo += 'Z';\n          }\n        });\n        linePathsTo.push(linePathTo);\n        areaPathsTo.push(areaPathTo);\n      }\n\n      return {\n        linePathsFrom: linePathsFrom,\n        linePathsTo: linePathsTo,\n        areaPathsFrom: areaPathsFrom,\n        areaPathsTo: areaPathsTo\n      };\n    }\n  }, {\n    key: \"getPathFrom\",\n    value: function getPathFrom(realIndex) {\n      var w = this.w;\n      var pathFrom = null;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {\n            pathFrom = w.globals.previousPaths[pp].paths[0].d;\n          }\n        }\n      }\n\n      return pathFrom;\n    }\n  }, {\n    key: \"getDataPointsPos\",\n    value: function getDataPointsPos(dataRadiusArr, angleArr) {\n      var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;\n      dataRadiusArr = dataRadiusArr || [];\n      angleArr = angleArr || [];\n      var dataPointsPosArray = [];\n\n      for (var j = 0; j < dataPointsLen; j++) {\n        var curPointPos = {};\n        curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);\n        curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);\n        dataPointsPosArray.push(curPointPos);\n      }\n\n      return dataPointsPosArray;\n    }\n  }, {\n    key: \"getPolygonPos\",\n    value: function getPolygonPos(size) {\n      var dotsArray = [];\n      var angle = Math.PI * 2 / this.dataPointsLen;\n\n      for (var i = 0; i < this.dataPointsLen; i++) {\n        var curPos = {};\n        curPos.x = size * Math.sin(i * angle);\n        curPos.y = -size * Math.cos(i * angle);\n        dotsArray.push(curPos);\n      }\n\n      return dotsArray;\n    }\n  }]);\n\n  return Radar;\n}();\n\n/**\n * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.\n * @module Radial\n **/\n\nvar Radial =\n/*#__PURE__*/\nfunction (_Pie) {\n  _inherits(Radial, _Pie);\n\n  function Radial(ctx) {\n    var _this;\n\n    _classCallCheck(this, Radial);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Radial).call(this, ctx));\n    _this.ctx = ctx;\n    _this.w = ctx.w;\n    _this.animBeginArr = [0];\n    _this.animDur = 0;\n    var w = _this.w;\n    _this.startAngle = w.config.plotOptions.radialBar.startAngle;\n    _this.endAngle = w.config.plotOptions.radialBar.endAngle;\n    _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;\n    _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;\n    _this.radialDataLabels = w.config.plotOptions.radialBar.dataLabels;\n    if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;\n    if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;\n    if (_this.endAngle === 360) _this.endAngle = 359.99;\n    _this.fullAngle = 360 - w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle;\n    _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin);\n    return _this;\n  }\n\n  _createClass(Radial, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-radialbar'\n      });\n      var elSeries = graphics.group();\n      var centerY = this.defaultSize / 2;\n      var centerX = w.globals.gridWidth / 2;\n      var size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;\n\n      if (w.config.plotOptions.radialBar.size !== undefined) {\n        size = w.config.plotOptions.radialBar.size;\n      }\n\n      var colorArr = w.globals.fill.colors;\n\n      if (w.config.plotOptions.radialBar.track.show) {\n        var elTracks = this.drawTracks({\n          size: size,\n          centerX: centerX,\n          centerY: centerY,\n          colorArr: colorArr,\n          series: series\n        });\n        elSeries.add(elTracks);\n      }\n\n      var elG = this.drawArcs({\n        size: size,\n        centerX: centerX,\n        centerY: centerY,\n        colorArr: colorArr,\n        series: series\n      });\n      elSeries.add(elG.g);\n\n      if (w.config.plotOptions.radialBar.hollow.position === 'front') {\n        elG.g.add(elG.elHollow);\n\n        if (elG.dataLabels) {\n          elG.g.add(elG.dataLabels);\n        }\n      }\n\n      ret.add(elSeries);\n      return ret;\n    }\n  }, {\n    key: \"drawTracks\",\n    value: function drawTracks(opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var g = graphics.group();\n      var filters = new Filters(this.ctx);\n      var fill = new Fill(this.ctx);\n      var strokeWidth = this.getStrokeWidth(opts);\n      opts.size = opts.size - strokeWidth / 2;\n\n      for (var i = 0; i < opts.series.length; i++) {\n        var elRadialBarTrack = graphics.group({\n          class: 'apexcharts-radialbar-track apexcharts-track'\n        });\n        g.add(elRadialBarTrack);\n        elRadialBarTrack.attr({\n          id: 'apexcharts-track-' + i,\n          rel: i + 1\n        });\n        opts.size = opts.size - strokeWidth - this.margin;\n        var trackConfig = w.config.plotOptions.radialBar.track;\n        var pathFill = fill.fillPath({\n          seriesNumber: 0,\n          size: opts.size,\n          fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,\n          solid: true\n        });\n        var startAngle = this.trackStartAngle;\n        var endAngle = this.trackEndAngle;\n        if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;\n        var elPath = graphics.drawPath({\n          d: '',\n          stroke: pathFill,\n          strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth) / 100,\n          fill: 'none',\n          strokeOpacity: trackConfig.opacity,\n          classes: 'apexcharts-radialbar-area'\n        });\n\n        if (trackConfig.dropShadow.enabled) {\n          var shadow = trackConfig.dropShadow;\n          filters.dropShadow(elPath, shadow);\n        }\n\n        elRadialBarTrack.add(elPath);\n        elPath.attr('id', 'apexcharts-radialbarTrack-' + i);\n        var pie = new Pie(this.ctx);\n        pie.animatePaths(elPath, {\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          endAngle: endAngle,\n          startAngle: startAngle,\n          size: opts.size,\n          i: i,\n          totalItems: 2,\n          animBeginArr: 0,\n          dur: 0,\n          isTrack: true,\n          easing: w.globals.easing\n        });\n      }\n\n      return g;\n    }\n  }, {\n    key: \"drawArcs\",\n    value: function drawArcs(opts) {\n      var w = this.w; // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series\n\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var filters = new Filters(this.ctx);\n      var g = graphics.group();\n      var strokeWidth = this.getStrokeWidth(opts);\n      opts.size = opts.size - strokeWidth / 2;\n      var hollowFillID = w.config.plotOptions.radialBar.hollow.background;\n      var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth) / 100 / 2;\n      var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;\n\n      if (w.config.plotOptions.radialBar.hollow.image !== undefined) {\n        hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);\n      }\n\n      var elHollow = this.drawHollow({\n        size: hollowRadius,\n        centerX: opts.centerX,\n        centerY: opts.centerY,\n        fill: hollowFillID\n      });\n\n      if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {\n        var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;\n        filters.dropShadow(elHollow, shadow);\n      }\n\n      var shown = 1;\n\n      if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {\n        shown = 0;\n      }\n\n      var pie = new Pie(this.ctx);\n      var dataLabels = null;\n\n      if (this.radialDataLabels.show) {\n        dataLabels = pie.renderInnerDataLabels(this.radialDataLabels, {\n          hollowSize: hollowSize,\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          opacity: shown\n        });\n      }\n\n      if (w.config.plotOptions.radialBar.hollow.position === 'back') {\n        g.add(elHollow);\n\n        if (dataLabels) {\n          g.add(dataLabels);\n        }\n      }\n\n      var reverseLoop = false;\n\n      if (w.config.plotOptions.radialBar.inverseOrder) {\n        reverseLoop = true;\n      }\n\n      for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {\n        var elRadialBarArc = graphics.group({\n          class: \"apexcharts-series apexcharts-radial-series \".concat(Utils.escapeString(w.globals.seriesNames[i]))\n        });\n        g.add(elRadialBarArc);\n        elRadialBarArc.attr({\n          id: 'apexcharts-series-' + i,\n          rel: i + 1\n        });\n        this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);\n        opts.size = opts.size - strokeWidth - this.margin;\n        var pathFill = fill.fillPath({\n          seriesNumber: i,\n          size: opts.size\n        });\n        var startAngle = this.startAngle;\n        var prevStartAngle = void 0;\n        var totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle); // if data exceeds 100, make it 100\n\n        var dataValue = Utils.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;\n        var endAngle = Math.round(totalAngle * dataValue) + this.startAngle;\n        var prevEndAngle = void 0;\n\n        if (w.globals.dataChanged) {\n          prevStartAngle = this.startAngle;\n          prevEndAngle = Math.round(totalAngle * Utils.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;\n        }\n\n        var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);\n\n        if (currFullAngle >= 360) {\n          endAngle = endAngle - 0.01;\n        }\n\n        var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);\n\n        if (prevFullAngle >= 360) {\n          prevEndAngle = prevEndAngle - 0.01;\n        }\n\n        var angle = endAngle - startAngle;\n        var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;\n        var elPath = graphics.drawPath({\n          d: '',\n          stroke: pathFill,\n          strokeWidth: strokeWidth,\n          fill: 'none',\n          fillOpacity: w.config.fill.opacity,\n          classes: 'apexcharts-radialbar-area',\n          strokeDashArray: dashArray\n        });\n        Graphics.setAttrs(elPath.node, {\n          'data:angle': angle,\n          'data:value': opts.series[i]\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var _shadow = w.config.chart.dropShadow;\n          filters.dropShadow(elPath, _shadow);\n        }\n\n        this.addListeners(elPath, this.radialDataLabels);\n\n        var _pie = new Pie(this.ctx);\n\n        elRadialBarArc.add(elPath);\n        elPath.attr({\n          id: 'apexcharts-radialbar-slice-' + i,\n          index: 0,\n          j: i\n        });\n        var dur = 0;\n\n        if (_pie.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.speed;\n          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        }\n\n        if (w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.dynamicAnimation.speed;\n          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        }\n\n        _pie.animatePaths(elPath, {\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          endAngle: endAngle,\n          startAngle: startAngle,\n          prevEndAngle: prevEndAngle,\n          prevStartAngle: prevStartAngle,\n          size: opts.size,\n          i: i,\n          totalItems: 2,\n          animBeginArr: this.animBeginArr,\n          dur: dur,\n          shouldSetPrevPaths: true,\n          easing: w.globals.easing\n        });\n      }\n\n      return {\n        g: g,\n        elHollow: elHollow,\n        dataLabels: dataLabels\n      };\n    }\n  }, {\n    key: \"drawHollow\",\n    value: function drawHollow(opts) {\n      var graphics = new Graphics(this.ctx);\n      var circle = graphics.drawCircle(opts.size * 2);\n      circle.attr({\n        class: 'apexcharts-radialbar-hollow',\n        cx: opts.centerX,\n        cy: opts.centerY,\n        r: opts.size,\n        fill: opts.fill\n      });\n      return circle;\n    }\n  }, {\n    key: \"drawHollowImage\",\n    value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {\n      var w = this.w;\n      var fill = new Fill(this.ctx);\n      var randID = (Math.random() + 1).toString(36).substring(4);\n      var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;\n\n      if (w.config.plotOptions.radialBar.hollow.imageClipped) {\n        fill.clippedImgArea({\n          width: hollowSize,\n          height: hollowSize,\n          image: hollowFillImg,\n          patternID: \"pattern\".concat(w.globals.cuid).concat(randID)\n        });\n        hollowFillID = \"url(#pattern\".concat(w.globals.cuid).concat(randID, \")\");\n      } else {\n        var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;\n        var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;\n\n        if (imgWidth === undefined && imgHeight === undefined) {\n          var image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n            this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n          });\n          g.add(image);\n        } else {\n          var _image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n            this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n            this.size(imgWidth, imgHeight);\n          });\n\n          g.add(_image);\n        }\n      }\n\n      return hollowFillID;\n    }\n  }, {\n    key: \"getStrokeWidth\",\n    value: function getStrokeWidth(opts) {\n      var w = this.w;\n      return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size)) / 100 / (opts.series.length + 1) - this.margin;\n    }\n  }]);\n\n  return Radial;\n}(Pie);\n\n/**\n * ApexCharts RangeBar Class responsible for drawing Range/Timeline Bars.\n *\n * @module RangeBar\n **/\n\nvar RangeBar =\n/*#__PURE__*/\nfunction (_Bar) {\n  _inherits(RangeBar, _Bar);\n\n  function RangeBar() {\n    _classCallCheck(this, RangeBar);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RangeBar).apply(this, arguments));\n  }\n\n  _createClass(RangeBar, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      this.rangeBarOptions = this.w.config.plotOptions.rangeBar;\n      this.series = series;\n      this.seriesRangeStart = w.globals.seriesRangeStart;\n      this.seriesRangeEnd = w.globals.seriesRangeEnd;\n      this.initVariables(series);\n      var ret = graphics.group({\n        class: 'apexcharts-rangebar-series apexcharts-plot-series'\n      });\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var x = void 0,\n            y = void 0,\n            xDivision = void 0,\n            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n        yDivision = void 0,\n            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n        zeroH = void 0,\n            // zeroH is the baseline where 0 meets y axis\n        zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n\n        if (series[i].length > 0) {\n          this.visibleI = this.visibleI + 1;\n        }\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        var initPositions = this.initialPositions();\n        y = initPositions.y;\n        yDivision = initPositions.yDivision;\n        barHeight = initPositions.barHeight;\n        zeroW = initPositions.zeroW;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n        xArrj.push(x + barWidth / 2); // eldatalabels\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {\n          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {\n            this.isNullValue = true;\n          } else {\n            this.isNullValue = false;\n          }\n\n          if (w.config.stroke.show) {\n            if (this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n            }\n          }\n\n          var paths = null;\n\n          if (this.isHorizontal) {\n            paths = this.drawRangeBarPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              barHeight: barHeight,\n              strokeWidth: strokeWidth,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              zeroW: zeroW,\n              x: x,\n              y: y,\n              yDivision: yDivision,\n              elSeries: elSeries\n            });\n          } else {\n            paths = this.drawRangeColumnPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              xDivision: xDivision,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              barWidth: barWidth,\n              zeroH: zeroH,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            });\n          }\n\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x; // push current X\n\n          if (j > 0) {\n            xArrj.push(x + barWidth / 2);\n          }\n\n          yArrj.push(y);\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex\n          });\n          var lineFill = w.globals.stroke.colors[realIndex];\n          elSeries = this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            lineFill: lineFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            visibleSeries: this.visibleI,\n            type: 'rangebar'\n          });\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj;\n        ret.add(elSeries);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"drawRangeColumnPaths\",\n    value: function drawRangeColumnPaths(_ref) {\n      var indexes = _ref.indexes,\n          x = _ref.x,\n          y = _ref.y,\n          strokeWidth = _ref.strokeWidth,\n          xDivision = _ref.xDivision,\n          pathTo = _ref.pathTo,\n          pathFrom = _ref.pathFrom,\n          barWidth = _ref.barWidth,\n          zeroH = _ref.zeroH;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var yRatio = this.yRatio[this.yaxisIndex];\n      var realIndex = indexes.realIndex;\n      var range = this.getRangeValue(realIndex, j);\n      var y1 = Math.min(range.start, range.end);\n      var y2 = Math.max(range.start, range.end);\n\n      if (w.globals.isXNumeric) {\n        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x + barWidth * this.visibleI;\n      pathTo = graphics.move(barXPosition, zeroH);\n      pathFrom = graphics.move(barXPosition, zeroH);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j, true);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        y1 = zeroH;\n      } else {\n        y1 = zeroH - y1 / yRatio;\n        y2 = zeroH - y2 / yRatio;\n      }\n\n      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);\n\n      if (!w.globals.isXNumeric) {\n        x = x + xDivision;\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y2,\n        barXPosition: barXPosition\n      };\n    }\n  }, {\n    key: \"drawRangeBarPaths\",\n    value: function drawRangeBarPaths(_ref2) {\n      var indexes = _ref2.indexes,\n          x = _ref2.x,\n          y = _ref2.y,\n          yDivision = _ref2.yDivision,\n          pathTo = _ref2.pathTo,\n          pathFrom = _ref2.pathFrom,\n          barHeight = _ref2.barHeight,\n          zeroW = _ref2.zeroW;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var x1 = zeroW;\n      var x2 = zeroW;\n\n      if (w.globals.isXNumeric) {\n        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;\n      }\n\n      var barYPosition = y + barHeight * this.visibleI;\n      pathTo = graphics.move(zeroW, barYPosition);\n      pathFrom = graphics.move(zeroW, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j);\n      }\n\n      if (typeof this.series[i][j] !== 'undefined' && this.series[i][j] !== null) {\n        x1 = zeroW + this.seriesRangeStart[i][j] / this.invertedYRatio;\n        x2 = zeroW + this.seriesRangeEnd[i][j] / this.invertedYRatio;\n      }\n\n      pathTo = graphics.move(x1, barYPosition) + graphics.line(x2, barYPosition) + graphics.line(x2, barYPosition + barHeight) + graphics.line(x1, barYPosition + barHeight) + graphics.line(x1, barYPosition);\n\n      if (!w.globals.isXNumeric) {\n        y = y + yDivision;\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x2,\n        y: y,\n        barYPosition: barYPosition\n      };\n    }\n  }, {\n    key: \"getRangeValue\",\n    value: function getRangeValue(i, j) {\n      var w = this.w;\n      return {\n        start: w.globals.seriesRangeStart[i][j],\n        end: w.globals.seriesRangeEnd[i][j]\n      };\n    }\n  }]);\n\n  return RangeBar;\n}(Bar);\n\n/**\n * ApexCharts Line Class responsible for drawing Line / Area Charts.\n * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions\n * @module Line\n **/\n\nvar Line =\n/*#__PURE__*/\nfunction () {\n  function Line(ctx, xyRatios, isPointsChart) {\n    _classCallCheck(this, Line);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.xyRatios = xyRatios;\n    this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;\n    this.scatter = new Scatter(this.ctx);\n    this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;\n    this.yaxisIndex = 0;\n  }\n\n  _createClass(Line, [{\n    key: \"draw\",\n    value: function draw(series, ptype, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var type = w.globals.comboCharts ? ptype : w.config.chart.type;\n      var ret = graphics.group({\n        class: \"apexcharts-\".concat(type, \"-series apexcharts-plot-series\")\n      });\n      var coreUtils = new CoreUtils(this.ctx, w);\n      series = coreUtils.getLogSeries(series);\n      var yRatio = this.xyRatios.yRatio;\n      yRatio = coreUtils.getLogYRatios(yRatio);\n      var zRatio = this.xyRatios.zRatio;\n      var xRatio = this.xyRatios.xRatio;\n      var baseLineY = this.xyRatios.baseLineY; // push all series in an array, so we can draw in reverse order (for stacked charts)\n\n      var allSeries = [];\n      var prevSeriesY = [];\n      var categoryAxisCorrection = 0;\n\n      for (var i = 0; i < series.length; i++) {\n        // width divided into equal parts\n        if (type === 'line' && (w.config.fill.type === 'gradient' || w.config.fill.type[i] === 'gradient')) {\n          // a small adjustment to allow gradient line to draw correctly for all same values\n\n          /* #fix https://github.com/apexcharts/apexcharts.js/issues/358 */\n          if (coreUtils.seriesHaveSameValues(i)) {\n            var gSeries = series[i].slice();\n            gSeries[gSeries.length - 1] = gSeries[gSeries.length - 1] + 0.000001;\n            series[i] = gSeries;\n          }\n        }\n\n        var xDivision = w.globals.gridWidth / w.globals.dataPoints;\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n        if (yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n        // zeroY is the 0 value in y series which can be used in negative charts\n\n        var zeroY = w.globals.gridHeight - baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? baseLineY[this.yaxisIndex] * 2 : 0);\n        var areaBottomY = zeroY;\n\n        if (zeroY > w.globals.gridHeight) {\n          areaBottomY = w.globals.gridHeight;\n        }\n\n        categoryAxisCorrection = xDivision / 2;\n        var x = w.globals.padHorizontal + categoryAxisCorrection;\n        var y = 1;\n\n        if (w.globals.isXNumeric && w.globals.seriesX.length > 0) {\n          x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio;\n        }\n\n        xArrj.push(x);\n        var linePath = void 0,\n            areaPath = void 0,\n            pathFromLine = void 0,\n            pathFromArea = void 0;\n        var linePaths = [];\n        var areaPaths = []; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex]))\n        }); // points\n\n        var elPointsMain = graphics.group({\n          class: 'apexcharts-series-markers-wrap'\n        }); // eldatalabels\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n        var longestSeries = series[i].length === w.globals.dataPoints;\n        elSeries.attr({\n          'data:longestSeries': longestSeries,\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n        this.appendPathFrom = true;\n        var pX = x;\n        var pY = void 0;\n        var prevX = pX;\n        var prevY = zeroY; // w.globals.svgHeight;\n\n        var lineYPosition = 0; // the first value in the current series is not null or undefined\n\n        var firstPrevY = this.determineFirstPrevY({\n          i: i,\n          series: series,\n          yRatio: yRatio[this.yaxisIndex],\n          zeroY: zeroY,\n          prevY: prevY,\n          prevSeriesY: prevSeriesY,\n          lineYPosition: lineYPosition\n        });\n        prevY = firstPrevY.prevY;\n        yArrj.push(prevY);\n        pY = prevY;\n\n        if (series[i][0] === null) {\n          // when the first value itself is null, we need to move the pointer to a location where a null value is not found\n          for (var s = 0; s < series[i].length; s++) {\n            if (series[i][s] !== null) {\n              prevX = xDivision * s;\n              prevY = zeroY - series[i][s] / yRatio[this.yaxisIndex];\n              linePath = graphics.move(prevX, prevY);\n              areaPath = graphics.move(prevX, areaBottomY);\n              break;\n            }\n          }\n        } else {\n          linePath = graphics.move(prevX, prevY);\n          areaPath = graphics.move(prevX, areaBottomY) + graphics.line(prevX, prevY);\n        }\n\n        pathFromLine = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);\n        pathFromArea = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);\n\n        if (w.globals.previousPaths.length > 0) {\n          var pathFrom = this.checkPreviousPaths({\n            pathFromLine: pathFromLine,\n            pathFromArea: pathFromArea,\n            realIndex: realIndex\n          });\n          pathFromLine = pathFrom.pathFromLine;\n          pathFromArea = pathFrom.pathFromArea;\n        }\n\n        var iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;\n\n        for (var j = 0; j < iterations; j++) {\n          if (w.globals.isXNumeric) {\n            var sX = w.globals.seriesX[realIndex][j + 1];\n\n            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {\n              /* fix #374 */\n              sX = w.globals.seriesX[realIndex][iterations - 1];\n            }\n\n            x = (sX - w.globals.minX) / xRatio;\n          } else {\n            x = x + xDivision;\n          }\n\n          var minY = Utils.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;\n\n          if (w.config.chart.stacked) {\n            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {\n              lineYPosition = prevSeriesY[i - 1][j + 1];\n            } else {\n              // the first series will not have prevY values\n              lineYPosition = zeroY;\n            }\n\n            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {\n              y = lineYPosition - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;\n            } else {\n              y = lineYPosition - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;\n            }\n          } else {\n            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {\n              y = zeroY - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;\n            } else {\n              y = zeroY - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;\n            }\n          } // push current X\n\n\n          xArrj.push(x); // push current Y that will be used as next series's bottom position\n\n          yArrj.push(y);\n          var calculatedPaths = this.createPaths({\n            series: series,\n            i: i,\n            j: j,\n            x: x,\n            y: y,\n            xDivision: xDivision,\n            pX: pX,\n            pY: pY,\n            areaBottomY: areaBottomY,\n            linePath: linePath,\n            areaPath: areaPath,\n            linePaths: linePaths,\n            areaPaths: areaPaths,\n            seriesIndex: seriesIndex\n          });\n          areaPaths = calculatedPaths.areaPaths;\n          linePaths = calculatedPaths.linePaths;\n          pX = calculatedPaths.pX;\n          pY = calculatedPaths.pY;\n          areaPath = calculatedPaths.areaPath;\n          linePath = calculatedPaths.linePath;\n\n          if (this.appendPathFrom) {\n            pathFromLine = pathFromLine + graphics.line(x, zeroY);\n            pathFromArea = pathFromArea + graphics.line(x, zeroY);\n          }\n\n          var pointsPos = this.calculatePoints({\n            series: series,\n            x: x,\n            y: y,\n            realIndex: realIndex,\n            i: i,\n            j: j,\n            prevY: prevY,\n            categoryAxisCorrection: categoryAxisCorrection,\n            xRatio: xRatio\n          });\n\n          if (!this.pointsChart) {\n            var markers = new Markers(this.ctx);\n\n            if (w.globals.dataPoints > 1) {\n              elPointsMain.node.classList.add('hidden');\n            }\n\n            var elPointsWrap = markers.plotChartMarkers(pointsPos, realIndex, j + 1);\n\n            if (elPointsWrap !== null) {\n              elPointsMain.add(elPointsWrap);\n            }\n          } else {\n            // scatter / bubble chart points creation\n            this.scatter.draw(elSeries, j, {\n              realIndex: realIndex,\n              pointsPos: pointsPos,\n              zRatio: zRatio,\n              elParent: elPointsMain\n            });\n          }\n\n          var dataLabelAlign = !series[i][j + 1] || series[i][j + 1] > series[i][j] ? 'top' : 'bottom';\n          var dataLabels = new DataLabels(this.ctx);\n          var drawnLabels = dataLabels.drawDataLabel(pointsPos, realIndex, j + 1, null, dataLabelAlign);\n\n          if (drawnLabels !== null) {\n            elDataLabelsWrap.add(drawnLabels);\n          }\n        } // push all current y values array to main PrevY Array\n\n\n        prevSeriesY.push(yArrj); // push all x val arrays into main xArr\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj; // these elements will be shown after area path animation completes\n\n        if (!this.pointsChart) {\n          w.globals.delayedElements.push({\n            el: elPointsMain.node,\n            index: realIndex\n          });\n        }\n\n        var defaultRenderedPathOptions = {\n          i: i,\n          realIndex: realIndex,\n          animationDelay: i,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-\".concat(type),\n          id: \"apexcharts-\".concat(type)\n        };\n\n        if (type === 'area') {\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex\n          });\n\n          for (var p = 0; p < areaPaths.length; p++) {\n            var renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n              pathFrom: pathFromArea,\n              pathTo: areaPaths[p],\n              stroke: 'none',\n              strokeWidth: 0,\n              strokeLineCap: null,\n              fill: pathFill\n            }));\n            elSeries.add(renderedPath);\n          }\n        }\n\n        if (w.config.stroke.show && !this.pointsChart) {\n          var lineFill = null;\n\n          if (type === 'line') {\n            // fillable lines only for lineChart\n            lineFill = fill.fillPath({\n              seriesNumber: realIndex,\n              i: i\n            });\n          } else {\n            lineFill = w.globals.stroke.colors[realIndex];\n          }\n\n          for (var _p = 0; _p < linePaths.length; _p++) {\n            var _renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n              pathFrom: pathFromLine,\n              pathTo: linePaths[_p],\n              stroke: lineFill,\n              strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width,\n              strokeLineCap: w.config.stroke.lineCap,\n              fill: 'none'\n            }));\n\n            elSeries.add(_renderedPath);\n          }\n        }\n\n        elSeries.add(elPointsMain);\n        elSeries.add(elDataLabelsWrap);\n        allSeries.push(elSeries);\n      }\n\n      for (var _s = allSeries.length; _s > 0; _s--) {\n        ret.add(allSeries[_s - 1]);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"createPaths\",\n    value: function createPaths(_ref) {\n      var series = _ref.series,\n          i = _ref.i,\n          j = _ref.j,\n          x = _ref.x,\n          y = _ref.y,\n          pX = _ref.pX,\n          pY = _ref.pY,\n          xDivision = _ref.xDivision,\n          areaBottomY = _ref.areaBottomY,\n          linePath = _ref.linePath,\n          areaPath = _ref.areaPath,\n          linePaths = _ref.linePaths,\n          areaPaths = _ref.areaPaths,\n          seriesIndex = _ref.seriesIndex;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var curve = w.config.stroke.curve;\n\n      if (Array.isArray(w.config.stroke.curve)) {\n        if (Array.isArray(seriesIndex)) {\n          curve = w.config.stroke.curve[seriesIndex[i]];\n        } else {\n          curve = w.config.stroke.curve[i];\n        }\n      } // logic of smooth curve derived from chartist\n      // CREDITS: https://gionkunz.github.io/chartist-js/\n\n\n      if (curve === 'smooth') {\n        var length = (x - pX) * 0.35;\n\n        if (w.globals.hasNullValues) {\n          if (series[i][j] !== null) {\n            if (series[i][j + 1] !== null) {\n              linePath = graphics.move(pX, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y);\n              areaPath = graphics.move(pX + 1, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y) + graphics.line(x, areaBottomY) + graphics.line(pX, areaBottomY) + 'z';\n            } else {\n              linePath = graphics.move(pX, pY);\n              areaPath = graphics.move(pX, pY) + 'z';\n            }\n          }\n\n          linePaths.push(linePath);\n          areaPaths.push(areaPath);\n        } else {\n          linePath = linePath + graphics.curve(pX + length, pY, x - length, y, x, y);\n          areaPath = areaPath + graphics.curve(pX + length, pY, x - length, y, x, y);\n        }\n\n        pX = x;\n        pY = y;\n\n        if (j === series[i].length - 2) {\n          // last loop, close path\n          areaPath = areaPath + graphics.curve(pX, pY, x, y, x, areaBottomY) + graphics.move(x, y) + 'z';\n\n          if (!w.globals.hasNullValues) {\n            linePaths.push(linePath);\n            areaPaths.push(areaPath);\n          }\n        }\n      } else {\n        if (series[i][j + 1] === null) {\n          linePath = linePath + graphics.move(x, y);\n          areaPath = areaPath + graphics.line(x - xDivision, areaBottomY) + graphics.move(x, y);\n        }\n\n        if (series[i][j] === null) {\n          linePath = linePath + graphics.move(x, y);\n          areaPath = areaPath + graphics.move(x, areaBottomY);\n        }\n\n        if (curve === 'stepline') {\n          linePath = linePath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n          areaPath = areaPath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n        } else if (curve === 'straight') {\n          linePath = linePath + graphics.line(x, y);\n          areaPath = areaPath + graphics.line(x, y);\n        }\n\n        if (j === series[i].length - 2) {\n          // last loop, close path\n          areaPath = areaPath + graphics.line(x, areaBottomY) + graphics.move(x, y) + 'z';\n          linePaths.push(linePath);\n          areaPaths.push(areaPath);\n        }\n      }\n\n      return {\n        linePaths: linePaths,\n        areaPaths: areaPaths,\n        pX: pX,\n        pY: pY,\n        linePath: linePath,\n        areaPath: areaPath\n      };\n    }\n  }, {\n    key: \"calculatePoints\",\n    value: function calculatePoints(_ref2) {\n      var series = _ref2.series,\n          realIndex = _ref2.realIndex,\n          x = _ref2.x,\n          y = _ref2.y,\n          i = _ref2.i,\n          j = _ref2.j,\n          prevY = _ref2.prevY,\n          categoryAxisCorrection = _ref2.categoryAxisCorrection,\n          xRatio = _ref2.xRatio;\n      var w = this.w;\n      var ptX = [];\n      var ptY = [];\n\n      if (j === 0) {\n        var xPT1st = categoryAxisCorrection + w.config.markers.offsetX; // the first point for line series\n        // we need to check whether it's not a time series, because a time series may\n        // start from the middle of the x axis\n\n        if (w.globals.isXNumeric) {\n          xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio + w.config.markers.offsetX;\n        } // push 2 points for the first data values\n\n\n        ptX.push(xPT1st);\n        ptY.push(Utils.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);\n        ptX.push(x + w.config.markers.offsetX);\n        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n      } else {\n        ptX.push(x + w.config.markers.offsetX);\n        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n      }\n\n      var pointsPos = {\n        x: ptX,\n        y: ptY\n      };\n      return pointsPos;\n    }\n  }, {\n    key: \"checkPreviousPaths\",\n    value: function checkPreviousPaths(_ref3) {\n      var pathFromLine = _ref3.pathFromLine,\n          pathFromArea = _ref3.pathFromArea,\n          realIndex = _ref3.realIndex;\n      var w = this.w;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (gpp.type === 'line') {\n            this.appendPathFrom = false;\n            pathFromLine = w.globals.previousPaths[pp].paths[0].d;\n          } else if (gpp.type === 'area') {\n            this.appendPathFrom = false;\n            pathFromArea = w.globals.previousPaths[pp].paths[0].d;\n\n            if (w.config.stroke.show) {\n              pathFromLine = w.globals.previousPaths[pp].paths[1].d;\n            }\n          }\n        }\n      }\n\n      return {\n        pathFromLine: pathFromLine,\n        pathFromArea: pathFromArea\n      };\n    }\n  }, {\n    key: \"determineFirstPrevY\",\n    value: function determineFirstPrevY(_ref4) {\n      var i = _ref4.i,\n          series = _ref4.series,\n          yRatio = _ref4.yRatio,\n          zeroY = _ref4.zeroY,\n          prevY = _ref4.prevY,\n          prevSeriesY = _ref4.prevSeriesY,\n          lineYPosition = _ref4.lineYPosition;\n      var w = this.w;\n\n      if (typeof series[i][0] !== 'undefined') {\n        if (w.config.chart.stacked) {\n          if (i > 0) {\n            // 1st y value of previous series\n            lineYPosition = prevSeriesY[i - 1][0];\n          } else {\n            // the first series will not have prevY values\n            lineYPosition = zeroY;\n          }\n\n          prevY = lineYPosition - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;\n        } else {\n          prevY = zeroY - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;\n        }\n      } else {\n        // the first value in the current series is null\n        if (w.config.chart.stacked && i > 0 && typeof series[i][0] === 'undefined') {\n          // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)\n          for (var s = i - 1; s >= 0; s--) {\n            // for loop to get to 1st previous value until we get it\n            if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {\n              lineYPosition = prevSeriesY[s][0];\n              prevY = lineYPosition;\n              break;\n            }\n          }\n        }\n      }\n\n      return {\n        prevY: prevY,\n        lineYPosition: lineYPosition\n      };\n    }\n  }]);\n\n  return Line;\n}();\n\n/**\n * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.\n *\n * @module Formatters\n **/\n\nvar Formatters =\n/*#__PURE__*/\nfunction () {\n  function Formatters(ctx) {\n    _classCallCheck(this, Formatters);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.tooltipKeyFormat = 'dd MMM';\n  }\n\n  _createClass(Formatters, [{\n    key: \"xLabelFormat\",\n    value: function xLabelFormat(fn, val) {\n      var w = this.w;\n\n      if (w.config.xaxis.type === 'datetime') {\n        // if user has not specified a custom formatter, use the default tooltip.x.format\n        if (w.config.tooltip.x.formatter === undefined) {\n          var datetimeObj = new DateTime(this.ctx);\n          return datetimeObj.formatDate(new Date(val), w.config.tooltip.x.format, true, true);\n        }\n      }\n\n      return fn(val);\n    }\n  }, {\n    key: \"setLabelFormatters\",\n    value: function setLabelFormatters() {\n      var w = this.w;\n\n      w.globals.xLabelFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.xaxisTooltipFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.ttKeyFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.ttZFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.legendFormatter = function (val) {\n        return val;\n      };\n\n      if (typeof w.config.tooltip.x.formatter === 'function') {\n        w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;\n      }\n\n      if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n        w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;\n      }\n\n      if (Array.isArray(w.config.tooltip.y)) {\n        w.globals.ttVal = w.config.tooltip.y;\n      } else {\n        if (w.config.tooltip.y.formatter !== undefined) {\n          w.globals.ttVal = w.config.tooltip.y;\n        }\n      }\n\n      if (w.config.tooltip.z.formatter !== undefined) {\n        w.globals.ttZFormatter = w.config.tooltip.z.formatter;\n      } // legend formatter - if user wants to append any global values of series to legend text\n\n\n      if (w.config.legend.formatter !== undefined) {\n        w.globals.legendFormatter = w.config.legend.formatter;\n      } // formatter function will always overwrite format property\n\n\n      if (w.config.xaxis.labels.formatter !== undefined) {\n        w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;\n      } else {\n        w.globals.xLabelFormatter = function (val) {\n          if (Utils.isNumber(val)) {\n            // numeric xaxis may have smaller range, so defaulting to 1 decimal\n            if (w.config.xaxis.type === 'numeric' && w.globals.dataPoints < 50) {\n              return val.toFixed(1);\n            }\n\n            return val.toFixed(0);\n          }\n\n          return val;\n        };\n      } // formatter function will always overwrite format property\n\n\n      w.config.yaxis.forEach(function (yaxe, i) {\n        if (yaxe.labels.formatter !== undefined) {\n          w.globals.yLabelFormatters[i] = yaxe.labels.formatter;\n        } else {\n          w.globals.yLabelFormatters[i] = function (val) {\n            if (Utils.isNumber(val)) {\n              if (w.globals.yValueDecimal !== 0 || w.globals.maxY - w.globals.minY < 4) {\n                return val.toFixed(yaxe.decimalsInFloat);\n              } else {\n                return val.toFixed(0);\n              }\n            }\n\n            return val;\n          };\n        }\n      });\n      return w.globals;\n    }\n  }, {\n    key: \"heatmapLabelFormatters\",\n    value: function heatmapLabelFormatters() {\n      var w = this.w;\n\n      if (w.config.chart.type === 'heatmap') {\n        w.globals.yAxisScale[0].result = w.globals.seriesNames.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n        var longest = w.globals.seriesNames.reduce(function (a, b) {\n          return a.length > b.length ? a : b;\n        }, 0);\n        w.globals.yAxisScale[0].niceMax = longest;\n        w.globals.yAxisScale[0].niceMin = longest;\n      }\n    }\n  }]);\n\n  return Formatters;\n}();\n\nvar AxesUtils =\n/*#__PURE__*/\nfunction () {\n  function AxesUtils(ctx) {\n    _classCallCheck(this, AxesUtils);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // Based on the formatter function, get the label text and position\n\n\n  _createClass(AxesUtils, [{\n    key: \"getLabel\",\n    value: function getLabel(labels, timelineLabels, x, i) {\n      var drawnLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      var w = this.w;\n      var rawLabel = typeof labels[i] === 'undefined' ? '' : labels[i];\n      var label;\n      var xlbFormatter = w.globals.xLabelFormatter;\n      var customFormatter = w.config.xaxis.labels.formatter;\n      var xFormat = new Formatters(this.ctx);\n      label = xFormat.xLabelFormat(xlbFormatter, rawLabel);\n\n      if (customFormatter !== undefined) {\n        label = customFormatter(rawLabel, labels[i], i);\n      }\n\n      if (timelineLabels.length > 0) {\n        x = timelineLabels[i].position;\n        label = timelineLabels[i].value;\n      } else {\n        if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {\n          label = '';\n        }\n      }\n\n      if (typeof label === 'undefined') label = '';\n      label = label.toString();\n\n      if (label.indexOf('NaN') === 0 || label.toLowerCase().indexOf('invalid') === 0 || label.toLowerCase().indexOf('infinity') >= 0 || drawnLabels.indexOf(label) >= 0 && !w.config.xaxis.labels.showDuplicates) {\n        label = '';\n      }\n\n      return {\n        x: x,\n        text: label\n      };\n    }\n  }, {\n    key: \"drawYAxisTicks\",\n    value: function drawYAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx); // initial label position = 0;\n\n      var t = w.globals.translateY;\n\n      if (axisTicks.show) {\n        if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;\n\n        for (var i = tickAmount; i >= 0; i--) {\n          var tY = t + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY - 1;\n\n          if (w.globals.isBarHorizontal) {\n            tY = labelsDivider * i;\n          }\n\n          var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisBorder.color);\n          elYaxis.add(elTick);\n          t = t + labelsDivider;\n        }\n      }\n    }\n  }]);\n\n  return AxesUtils;\n}();\n\n/**\n * ApexCharts XAxis Class for drawing X-Axis.\n *\n * @module XAxis\n **/\n\nvar XAxis =\n/*#__PURE__*/\nfunction () {\n  function XAxis(ctx) {\n    _classCallCheck(this, XAxis);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.xaxisLabels = w.globals.labels.slice();\n\n    if (w.globals.timelineLabels.length > 0) {\n      //  timeline labels are there\n      this.xaxisLabels = w.globals.timelineLabels.slice();\n    }\n\n    this.drawnLabels = [];\n\n    if (w.config.xaxis.position === 'top') {\n      this.offY = 0;\n    } else {\n      this.offY = w.globals.gridHeight + 1;\n    }\n\n    this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;\n    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;\n    this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;\n    this.xaxisForeColors = w.config.xaxis.labels.style.colors;\n    this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;\n\n    if (this.xaxisBorderWidth.indexOf('%') > -1) {\n      this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth) / 100;\n    } else {\n      this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth);\n    }\n\n    this.xaxisBorderHeight = w.config.xaxis.axisBorder.height; // For bars, we will only consider single y xais,\n    // as we are not providing multiple yaxis for bar charts\n\n    this.yaxis = w.config.yaxis[0];\n    this.axesUtils = new AxesUtils(ctx);\n  }\n\n  _createClass(XAxis, [{\n    key: \"drawXaxis\",\n    value: function drawXaxis() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var elXaxis = graphics.group({\n        class: 'apexcharts-xaxis',\n        transform: \"translate(\".concat(w.config.xaxis.offsetX, \", \").concat(w.config.xaxis.offsetY, \")\")\n      });\n      var elXaxisTexts = graphics.group({\n        class: 'apexcharts-xaxis-texts-g',\n        transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n      });\n      elXaxis.add(elXaxisTexts);\n      var colWidth; // initial x Position (keep adding column width in the loop)\n\n      var xPos = w.globals.padHorizontal;\n      var labels = [];\n\n      for (var i = 0; i < this.xaxisLabels.length; i++) {\n        labels.push(this.xaxisLabels[i]);\n      }\n\n      if (w.globals.isXNumeric) {\n        colWidth = w.globals.gridWidth / (labels.length - 1);\n        xPos = xPos + colWidth / 2 + w.config.xaxis.labels.offsetX;\n      } else {\n        colWidth = w.globals.gridWidth / labels.length;\n        xPos = xPos + colWidth + w.config.xaxis.labels.offsetX;\n      }\n\n      var labelsLen = labels.length;\n\n      if (w.config.xaxis.labels.show) {\n        for (var _i = 0; _i <= labelsLen - 1; _i++) {\n          var x = xPos - colWidth / 2 + w.config.xaxis.labels.offsetX;\n          var label = this.axesUtils.getLabel(labels, w.globals.timelineLabels, x, _i, this.drawnLabels);\n          this.drawnLabels.push(label.text);\n          var offsetYCorrection = 28;\n\n          if (w.globals.rotateXLabels) {\n            offsetYCorrection = 22;\n          }\n\n          var elTick = graphics.drawText({\n            x: label.x,\n            y: this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection,\n            text: '',\n            textAnchor: 'middle',\n            fontSize: this.xaxisFontSize,\n            fontFamily: this.xaxisFontFamily,\n            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[_i] : this.xaxisForeColors,\n            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass\n          });\n          elXaxisTexts.add(elTick);\n          graphics.addTspan(elTick, label.text, this.xaxisFontFamily);\n          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n          elTooltipTitle.textContent = label.text;\n          elTick.node.appendChild(elTooltipTitle);\n          xPos = xPos + colWidth;\n        }\n      }\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var elXaxisTitle = graphics.group({\n          class: 'apexcharts-xaxis-title'\n        });\n        var elXAxisTitleText = graphics.drawText({\n          x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,\n          y: this.offY - parseInt(this.xaxisFontSize) + w.globals.xAxisLabelsHeight + w.config.xaxis.title.offsetY,\n          text: w.config.xaxis.title.text,\n          textAnchor: 'middle',\n          fontSize: w.config.xaxis.title.style.fontSize,\n          fontFamily: w.config.xaxis.title.style.fontFamily,\n          foreColor: w.config.xaxis.title.style.color,\n          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n        });\n        elXaxisTitle.add(elXAxisTitleText);\n        elXaxis.add(elXaxisTitle);\n      }\n\n      if (w.config.xaxis.axisBorder.show) {\n        var lineCorrection = 0;\n\n        if (w.config.chart.type === 'bar' && w.globals.isXNumeric) {\n          lineCorrection = lineCorrection - 15;\n        }\n\n        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);\n        elXaxis.add(elHorzLine);\n      }\n\n      return elXaxis;\n    } // this actually becomes the vertical axis (for bar charts)\n\n  }, {\n    key: \"drawXaxisInversed\",\n    value: function drawXaxisInversed(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;\n      var elYaxis = graphics.group({\n        class: 'apexcharts-yaxis apexcharts-xaxis-inversed',\n        rel: realIndex\n      });\n      var elYaxisTexts = graphics.group({\n        class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',\n        transform: 'translate(' + translateYAxisX + ', 0)'\n      });\n      elYaxis.add(elYaxisTexts);\n      var colHeight; // initial x Position (keep adding column width in the loop)\n\n      var yPos;\n      var labels = [];\n\n      for (var i = 0; i < this.xaxisLabels.length; i++) {\n        labels.push(this.xaxisLabels[i]);\n      }\n\n      colHeight = w.globals.gridHeight / labels.length;\n      yPos = -(colHeight / 2.2);\n      var lbFormatter = w.globals.yLabelFormatters[0];\n      var ylabels = w.config.yaxis[0].labels;\n\n      if (ylabels.show) {\n        for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {\n          var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];\n          label = lbFormatter(label);\n          var elLabel = graphics.drawText({\n            x: ylabels.offsetX - 15,\n            y: yPos + colHeight + ylabels.offsetY,\n            text: label,\n            textAnchor: this.yaxis.opposite ? 'start' : 'end',\n            foreColor: ylabels.style.color ? ylabels.style.color : ylabels.style.colors[_i2],\n            fontSize: ylabels.style.fontSize,\n            fontFamily: ylabels.style.fontFamily,\n            cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass\n          });\n          elYaxisTexts.add(elLabel);\n          yPos = yPos + colHeight;\n        }\n      }\n\n      if (w.config.yaxis[0].title.text !== undefined) {\n        var elXaxisTitle = graphics.group({\n          class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',\n          transform: 'translate(' + translateYAxisX + ', 0)'\n        });\n        var elXAxisTitleText = graphics.drawText({\n          x: 0,\n          y: w.globals.gridHeight / 2,\n          text: w.config.yaxis[0].title.text,\n          textAnchor: 'middle',\n          foreColor: w.config.yaxis[0].title.style.color,\n          fontSize: w.config.yaxis[0].title.style.fontSize,\n          fontFamily: w.config.yaxis[0].title.style.fontFamily,\n          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass\n        });\n        elXaxisTitle.add(elXAxisTitleText);\n        elYaxis.add(elXaxisTitle);\n      }\n\n      if (w.config.xaxis.axisBorder.show) {\n        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, this.yaxis.axisBorder.color, 0, this.xaxisBorderHeight);\n        elYaxis.add(elHorzLine);\n        this.axesUtils.drawYAxisTicks(0, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);\n      }\n\n      return elYaxis;\n    }\n  }, {\n    key: \"drawXaxisTicks\",\n    value: function drawXaxisTicks(x1, appendToElement) {\n      var w = this.w;\n      var x2 = x1;\n      if (x1 < 0 || x1 > w.globals.gridWidth) return;\n      var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;\n      var y2 = y1 + w.config.xaxis.axisTicks.height;\n\n      if (w.config.xaxis.axisTicks.show) {\n        var graphics = new Graphics(this.ctx);\n        var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color); // we are not returning anything, but appending directly to the element pased in param\n\n        appendToElement.add(line);\n        line.node.classList.add('apexcharts-xaxis-tick');\n      }\n    }\n  }, {\n    key: \"getXAxisTicksPositions\",\n    value: function getXAxisTicksPositions() {\n      var w = this.w;\n      var xAxisTicksPositions = [];\n      var xCount = this.xaxisLabels.length;\n      var x1 = w.globals.padHorizontal;\n\n      if (w.globals.timelineLabels.length > 0) {\n        for (var i = 0; i < xCount; i++) {\n          x1 = this.xaxisLabels[i].position;\n          xAxisTicksPositions.push(x1);\n        }\n      } else {\n        var xCountForCategoryCharts = xCount;\n\n        for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {\n          var x1Count = xCountForCategoryCharts;\n\n          if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {\n            x1Count -= 1;\n          }\n\n          x1 = x1 + w.globals.gridWidth / x1Count;\n          xAxisTicksPositions.push(x1);\n        }\n      }\n\n      return xAxisTicksPositions;\n    } // to rotate x-axis labels or to put ... for longer text in xaxis\n\n  }, {\n    key: \"xAxisLabelCorrections\",\n    value: function xAxisLabelCorrections() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');\n      var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text');\n      var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');\n      var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text');\n\n      if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {\n        for (var xat = 0; xat < xAxisTexts.length; xat++) {\n          var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);\n          textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;\n\n          textRotatingCenter.x = textRotatingCenter.x + 1;\n          xAxisTexts[xat].setAttribute('transform', \"rotate(\".concat(w.config.xaxis.labels.rotate, \" \").concat(textRotatingCenter.x, \" \").concat(textRotatingCenter.y, \")\"));\n          xAxisTexts[xat].setAttribute('text-anchor', \"end\");\n          var offsetHeight = 10;\n          xAxis.setAttribute('transform', \"translate(0, \".concat(-offsetHeight, \")\"));\n          var tSpan = xAxisTexts[xat].childNodes;\n\n          if (w.config.xaxis.labels.trim) {\n            graphics.placeTextWithEllipsis(tSpan[0], tSpan[0].textContent, w.config.xaxis.labels.maxHeight - 40);\n          }\n        }\n      } else {\n        var width = w.globals.gridWidth / w.globals.labels.length;\n\n        for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {\n          var _tSpan = xAxisTexts[_xat].childNodes;\n\n          if (w.config.xaxis.labels.trim && w.config.xaxis.type !== 'datetime') {\n            graphics.placeTextWithEllipsis(_tSpan[0], _tSpan[0].textContent, width);\n          }\n        }\n      }\n\n      if (yAxisTextsInversed.length > 0) {\n        // truncate rotated y axis in bar chart (x axis)\n        var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();\n        var lastLabelPosX = yAxisTextsInversed[0].getBBox();\n\n        if (firstLabelPosX.x < -20) {\n          yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);\n        }\n\n        if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth) {\n          yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);\n        } // truncate rotated x axis in bar chart (y axis)\n\n\n        for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {\n          graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - parseInt(w.config.yaxis[0].title.style.fontSize) * 2 - 20);\n        }\n      }\n    } // renderXAxisBands() {\n    //   let w = this.w;\n    //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')\n    //   w.globals.dom.elGraphical.add(plotBand)\n    // }\n\n  }]);\n\n  return XAxis;\n}();\n\n/**\n * ApexCharts YAxis Class for drawing Y-Axis.\n *\n * @module YAxis\n **/\n\nvar YAxis =\n/*#__PURE__*/\nfunction () {\n  function YAxis(ctx) {\n    _classCallCheck(this, YAxis);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;\n    this.axisFontFamily = w.config.xaxis.labels.style.fontFamily;\n    this.xaxisForeColors = w.config.xaxis.labels.style.colors;\n    this.xAxisoffX = 0;\n\n    if (w.config.xaxis.position === 'bottom') {\n      this.xAxisoffX = w.globals.gridHeight;\n    }\n\n    this.drawnLabels = [];\n    this.axesUtils = new AxesUtils(ctx);\n  }\n\n  _createClass(YAxis, [{\n    key: \"drawYaxis\",\n    value: function drawYaxis(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var yaxisFontSize = w.config.yaxis[realIndex].labels.style.fontSize;\n      var yaxisFontFamily = w.config.yaxis[realIndex].labels.style.fontFamily;\n      var elYaxis = graphics.group({\n        class: 'apexcharts-yaxis',\n        rel: realIndex,\n        transform: 'translate(' + w.globals.translateYAxisX[realIndex] + ', 0)'\n      });\n\n      if (!w.config.yaxis[realIndex].show) {\n        return elYaxis;\n      }\n\n      var elYaxisTexts = graphics.group({\n        class: 'apexcharts-yaxis-texts-g'\n      });\n      elYaxis.add(elYaxisTexts);\n      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg height/number of ticks\n\n      var labelsDivider = w.globals.gridHeight / tickAmount + 0.1; // initial label position = 0;\n\n      var l = w.globals.translateY;\n      var lbFormatter = w.globals.yLabelFormatters[realIndex];\n      var labels = w.globals.yAxisScale[realIndex].result.slice();\n\n      if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].reversed) {\n        labels.reverse();\n      }\n\n      if (w.config.yaxis[realIndex].labels.show) {\n        for (var i = tickAmount; i >= 0; i--) {\n          var val = labels[i];\n          val = lbFormatter(val, i);\n          var xPad = w.config.yaxis[realIndex].labels.padding;\n\n          if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) {\n            xPad = xPad * -1;\n          }\n\n          var label = graphics.drawText({\n            x: xPad,\n            y: l + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY + 1,\n            text: val,\n            textAnchor: w.config.yaxis[realIndex].opposite ? 'start' : 'end',\n            fontSize: yaxisFontSize,\n            fontFamily: yaxisFontFamily,\n            foreColor: w.config.yaxis[realIndex].labels.style.color,\n            cssClass: 'apexcharts-yaxis-label ' + w.config.yaxis[realIndex].labels.style.cssClass\n          });\n          elYaxisTexts.add(label);\n          var labelRotatingCenter = graphics.rotateAroundCenter(label.node);\n\n          if (w.config.yaxis[realIndex].labels.rotate !== 0) {\n            label.node.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].labels.rotate, \" \").concat(labelRotatingCenter.x, \" \").concat(labelRotatingCenter.y, \")\"));\n          }\n\n          l = l + labelsDivider;\n        }\n      }\n\n      if (w.config.yaxis[realIndex].title.text !== undefined) {\n        var elYaxisTitle = graphics.group({\n          class: 'apexcharts-yaxis-title'\n        });\n        var x = 0;\n\n        if (w.config.yaxis[realIndex].opposite) {\n          x = w.globals.translateYAxisX[realIndex];\n        }\n\n        var elYAxisTitleText = graphics.drawText({\n          x: x,\n          y: w.globals.gridHeight / 2 + w.globals.translateY,\n          text: w.config.yaxis[realIndex].title.text,\n          textAnchor: 'end',\n          foreColor: w.config.yaxis[realIndex].title.style.color,\n          fontSize: w.config.yaxis[realIndex].title.style.fontSize,\n          fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,\n          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[realIndex].title.style.cssClass\n        });\n        elYaxisTitle.add(elYAxisTitleText);\n        elYaxis.add(elYaxisTitle);\n      }\n\n      var axisBorder = w.config.yaxis[realIndex].axisBorder;\n\n      if (axisBorder.show) {\n        var _x = 31 + axisBorder.offsetX;\n\n        if (w.config.yaxis[realIndex].opposite) {\n          _x = -31 - axisBorder.offsetX;\n        }\n\n        var elVerticalLine = graphics.drawLine(_x, w.globals.translateY + axisBorder.offsetY - 2, _x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color);\n        elYaxis.add(elVerticalLine);\n        this.axesUtils.drawYAxisTicks(_x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);\n      }\n\n      return elYaxis;\n    } // This actually becomes horizonal axis (for bar charts)\n\n  }, {\n    key: \"drawYaxisInversed\",\n    value: function drawYaxisInversed(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var elXaxis = graphics.group({\n        class: 'apexcharts-xaxis apexcharts-yaxis-inversed'\n      });\n      var elXaxisTexts = graphics.group({\n        class: 'apexcharts-xaxis-texts-g',\n        transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n      });\n      elXaxis.add(elXaxisTexts);\n      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg width/number of ticks\n\n      var labelsDivider = w.globals.gridWidth / tickAmount + 0.1; // initial label position;\n\n      var l = labelsDivider + w.config.xaxis.labels.offsetX;\n      var lbFormatter = w.globals.xLabelFormatter;\n      var labels = w.globals.yAxisScale[realIndex].result.slice();\n      var timelineLabels = w.globals.invertedTimelineLabels;\n\n      if (timelineLabels.length > 0) {\n        this.xaxisLabels = timelineLabels.slice();\n        labels = timelineLabels.slice();\n        tickAmount = labels.length;\n      }\n\n      if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].reversed) {\n        labels.reverse();\n      }\n\n      var tl = timelineLabels.length;\n\n      if (w.config.xaxis.labels.show) {\n        for (var i = tl ? 0 : tickAmount; tl ? i < tl - 1 : i >= 0; tl ? i++ : i--) {\n          var val = labels[i];\n          val = lbFormatter(val, i);\n          var x = w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX);\n\n          if (timelineLabels.length) {\n            var label = this.axesUtils.getLabel(labels, timelineLabels, x, i, this.drawnLabels);\n            x = label.x;\n            val = label.text;\n            this.drawnLabels.push(label.text);\n          }\n\n          var elTick = graphics.drawText({\n            x: x,\n            y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30,\n            text: '',\n            textAnchor: 'middle',\n            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,\n            fontSize: this.xaxisFontSize,\n            fontFamily: this.xaxisFontFamily,\n            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass\n          });\n          elXaxisTexts.add(elTick);\n          elTick.tspan(val);\n          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n          elTooltipTitle.textContent = val;\n          elTick.node.appendChild(elTooltipTitle);\n          l = l + labelsDivider;\n        }\n      }\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var elYaxisTitle = graphics.group({\n          class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'\n        });\n        var elYAxisTitleText = graphics.drawText({\n          x: w.globals.gridWidth / 2,\n          y: this.xAxisoffX + parseInt(this.xaxisFontSize) + parseInt(w.config.xaxis.title.style.fontSize) + 20,\n          text: w.config.xaxis.title.text,\n          textAnchor: 'middle',\n          fontSize: w.config.xaxis.title.style.fontSize,\n          fontFamily: w.config.xaxis.title.style.fontFamily,\n          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n        });\n        elYaxisTitle.add(elYAxisTitleText);\n        elXaxis.add(elYaxisTitle);\n      }\n\n      var axisBorder = w.config.yaxis[realIndex].axisBorder;\n\n      if (axisBorder.show) {\n        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color);\n        elXaxis.add(elVerticalLine);\n      }\n\n      return elXaxis;\n    }\n  }, {\n    key: \"yAxisTitleRotate\",\n    value: function yAxisTitleRotate(realIndex, yAxisOpposite) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var yAxisLabelsCoord = {\n        width: 0,\n        height: 0\n      };\n      var yAxisTitleCoord = {\n        width: 0,\n        height: 0\n      };\n      var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(\" .apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-texts-g\"));\n\n      if (elYAxisLabelsWrap !== null) {\n        yAxisLabelsCoord = elYAxisLabelsWrap.getBoundingClientRect();\n      }\n\n      var yAxisTitle = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-title text\"));\n\n      if (yAxisTitle !== null) {\n        yAxisTitleCoord = yAxisTitle.getBoundingClientRect();\n      }\n\n      if (yAxisTitle !== null) {\n        var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);\n        yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));\n      }\n\n      if (yAxisTitle !== null) {\n        var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);\n\n        if (!yAxisOpposite) {\n          yAxisTitle.setAttribute('transform', \"rotate(-\".concat(w.config.yaxis[realIndex].title.rotate, \" \").concat(titleRotatingCenter.x, \" \").concat(titleRotatingCenter.y, \")\"));\n        } else {\n          yAxisTitle.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].title.rotate, \" \").concat(titleRotatingCenter.x, \" \").concat(titleRotatingCenter.y, \")\"));\n        }\n      }\n    }\n  }, {\n    key: \"xPaddingForYAxisTitle\",\n    value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {\n      var w = this.w;\n      var oppositeAxisCount = 0;\n      var x = 0;\n      var padd = 10;\n\n      if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {\n        return {\n          xPos: x,\n          padd: 0\n        };\n      }\n\n      if (yAxisOpposite) {\n        x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;\n        oppositeAxisCount += 1;\n\n        if (oppositeAxisCount === 0) {\n          x = x - padd / 2;\n        }\n      } else {\n        x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;\n\n        if (w.globals.isBarHorizontal) {\n          padd = 25;\n          x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;\n        }\n      }\n\n      return {\n        xPos: x,\n        padd: padd\n      };\n    } // sets the x position of the y-axis by counting the labels width, title width and any offset\n\n  }, {\n    key: \"setYAxisXPosition\",\n    value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {\n      var w = this.w;\n      var xLeft = 0;\n      var xRight = 0;\n      var leftOffsetX = 21;\n      var rightOffsetX = 1;\n\n      if (w.config.yaxis.length > 1) {\n        this.multipleYs = true;\n      }\n\n      w.config.yaxis.map(function (yaxe, index) {\n        var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.indexOf(index) > -1 || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;\n        var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;\n\n        if (!yaxe.opposite) {\n          xLeft = w.globals.translateX - leftOffsetX;\n\n          if (!shouldNotDrawAxis) {\n            leftOffsetX = leftOffsetX + axisWidth + 20;\n          }\n\n          w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;\n        } else {\n          if (w.globals.isBarHorizontal) {\n            xRight = w.globals.gridWidth + w.globals.translateX - 1;\n            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;\n          } else {\n            xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;\n\n            if (!shouldNotDrawAxis) {\n              rightOffsetX = rightOffsetX + axisWidth + 20;\n            }\n\n            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"setYAxisTextAlignments\",\n    value: function setYAxisTextAlignments() {\n      var w = this.w;\n      var yaxis = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-yaxis\");\n      yaxis = Utils.listToArray(yaxis);\n      yaxis.forEach(function (y, index) {\n        var yaxe = w.config.yaxis[index]; // proceed only if user has specified alignment\n\n        if (yaxe.labels.align !== undefined) {\n          var yAxisInner = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxis[rel='\".concat(index, \"'] .apexcharts-yaxis-texts-g\"));\n          var yAxisTexts = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-yaxis[rel='\".concat(index, \"'] .apexcharts-yaxis-label\"));\n          yAxisTexts = Utils.listToArray(yAxisTexts);\n          var rect = yAxisInner.getBoundingClientRect();\n\n          if (yaxe.labels.align === 'left') {\n            yAxisTexts.forEach(function (label, lI) {\n              label.setAttribute('text-anchor', 'start');\n            });\n\n            if (!yaxe.opposite) {\n              yAxisInner.setAttribute('transform', \"translate(-\".concat(rect.width, \", 0)\"));\n            }\n          } else if (yaxe.labels.align === 'center') {\n            yAxisTexts.forEach(function (label, lI) {\n              label.setAttribute('text-anchor', 'middle');\n            });\n            yAxisInner.setAttribute('transform', \"translate(\".concat(rect.width / 2 * (!yaxe.opposite ? -1 : 1), \", 0)\"));\n          } else if (yaxe.labels.align === 'right') {\n            yAxisTexts.forEach(function (label, lI) {\n              label.setAttribute('text-anchor', 'end');\n            });\n\n            if (yaxe.opposite) {\n              yAxisInner.setAttribute('transform', \"translate(\".concat(rect.width, \", 0)\"));\n            }\n          }\n        }\n      });\n    }\n  }]);\n\n  return YAxis;\n}();\n\nvar Range =\n/*#__PURE__*/\nfunction () {\n  function Range(ctx) {\n    _classCallCheck(this, Range);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axiss\n  // This routine creates the Y axis values for a graph.\n\n\n  _createClass(Range, [{\n    key: \"niceScale\",\n    value: function niceScale(yMin, yMax) {\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var ticks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n      var w = this.w;\n\n      if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils.isNumber(yMin) && !Utils.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {\n        // when all values are 0\n        yMin = 0;\n        yMax = ticks;\n        var linearScale = this.linearScale(yMin, yMax, ticks);\n        return linearScale;\n      }\n\n      if (yMin > yMax) {\n        // if somehow due to some wrong config, user sent max less than min,\n        // adjust the min/max again\n        console.warn('yaxis.min cannot be greater than yaxis.max');\n        yMax = yMin + 0.1;\n      } else if (yMin === yMax) {\n        // If yMin and yMax are identical, then\n        // adjust the yMin and yMax values to actually\n        // make a graph. Also avoids division by zero errors.\n        yMin = yMin === 0 ? 0 : yMin - 0.5; // some small value\n\n        yMax = yMax === 0 ? 2 : yMax + 0.5; // some small value\n      } // Calculate Min amd Max graphical labels and graph\n      // increments.  The number of ticks defaults to\n      // 10 which is the SUGGESTED value.  Any tick value\n      // entered is used as a suggested value which is\n      // adjusted to be a 'pretty' value.\n      //\n      // Output will be an array of the Y axis values that\n      // encompass the Y values.\n\n\n      var result = []; // Determine Range\n\n      var range = yMax - yMin;\n\n      if (range < 1 && w.config.yaxis[index].forceNiceScale && (w.config.chart.type === 'candlestick' || w.config.series[index].type === 'candlestick' || w.globals.isRangeData)) {\n        /* fix https://github.com/apexcharts/apexcharts.js/issues/430 */\n        yMax = yMax * 1.01;\n      }\n\n      var tiks = ticks + 1; // Adjust ticks if needed\n\n      if (tiks < 2) {\n        tiks = 2;\n      } else if (tiks > 2) {\n        tiks -= 2;\n      } // Get raw step value\n\n\n      var tempStep = range / tiks; // Calculate pretty step value\n\n      var mag = Math.floor(Utils.log10(tempStep));\n      var magPow = Math.pow(10, mag);\n      var magMsd = parseInt(tempStep / magPow);\n      var stepSize = magMsd * magPow; // build Y label array.\n      // Lower and upper bounds calculations\n\n      var lb = stepSize * Math.floor(yMin / stepSize);\n      var ub = stepSize * Math.ceil(yMax / stepSize); // Build array\n\n      var val = lb;\n\n      while (1) {\n        result.push(val);\n        val += stepSize;\n\n        if (val > ub) {\n          break;\n        }\n      }\n\n      if (this.w.config.yaxis[index].max === undefined && this.w.config.yaxis[index].min === undefined || this.w.config.yaxis[index].forceNiceScale) {\n        return {\n          result: result,\n          niceMin: result[0],\n          niceMax: result[result.length - 1]\n        };\n      } else {\n        result = [];\n        var v = yMin;\n        result.push(v);\n        var valuesDivider = Math.abs(yMax - yMin) / ticks;\n\n        for (var i = 0; i <= ticks - 1; i++) {\n          v = v + valuesDivider;\n          result.push(v);\n        }\n\n        return {\n          result: result,\n          niceMin: result[0],\n          niceMax: result[result.length - 1]\n        };\n      }\n    }\n  }, {\n    key: \"linearScale\",\n    value: function linearScale(yMin, yMax) {\n      var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      var range = Math.abs(yMax - yMin);\n      var step = range / ticks;\n\n      if (ticks === Number.MAX_VALUE) {\n        ticks = 10;\n        step = 1;\n      }\n\n      var result = [];\n      var v = yMin;\n\n      while (ticks >= 0) {\n        result.push(v);\n        v = v + step;\n        ticks -= 1;\n      }\n\n      return {\n        result: result,\n        niceMin: result[0],\n        niceMax: result[result.length - 1]\n      };\n    }\n  }, {\n    key: \"logarithmicScale\",\n    value: function logarithmicScale(index, yMin, yMax, ticks) {\n      if (yMin < 0 || yMin === Number.MIN_VALUE) yMin = 0.01;\n      var base = 10;\n      var min = Math.log(yMin) / Math.log(base);\n      var max = Math.log(yMax) / Math.log(base);\n      var range = Math.abs(yMax - yMin);\n      var step = range / ticks;\n      var result = [];\n      var v = yMin;\n\n      while (ticks >= 0) {\n        result.push(v);\n        v = v + step;\n        ticks -= 1;\n      }\n\n      var logs = result.map(function (niceNumber, i) {\n        if (niceNumber <= 0) {\n          niceNumber = 0.01;\n        } // calculate adjustment factor\n\n\n        var scale = (max - min) / (yMax - yMin);\n        var logVal = Math.pow(base, min + scale * (niceNumber - min));\n        return Math.round(logVal / Utils.roundToBase(logVal, base)) * Utils.roundToBase(logVal, base);\n      }); // Math.floor may have rounded the value to 0, revert back to 1\n\n      if (logs[0] === 0) logs[0] = 1;\n      return {\n        result: logs,\n        niceMin: logs[0],\n        niceMax: logs[logs.length - 1]\n      };\n    }\n  }, {\n    key: \"setYScaleForIndex\",\n    value: function setYScaleForIndex(index, minY, maxY) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var y = gl.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];\n\n      if (typeof gl.yAxisScale[index] === 'undefined') {\n        gl.yAxisScale[index] = [];\n      }\n\n      if (y.logarithmic) {\n        gl.allSeriesCollapsed = false;\n        gl.yAxisScale[index] = this.logarithmicScale(index, minY, maxY, y.tickAmount ? y.tickAmount : Math.floor(Math.log10(maxY)));\n      } else {\n        if (maxY === -Number.MAX_VALUE || !Utils.isNumber(maxY)) {\n          // no data in the chart. Either all series collapsed or user passed a blank array\n          gl.yAxisScale[index] = this.linearScale(0, 5, 5);\n        } else {\n          // there is some data. Turn off the allSeriesCollapsed flag\n          gl.allSeriesCollapsed = false;\n\n          if ((y.min !== undefined || y.max !== undefined) && !y.forceNiceScale) {\n            // fix https://github.com/apexcharts/apexcharts.js/issues/492\n            gl.yAxisScale[index] = this.linearScale(minY, maxY, y.tickAmount);\n          } else {\n            gl.yAxisScale[index] = this.niceScale(minY, maxY, index, // fix https://github.com/apexcharts/apexcharts.js/issues/397\n            y.tickAmount ? y.tickAmount : maxY < 5 && maxY > 1 ? maxY + 1 : 5);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setMultipleYScales\",\n    value: function setMultipleYScales() {\n      var _this = this;\n\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var minYArr = gl.minYArr.concat([]);\n      var maxYArr = gl.maxYArr.concat([]);\n      var scalesIndices = []; // here, we loop through the yaxis array and find the item which has \"seriesName\" property\n\n      cnf.yaxis.forEach(function (yaxe, i) {\n        var index = i;\n        cnf.series.forEach(function (s, si) {\n          // if seriesName matches and that series is not collapsed, we use that scale\n          if (s.name === yaxe.seriesName && gl.collapsedSeriesIndices.indexOf(si) === -1) {\n            index = si;\n\n            if (i !== si) {\n              scalesIndices.push({\n                index: si,\n                similarIndex: i,\n                alreadyExists: true\n              });\n            } else {\n              scalesIndices.push({\n                index: si\n              });\n            }\n          }\n        });\n        var minY = minYArr[index];\n        var maxY = maxYArr[index];\n\n        _this.setYScaleForIndex(i, minY, maxY);\n      });\n      this.sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices);\n    }\n  }, {\n    key: \"sameScaleInMultipleAxes\",\n    value: function sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices) {\n      var _this2 = this;\n\n      var cnf = this.w.config;\n      var gl = this.w.globals; // we got the scalesIndices array in the above code, but we need to filter out the items which doesn't have same scales\n\n      var similarIndices = [];\n      scalesIndices.forEach(function (scale) {\n        if (scale.alreadyExists) {\n          if (typeof similarIndices[scale.index] === 'undefined') {\n            similarIndices[scale.index] = [];\n          }\n\n          similarIndices[scale.index].push(scale.index);\n          similarIndices[scale.index].push(scale.similarIndex);\n        }\n      });\n\n      function intersect(a, b) {\n        return a.filter(function (value) {\n          return b.indexOf(value) !== -1;\n        });\n      }\n\n      similarIndices.forEach(function (si, i) {\n        similarIndices.forEach(function (sj, j) {\n          if (i !== j) {\n            if (intersect(si, sj).length > 0) {\n              similarIndices[i] = similarIndices[i].concat(similarIndices[j]);\n            }\n          }\n        });\n      }); // then, we remove duplicates from the similarScale array\n\n      var uniqueSimilarIndices = similarIndices.map(function (item) {\n        return item.filter(function (i, pos) {\n          return item.indexOf(i) === pos;\n        });\n      }); // sort further to remove whole duplicate arrays later\n\n      var sortedIndices = uniqueSimilarIndices.map(function (s) {\n        return s.sort();\n      }); // remove undefined items\n\n      similarIndices = similarIndices.filter(function (s) {\n        return !!s;\n      });\n      var indices = sortedIndices.slice();\n      var stringIndices = indices.map(function (ind) {\n        return JSON.stringify(ind);\n      });\n      indices = indices.filter(function (ind, p) {\n        return stringIndices.indexOf(JSON.stringify(ind)) === p;\n      });\n      var sameScaleMinYArr = [];\n      var sameScaleMaxYArr = [];\n      minYArr.forEach(function (minYValue, yi) {\n        indices.forEach(function (scale, i) {\n          // we compare only the yIndex which exists in the indices array\n          if (scale.indexOf(yi) > -1) {\n            if (typeof sameScaleMinYArr[i] === 'undefined') {\n              sameScaleMinYArr[i] = [];\n              sameScaleMaxYArr[i] = [];\n            }\n\n            sameScaleMinYArr[i].push({\n              key: yi,\n              value: minYValue\n            });\n            sameScaleMaxYArr[i].push({\n              key: yi,\n              value: maxYArr[yi]\n            });\n          }\n        });\n      });\n      var sameScaleMin = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, Number.MIN_VALUE);\n      var sameScaleMax = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);\n      sameScaleMinYArr.forEach(function (s, i) {\n        s.forEach(function (sc, j) {\n          sameScaleMin[i] = Math.min(sc.value, sameScaleMin[i]);\n        });\n      });\n      sameScaleMaxYArr.forEach(function (s, i) {\n        s.forEach(function (sc, j) {\n          sameScaleMax[i] = Math.max(sc.value, sameScaleMax[i]);\n        });\n      });\n      minYArr.forEach(function (min, i) {\n        sameScaleMaxYArr.forEach(function (s, si) {\n          var minY = sameScaleMin[si];\n          var maxY = sameScaleMax[si];\n          s.forEach(function (ind, k) {\n            if (s[k].key === i) {\n              if (cnf.yaxis[i].min !== undefined) {\n                if (typeof cnf.yaxis[i].min === 'function') {\n                  minY = cnf.yaxis[i].min(gl.minY);\n                } else {\n                  minY = cnf.yaxis[i].min;\n                }\n              }\n\n              if (cnf.yaxis[i].max !== undefined) {\n                if (typeof cnf.yaxis[i].max === 'function') {\n                  maxY = cnf.yaxis[i].max(gl.maxY);\n                } else {\n                  maxY = cnf.yaxis[i].max;\n                }\n              }\n\n              _this2.setYScaleForIndex(i, minY, maxY);\n            }\n          });\n        });\n      });\n    }\n  }, {\n    key: \"autoScaleY\",\n    value: function autoScaleY(ctx, e) {\n      if (!ctx) {\n        ctx = this;\n      }\n\n      var ret = [];\n      ctx.w.config.series.forEach(function (serie) {\n        var min, max;\n        var first = serie.data.find(function (x) {\n          return x[0] >= e.xaxis.min;\n        });\n        var firstValue = first[1];\n        max = min = firstValue;\n        serie.data.forEach(function (data) {\n          if (data[0] <= e.xaxis.max && data[0] >= e.xaxis.min) {\n            if (data[1] > max && data[1] !== null) max = data[1];\n            if (data[1] < min && data[1] !== null) min = data[1];\n          }\n        });\n        min *= 0.95;\n        max *= 1.05;\n        ret.push({\n          min: min,\n          max: max\n        });\n      });\n      return ret;\n    }\n  }]);\n\n  return Range;\n}();\n\n/**\n * Range is used to generates values between min and max.\n *\n * @module Range\n **/\n\nvar Range$1 =\n/*#__PURE__*/\nfunction () {\n  function Range$$1(ctx) {\n    _classCallCheck(this, Range$$1);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.scales = new Range(ctx);\n  }\n\n  _createClass(Range$$1, [{\n    key: \"init\",\n    value: function init() {\n      this.setYRange();\n      this.setXRange();\n      this.setZRange();\n    }\n  }, {\n    key: \"getMinYMaxY\",\n    value: function getMinYMaxY(startingIndex) {\n      var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n      var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;\n      var len = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var gl = this.w.globals;\n      var maxY = -Number.MAX_VALUE;\n      var minY = Number.MIN_VALUE;\n\n      if (len === null) {\n        len = startingIndex + 1;\n      }\n\n      var series = gl.series;\n      var seriesMin = series;\n      var seriesMax = series;\n\n      if (this.w.config.chart.type === 'candlestick') {\n        seriesMin = gl.seriesCandleL;\n        seriesMax = gl.seriesCandleH;\n      } else if (gl.isRangeData) {\n        seriesMin = gl.seriesRangeStart;\n        seriesMax = gl.seriesRangeEnd;\n      }\n\n      for (var i = startingIndex; i < len; i++) {\n        gl.dataPoints = Math.max(gl.dataPoints, series[i].length);\n\n        for (var j = 0; j < gl.series[i].length; j++) {\n          if (series[i][j] !== null && Utils.isNumber(series[i][j])) {\n            maxY = Math.max(maxY, seriesMax[i][j]);\n            lowestY = Math.min(lowestY, seriesMin[i][j]);\n            highestY = Math.max(highestY, seriesMin[i][j]);\n\n            if (this.w.config.chart.type === 'candlestick') {\n              maxY = Math.max(maxY, gl.seriesCandleO[i][j]);\n              maxY = Math.max(maxY, gl.seriesCandleH[i][j]);\n              maxY = Math.max(maxY, gl.seriesCandleL[i][j]);\n              maxY = Math.max(maxY, gl.seriesCandleC[i][j]);\n              highestY = maxY;\n            }\n\n            if (Utils.isFloat(series[i][j])) {\n              gl.yValueDecimal = Math.max(gl.yValueDecimal, series[i][j].toString().split('.')[1].length);\n            }\n\n            if (minY > seriesMin[i][j] && seriesMin[i][j] < 0) {\n              minY = seriesMin[i][j];\n            }\n          } else {\n            gl.hasNullValues = true;\n          }\n        }\n      }\n\n      return {\n        minY: minY,\n        maxY: maxY,\n        lowestY: lowestY,\n        highestY: highestY\n      };\n    }\n  }, {\n    key: \"setYRange\",\n    value: function setYRange() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.maxY = -Number.MAX_VALUE;\n      gl.minY = Number.MIN_VALUE;\n      var lowestYInAllSeries = Number.MAX_VALUE;\n\n      if (gl.isMultipleYAxis) {\n        // we need to get minY and maxY for multiple y axis\n        for (var i = 0; i < gl.series.length; i++) {\n          var minYMaxYArr = this.getMinYMaxY(i, lowestYInAllSeries, null, i + 1);\n          gl.minYArr.push(minYMaxYArr.minY);\n          gl.maxYArr.push(minYMaxYArr.maxY);\n          lowestYInAllSeries = minYMaxYArr.lowestY;\n        }\n      } // and then, get the minY and maxY from all series\n\n\n      var minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);\n      gl.minY = minYMaxY.minY;\n      gl.maxY = minYMaxY.maxY;\n      lowestYInAllSeries = minYMaxY.lowestY;\n\n      if (cnf.chart.stacked) {\n        // for stacked charts, we calculate each series's parallel values. i.e, series[0][j] + series[1][j] .... [series[i.length][j]] and get the max out of it\n        var stackedPoss = [];\n        var stackedNegs = [];\n\n        for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {\n          var poss = 0;\n          var negs = 0;\n\n          for (var _i = 0; _i < gl.series.length; _i++) {\n            if (gl.series[_i][j] !== null && Utils.isNumber(gl.series[_i][j])) {\n              if (gl.series[_i][j] > 0) {\n                // 0.0001 fixes #185 when values are very small\n                poss = poss + parseFloat(gl.series[_i][j]) + 0.0001;\n              } else {\n                negs = negs + parseFloat(gl.series[_i][j]);\n              }\n            }\n\n            if (_i === gl.series.length - 1) {\n              // push all the totals to the array for future use\n              stackedPoss.push(poss);\n              stackedNegs.push(negs);\n            }\n          }\n        } // get the max/min out of the added parallel values\n\n\n        for (var z = 0; z < stackedPoss.length; z++) {\n          gl.maxY = Math.max(gl.maxY, stackedPoss[z]);\n          gl.minY = Math.min(gl.minY, stackedNegs[z]);\n        }\n      } // if the numbers are too big, reduce the range\n      // for eg, if number is between 100000-110000, putting 0 as the lowest value is not so good idea. So change the gl.minY for line/area/candlesticks\n\n\n      if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'candlestick') {\n        if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE && lowestYInAllSeries !== gl.maxY // single value possibility\n        ) {\n            var diff = gl.maxY - lowestYInAllSeries;\n\n            if (lowestYInAllSeries >= 0 && lowestYInAllSeries <= 10) {\n              // if minY is already 0/low value, we don't want to go negatives here - so this check is essential.\n              diff = 0;\n            }\n\n            gl.minY = lowestYInAllSeries - diff * 5 / 100;\n            /* fix https://github.com/apexcharts/apexcharts.js/issues/426 */\n\n            gl.maxY = gl.maxY + diff * 5 / 100;\n          }\n      }\n\n      cnf.yaxis.map(function (yaxe, index) {\n        // override all min/max values by user defined values (y axis)\n        if (yaxe.max !== undefined) {\n          if (typeof yaxe.max === 'number') {\n            gl.maxYArr[index] = yaxe.max;\n          } else if (typeof yaxe.max === 'function') {\n            gl.maxYArr[index] = yaxe.max(gl.maxY);\n          } // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n          gl.maxY = gl.maxYArr[index];\n        }\n\n        if (yaxe.min !== undefined) {\n          if (typeof yaxe.min === 'number') {\n            gl.minYArr[index] = yaxe.min;\n          } else if (typeof yaxe.min === 'function') {\n            gl.minYArr[index] = yaxe.min(gl.minY);\n          } // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n          gl.minY = gl.minYArr[index];\n        }\n      }); // for horizontal bar charts, we need to check xaxis min/max as user may have specified there\n\n      if (gl.isBarHorizontal) {\n        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {\n          gl.minY = cnf.xaxis.min;\n        }\n\n        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {\n          gl.maxY = cnf.xaxis.max;\n        }\n      } // for multi y-axis we need different scales for each\n\n\n      if (gl.isMultipleYAxis) {\n        this.scales.setMultipleYScales();\n        gl.minY = lowestYInAllSeries;\n        gl.yAxisScale.forEach(function (scale, i) {\n          gl.minYArr[i] = scale.niceMin;\n          gl.maxYArr[i] = scale.niceMax;\n        });\n      } else {\n        this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);\n        gl.minY = gl.yAxisScale[0].niceMin;\n        gl.maxY = gl.yAxisScale[0].niceMax;\n        gl.minYArr[0] = gl.yAxisScale[0].niceMin;\n        gl.maxYArr[0] = gl.yAxisScale[0].niceMax;\n      }\n\n      return {\n        minY: gl.minY,\n        maxY: gl.maxY,\n        minYArr: gl.minYArr,\n        maxYArr: gl.maxYArr\n      };\n    }\n  }, {\n    key: \"setXRange\",\n    value: function setXRange() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided || gl.noLabelsProvided; // minX maxX starts here\n\n      if (gl.isXNumeric) {\n        for (var i = 0; i < gl.series.length; i++) {\n          if (gl.labels[i]) {\n            for (var j = 0; j < gl.labels[i].length; j++) {\n              if (gl.labels[i][j] !== null && Utils.isNumber(gl.labels[i][j])) {\n                gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);\n                gl.initialmaxX = Math.max(gl.maxX, gl.labels[i][j]);\n                gl.minX = Math.min(gl.minX, gl.labels[i][j]);\n                gl.initialminX = Math.min(gl.minX, gl.labels[i][j]);\n              }\n            }\n          }\n        }\n      }\n\n      if (gl.noLabelsProvided) {\n        if (cnf.xaxis.categories.length === 0) {\n          gl.maxX = gl.labels[gl.labels.length - 1];\n          gl.initialmaxX = gl.labels[gl.labels.length - 1];\n          gl.minX = 1;\n          gl.initialminX = 1;\n        }\n      } // for numeric xaxis, we need to adjust some padding left and right for bar charts\n\n\n      if (gl.comboChartsHasBars || cnf.chart.type === 'candlestick' || cnf.chart.type === 'bar' && cnf.xaxis.type !== 'category') {\n        if (cnf.xaxis.type !== 'category') {\n          var minX = gl.minX - gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;\n          gl.minX = minX;\n          gl.initialminX = minX;\n          var maxX = gl.maxX + gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;\n          gl.maxX = maxX;\n          gl.initialmaxX = maxX;\n        }\n      }\n\n      if ((gl.isXNumeric || gl.noLabelsProvided) && (!cnf.xaxis.convertedCatToNumeric || gl.dataFormatXNumeric)) {\n        var ticks;\n\n        if (cnf.xaxis.tickAmount === undefined) {\n          ticks = Math.round(gl.svgWidth / 150); // no labels provided and total number of dataPoints is less than 20\n\n          if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 20) {\n            ticks = gl.dataPoints - 1;\n          } // this check is for when ticks exceeds total datapoints and that would result in duplicate labels\n\n\n          if (ticks > gl.dataPoints && gl.dataPoints !== 0) {\n            ticks = gl.dataPoints - 1;\n          }\n        } else if (cnf.xaxis.tickAmount === 'dataPoints') {\n          ticks = gl.series[gl.maxValsInArrayIndex].length - 1;\n        } else {\n          ticks = cnf.xaxis.tickAmount;\n        } // override all min/max values by user defined values (x axis)\n\n\n        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {\n          gl.maxX = cnf.xaxis.max;\n        }\n\n        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {\n          gl.minX = cnf.xaxis.min;\n        } // if range is provided, adjust the new minX\n\n\n        if (cnf.xaxis.range !== undefined) {\n          gl.minX = gl.maxX - cnf.xaxis.range;\n        }\n\n        if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {\n          gl.xAxisScale = this.scales.linearScale(gl.minX, gl.maxX, ticks);\n        } else {\n          gl.xAxisScale = this.scales.linearScale(1, ticks, ticks);\n\n          if (gl.noLabelsProvided && gl.labels.length > 0) {\n            gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1); // this is the only place seriesX is again mutated\n\n            gl.seriesX = gl.labels.slice();\n          }\n        } // we will still store these labels as the count for this will be different (to draw grid and labels placement)\n\n\n        if (isXNumeric) {\n          gl.labels = gl.xAxisScale.result.slice();\n        }\n      }\n\n      if (gl.minX === gl.maxX) {\n        // single dataPoint\n        if (cnf.xaxis.type === 'datetime') {\n          var newMinX = new Date(gl.minX);\n          newMinX.setDate(newMinX.getDate() - 2);\n          gl.minX = new Date(newMinX).getTime();\n          var newMaxX = new Date(gl.maxX);\n          newMaxX.setDate(newMaxX.getDate() + 2);\n          gl.maxX = new Date(newMaxX).getTime();\n        } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {\n          gl.minX = gl.minX - 2;\n          gl.maxX = gl.maxX + 2;\n        }\n      }\n\n      if (gl.isXNumeric) {\n        // get the least x diff if numeric x axis is present\n        gl.seriesX.forEach(function (sX, i) {\n          sX.forEach(function (s, j) {\n            if (j > 0) {\n              var xDiff = s - gl.seriesX[i][j - 1];\n              gl.minXDiff = Math.min(xDiff, gl.minXDiff);\n            }\n          });\n        });\n        this.calcMinXDiffForTinySeries();\n      }\n\n      return {\n        minX: gl.minX,\n        maxX: gl.maxX\n      };\n    }\n  }, {\n    key: \"calcMinXDiffForTinySeries\",\n    value: function calcMinXDiffForTinySeries() {\n      var w = this.w;\n      var len = w.globals.labels.length;\n\n      if (w.globals.labels.length === 1) {\n        w.globals.minXDiff = (w.globals.maxX - w.globals.minX) / len / 3;\n      } else {\n        if (w.globals.minXDiff === Number.MAX_VALUE) {\n          // possibly a single dataPoint (fixes react-apexcharts/issue#34)\n          if (w.globals.timelineLabels.length > 0) {\n            len = w.globals.timelineLabels.length;\n          }\n\n          if (len < 3) {\n            len = 3;\n          }\n\n          w.globals.minXDiff = (w.globals.maxX - w.globals.minX) / len;\n        }\n      }\n\n      return w.globals.minXDiff;\n    }\n  }, {\n    key: \"setZRange\",\n    value: function setZRange() {\n      var gl = this.w.globals; // minZ, maxZ starts here\n\n      if (gl.isDataXYZ) {\n        for (var i = 0; i < gl.series.length; i++) {\n          if (typeof gl.seriesZ[i] !== 'undefined') {\n            for (var j = 0; j < gl.seriesZ[i].length; j++) {\n              if (gl.seriesZ[i][j] !== null && Utils.isNumber(gl.seriesZ[i][j])) {\n                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);\n                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return Range$$1;\n}();\n\n/**\n * ApexCharts Series Class for interation with the Series of the chart.\n *\n * @module Series\n **/\n\nvar Series =\n/*#__PURE__*/\nfunction () {\n  function Series(ctx) {\n    _classCallCheck(this, Series);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Series, [{\n    key: \"getAllSeriesEls\",\n    value: function getAllSeriesEls() {\n      return this.w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series\");\n    }\n  }, {\n    key: \"getSeriesByName\",\n    value: function getSeriesByName(seriesName) {\n      return this.w.globals.dom.baseEl.querySelector(\".apexcharts-series.\".concat(Utils.escapeString(seriesName)));\n    }\n  }, {\n    key: \"addCollapsedClassToSeries\",\n    value: function addCollapsedClassToSeries(elSeries, index) {\n      var w = this.w;\n\n      for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {\n        if (w.globals.collapsedSeries[cs].index === index) {\n          elSeries.node.classList.add('apexcharts-series-collapsed');\n        }\n      }\n    }\n  }, {\n    key: \"toggleSeriesOnHover\",\n    value: function toggleSeriesOnHover(e, targetElement) {\n      var w = this.w;\n      var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series\");\n\n      if (e.type === 'mousemove') {\n        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;\n        var seriesEl = null;\n\n        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n          if (w.globals.axisCharts) {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n          } else {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n          }\n        } else {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n        }\n\n        for (var se = 0; se < allSeriesEls.length; se++) {\n          allSeriesEls[se].classList.add('legend-mouseover-inactive');\n        }\n\n        if (seriesEl !== null) {\n          if (!w.globals.axisCharts) {\n            seriesEl.parentNode.classList.remove('legend-mouseover-inactive');\n          }\n\n          seriesEl.classList.remove('legend-mouseover-inactive');\n        }\n      } else if (e.type === 'mouseout') {\n        for (var _se = 0; _se < allSeriesEls.length; _se++) {\n          allSeriesEls[_se].classList.remove('legend-mouseover-inactive');\n        }\n      }\n    }\n  }, {\n    key: \"highlightRangeInSeries\",\n    value: function highlightRangeInSeries(e, targetElement) {\n      var w = this.w;\n      var allHeatMapElements = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect');\n\n      var allActive = function allActive() {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          allHeatMapElements[i].classList.remove('legend-mouseover-inactive');\n        }\n      };\n\n      var allInactive = function allInactive() {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          allHeatMapElements[i].classList.add('legend-mouseover-inactive');\n        }\n      };\n\n      var selectedActive = function selectedActive(range) {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          var val = parseInt(allHeatMapElements[i].getAttribute('val'));\n\n          if (val >= range.from && val <= range.to) {\n            allHeatMapElements[i].classList.remove('legend-mouseover-inactive');\n          }\n        }\n      };\n\n      if (e.type === 'mousemove') {\n        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;\n        allActive();\n        allInactive();\n        var range = w.config.plotOptions.heatmap.colorScale.ranges[seriesCnt];\n        selectedActive(range);\n      } else if (e.type === 'mouseout') {\n        allActive();\n      }\n    }\n  }, {\n    key: \"getActiveSeriesIndex\",\n    value: function getActiveSeriesIndex() {\n      var w = this.w;\n      var activeIndex = 0;\n\n      if (w.globals.series.length > 1) {\n        // active series flag is required to know if user has not deactivated via legend click\n        var firstActiveSeriesIndex = w.globals.series.map(function (series, index) {\n          if (series.length > 0 && w.config.series[index].type !== 'bar' && w.config.series[index].type !== 'column') {\n            return index;\n          } else {\n            return -1;\n          }\n        });\n\n        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n          if (firstActiveSeriesIndex[a] !== -1) {\n            activeIndex = firstActiveSeriesIndex[a];\n            break;\n          }\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"getActiveConfigSeriesIndex\",\n    value: function getActiveConfigSeriesIndex() {\n      var w = this.w;\n      var activeIndex = 0;\n\n      if (w.config.series.length > 1) {\n        // active series flag is required to know if user has not deactivated via legend click\n        var firstActiveSeriesIndex = w.config.series.map(function (series, index) {\n          if (series.data && series.data.length > 0) {\n            return index;\n          } else {\n            return -1;\n          }\n        });\n\n        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n          if (firstActiveSeriesIndex[a] !== -1) {\n            activeIndex = firstActiveSeriesIndex[a];\n            break;\n          }\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"getPreviousPaths\",\n    value: function getPreviousPaths() {\n      var w = this.w;\n      w.globals.previousPaths = [];\n\n      function pushPaths(seriesEls, i, type) {\n        var paths = seriesEls[i].childNodes;\n        var dArr = {\n          type: type,\n          paths: [],\n          realIndex: seriesEls[i].getAttribute('data:realIndex')\n        };\n\n        for (var j = 0; j < paths.length; j++) {\n          if (paths[j].hasAttribute('pathTo')) {\n            var d = paths[j].getAttribute('pathTo');\n            dArr.paths.push({\n              d: d\n            });\n          }\n        }\n\n        w.globals.previousPaths.push(dArr);\n      }\n\n      var linePaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-series');\n\n      if (linePaths.length > 0) {\n        for (var p = linePaths.length - 1; p >= 0; p--) {\n          pushPaths(linePaths, p, 'line');\n        }\n      }\n\n      var areapaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-series');\n\n      if (areapaths.length > 0) {\n        for (var i = areapaths.length - 1; i >= 0; i--) {\n          pushPaths(areapaths, i, 'area');\n        }\n      }\n\n      var barPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series .apexcharts-series');\n\n      if (barPaths.length > 0) {\n        for (var _p = 0; _p < barPaths.length; _p++) {\n          pushPaths(barPaths, _p, 'bar');\n        }\n      }\n\n      var candlestickPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-candlestick-series .apexcharts-series');\n\n      if (candlestickPaths.length > 0) {\n        for (var _p2 = 0; _p2 < candlestickPaths.length; _p2++) {\n          pushPaths(candlestickPaths, _p2, 'candlestick');\n        }\n      }\n\n      var radarPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-radar-series .apexcharts-series');\n\n      if (radarPaths.length > 0) {\n        for (var _p3 = 0; _p3 < radarPaths.length; _p3++) {\n          pushPaths(radarPaths, _p3, 'radar');\n        }\n      }\n\n      var bubblepaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bubble-series .apexcharts-series');\n\n      if (bubblepaths.length > 0) {\n        for (var s = 0; s < bubblepaths.length; s++) {\n          var seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-bubble-series .apexcharts-series[data\\\\:realIndex='\".concat(s, \"'] circle\"));\n          var dArr = [];\n\n          for (var _i = 0; _i < seriesEls.length; _i++) {\n            dArr.push({\n              x: seriesEls[_i].getAttribute('cx'),\n              y: seriesEls[_i].getAttribute('cy'),\n              r: seriesEls[_i].getAttribute('r')\n            });\n          }\n\n          w.globals.previousPaths.push(dArr);\n        }\n      }\n\n      var scatterpaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-scatter-series .apexcharts-series');\n\n      if (scatterpaths.length > 0) {\n        for (var _s = 0; _s < scatterpaths.length; _s++) {\n          var _seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-scatter-series .apexcharts-series[data\\\\:realIndex='\".concat(_s, \"'] circle\"));\n\n          var _dArr = [];\n\n          for (var _i2 = 0; _i2 < _seriesEls.length; _i2++) {\n            _dArr.push({\n              x: _seriesEls[_i2].getAttribute('cx'),\n              y: _seriesEls[_i2].getAttribute('cy'),\n              r: _seriesEls[_i2].getAttribute('r')\n            });\n          }\n\n          w.globals.previousPaths.push(_dArr);\n        }\n      }\n\n      var heatmapColors = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series');\n\n      if (heatmapColors.length > 0) {\n        for (var h = 0; h < heatmapColors.length; h++) {\n          var _seriesEls2 = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-heatmap .apexcharts-series[data\\\\:realIndex='\".concat(h, \"'] rect\"));\n\n          var _dArr2 = [];\n\n          for (var _i3 = 0; _i3 < _seriesEls2.length; _i3++) {\n            _dArr2.push({\n              color: _seriesEls2[_i3].getAttribute('color')\n            });\n          }\n\n          w.globals.previousPaths.push(_dArr2);\n        }\n      }\n\n      if (!w.globals.axisCharts) {\n        // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)\n        w.globals.previousPaths = w.globals.series;\n      }\n    }\n  }, {\n    key: \"handleNoData\",\n    value: function handleNoData() {\n      var w = this.w;\n      var me = this;\n      var noDataOpts = w.config.noData;\n      var graphics = new Graphics(me.ctx);\n      var x = w.globals.svgWidth / 2;\n      var y = w.globals.svgHeight / 2;\n      var textAnchor = 'middle';\n      w.globals.noData = true;\n      w.globals.animationEnded = true;\n\n      if (noDataOpts.align === 'left') {\n        x = 10;\n        textAnchor = 'start';\n      } else if (noDataOpts.align === 'right') {\n        x = w.globals.svgWidth - 10;\n        textAnchor = 'end';\n      }\n\n      if (noDataOpts.verticalAlign === 'top') {\n        y = 50;\n      } else if (noDataOpts.verticalAlign === 'bottom') {\n        y = w.globals.svgHeight - 50;\n      }\n\n      x = x + noDataOpts.offsetX;\n      y = y + parseInt(noDataOpts.style.fontSize) + 2;\n\n      if (noDataOpts.text !== undefined && noDataOpts.text !== '') {\n        var titleText = graphics.drawText({\n          x: x,\n          y: y,\n          text: noDataOpts.text,\n          textAnchor: textAnchor,\n          fontSize: noDataOpts.style.fontSize,\n          fontFamily: noDataOpts.style.fontFamily,\n          foreColor: noDataOpts.style.color,\n          opacity: 1,\n          class: 'apexcharts-text-nodata'\n        });\n        titleText.node.setAttribute('class', 'apexcharts-title-text');\n        w.globals.dom.Paper.add(titleText);\n      }\n    } // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]\n    // This is because we don't want to alter the series' length as it is used at many places\n\n  }, {\n    key: \"setNullSeriesToZeroValues\",\n    value: function setNullSeriesToZeroValues(series) {\n      var w = this.w;\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length === 0) {\n          for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {\n            series[sl].push(0);\n          }\n        }\n      }\n\n      return series;\n    }\n  }, {\n    key: \"hasAllSeriesEqualX\",\n    value: function hasAllSeriesEqualX() {\n      var equalLen = true;\n      var w = this.w;\n      var filteredSerX = this.filteredSeriesX();\n\n      for (var i = 0; i < filteredSerX.length - 1; i++) {\n        if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {\n          equalLen = false;\n          break;\n        }\n      }\n\n      w.globals.allSeriesHasEqualX = equalLen;\n      return equalLen;\n    }\n  }, {\n    key: \"filteredSeriesX\",\n    value: function filteredSeriesX() {\n      var w = this.w;\n      var filteredSeriesX = w.globals.seriesX.map(function (ser, index) {\n        if (ser.length > 0) {\n          return ser;\n        } else {\n          return [];\n        }\n      });\n      return filteredSeriesX;\n    }\n  }]);\n\n  return Series;\n}();\n\n/**\n * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.\n *\n * @module Dimensions\n **/\n\nvar Dimensions =\n/*#__PURE__*/\nfunction () {\n  function Dimensions(ctx) {\n    _classCallCheck(this, Dimensions);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.lgRect = {};\n    this.yAxisWidth = 0;\n    this.xAxisHeight = 0;\n    this.isSparkline = this.w.config.chart.sparkline.enabled;\n    this.xPadRight = 0;\n    this.xPadLeft = 0;\n  }\n  /**\n   * @memberof Dimensions\n   * @param {object} w - chart context\n   **/\n\n\n  _createClass(Dimensions, [{\n    key: \"plotCoords\",\n    value: function plotCoords() {\n      var w = this.w;\n      var gl = w.globals;\n      var lgRect = this.getLegendsRect();\n\n      if (gl.axisCharts) {\n        // for line / area / scatter / column\n        this.setGridCoordsForAxisCharts(lgRect);\n      } else {\n        // for pie / donuts / circle\n        this.setGridCoordsForNonAxisCharts(lgRect);\n      }\n\n      this.titleSubtitleOffset(); // after calculating everything, apply padding set by user\n\n      gl.gridHeight = gl.gridHeight - w.config.grid.padding.top - w.config.grid.padding.bottom;\n      gl.gridWidth = gl.gridWidth - w.config.grid.padding.left - w.config.grid.padding.right - this.xPadRight - this.xPadLeft;\n      gl.translateX = gl.translateX + w.config.grid.padding.left + this.xPadLeft;\n      gl.translateY = gl.translateY + w.config.grid.padding.top;\n    }\n  }, {\n    key: \"conditionalChecksForAxisCoords\",\n    value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords) {\n      var w = this.w;\n      this.xAxisHeight = (xaxisLabelCoords.height + xtitleCoords.height) * w.globals.LINE_HEIGHT_RATIO + 15;\n      this.xAxisWidth = xaxisLabelCoords.width;\n\n      if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {\n        this.xAxisHeight = w.config.xaxis.labels.maxHeight;\n      }\n\n      if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {\n        this.xAxisHeight = w.config.xaxis.labels.minHeight;\n      }\n\n      if (w.config.xaxis.floating) {\n        this.xAxisHeight = 0;\n      }\n\n      if (!w.globals.isBarHorizontal) {\n        this.yAxisWidth = this.getTotalYAxisWidth();\n      } else {\n        this.yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;\n      }\n\n      var minYAxisWidth = 0;\n      var maxYAxisWidth = 0;\n      w.config.yaxis.forEach(function (y) {\n        minYAxisWidth += y.labels.minWidth;\n        maxYAxisWidth += y.labels.maxWidth;\n      });\n\n      if (this.yAxisWidth < minYAxisWidth) {\n        this.yAxisWidth = minYAxisWidth;\n      }\n\n      if (this.yAxisWidth > maxYAxisWidth) {\n        this.yAxisWidth = maxYAxisWidth;\n      }\n    }\n  }, {\n    key: \"setGridCoordsForAxisCharts\",\n    value: function setGridCoordsForAxisCharts(lgRect) {\n      var w = this.w;\n      var gl = w.globals;\n      var yaxisLabelCoords = this.getyAxisLabelsCoords();\n      var xaxisLabelCoords = this.getxAxisLabelsCoords();\n      var yTitleCoords = this.getyAxisTitleCoords();\n      var xtitleCoords = this.getxAxisTitleCoords();\n      w.globals.yLabelsCoords = [];\n      w.globals.yTitleCoords = [];\n      w.config.yaxis.map(function (yaxe, index) {\n        // store the labels and titles coords in global vars\n        w.globals.yLabelsCoords.push({\n          width: yaxisLabelCoords[index].width,\n          index: index\n        });\n        w.globals.yTitleCoords.push({\n          width: yTitleCoords[index].width,\n          index: index\n        });\n      });\n      this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords);\n      gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;\n      gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;\n\n      if (w.globals.isBarHorizontal) {\n        gl.rotateXLabels = false;\n        gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize) / 1.5);\n      }\n\n      gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;\n      gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;\n      var yAxisWidth = this.yAxisWidth;\n      var xAxisHeight = this.xAxisHeight;\n      gl.xAxisLabelsHeight = this.xAxisHeight;\n      gl.xAxisHeight = this.xAxisHeight;\n      var translateY = 10;\n\n      if (!w.config.grid.show || w.config.chart.type === 'radar') {\n        yAxisWidth = 0;\n        xAxisHeight = 35;\n      }\n\n      if (this.isSparkline) {\n        lgRect = {\n          height: 0,\n          width: 0\n        };\n        xAxisHeight = 0;\n        yAxisWidth = 0;\n        translateY = 0;\n      }\n\n      this.additionalPaddingXLabels(xaxisLabelCoords);\n\n      switch (w.config.legend.position) {\n        case 'bottom':\n          gl.translateY = translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);\n          gl.gridWidth = gl.svgWidth - yAxisWidth;\n          break;\n\n        case 'top':\n          gl.translateY = lgRect.height + translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);\n          gl.gridWidth = gl.svgWidth - yAxisWidth;\n          break;\n\n        case 'left':\n          gl.translateY = translateY;\n          gl.translateX = lgRect.width + yAxisWidth;\n          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth;\n          break;\n\n        case 'right':\n          gl.translateY = translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth - 5;\n          break;\n\n        default:\n          throw new Error('Legend position not supported');\n      }\n\n      this.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords); // after drawing everything, set the Y axis positions\n\n      var objyAxis = new YAxis(this.ctx);\n      objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);\n    }\n  }, {\n    key: \"setGridCoordsForNonAxisCharts\",\n    value: function setGridCoordsForNonAxisCharts(lgRect) {\n      var w = this.w;\n      var gl = w.globals;\n      var xPad = 0;\n\n      if (w.config.legend.show && !w.config.legend.floating) {\n        xPad = 20;\n      }\n\n      var offY = 10;\n      var offX = 0;\n\n      if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {\n        offY = offY + w.config.plotOptions.pie.offsetY;\n        offX = offX + w.config.plotOptions.pie.offsetX;\n      } else if (w.config.chart.type === 'radialBar') {\n        offY = offY + w.config.plotOptions.radialBar.offsetY;\n        offX = offX + w.config.plotOptions.radialBar.offsetX;\n      }\n\n      if (!w.config.legend.show) {\n        gl.gridHeight = gl.svgHeight - 35;\n        gl.gridWidth = gl.gridHeight;\n        gl.translateY = offY - 10;\n        gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n        return;\n      }\n\n      switch (w.config.legend.position) {\n        case 'bottom':\n          gl.gridHeight = gl.svgHeight - lgRect.height - 35;\n          gl.gridWidth = gl.gridHeight;\n          gl.translateY = offY - 20;\n          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n          break;\n\n        case 'top':\n          gl.gridHeight = gl.svgHeight - lgRect.height - 35;\n          gl.gridWidth = gl.gridHeight;\n          gl.translateY = lgRect.height + offY;\n          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n          break;\n\n        case 'left':\n          gl.gridWidth = gl.svgWidth - lgRect.width - xPad;\n          gl.gridHeight = gl.gridWidth;\n          gl.translateY = offY;\n          gl.translateX = offX + lgRect.width + xPad;\n          break;\n\n        case 'right':\n          gl.gridWidth = gl.svgWidth - lgRect.width - xPad - 5;\n          gl.gridHeight = gl.gridWidth;\n          gl.translateY = offY;\n          gl.translateX = offX + 10;\n          break;\n\n        default:\n          throw new Error('Legend position not supported');\n      }\n    }\n  }, {\n    key: \"setGridXPosForDualYAxis\",\n    value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {\n      var w = this.w;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !w.config.yaxis[index].floating && w.config.yaxis[index].show) {\n          if (yaxe.opposite) {\n            w.globals.translateX = w.globals.translateX - (yaxisLabelCoords[index].width + yTitleCoords[index].width) - parseInt(w.config.yaxis[index].labels.style.fontSize) / 1.2 - 12;\n          }\n        }\n      });\n    } // Sometimes, the last labels gets cropped in category/numeric xaxis.\n    // Hence, we add some additional padding based on the label length to avoid the last label being cropped.\n    // NOTE: datetime x-axis won't have any effect with this as we don't know the label length there due to many constraints.\n\n  }, {\n    key: \"additionalPaddingXLabels\",\n    value: function additionalPaddingXLabels(xaxisLabelCoords) {\n      var _this = this;\n\n      var w = this.w;\n\n      if (w.config.xaxis.type === 'category' && w.globals.isBarHorizontal || w.config.xaxis.type === 'numeric') {\n        var rightPad = function rightPad(labels) {\n          if (w.config.grid.padding.right < labels.width) {\n            _this.xPadRight = labels.width / 2 + 1;\n          }\n        };\n\n        var leftPad = function leftPad(labels) {\n          if (w.config.grid.padding.left < labels.width) {\n            _this.xPadLeft = labels.width / 2 + 1;\n          }\n        };\n\n        var lineArea = w.config.chart.type === 'line' || w.config.chart.type === 'area';\n        w.config.yaxis.forEach(function (yaxe, i) {\n          var shouldPad = !yaxe.show || yaxe.floating || w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea || yaxe.opposite && w.globals.isBarHorizontal;\n\n          if (shouldPad) {\n            if (lineArea && w.globals.isMultipleYAxis && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || w.globals.isBarHorizontal && yaxe.opposite) {\n              leftPad(xaxisLabelCoords);\n            }\n\n            if (!w.globals.isBarHorizontal && yaxe.opposite && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea && !w.globals.isMultipleYAxis) {\n              rightPad(xaxisLabelCoords);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"titleSubtitleOffset\",\n    value: function titleSubtitleOffset() {\n      var w = this.w;\n      var gl = w.globals;\n      var gridShrinkOffset = this.isSparkline || !w.globals.axisCharts ? 0 : 10;\n\n      if (w.config.title.text !== undefined) {\n        gridShrinkOffset += w.config.title.margin;\n      } else {\n        gridShrinkOffset += this.isSparkline || !w.globals.axisCharts ? 0 : 5;\n      }\n\n      if (w.config.subtitle.text !== undefined) {\n        gridShrinkOffset += w.config.subtitle.margin;\n      } else {\n        gridShrinkOffset += this.isSparkline || !w.globals.axisCharts ? 0 : 5;\n      }\n\n      if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && w.config.series.length > 1) {\n        gridShrinkOffset += 10;\n      }\n\n      var titleCoords = this.getTitleSubtitleCoords('title');\n      var subtitleCoords = this.getTitleSubtitleCoords('subtitle');\n      gl.gridHeight = gl.gridHeight - titleCoords.height - subtitleCoords.height - gridShrinkOffset;\n      gl.translateY = gl.translateY + titleCoords.height + subtitleCoords.height + gridShrinkOffset;\n    }\n  }, {\n    key: \"getTotalYAxisWidth\",\n    value: function getTotalYAxisWidth() {\n      var w = this.w;\n      var yAxisWidth = 0;\n      var padding = 10;\n\n      var isHiddenYAxis = function isHiddenYAxis(index) {\n        return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;\n      };\n\n      w.globals.yLabelsCoords.map(function (yLabelCoord, index) {\n        var floating = w.config.yaxis[index].floating;\n\n        if (yLabelCoord.width > 0 && !floating) {\n          yAxisWidth = yAxisWidth + yLabelCoord.width + padding;\n\n          if (isHiddenYAxis(index)) {\n            yAxisWidth = yAxisWidth - yLabelCoord.width - padding;\n          }\n        } else {\n          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);\n        }\n      });\n      w.globals.yTitleCoords.map(function (yTitleCoord, index) {\n        var floating = w.config.yaxis[index].floating;\n        padding = parseInt(w.config.yaxis[index].title.style.fontSize);\n\n        if (yTitleCoord.width > 0 && !floating) {\n          yAxisWidth = yAxisWidth + yTitleCoord.width + padding;\n\n          if (isHiddenYAxis(index)) {\n            yAxisWidth = yAxisWidth - yTitleCoord.width - padding;\n          }\n        } else {\n          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);\n        }\n      });\n      return yAxisWidth;\n    }\n  }, {\n    key: \"getxAxisTimeScaleLabelsCoords\",\n    value: function getxAxisTimeScaleLabelsCoords() {\n      var w = this.w;\n      var rect;\n      var timescaleLabels = w.globals.timelineLabels.slice();\n\n      if (w.globals.isBarHorizontal && w.config.xaxis.type === 'datetime') {\n        timescaleLabels = w.globals.invertedTimelineLabels.slice();\n      }\n\n      var labels = timescaleLabels.map(function (label) {\n        return label.value;\n      }); //  get the longest string from the labels array and also apply label formatter to it\n\n      var val = labels.reduce(function (a, b) {\n        // if undefined, maybe user didn't pass the datetime(x) values\n        if (typeof a === 'undefined') {\n          console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');\n          return 0;\n        } else {\n          return a.length > b.length ? a : b;\n        }\n      }, 0);\n      var graphics = new Graphics(this.ctx);\n      rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n      var totalWidthRotated = rect.width * 1.05 * labels.length;\n\n      if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {\n        w.globals.overlappingXLabels = true;\n      }\n\n      return rect;\n    }\n    /**\n     * Get X Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getxAxisLabelsCoords\",\n    value: function getxAxisLabelsCoords() {\n      var _this2 = this;\n\n      var w = this.w;\n      var xaxisLabels = w.globals.labels.slice();\n      var rect;\n\n      if (w.globals.timelineLabels.length > 0) {\n        var coords = this.getxAxisTimeScaleLabelsCoords();\n        rect = {\n          width: coords.width,\n          height: coords.height\n        };\n      } else {\n        var lgWidthForSideLegends = w.config.legend.position === 'left' && w.config.legend.position === 'right' && !w.config.legend.floating ? this.lgRect.width : 0; //  get the longest string from the labels array and also apply label formatter to it\n\n        var labels = [];\n        var xlbFormatter = w.globals.xLabelFormatter;\n        xaxisLabels.forEach(function (xl) {\n          var xFormat = new Formatters(_this2.ctx);\n          var label = xFormat.xLabelFormat(xlbFormatter, xl);\n          labels.push(label);\n        });\n        var val = labels.reduce(function (a, b) {\n          return a.length > b.length ? a : b;\n        }, 0); // the labels gets changed for bar charts\n\n        if (w.globals.isBarHorizontal) {\n          val = w.globals.yAxisScale[0].result.reduce(function (a, b) {\n            return a.length > b.length ? a : b;\n          }, 0);\n        }\n\n        var xFormat = new Formatters(this.ctx);\n        val = xFormat.xLabelFormat(xlbFormatter, val);\n        var graphics = new Graphics(this.ctx);\n        var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n        rect = {\n          width: xLabelrect.width,\n          height: xLabelrect.height\n        };\n\n        if (rect.width * xaxisLabels.length > w.globals.svgWidth - lgWidthForSideLegends - this.yAxisWidth && w.config.xaxis.labels.rotate !== 0) {\n          if (!w.globals.isBarHorizontal) {\n            w.globals.rotateXLabels = true;\n            xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, \"rotate(\".concat(w.config.xaxis.labels.rotate, \" 0 0)\"), false);\n            rect.height = xLabelrect.height / 1.66;\n          }\n        } else {\n          w.globals.rotateXLabels = false;\n        }\n      }\n\n      if (!w.config.xaxis.labels.show) {\n        rect = {\n          width: 0,\n          height: 0\n        };\n      }\n\n      return {\n        width: rect.width,\n        height: rect.height\n      };\n    }\n    /**\n     * Get Y Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getyAxisLabelsCoords\",\n    value: function getyAxisLabelsCoords() {\n      var _this3 = this;\n\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n      var ret = [];\n      var labelPad = 10;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (yaxe.show && yaxe.labels.show && w.globals.yAxisScale[index].result.length) {\n          var lbFormatter = w.globals.yLabelFormatters[index]; // the second parameter -1 is the index of tick which user can use in the formatter\n\n          var val = lbFormatter(w.globals.yAxisScale[index].niceMax, -1); // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.\n\n          if (typeof val === 'undefined' || val.length === 0) {\n            val = w.globals.yAxisScale[index].niceMax;\n          }\n\n          if (w.globals.isBarHorizontal) {\n            labelPad = 0;\n            var barYaxisLabels = w.globals.labels.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n            val = barYaxisLabels.reduce(function (a, b) {\n              return a.length > b.length ? a : b;\n            }, 0);\n            val = lbFormatter(val, -1);\n          }\n\n          var graphics = new Graphics(_this3.ctx);\n          var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize);\n          ret.push({\n            width: rect.width + labelPad,\n            height: rect.height\n          });\n        } else {\n          ret.push({\n            width: width,\n            height: height\n          });\n        }\n      });\n      return ret;\n    }\n    /**\n     * Get X Axis Title Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getxAxisTitleCoords\",\n    value: function getxAxisTitleCoords() {\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var graphics = new Graphics(this.ctx);\n        var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);\n        width = rect.width;\n        height = rect.height;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n    /**\n     * Get Y Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getyAxisTitleCoords\",\n    value: function getyAxisTitleCoords() {\n      var _this4 = this;\n\n      var w = this.w;\n      var ret = [];\n      w.config.yaxis.map(function (yaxe, index) {\n        if (yaxe.show && yaxe.title.text !== undefined) {\n          var graphics = new Graphics(_this4.ctx);\n          var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, 'rotate(-90 0 0)', false);\n          ret.push({\n            width: rect.width,\n            height: rect.height\n          });\n        } else {\n          ret.push({\n            width: 0,\n            height: 0\n          });\n        }\n      });\n      return ret;\n    }\n    /**\n     * Get Chart Title/Subtitle Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getTitleSubtitleCoords\",\n    value: function getTitleSubtitleCoords(type) {\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n      var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;\n      var el = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-text\"));\n\n      if (el !== null && !floating) {\n        var coord = el.getBoundingClientRect();\n        width = coord.width;\n        height = w.globals.axisCharts ? coord.height + 5 : coord.height;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }, {\n    key: \"getLegendsRect\",\n    value: function getLegendsRect() {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var lgRect = Object.assign({}, Utils.getBoundingClientRect(elLegendWrap));\n\n      if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {\n        this.lgRect = {\n          x: lgRect.x,\n          y: lgRect.y,\n          height: lgRect.height,\n          width: lgRect.height === 0 ? 0 : lgRect.width\n        };\n      } else {\n        this.lgRect = {\n          x: 0,\n          y: 0,\n          height: 0,\n          width: 0\n        };\n      }\n\n      return this.lgRect;\n    }\n  }]);\n\n  return Dimensions;\n}();\n\n/**\n * ApexCharts TimeScale Class for generating time ticks for x-axis.\n *\n * @module TimeScale\n **/\n\nvar TimeScale =\n/*#__PURE__*/\nfunction () {\n  function TimeScale(ctx) {\n    _classCallCheck(this, TimeScale);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.timeScaleArray = [];\n  }\n\n  _createClass(TimeScale, [{\n    key: \"calculateTimeScaleTicks\",\n    value: function calculateTimeScaleTicks(minX, maxX) {\n      var _this = this;\n\n      var w = this.w; // null check when no series to show\n\n      if (w.globals.allSeriesCollapsed) {\n        w.globals.labels = [];\n        w.globals.timelineLabels = [];\n        return [];\n      }\n\n      var dt = new DateTime(this.ctx);\n      var daysDiff = (maxX - minX) / (1000 * 60 * 60 * 24);\n      this.determineInterval(daysDiff);\n      w.globals.disableZoomIn = false;\n      w.globals.disableZoomOut = false;\n\n      if (daysDiff < 0.005) {\n        w.globals.disableZoomIn = true;\n      } else if (daysDiff > 50000) {\n        w.globals.disableZoomOut = true;\n      }\n\n      var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX);\n      var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;\n      var hoursWidthOnXAxis = daysWidthOnXAxis / 24;\n      var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;\n      var numberOfHours = Math.floor(daysDiff * 24);\n      var numberOfMinutes = Math.floor(daysDiff * 24 * 60);\n      var numberOfDays = Math.floor(daysDiff);\n      var numberOfMonths = Math.floor(daysDiff / 30);\n      var numberOfYears = Math.floor(daysDiff / 365);\n      var firstVal = {\n        minMinute: timeIntervals.minMinute,\n        minHour: timeIntervals.minHour,\n        minDate: timeIntervals.minDate,\n        minMonth: timeIntervals.minMonth,\n        minYear: timeIntervals.minYear\n      };\n      var currentMinute = firstVal.minMinute;\n      var currentHour = firstVal.minHour;\n      var currentMonthDate = firstVal.minDate;\n      var currentDate = firstVal.minDate;\n      var currentMonth = firstVal.minMonth;\n      var currentYear = firstVal.minYear;\n      var params = {\n        firstVal: firstVal,\n        currentMinute: currentMinute,\n        currentHour: currentHour,\n        currentMonthDate: currentMonthDate,\n        currentDate: currentDate,\n        currentMonth: currentMonth,\n        currentYear: currentYear,\n        daysWidthOnXAxis: daysWidthOnXAxis,\n        hoursWidthOnXAxis: hoursWidthOnXAxis,\n        minutesWidthOnXAxis: minutesWidthOnXAxis,\n        numberOfMinutes: numberOfMinutes,\n        numberOfHours: numberOfHours,\n        numberOfDays: numberOfDays,\n        numberOfMonths: numberOfMonths,\n        numberOfYears: numberOfYears\n      };\n\n      switch (this.tickInterval) {\n        case 'years':\n          {\n            this.generateYearScale(params);\n            break;\n          }\n\n        case 'months':\n        case 'half_year':\n          {\n            this.generateMonthScale(params);\n            break;\n          }\n\n        case 'months_days':\n        case 'months_fortnight':\n        case 'days':\n        case 'week_days':\n          {\n            this.generateDayScale(params);\n            break;\n          }\n\n        case 'hours':\n          {\n            this.generateHourScale(params);\n            break;\n          }\n\n        case 'minutes':\n          this.generateMinuteScale(params);\n          break;\n      } // first, we will adjust the month values index\n      // as in the upper function, it is starting from 0\n      // we will start them from 1\n\n\n      var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {\n        var defaultReturn = {\n          position: ts.position,\n          unit: ts.unit,\n          year: ts.year,\n          day: ts.day ? ts.day : 1,\n          hour: ts.hour ? ts.hour : 0,\n          month: ts.month + 1\n        };\n\n        if (ts.unit === 'month') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value + 1\n          });\n        } else if (ts.unit === 'day' || ts.unit === 'hour') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value\n          });\n        } else if (ts.unit === 'minute') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value,\n            minute: ts.value\n          });\n        }\n\n        return ts;\n      });\n      var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {\n        var modulo = 1;\n        var ticks = Math.ceil(w.globals.gridWidth / 120);\n        var value = ts.value;\n\n        if (w.config.xaxis.tickAmount !== undefined) {\n          ticks = w.config.xaxis.tickAmount;\n        }\n\n        if (adjustedMonthInTimeScaleArray.length > ticks) {\n          modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);\n        }\n\n        var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months\n\n        var shouldNotPrint = false; // should skip these values\n\n        switch (_this.tickInterval) {\n          case 'half_year':\n            modulo = 7;\n\n            if (ts.unit === 'year') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'months':\n            modulo = 1;\n\n            if (ts.unit === 'year') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'months_fortnight':\n            modulo = 15;\n\n            if (ts.unit === 'year' || ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            if (value === 30) {\n              shouldNotPrint = true;\n            }\n\n            break;\n\n          case 'months_days':\n            modulo = 10;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            if (value === 30) {\n              shouldNotPrint = true;\n            }\n\n            break;\n\n          case 'week_days':\n            modulo = 8;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'days':\n            modulo = 1;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'hours':\n            if (ts.unit === 'day') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'minutes':\n            if (value % 5 !== 0) {\n              shouldNotPrint = true;\n            }\n\n            break;\n        }\n\n        if (_this.tickInterval === 'minutes' || _this.tickInterval === 'hours') {\n          if (!shouldNotPrint) {\n            return true;\n          }\n        } else {\n          if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {\n            return true;\n          }\n        }\n      });\n      return filteredTimeScale;\n    }\n  }, {\n    key: \"recalcDimensionsBasedOnFormat\",\n    value: function recalcDimensionsBasedOnFormat(filteredTimeScale, inverted) {\n      var w = this.w;\n      var reformattedTimescaleArray = this.formatDates(filteredTimeScale);\n      var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);\n\n      if (!inverted) {\n        w.globals.timelineLabels = removedOverlappingTS.slice();\n      } else {\n        w.globals.invertedTimelineLabels = removedOverlappingTS.slice();\n      } // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords\n      // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX\n      // Dependency on Dimensions(), need to refactor correctly\n      // TODO - find an alternate way to avoid calling this Heavy method twice\n\n\n      var dimensions = new Dimensions(this.ctx);\n      dimensions.plotCoords();\n    }\n  }, {\n    key: \"determineInterval\",\n    value: function determineInterval(daysDiff) {\n      switch (true) {\n        case daysDiff > 1825:\n          // difference is more than 5 years\n          this.tickInterval = 'years';\n          break;\n\n        case daysDiff > 800 && daysDiff <= 1825:\n          this.tickInterval = 'half_year';\n          break;\n\n        case daysDiff > 180 && daysDiff <= 800:\n          this.tickInterval = 'months';\n          break;\n\n        case daysDiff > 90 && daysDiff <= 180:\n          this.tickInterval = 'months_fortnight';\n          break;\n\n        case daysDiff > 60 && daysDiff <= 90:\n          this.tickInterval = 'months_days';\n          break;\n\n        case daysDiff > 30 && daysDiff <= 60:\n          this.tickInterval = 'week_days';\n          break;\n\n        case daysDiff > 2 && daysDiff <= 30:\n          this.tickInterval = 'days';\n          break;\n\n        case daysDiff > 0.1 && daysDiff <= 2:\n          // less than  2 days\n          this.tickInterval = 'hours';\n          break;\n\n        case daysDiff < 0.1:\n          this.tickInterval = 'minutes';\n          break;\n\n        default:\n          this.tickInterval = 'days';\n          break;\n      }\n    }\n  }, {\n    key: \"generateYearScale\",\n    value: function generateYearScale(params) {\n      var firstVal = params.firstVal,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          daysWidthOnXAxis = params.daysWidthOnXAxis,\n          numberOfYears = params.numberOfYears;\n      var firstTickValue = firstVal.minYear;\n      var firstTickPosition = 0;\n      var dt = new DateTime(this.ctx);\n      var unit = 'year';\n\n      if (firstVal.minDate > 1 && firstVal.minMonth > 0) {\n        var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate); // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n\n        var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1; // calculate the first tick position\n\n        firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;\n        firstTickValue = firstVal.minYear + 1; // push the first tick in the array\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: firstTickValue,\n          month: Utils.monthMod(currentMonth + 1)\n        });\n      } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {\n        // push the first tick in the array\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: currentYear,\n          month: Utils.monthMod(currentMonth + 1)\n        });\n      }\n\n      var year = firstTickValue;\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfYears; i++) {\n        year++;\n        pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;\n        this.timeScaleArray.push({\n          position: pos,\n          value: year,\n          unit: unit,\n          year: year,\n          month: 1\n        });\n      }\n    }\n  }, {\n    key: \"generateMonthScale\",\n    value: function generateMonthScale(params) {\n      var firstVal = params.firstVal,\n          currentMonthDate = params.currentMonthDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          daysWidthOnXAxis = params.daysWidthOnXAxis,\n          numberOfMonths = params.numberOfMonths;\n      var firstTickValue = currentMonth;\n      var firstTickPosition = 0;\n      var dt = new DateTime(this.ctx);\n      var unit = 'month';\n      var yrCounter = 0;\n\n      if (firstVal.minDate > 1) {\n        // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n        var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1; // calculate the first tick position\n\n        firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;\n        firstTickValue = Utils.monthMod(currentMonth + 1);\n        var year = currentYear + yrCounter;\n\n        var _month = Utils.monthMod(firstTickValue);\n\n        var value = firstTickValue; // it's Jan, so update the year\n\n        if (firstTickValue === 0) {\n          unit = 'year';\n          value = year;\n          _month = 1;\n          yrCounter += 1;\n          year = year + yrCounter;\n        } // push the first tick in the array\n\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: value,\n          unit: unit,\n          year: year,\n          month: _month\n        });\n      } else {\n        // push the first tick in the array\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: currentYear,\n          month: Utils.monthMod(currentMonth)\n        });\n      }\n\n      var month = firstTickValue + 1;\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {\n        month = Utils.monthMod(month);\n\n        if (month === 0) {\n          unit = 'year';\n          yrCounter += 1;\n        } else {\n          unit = 'month';\n        }\n\n        var _year = currentYear + Math.floor(month / 12) + yrCounter;\n\n        pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;\n        var monthVal = month === 0 ? _year : month;\n        this.timeScaleArray.push({\n          position: pos,\n          value: monthVal,\n          unit: unit,\n          year: _year,\n          month: month === 0 ? 1 : month\n        });\n        month++;\n      }\n    }\n  }, {\n    key: \"generateDayScale\",\n    value: function generateDayScale(params) {\n      var firstVal = params.firstVal,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          hoursWidthOnXAxis = params.hoursWidthOnXAxis,\n          numberOfDays = params.numberOfDays;\n      var dt = new DateTime(this.ctx);\n      var unit = 'day';\n      var remainingHours = 24 - firstVal.minHour;\n      var yrCounter = 0; // calculate the first tick position\n\n      var firstTickPosition = remainingHours * hoursWidthOnXAxis;\n      var firstTickValue = firstVal.minDate + 1;\n      var val = firstTickValue;\n\n      var changeMonth = function changeMonth(dateVal, month, year) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, year);\n\n        if (dateVal > monthdays) {\n          month = month + 1;\n          date = 1;\n          unit = 'month';\n          val = month;\n          return month;\n        }\n\n        return month;\n      };\n\n      var date = firstTickValue;\n      var month = changeMonth(date, currentMonth, currentYear); // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: val,\n        unit: unit,\n        year: currentYear,\n        month: Utils.monthMod(month),\n        day: date\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfDays; i++) {\n        date += 1;\n        unit = 'day';\n        month = changeMonth(date, month, currentYear + Math.floor(month / 12) + yrCounter);\n        var year = currentYear + Math.floor(month / 12) + yrCounter;\n        pos = 24 * hoursWidthOnXAxis + pos;\n\n        var _val = date === 1 ? Utils.monthMod(month) : date;\n\n        this.timeScaleArray.push({\n          position: pos,\n          value: _val,\n          unit: unit,\n          year: year,\n          month: Utils.monthMod(month),\n          day: _val\n        });\n      }\n    }\n  }, {\n    key: \"generateHourScale\",\n    value: function generateHourScale(params) {\n      var firstVal = params.firstVal,\n          currentDate = params.currentDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          minutesWidthOnXAxis = params.minutesWidthOnXAxis,\n          numberOfHours = params.numberOfHours;\n      var dt = new DateTime(this.ctx);\n      var yrCounter = 0;\n      var unit = 'hour';\n\n      var changeDate = function changeDate(dateVal, month) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n        if (dateVal > monthdays) {\n          date = 1;\n          month = month + 1;\n        }\n\n        return {\n          month: month,\n          date: date\n        };\n      };\n\n      var changeMonth = function changeMonth(dateVal, month) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n        if (dateVal > monthdays) {\n          month = month + 1;\n          return month;\n        }\n\n        return month;\n      };\n\n      var remainingMins = 60 - firstVal.minMinute;\n      var firstTickPosition = remainingMins * minutesWidthOnXAxis;\n      var firstTickValue = firstVal.minHour + 1;\n      var hour = firstTickValue + 1;\n\n      if (remainingMins === 60) {\n        firstTickPosition = 0;\n        firstTickValue = firstVal.minHour;\n        hour = firstTickValue + 1;\n      }\n\n      var date = currentDate;\n      var month = changeMonth(date, currentMonth); // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: firstTickValue,\n        unit: unit,\n        day: date,\n        hour: hour,\n        year: currentYear,\n        month: Utils.monthMod(month)\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfHours; i++) {\n        unit = 'hour';\n\n        if (hour >= 24) {\n          hour = 0;\n          date += 1;\n          unit = 'day';\n          var checkNextMonth = changeDate(date, month);\n          month = checkNextMonth.month;\n          month = changeMonth(date, month);\n        }\n\n        var year = currentYear + Math.floor(month / 12) + yrCounter;\n        pos = hour === 0 && i === 0 ? remainingMins * minutesWidthOnXAxis : 60 * minutesWidthOnXAxis + pos;\n        var val = hour === 0 ? date : hour;\n        this.timeScaleArray.push({\n          position: pos,\n          value: val,\n          unit: unit,\n          hour: hour,\n          day: date,\n          year: year,\n          month: Utils.monthMod(month)\n        });\n        hour++;\n      }\n    }\n  }, {\n    key: \"generateMinuteScale\",\n    value: function generateMinuteScale(params) {\n      var firstVal = params.firstVal,\n          currentMinute = params.currentMinute,\n          currentHour = params.currentHour,\n          currentDate = params.currentDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          minutesWidthOnXAxis = params.minutesWidthOnXAxis,\n          numberOfMinutes = params.numberOfMinutes;\n      var yrCounter = 0;\n      var unit = 'minute';\n      var remainingMins = currentMinute - firstVal.minMinute;\n      var firstTickPosition = minutesWidthOnXAxis - remainingMins;\n      var firstTickValue = firstVal.minMinute + 1;\n      var minute = firstTickValue + 1;\n      var date = currentDate;\n      var month = currentMonth;\n      var year = currentYear;\n      var hour = currentHour; // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: firstTickValue,\n        unit: unit,\n        day: date,\n        hour: hour,\n        minute: minute,\n        year: year,\n        month: Utils.monthMod(month)\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfMinutes; i++) {\n        if (minute >= 60) {\n          minute = 0;\n          hour += 1;\n\n          if (hour === 24) {\n            hour = 0;\n          }\n        }\n\n        var _year2 = currentYear + Math.floor(month / 12) + yrCounter;\n\n        pos = minutesWidthOnXAxis + pos;\n        var val = minute;\n        this.timeScaleArray.push({\n          position: pos,\n          value: val,\n          unit: unit,\n          hour: hour,\n          minute: minute,\n          day: date,\n          year: _year2,\n          month: Utils.monthMod(month)\n        });\n        minute++;\n      }\n    }\n  }, {\n    key: \"createRawDateString\",\n    value: function createRawDateString(ts, value) {\n      var raw = ts.year;\n      raw += '-' + ('0' + ts.month.toString()).slice(-2); // unit is day\n\n      if (ts.unit === 'day') {\n        raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';\n      } else {\n        raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);\n      } // unit is hour\n\n\n      if (ts.unit === 'hour') {\n        raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';\n      } else {\n        raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);\n      } // unit is minute\n\n\n      raw += ts.unit === 'minute' ? ':' + ('0' + value).slice(-2) + ':00.000Z' : ':00:00.000Z';\n      return raw;\n    }\n  }, {\n    key: \"formatDates\",\n    value: function formatDates(filteredTimeScale) {\n      var _this2 = this;\n\n      var w = this.w;\n      var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {\n        var value = ts.value.toString();\n        var dt = new DateTime(_this2.ctx);\n\n        var raw = _this2.createRawDateString(ts, value); // parse the whole ISO datestring\n\n\n        var dateString = new Date(Date.parse(raw));\n\n        if (w.config.xaxis.labels.format === undefined) {\n          var customFormat = 'dd MMM';\n          var dtFormatter = w.config.xaxis.labels.datetimeFormatter;\n          if (ts.unit === 'year') customFormat = dtFormatter.year;\n          if (ts.unit === 'month') customFormat = dtFormatter.month;\n          if (ts.unit === 'day') customFormat = dtFormatter.day;\n          if (ts.unit === 'hour') customFormat = dtFormatter.hour;\n          if (ts.unit === 'minute') customFormat = dtFormatter.minute;\n          value = dt.formatDate(dateString, customFormat, true, false);\n        } else {\n          value = dt.formatDate(dateString, w.config.xaxis.labels.format);\n        }\n\n        return {\n          dateString: raw,\n          position: ts.position,\n          value: value,\n          unit: ts.unit,\n          year: ts.year,\n          month: ts.month\n        };\n      });\n      return reformattedTimescaleArray;\n    }\n  }, {\n    key: \"removeOverlappingTS\",\n    value: function removeOverlappingTS(arr) {\n      var _this3 = this;\n\n      var graphics = new Graphics(this.ctx);\n      var lastDrawnIndex = 0;\n      var filteredArray = arr.map(function (item, index) {\n        if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {\n          var prevLabelWidth = graphics.getTextRects(arr[lastDrawnIndex].value).width;\n          var prevPos = arr[lastDrawnIndex].position;\n          var pos = item.position;\n\n          if (pos > prevPos + prevLabelWidth + 10) {\n            lastDrawnIndex = index;\n            return item;\n          } else {\n            return null;\n          }\n        } else {\n          return item;\n        }\n      });\n      filteredArray = filteredArray.filter(function (f) {\n        return f !== null;\n      });\n      return filteredArray;\n    }\n  }]);\n\n  return TimeScale;\n}();\n\n/**\n * ApexCharts Core Class responsible for major calculations and creating elements.\n *\n * @module Core\n **/\n\nvar Core =\n/*#__PURE__*/\nfunction () {\n  function Core(el, ctx) {\n    _classCallCheck(this, Core);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.el = el;\n    this.coreUtils = new CoreUtils(this.ctx);\n    this.twoDSeries = [];\n    this.threeDSeries = [];\n    this.twoDSeriesX = [];\n  } // get data and store into appropriate vars\n\n\n  _createClass(Core, [{\n    key: \"setupElements\",\n    value: function setupElements() {\n      var gl = this.w.globals;\n      var cnf = this.w.config; // const graphics = new Graphics(this.ctx)\n\n      var ct = cnf.chart.type;\n      var axisChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', // 'rangeArea',\n      'candlestick', 'radar', 'scatter', 'bubble', 'heatmap'];\n      var xyChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', // 'rangeArea',\n      'candlestick', 'scatter', 'bubble'];\n      gl.axisCharts = axisChartsArrTypes.indexOf(ct) > -1;\n      gl.xyCharts = xyChartsArrTypes.indexOf(ct) > -1;\n      gl.isBarHorizontal = (cnf.chart.type === 'bar' || cnf.chart.type === 'rangeBar') && cnf.plotOptions.bar.horizontal;\n      gl.chartClass = '.apexcharts' + gl.cuid;\n      gl.dom.baseEl = this.el;\n      gl.dom.elWrap = document.createElement('div');\n      Graphics.setAttrs(gl.dom.elWrap, {\n        id: gl.chartClass.substring(1),\n        class: 'apexcharts-canvas ' + gl.chartClass.substring(1)\n      });\n      this.el.appendChild(gl.dom.elWrap);\n      gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap);\n      gl.dom.Paper.attr({\n        class: 'apexcharts-svg',\n        'xmlns:data': 'ApexChartsNS',\n        transform: \"translate(\".concat(cnf.chart.offsetX, \", \").concat(cnf.chart.offsetY, \")\")\n      });\n      gl.dom.Paper.node.style.background = cnf.chart.background;\n      this.setSVGDimensions();\n      gl.dom.elGraphical = gl.dom.Paper.group().attr({\n        class: 'apexcharts-inner apexcharts-graphical'\n      });\n      gl.dom.elDefs = gl.dom.Paper.defs();\n      gl.dom.elLegendWrap = document.createElement('div');\n      gl.dom.elLegendWrap.classList.add('apexcharts-legend');\n      gl.dom.elWrap.appendChild(gl.dom.elLegendWrap); // gl.dom.Paper.add(gl.dom.elLegendWrap)\n\n      gl.dom.Paper.add(gl.dom.elGraphical);\n      gl.dom.elGraphical.add(gl.dom.elDefs);\n    }\n  }, {\n    key: \"plotChartType\",\n    value: function plotChartType(ser, xyRatios) {\n      var w = this.w;\n      var cnf = w.config;\n      var gl = w.globals;\n      var lineSeries = {\n        series: [],\n        i: []\n      };\n      var areaSeries = {\n        series: [],\n        i: []\n      };\n      var scatterSeries = {\n        series: [],\n        i: []\n      };\n      var columnSeries = {\n        series: [],\n        i: []\n      };\n      var candlestickSeries = {\n        series: [],\n        i: []\n      };\n      gl.series.map(function (series, st) {\n        // if user has specified a particular type for particular series\n        if (typeof ser[st].type !== 'undefined') {\n          if (ser[st].type === 'column' || ser[st].type === 'bar') {\n            w.config.plotOptions.bar.horizontal = false; // horizontal bars not supported in mixed charts, hence forcefully set to false\n\n            columnSeries.series.push(series);\n            columnSeries.i.push(st);\n          } else if (ser[st].type === 'area') {\n            areaSeries.series.push(series);\n            areaSeries.i.push(st);\n          } else if (ser[st].type === 'line') {\n            lineSeries.series.push(series);\n            lineSeries.i.push(st);\n          } else if (ser[st].type === 'scatter') {\n            scatterSeries.series.push(series);\n            scatterSeries.i.push(st);\n          } else if (ser[st].type === 'bubble') ; else if (ser[st].type === 'candlestick') {\n            candlestickSeries.series.push(series);\n            candlestickSeries.i.push(st);\n          } else {\n            // user has specified type, but it is not valid (other than line/area/column)\n            console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble');\n          }\n\n          gl.comboCharts = true;\n        } else {\n          lineSeries.series.push(series);\n          lineSeries.i.push(st);\n        }\n      });\n      var line = new Line(this.ctx, xyRatios);\n      var candlestick = new CandleStick(this.ctx, xyRatios);\n      var pie = new Pie(this.ctx);\n      var radialBar = new Radial(this.ctx);\n      var rangeBar = new RangeBar(this.ctx, xyRatios);\n      var radar = new Radar(this.ctx);\n      var elGraph = [];\n\n      if (gl.comboCharts) {\n        if (areaSeries.series.length > 0) {\n          elGraph.push(line.draw(areaSeries.series, 'area', areaSeries.i));\n        }\n\n        if (columnSeries.series.length > 0) {\n          if (w.config.chart.stacked) {\n            var barStacked = new BarStacked(this.ctx, xyRatios);\n            elGraph.push(barStacked.draw(columnSeries.series, columnSeries.i));\n          } else {\n            var bar = new Bar(this.ctx, xyRatios);\n            elGraph.push(bar.draw(columnSeries.series, columnSeries.i));\n          }\n        }\n\n        if (lineSeries.series.length > 0) {\n          elGraph.push(line.draw(lineSeries.series, 'line', lineSeries.i));\n        }\n\n        if (candlestickSeries.series.length > 0) {\n          elGraph.push(candlestick.draw(candlestickSeries.series, candlestickSeries.i));\n        }\n\n        if (scatterSeries.series.length > 0) {\n          var scatterLine = new Line(this.ctx, xyRatios, true);\n          elGraph.push(scatterLine.draw(scatterSeries.series, 'scatter', scatterSeries.i));\n        } // TODO: allow bubble series in a combo chart\n        // if (bubbleSeries.series.length > 0) {\n        //   const bubbleLine = new Line(this.ctx, xyRatios, true)\n        //   elGraph.push(\n        //     bubbleLine.draw(bubbleSeries.series, 'bubble', bubbleSeries.i)\n        //   )\n        // }\n\n      } else {\n        switch (cnf.chart.type) {\n          case 'line':\n            elGraph = line.draw(gl.series, 'line');\n            break;\n\n          case 'area':\n            elGraph = line.draw(gl.series, 'area');\n            break;\n\n          case 'bar':\n            if (cnf.chart.stacked) {\n              var _barStacked = new BarStacked(this.ctx, xyRatios);\n\n              elGraph = _barStacked.draw(gl.series);\n            } else {\n              var _bar = new Bar(this.ctx, xyRatios);\n\n              elGraph = _bar.draw(gl.series);\n            }\n\n            break;\n\n          case 'candlestick':\n            var candleStick = new CandleStick(this.ctx, xyRatios);\n            elGraph = candleStick.draw(gl.series);\n            break;\n\n          case 'rangeBar':\n            elGraph = rangeBar.draw(gl.series);\n            break;\n\n          case 'heatmap':\n            var heatmap = new HeatMap(this.ctx, xyRatios);\n            elGraph = heatmap.draw(gl.series);\n            break;\n\n          case 'pie':\n          case 'donut':\n            elGraph = pie.draw(gl.series);\n            break;\n\n          case 'radialBar':\n            elGraph = radialBar.draw(gl.series);\n            break;\n\n          case 'radar':\n            elGraph = radar.draw(gl.series);\n            break;\n\n          default:\n            elGraph = line.draw(gl.series);\n        }\n      }\n\n      return elGraph;\n    }\n  }, {\n    key: \"setSVGDimensions\",\n    value: function setSVGDimensions() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.svgWidth = cnf.chart.width;\n      gl.svgHeight = cnf.chart.height;\n      var elDim = Utils.getDimensions(this.el);\n      var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();\n\n      if (widthUnit === '%') {\n        if (Utils.isNumber(elDim[0])) {\n          if (elDim[0].width === 0) {\n            elDim = Utils.getDimensions(this.el.parentNode);\n          }\n\n          gl.svgWidth = elDim[0] * parseInt(cnf.chart.width) / 100;\n        }\n      } else if (widthUnit === 'px' || widthUnit === '') {\n        gl.svgWidth = parseInt(cnf.chart.width);\n      }\n\n      if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {\n        var heightUnit = cnf.chart.height.toString().split(/[0-9]+/g).pop();\n\n        if (heightUnit === '%') {\n          var elParentDim = Utils.getDimensions(this.el.parentNode);\n          gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height) / 100;\n        } else {\n          gl.svgHeight = parseInt(cnf.chart.height);\n        }\n      } else {\n        if (gl.axisCharts) {\n          gl.svgHeight = gl.svgWidth / 1.61;\n        } else {\n          gl.svgHeight = gl.svgWidth;\n        }\n      }\n\n      Graphics.setAttrs(gl.dom.Paper.node, {\n        width: gl.svgWidth,\n        height: gl.svgHeight\n      }); // gl.dom.Paper.node.parentNode.parentNode.style.minWidth = gl.svgWidth + \"px\";\n\n      var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? cnf.chart.parentHeightOffset : 0;\n      gl.dom.Paper.node.parentNode.parentNode.style.minHeight = gl.svgHeight + offsetY + 'px';\n      gl.dom.elWrap.style.width = gl.svgWidth + 'px';\n      gl.dom.elWrap.style.height = gl.svgHeight + 'px';\n    }\n  }, {\n    key: \"shiftGraphPosition\",\n    value: function shiftGraphPosition() {\n      var gl = this.w.globals;\n      var tY = gl.translateY;\n      var tX = gl.translateX;\n      var scalingAttrs = {\n        transform: 'translate(' + tX + ', ' + tY + ')'\n      };\n      Graphics.setAttrs(gl.dom.elGraphical.node, scalingAttrs);\n    }\n    /*\n     ** All the calculations for setting range in charts will be done here\n     */\n\n  }, {\n    key: \"coreCalculations\",\n    value: function coreCalculations() {\n      var range = new Range$1(this.ctx);\n      range.init();\n    }\n  }, {\n    key: \"resetGlobals\",\n    value: function resetGlobals() {\n      var _this = this;\n\n      var gl = this.w.globals;\n      gl.series = [];\n      gl.seriesCandleO = [];\n      gl.seriesCandleH = [];\n      gl.seriesCandleL = [];\n      gl.seriesCandleC = [];\n      gl.seriesRangeStart = [];\n      gl.seriesRangeEnd = [];\n      gl.seriesPercent = [];\n      gl.seriesX = [];\n      gl.seriesZ = [];\n      gl.seriesNames = [];\n      gl.seriesTotals = [];\n      gl.stackedSeriesTotals = [];\n      gl.labels = [];\n      gl.timelineLabels = [];\n      gl.noLabelsProvided = false;\n      gl.timescaleTicks = [];\n      gl.resizeTimer = null;\n      gl.selectionResizeTimer = null;\n\n      gl.seriesXvalues = function () {\n        return _this.w.config.series.map(function (s) {\n          return [];\n        });\n      }();\n\n      gl.seriesYvalues = function () {\n        return _this.w.config.series.map(function (s) {\n          return [];\n        });\n      }();\n\n      gl.delayedElements = [];\n      gl.pointsArray = [];\n      gl.dataLabelsRects = [];\n      gl.isXNumeric = false;\n      gl.isDataXYZ = false;\n      gl.maxY = -Number.MAX_VALUE;\n      gl.minY = Number.MIN_VALUE;\n      gl.minYArr = [];\n      gl.maxYArr = [];\n      gl.maxX = -Number.MAX_VALUE;\n      gl.minX = Number.MAX_VALUE;\n      gl.initialmaxX = -Number.MAX_VALUE;\n      gl.initialminX = Number.MAX_VALUE;\n      gl.maxDate = 0;\n      gl.minDate = Number.MAX_VALUE;\n      gl.minZ = Number.MAX_VALUE;\n      gl.maxZ = -Number.MAX_VALUE;\n      gl.minXDiff = Number.MAX_VALUE;\n      gl.yAxisScale = [];\n      gl.xAxisScale = null;\n      gl.xAxisTicksPositions = [];\n      gl.yLabelsCoords = [];\n      gl.yTitleCoords = [];\n      gl.xRange = 0;\n      gl.yRange = [];\n      gl.zRange = 0;\n      gl.dataPoints = 0;\n    }\n  }, {\n    key: \"isMultipleY\",\n    value: function isMultipleY() {\n      // user has supplied an array in yaxis property. So, turn on multipleYAxis flag\n      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) {\n        // first, turn off stacking if multiple y axis\n        this.w.config.chart.stacked = false;\n        this.w.globals.isMultipleYAxis = true;\n        return true;\n      }\n    }\n  }, {\n    key: \"excludeCollapsedSeriesInYAxis\",\n    value: function excludeCollapsedSeriesInYAxis() {\n      var _this2 = this;\n\n      var w = this.w;\n      w.globals.ignoreYAxisIndexes = w.globals.collapsedSeries.map(function (collapsed, i) {\n        if (_this2.w.globals.isMultipleYAxis) {\n          return collapsed.index;\n        }\n      });\n    }\n  }, {\n    key: \"isMultiFormat\",\n    value: function isMultiFormat() {\n      return this.isFormatXY() || this.isFormat2DArray();\n    } // given format is [{x, y}, {x, y}]\n\n  }, {\n    key: \"isFormatXY\",\n    value: function isFormatXY() {\n      var series = this.w.config.series.slice();\n      var sr = new Series(this.ctx);\n      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {\n        return true;\n      }\n    } // given format is [[x, y], [x, y]]\n\n  }, {\n    key: \"isFormat2DArray\",\n    value: function isFormat2DArray() {\n      var series = this.w.config.series.slice();\n      var sr = new Series(this.ctx);\n      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {\n        return true;\n      }\n    }\n  }, {\n    key: \"handleFormat2DArray\",\n    value: function handleFormat2DArray(ser, i) {\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n\n      for (var j = 0; j < ser[i].data.length; j++) {\n        if (typeof ser[i].data[j][1] !== 'undefined') {\n          if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4) {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1][3]));\n          } else {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1]));\n          }\n\n          gl.dataFormatXNumeric = true;\n        }\n\n        if (cnf.xaxis.type === 'datetime') {\n          // if timestamps are provided and xaxis type is datettime,\n          var ts = new Date(ser[i].data[j][0]);\n          ts = new Date(ts).getTime();\n          this.twoDSeriesX.push(ts);\n        } else {\n          this.twoDSeriesX.push(ser[i].data[j][0]);\n        }\n      }\n\n      for (var _j = 0; _j < ser[i].data.length; _j++) {\n        if (typeof ser[i].data[_j][2] !== 'undefined') {\n          this.threeDSeries.push(ser[i].data[_j][2]);\n          gl.isDataXYZ = true;\n        }\n      }\n    }\n  }, {\n    key: \"handleFormatXY\",\n    value: function handleFormatXY(ser, i) {\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n      var dt = new DateTime(this.ctx);\n      var activeI = i;\n\n      if (gl.collapsedSeriesIndices.indexOf(i) > -1) {\n        // fix #368\n        activeI = this.activeSeriesIndex;\n      } // get series\n\n\n      for (var j = 0; j < ser[i].data.length; j++) {\n        if (typeof ser[i].data[j].y !== 'undefined') {\n          if (Array.isArray(ser[i].data[j].y)) {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y[ser[i].data[j].y.length - 1]));\n          } else {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y));\n          }\n        }\n      } // get seriesX\n\n\n      for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {\n        var isXString = typeof ser[activeI].data[_j2].x === 'string';\n        var isXDate = !!dt.isValidDate(ser[activeI].data[_j2].x.toString());\n\n        if (isXString || isXDate) {\n          // user supplied '01/01/2017' or a date string (a JS date object is not supported)\n          if (isXString) {\n            if (cnf.xaxis.type === 'datetime' && !gl.isRangeData) {\n              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));\n            } else {\n              // a category and not a numeric x value\n              this.fallbackToCategory = true;\n              this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n            }\n          } else {\n            if (cnf.xaxis.type === 'datetime') {\n              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));\n            } else {\n              gl.dataFormatXNumeric = true;\n              this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));\n            }\n          }\n        } else {\n          // a numeric value in x property\n          this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n        }\n      }\n\n      if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {\n        for (var t = 0; t < ser[i].data.length; t++) {\n          this.threeDSeries.push(ser[i].data[t].z);\n        }\n\n        gl.isDataXYZ = true;\n      }\n    }\n  }, {\n    key: \"handleRangeData\",\n    value: function handleRangeData(ser, i) {\n      var gl = this.w.globals;\n      var range = {};\n\n      if (this.isFormat2DArray()) {\n        range = this.handleRangeDataFormat('array', ser, i);\n      } else if (this.isFormatXY()) {\n        range = this.handleRangeDataFormat('xy', ser, i);\n      }\n\n      gl.seriesRangeStart.push(range.start);\n      gl.seriesRangeEnd.push(range.end);\n      return range;\n    }\n  }, {\n    key: \"handleCandleStickData\",\n    value: function handleCandleStickData(ser, i) {\n      var gl = this.w.globals;\n      var ohlc = {};\n\n      if (this.isFormat2DArray()) {\n        ohlc = this.handleCandleStickDataFormat('array', ser, i);\n      } else if (this.isFormatXY()) {\n        ohlc = this.handleCandleStickDataFormat('xy', ser, i);\n      }\n\n      gl.seriesCandleO.push(ohlc.o);\n      gl.seriesCandleH.push(ohlc.h);\n      gl.seriesCandleL.push(ohlc.l);\n      gl.seriesCandleC.push(ohlc.c);\n      return ohlc;\n    }\n  }, {\n    key: \"handleRangeDataFormat\",\n    value: function handleRangeDataFormat(format, ser, i) {\n      var rangeStart = [];\n      var rangeEnd = [];\n      var err = 'Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts';\n      var serObj = new Series(this.ctx);\n      var activeIndex = serObj.getActiveConfigSeriesIndex();\n\n      if (format === 'array') {\n        if (ser[activeIndex].data[0][1].length !== 2) {\n          throw new Error(err);\n        }\n\n        for (var j = 0; j < ser[i].data.length; j++) {\n          rangeStart.push(ser[i].data[j][1][0]);\n          rangeEnd.push(ser[i].data[j][1][1]);\n        }\n      } else if (format === 'xy') {\n        if (ser[activeIndex].data[0].y.length !== 2) {\n          throw new Error(err);\n        }\n\n        for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {\n          rangeStart.push(ser[i].data[_j3].y[0]);\n          rangeEnd.push(ser[i].data[_j3].y[1]);\n        }\n      }\n\n      return {\n        start: rangeStart,\n        end: rangeEnd\n      };\n    }\n  }, {\n    key: \"handleCandleStickDataFormat\",\n    value: function handleCandleStickDataFormat(format, ser, i) {\n      var serO = [];\n      var serH = [];\n      var serL = [];\n      var serC = [];\n      var err = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick';\n\n      if (format === 'array') {\n        if (ser[i].data[0][1].length !== 4) {\n          throw new Error(err);\n        }\n\n        for (var j = 0; j < ser[i].data.length; j++) {\n          serO.push(ser[i].data[j][1][0]);\n          serH.push(ser[i].data[j][1][1]);\n          serL.push(ser[i].data[j][1][2]);\n          serC.push(ser[i].data[j][1][3]);\n        }\n      } else if (format === 'xy') {\n        if (ser[i].data[0].y.length !== 4) {\n          throw new Error(err);\n        }\n\n        for (var _j4 = 0; _j4 < ser[i].data.length; _j4++) {\n          serO.push(ser[i].data[_j4].y[0]);\n          serH.push(ser[i].data[_j4].y[1]);\n          serL.push(ser[i].data[_j4].y[2]);\n          serC.push(ser[i].data[_j4].y[3]);\n        }\n      }\n\n      return {\n        o: serO,\n        h: serH,\n        l: serL,\n        c: serC\n      };\n    }\n  }, {\n    key: \"parseDataAxisCharts\",\n    value: function parseDataAxisCharts(ser) {\n      var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n      var dt = new DateTime(ctx);\n\n      for (var i = 0; i < ser.length; i++) {\n        this.twoDSeries = [];\n        this.twoDSeriesX = [];\n        this.threeDSeries = [];\n\n        if (typeof ser[i].data === 'undefined') {\n          console.error(\"It is a possibility that you may have not included 'data' property in series.\");\n          return;\n        }\n\n        if (cnf.chart.type === 'rangeBar' || cnf.chart.type === 'rangeArea' || ser[i].type === 'rangeBar' || ser[i].type === 'rangeArea') {\n          gl.isRangeData = true;\n          this.handleRangeData(ser, i);\n        }\n\n        if (this.isMultiFormat()) {\n          if (this.isFormat2DArray()) {\n            this.handleFormat2DArray(ser, i);\n          } else if (this.isFormatXY()) {\n            this.handleFormatXY(ser, i);\n          }\n\n          if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick') {\n            this.handleCandleStickData(ser, i);\n          }\n\n          gl.series.push(this.twoDSeries);\n          gl.labels.push(this.twoDSeriesX);\n          gl.seriesX.push(this.twoDSeriesX);\n\n          if (!this.fallbackToCategory) {\n            gl.isXNumeric = true;\n          }\n        } else {\n          if (cnf.xaxis.type === 'datetime') {\n            // user didn't supplied [{x,y}] or [[x,y]], but single array in data.\n            // Also labels/categories were supplied differently\n            gl.isXNumeric = true;\n            var dates = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();\n\n            for (var j = 0; j < dates.length; j++) {\n              if (typeof dates[j] === 'string') {\n                var isDate = dt.isValidDate(dates[j]);\n\n                if (isDate) {\n                  this.twoDSeriesX.push(dt.parseDate(dates[j]));\n                } else {\n                  throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');\n                }\n              }\n            }\n\n            gl.seriesX.push(this.twoDSeriesX);\n          } else if (cnf.xaxis.type === 'numeric') {\n            gl.isXNumeric = true;\n            var x = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();\n\n            if (x.length > 0) {\n              this.twoDSeriesX = x;\n              gl.seriesX.push(this.twoDSeriesX);\n            }\n          }\n\n          gl.labels.push(this.twoDSeriesX);\n          var singleArray = ser[i].data.map(function (d) {\n            return Utils.parseNumber(d);\n          });\n          gl.series.push(singleArray);\n        }\n\n        gl.seriesZ.push(this.threeDSeries);\n\n        if (ser[i].name !== undefined) {\n          gl.seriesNames.push(ser[i].name);\n        } else {\n          gl.seriesNames.push('series-' + parseInt(i + 1));\n        }\n      }\n\n      return this.w;\n    }\n  }, {\n    key: \"parseDataNonAxisCharts\",\n    value: function parseDataNonAxisCharts(ser) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.series = ser.slice();\n      gl.seriesNames = cnf.labels.slice();\n\n      for (var i = 0; i < gl.series.length; i++) {\n        if (gl.seriesNames[i] === undefined) {\n          gl.seriesNames.push('series-' + (i + 1));\n        }\n      }\n\n      return this.w;\n    }\n    /** User possibly set string categories in xaxis.categories or labels prop\n     * Or didn't set xaxis labels at all - in which case we manually do it.\n     * If user passed series data as [[3, 2], [4, 5]] or [{ x: 3, y: 55 }],\n     * this shouldn't be called\n     * @param {array} ser - the series which user passed to the config\n     */\n\n  }, {\n    key: \"handleExternalLabelsData\",\n    value: function handleExternalLabelsData(ser) {\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n\n      if (cnf.xaxis.categories.length > 0) {\n        // user provided labels in xaxis.category prop\n        gl.labels = cnf.xaxis.categories;\n      } else if (cnf.labels.length > 0) {\n        // user provided labels in labels props\n        gl.labels = cnf.labels.slice();\n      } else if (this.fallbackToCategory) {\n        // user provided labels in x prop in [{ x: 3, y: 55 }] data, and those labels are already stored in gl.labels[0], so just re-arrange the gl.labels array\n        gl.labels = gl.labels[0];\n      } else {\n        // user didn't provided any labels, fallback to 1-2-3-4-5\n        var labelArr = [];\n\n        if (gl.axisCharts) {\n          // for axis charts, we get the longest series and create labels from it\n          for (var i = 0; i < gl.series[gl.maxValsInArrayIndex].length; i++) {\n            labelArr.push(i + 1);\n          } // create gl.seriesX as it will be used in calculations of x positions\n\n\n          for (var _i = 0; _i < ser.length; _i++) {\n            gl.seriesX.push(labelArr);\n          } // turn on the isXNumeric flag to allow minX and maxX to function properly\n\n\n          gl.isXNumeric = true;\n        } // no series to pull labels from, put a 0-10 series\n        // possibly, user collapsed all series. Hence we can't work with above calc\n\n\n        if (labelArr.length === 0) {\n          labelArr = [0, 10];\n\n          for (var _i2 = 0; _i2 < ser.length; _i2++) {\n            gl.seriesX.push(labelArr);\n          }\n        } // Finally, pass the labelArr in gl.labels which will be printed on x-axis\n\n\n        gl.labels = labelArr; // Turn on this global flag to indicate no labels were provided by user\n\n        gl.noLabelsProvided = true;\n\n        if (cnf.xaxis.type === 'category') {\n          gl.isXNumeric = false;\n        }\n      }\n    } // Segregate user provided data into appropriate vars\n\n  }, {\n    key: \"parseData\",\n    value: function parseData(ser) {\n      var w = this.w;\n      var cnf = w.config;\n      var gl = w.globals;\n      this.excludeCollapsedSeriesInYAxis(); // If we detected string in X prop of series, we fallback to category x-axis\n\n      this.fallbackToCategory = false;\n      this.resetGlobals();\n      this.isMultipleY();\n\n      if (gl.axisCharts) {\n        // axisCharts includes line / area / column / scatter\n        this.parseDataAxisCharts(ser);\n      } else {\n        // non-axis charts are pie / donut\n        this.parseDataNonAxisCharts(ser);\n      }\n\n      this.coreUtils.getLargestSeries(); // set Null values to 0 in all series when user hides/shows some series\n\n      if (cnf.chart.type === 'bar' && cnf.chart.stacked) {\n        var series = new Series(this.ctx);\n        gl.series = series.setNullSeriesToZeroValues(gl.series);\n      }\n\n      this.coreUtils.getSeriesTotals();\n\n      if (gl.axisCharts) {\n        this.coreUtils.getStackedSeriesTotals();\n      }\n\n      this.coreUtils.getPercentSeries();\n\n      if (!gl.dataFormatXNumeric && (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0)) {\n        // x-axis labels couldn't be detected; hence try searching every option in config\n        this.handleExternalLabelsData(ser);\n      }\n    }\n  }, {\n    key: \"xySettings\",\n    value: function xySettings() {\n      var xyRatios = null;\n      var w = this.w;\n\n      if (w.globals.axisCharts) {\n        if (w.config.xaxis.crosshairs.position === 'back') {\n          var crosshairs = new Crosshairs(this.ctx);\n          crosshairs.drawXCrosshairs();\n        }\n\n        if (w.config.yaxis[0].crosshairs.position === 'back') {\n          var _crosshairs = new Crosshairs(this.ctx);\n\n          _crosshairs.drawYCrosshairs();\n        }\n\n        xyRatios = this.coreUtils.getCalculatedRatios();\n\n        if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined) {\n          var ts = new TimeScale(this.ctx);\n          var formattedTimeScale;\n\n          if (isFinite(w.globals.minX) && isFinite(w.globals.maxX) && !w.globals.isBarHorizontal) {\n            formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);\n            ts.recalcDimensionsBasedOnFormat(formattedTimeScale, false);\n          } else if (w.globals.isBarHorizontal) {\n            formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minY, w.globals.maxY);\n            ts.recalcDimensionsBasedOnFormat(formattedTimeScale, true);\n          }\n        }\n      }\n\n      return xyRatios;\n    }\n  }, {\n    key: \"drawAxis\",\n    value: function drawAxis(type, xyRatios) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var xAxis = new XAxis(this.ctx);\n      var yAxis = new YAxis(this.ctx);\n\n      if (gl.axisCharts && type !== 'radar') {\n        var elXaxis, elYaxis;\n\n        if (gl.isBarHorizontal) {\n          elYaxis = yAxis.drawYaxisInversed(0);\n          elXaxis = xAxis.drawXaxisInversed(0);\n          gl.dom.elGraphical.add(elXaxis);\n          gl.dom.elGraphical.add(elYaxis);\n        } else {\n          elXaxis = xAxis.drawXaxis();\n          gl.dom.elGraphical.add(elXaxis);\n          cnf.yaxis.map(function (yaxe, index) {\n            if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {\n              elYaxis = yAxis.drawYaxis(index);\n              gl.dom.Paper.add(elYaxis);\n            }\n          });\n        }\n      }\n\n      cnf.yaxis.map(function (yaxe, index) {\n        if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {\n          yAxis.yAxisTitleRotate(index, yaxe.opposite);\n        }\n      });\n    }\n  }, {\n    key: \"setupBrushHandler\",\n    value: function setupBrushHandler() {\n      var _this3 = this;\n\n      var w = this.w; // only for brush charts\n\n      if (!w.config.chart.brush.enabled) {\n        return;\n      } // if user has not defined a custom function for selection - we handle the brush chart\n      // otherwise we leave it to the user to define the functionality for selection\n\n\n      if (typeof w.config.chart.events.selection !== 'function') {\n        var targets = w.config.chart.brush.targets || [w.config.chart.brush.target]; // retro compatibility with single target option\n\n        targets.forEach(function (target) {\n          var targetChart = ApexCharts.getChartByID(target);\n          targetChart.w.globals.brushSource = _this3.ctx;\n\n          var updateSourceChart = function updateSourceChart() {\n            _this3.ctx._updateOptions({\n              chart: {\n                selection: {\n                  xaxis: {\n                    min: targetChart.w.globals.minX,\n                    max: targetChart.w.globals.maxX\n                  }\n                }\n              }\n            }, false, false);\n          };\n\n          if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {\n            targetChart.w.config.chart.events.zoomed = function () {\n              updateSourceChart();\n            };\n          }\n\n          if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {\n            targetChart.w.config.chart.events.scrolled = function () {\n              updateSourceChart();\n            };\n          }\n\n          w.config.chart.events.selection = function (chart, e) {\n            var yaxis = Utils.clone(w.config.yaxis);\n\n            if (w.config.chart.brush.autoScaleYaxis) {\n              var scale = new Range(targetChart);\n              yaxis = scale.autoScaleY(targetChart, e);\n            }\n\n            targetChart._updateOptions({\n              xaxis: {\n                min: e.xaxis.min,\n                max: e.xaxis.max\n              },\n              yaxis: yaxis\n            }, false, false, false);\n          };\n        });\n      }\n    }\n  }]);\n\n  return Core;\n}();\n\n/**\n * @this {Promise}\n */\nfunction finallyConstructor(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n}\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\n/**\n * @constructor\n * @param {Function} fn\n */\nfunction Promise$1(fn) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  /** @type {!number} */\n  this._state = 0;\n  /** @type {!boolean} */\n  this._handled = false;\n  /** @type {Promise|undefined} */\n  this._value = undefined;\n  /** @type {!Array<!Function>} */\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise$1._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise$1) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise$1._immediateFn(function() {\n      if (!self._handled) {\n        Promise$1._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\n/**\n * @constructor\n */\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise$1.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise$1.prototype.then = function(onFulfilled, onRejected) {\n  // @ts-ignore\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise$1.prototype['finally'] = finallyConstructor;\n\nPromise$1.all = function(arr) {\n  return new Promise$1(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise$1.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise$1) {\n    return value;\n  }\n\n  return new Promise$1(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise$1.reject = function(value) {\n  return new Promise$1(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise$1.race = function(values) {\n  return new Promise$1(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise$1._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nvar Exports =\n/*#__PURE__*/\nfunction () {\n  function Exports(ctx) {\n    _classCallCheck(this, Exports);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Exports, [{\n    key: \"getSvgString\",\n    value: function getSvgString() {\n      return this.w.globals.dom.Paper.svg();\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var w = this.w; // hide some elements to avoid printing them on exported svg\n\n      var xcrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');\n      var ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');\n\n      if (xcrosshairs) {\n        xcrosshairs.setAttribute('x', -500);\n      }\n\n      if (ycrosshairs) {\n        ycrosshairs.setAttribute('y1', -100);\n        ycrosshairs.setAttribute('y2', -100);\n      }\n    }\n  }, {\n    key: \"svgUrl\",\n    value: function svgUrl() {\n      this.cleanup();\n      var svgData = this.getSvgString();\n      var svgBlob = new Blob([svgData], {\n        type: 'image/svg+xml;charset=utf-8'\n      });\n      return URL.createObjectURL(svgBlob);\n    }\n  }, {\n    key: \"dataURI\",\n    value: function dataURI() {\n      var _this = this;\n\n      return new Promise$1(function (resolve) {\n        var w = _this.w;\n\n        _this.cleanup();\n\n        var canvas = document.createElement('canvas');\n        canvas.width = w.globals.svgWidth;\n        canvas.height = w.globals.svgHeight;\n        var canvasBg = w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background;\n        var ctx = canvas.getContext('2d');\n        ctx.fillStyle = canvasBg;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        var DOMURL = window.URL || window.webkitURL || window;\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n\n        var svgData = _this.getSvgString();\n\n        var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);\n\n        img.onload = function () {\n          ctx.drawImage(img, 0, 0);\n          DOMURL.revokeObjectURL(svgUrl);\n          var imgURI = canvas.toDataURL('image/png');\n          resolve(imgURI);\n        };\n\n        img.src = svgUrl;\n      });\n    }\n  }, {\n    key: \"exportToSVG\",\n    value: function exportToSVG() {\n      this.triggerDownload(this.svgUrl(), '.svg');\n    }\n  }, {\n    key: \"exportToPng\",\n    value: function exportToPng() {\n      var _this2 = this;\n\n      this.dataURI().then(function (imgURI) {\n        _this2.triggerDownload(imgURI, '.png');\n      });\n    }\n  }, {\n    key: \"triggerDownload\",\n    value: function triggerDownload(href, ext) {\n      var downloadLink = document.createElement('a');\n      downloadLink.href = href;\n      downloadLink.download = this.w.globals.chartID + ext;\n      document.body.appendChild(downloadLink);\n      downloadLink.click();\n      document.body.removeChild(downloadLink);\n    }\n  }]);\n\n  return Exports;\n}();\n\n/**\n * ApexCharts Grid Class for drawing Cartesian Grid.\n *\n * @module Grid\n **/\n\nvar Grid =\n/*#__PURE__*/\nfunction () {\n  function Grid(ctx) {\n    _classCallCheck(this, Grid);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.anim = new Animations(this.ctx);\n    this.xaxisLabels = w.globals.labels.slice();\n    this.animX = w.config.grid.xaxis.lines.animate && w.config.chart.animations.enabled;\n    this.animY = w.config.grid.yaxis.lines.animate && w.config.chart.animations.enabled;\n\n    if (w.globals.timelineLabels.length > 0) {\n      //  timeline labels are there\n      this.xaxisLabels = w.globals.timelineLabels.slice();\n    }\n  } // .when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well\n\n\n  _createClass(Grid, [{\n    key: \"drawGridArea\",\n    value: function drawGridArea() {\n      var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n\n      if (elGrid === null) {\n        elGrid = graphics.group({\n          class: 'apexcharts-grid'\n        });\n      }\n\n      var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');\n      var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');\n      elGrid.add(elHorzLine);\n      elGrid.add(elVerticalLine);\n      return elGrid;\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var w = this.w;\n      var xAxis = new XAxis(this.ctx);\n      var yaxis = new YAxis(this.ctx);\n      var gl = this.w.globals;\n      var elgrid = null;\n\n      if (gl.axisCharts) {\n        if (w.config.grid.show) {\n          // grid is drawn after xaxis and yaxis are drawn\n          elgrid = this.renderGrid();\n          gl.dom.elGraphical.add(elgrid.el);\n          this.drawGridArea(elgrid.el);\n        } else {\n          var elgridArea = this.drawGridArea();\n          gl.dom.elGraphical.add(elgridArea);\n        }\n\n        if (elgrid !== null) {\n          xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);\n        }\n\n        yaxis.setYAxisTextAlignments();\n      }\n    } // This mask will clip off overflowing graphics from the drawable area\n\n  }, {\n    key: \"createGridMask\",\n    value: function createGridMask() {\n      var w = this.w;\n      var gl = w.globals;\n      var graphics = new Graphics(this.ctx);\n      var strokeSize = Array.isArray(w.config.stroke.width) ? 0 : w.config.stroke.width;\n\n      if (Array.isArray(w.config.stroke.width)) {\n        var strokeMaxSize = 0;\n        w.config.stroke.width.forEach(function (m) {\n          strokeMaxSize = Math.max(strokeMaxSize, m);\n        });\n        strokeSize = strokeMaxSize;\n      }\n\n      gl.dom.elGridRectMask = document.createElementNS(gl.SVGNS, 'clipPath');\n      gl.dom.elGridRectMask.setAttribute('id', \"gridRectMask\".concat(gl.cuid));\n      gl.dom.elGridRectMarkerMask = document.createElementNS(gl.SVGNS, 'clipPath');\n      gl.dom.elGridRectMarkerMask.setAttribute('id', \"gridRectMarkerMask\".concat(gl.cuid));\n      gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2, -strokeSize / 2, gl.gridWidth + strokeSize, gl.gridHeight + strokeSize, 0, '#fff');\n      var coreUtils = new CoreUtils(this);\n      coreUtils.getLargestMarkerSize();\n      var markerSize = w.globals.markers.largestSize + w.config.markers.hover.sizeOffset + 1;\n      if (markerSize < 10) markerSize = 10;\n      gl.dom.elGridRectMarker = graphics.drawRect(-markerSize * 2, -markerSize * 2, gl.gridWidth + markerSize * 4, gl.gridHeight + markerSize * 4, 0, '#fff');\n      gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);\n      gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);\n      var defs = gl.dom.baseEl.querySelector('defs');\n      defs.appendChild(gl.dom.elGridRectMask);\n      defs.appendChild(gl.dom.elGridRectMarkerMask);\n    } // actual grid rendering\n\n  }, {\n    key: \"renderGrid\",\n    value: function renderGrid() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var strokeDashArray = w.config.grid.strokeDashArray;\n      var elg = graphics.group({\n        class: 'apexcharts-grid'\n      });\n      var elgridLinesH = graphics.group({\n        class: 'apexcharts-gridlines-horizontal'\n      });\n      var elgridLinesV = graphics.group({\n        class: 'apexcharts-gridlines-vertical'\n      });\n      elg.add(elgridLinesH);\n      elg.add(elgridLinesV);\n      var tickAmount = 8;\n\n      for (var i = 0; i < w.globals.series.length; i++) {\n        if (typeof w.globals.yAxisScale[i] !== 'undefined') {\n          tickAmount = w.globals.yAxisScale[i].result.length - 1;\n        }\n\n        if (tickAmount > 2) break;\n      }\n\n      var xCount;\n\n      if (!w.globals.isBarHorizontal) {\n        xCount = this.xaxisLabels.length; // draw vertical lines\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var x1 = w.globals.padHorizontal;\n          var y1 = 0;\n          var x2;\n          var y2 = w.globals.gridHeight;\n\n          if (w.globals.timelineLabels.length > 0) {\n            for (var _i = 0; _i < xCount; _i++) {\n              x1 = this.xaxisLabels[_i].position;\n              x2 = this.xaxisLabels[_i].position;\n\n              if (w.config.grid.xaxis.lines.show && x1 > 0 && x1 < w.globals.gridWidth) {\n                var line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);\n                line.node.classList.add('apexcharts-gridline');\n                elgridLinesV.add(line);\n\n                if (this.animX) {\n                  this.animateLine(line, {\n                    x1: 0,\n                    x2: 0\n                  }, {\n                    x1: x1,\n                    x2: x2\n                  });\n                }\n              }\n\n              var xAxis = new XAxis(this.ctx);\n              xAxis.drawXaxisTicks(x1, elg);\n            }\n          } else {\n            var xCountForCategoryCharts = xCount;\n\n            for (var _i2 = 0; _i2 < xCountForCategoryCharts; _i2++) {\n              var x1Count = xCountForCategoryCharts;\n\n              if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {\n                x1Count -= 1;\n              }\n\n              x1 = x1 + w.globals.gridWidth / x1Count;\n              x2 = x1; // skip the last line\n\n              if (_i2 === x1Count - 1) break;\n\n              if (w.config.grid.xaxis.lines.show) {\n                var _line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);\n\n                _line.node.classList.add('apexcharts-gridline');\n\n                elgridLinesV.add(_line);\n\n                if (this.animX) {\n                  this.animateLine(_line, {\n                    x1: 0,\n                    x2: 0\n                  }, {\n                    x1: x1,\n                    x2: x2\n                  });\n                }\n              }\n\n              var _xAxis = new XAxis(this.ctx);\n\n              _xAxis.drawXaxisTicks(x1, elg);\n            }\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x = 0;\n          var _y = 0;\n          var _y2 = 0;\n          var _x2 = w.globals.gridWidth;\n\n          for (var _i3 = 0; _i3 < tickAmount + 1; _i3++) {\n            var _line2 = graphics.drawLine(_x, _y, _x2, _y2, w.config.grid.borderColor, strokeDashArray);\n\n            elgridLinesH.add(_line2);\n\n            _line2.node.classList.add('apexcharts-gridline');\n\n            if (this.animY) {\n              this.animateLine(_line2, {\n                y1: _y + 20,\n                y2: _y2 + 20\n              }, {\n                y1: _y,\n                y2: _y2\n              });\n            }\n\n            _y = _y + w.globals.gridHeight / tickAmount;\n            _y2 = _y;\n          }\n        }\n      } else {\n        xCount = tickAmount; // draw vertical lines\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var _x3 = w.globals.padHorizontal;\n          var _y3 = 0;\n\n          var _x4;\n\n          var _y4 = w.globals.gridHeight;\n\n          for (var _i4 = 0; _i4 < xCount + 1; _i4++) {\n            _x3 = _x3 + w.globals.gridWidth / xCount + 0.3;\n            _x4 = _x3; // skip the last vertical line\n\n            if (_i4 === xCount - 1) break;\n\n            if (w.config.grid.xaxis.lines.show) {\n              var _line3 = graphics.drawLine(_x3, _y3, _x4, _y4, w.config.grid.borderColor, strokeDashArray);\n\n              _line3.node.classList.add('apexcharts-gridline');\n\n              elgridLinesV.add(_line3);\n\n              if (this.animX) {\n                this.animateLine(_line3, {\n                  x1: 0,\n                  x2: 0\n                }, {\n                  x1: _x3,\n                  x2: _x4\n                });\n              }\n            } // skip the first vertical line\n\n\n            var _xAxis2 = new XAxis(this.ctx);\n\n            _xAxis2.drawXaxisTicks(_x3, elg);\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x5 = 0;\n          var _y5 = 0;\n          var _y6 = 0;\n          var _x6 = w.globals.gridWidth;\n\n          for (var _i5 = 0; _i5 < w.globals.dataPoints + 1; _i5++) {\n            var _line4 = graphics.drawLine(_x5, _y5, _x6, _y6, w.config.grid.borderColor, strokeDashArray);\n\n            elgridLinesH.add(_line4);\n\n            _line4.node.classList.add('apexcharts-gridline');\n\n            if (this.animY) {\n              this.animateLine(_line4, {\n                y1: _y5 + 20,\n                y2: _y6 + 20\n              }, {\n                y1: _y5,\n                y2: _y6\n              });\n            }\n\n            _y5 = _y5 + w.globals.gridHeight / w.globals.dataPoints;\n            _y6 = _y5;\n          }\n        }\n      }\n\n      this.drawGridBands(elg, xCount, tickAmount);\n      return {\n        el: elg,\n        xAxisTickWidth: w.globals.gridWidth / xCount\n      };\n    }\n  }, {\n    key: \"drawGridBands\",\n    value: function drawGridBands(elg, xCount, tickAmount) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx); // rows background bands\n\n      if (w.config.grid.row.colors !== undefined && w.config.grid.row.colors.length > 0) {\n        var x1 = 0;\n        var y1 = 0;\n        var y2 = w.globals.gridHeight / tickAmount;\n        var x2 = w.globals.gridWidth;\n\n        for (var i = 0, c = 0; i < tickAmount; i++, c++) {\n          if (c >= w.config.grid.row.colors.length) {\n            c = 0;\n          }\n\n          var color = w.config.grid.row.colors[c];\n          var rect = graphics.drawRect(x1, y1, x2, y2, 0, color, w.config.grid.row.opacity);\n          elg.add(rect);\n          rect.node.classList.add('apexcharts-gridRow');\n          y1 = y1 + w.globals.gridHeight / tickAmount;\n        }\n      } // columns background bands\n\n\n      if (w.config.grid.column.colors !== undefined && w.config.grid.column.colors.length > 0) {\n        var _x7 = w.globals.padHorizontal;\n        var _y7 = 0;\n\n        var _x8 = w.globals.padHorizontal + w.globals.gridWidth / xCount;\n\n        var _y8 = w.globals.gridHeight;\n\n        for (var _i6 = 0, _c = 0; _i6 < xCount; _i6++, _c++) {\n          if (_c >= w.config.grid.column.colors.length) {\n            _c = 0;\n          }\n\n          var _color = w.config.grid.column.colors[_c];\n\n          var _rect = graphics.drawRect(_x7, _y7, _x8, _y8, 0, _color, w.config.grid.column.opacity);\n\n          _rect.node.classList.add('apexcharts-gridColumn');\n\n          elg.add(_rect);\n          _x7 = _x7 + w.globals.gridWidth / xCount;\n        }\n      }\n    }\n  }, {\n    key: \"animateLine\",\n    value: function animateLine(line, from, to) {\n      var w = this.w;\n      var initialAnim = w.config.chart.animations;\n\n      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n        var speed = initialAnim.speed;\n        this.anim.animateLine(line, from, to, speed);\n      }\n    }\n  }]);\n\n  return Grid;\n}();\n\n/**\n * ApexCharts Legend Class to draw legend.\n *\n * @module Legend\n **/\n\nvar Legend =\n/*#__PURE__*/\nfunction () {\n  function Legend(ctx, opts) {\n    _classCallCheck(this, Legend);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.onLegendClick = this.onLegendClick.bind(this);\n    this.onLegendHovered = this.onLegendHovered.bind(this);\n  }\n\n  _createClass(Legend, [{\n    key: \"init\",\n    value: function init() {\n      var w = this.w;\n      var gl = w.globals;\n      var cnf = w.config;\n      var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || gl.series.length > 1;\n\n      if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {\n        while (gl.dom.elLegendWrap.firstChild) {\n          gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);\n        }\n\n        this.drawLegends();\n\n        if (!Utils.isIE11()) {\n          this.appendToForeignObject();\n        } else {\n          // IE11 doesn't supports foreignObject, hence append it to <head>\n          document.getElementsByTagName('head')[0].appendChild(this.getLegendStyles());\n        }\n\n        if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {\n          this.legendAlignHorizontal();\n        } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {\n          this.legendAlignVertical();\n        }\n      }\n    }\n  }, {\n    key: \"appendToForeignObject\",\n    value: function appendToForeignObject() {\n      var gl = this.w.globals;\n      var elForeign = document.createElementNS(gl.SVGNS, 'foreignObject');\n      elForeign.setAttribute('x', 0);\n      elForeign.setAttribute('y', 0);\n      elForeign.setAttribute('width', gl.svgWidth);\n      elForeign.setAttribute('height', gl.svgHeight);\n      gl.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n      elForeign.appendChild(gl.dom.elLegendWrap);\n      elForeign.appendChild(this.getLegendStyles());\n      gl.dom.Paper.node.insertBefore(elForeign, gl.dom.elGraphical.node);\n    }\n  }, {\n    key: \"drawLegends\",\n    value: function drawLegends() {\n      var self = this;\n      var w = this.w;\n      var fontFamily = w.config.legend.fontFamily;\n      var legendNames = w.globals.seriesNames;\n      var fillcolor = w.globals.colors.slice();\n\n      if (w.config.chart.type === 'heatmap') {\n        var ranges = w.config.plotOptions.heatmap.colorScale.ranges;\n        legendNames = ranges.map(function (colorScale) {\n          return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;\n        });\n        fillcolor = ranges.map(function (color) {\n          return color.color;\n        });\n      }\n\n      var legendFormatter = w.globals.legendFormatter;\n\n      for (var i = 0; i <= legendNames.length - 1; i++) {\n        var text = legendFormatter(legendNames[i], {\n          seriesIndex: i,\n          w: w\n        });\n        var collapsedSeries = false;\n        var ancillaryCollapsedSeries = false;\n\n        if (w.globals.collapsedSeries.length > 0) {\n          for (var c = 0; c < w.globals.collapsedSeries.length; c++) {\n            if (w.globals.collapsedSeries[c].index === i) {\n              collapsedSeries = true;\n            }\n          }\n        }\n\n        if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {\n          for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {\n            if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {\n              ancillaryCollapsedSeries = true;\n            }\n          }\n        }\n\n        var elMarker = document.createElement('span');\n        elMarker.classList.add('apexcharts-legend-marker');\n        var mOffsetX = w.config.legend.markers.offsetX;\n        var mOffsetY = w.config.legend.markers.offsetY;\n        var mHeight = w.config.legend.markers.height;\n        var mWidth = w.config.legend.markers.width;\n        var mBorderWidth = w.config.legend.markers.strokeWidth;\n        var mBorderColor = w.config.legend.markers.strokeColor;\n        var mBorderRadius = w.config.legend.markers.radius;\n        var mStyle = elMarker.style;\n        mStyle.background = fillcolor[i];\n        mStyle.color = fillcolor[i];\n        mStyle.height = Array.isArray(mHeight) ? parseFloat(mHeight[i]) + 'px' : parseFloat(mHeight) + 'px';\n        mStyle.width = Array.isArray(mWidth) ? parseFloat(mWidth[i]) + 'px' : parseFloat(mWidth) + 'px';\n        mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX;\n        mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY;\n        mStyle.borderWidth = Array.isArray(mBorderWidth) ? mBorderWidth[i] : mBorderWidth;\n        mStyle.borderColor = Array.isArray(mBorderColor) ? mBorderColor[i] : mBorderColor;\n        mStyle.borderRadius = Array.isArray(mBorderRadius) ? parseFloat(mBorderRadius[i]) + 'px' : parseFloat(mBorderRadius) + 'px';\n\n        if (w.config.legend.markers.customHTML) {\n          if (Array.isArray(w.config.legend.markers.customHTML)) {\n            elMarker.innerHTML = w.config.legend.markers.customHTML[i]();\n          } else {\n            elMarker.innerHTML = w.config.legend.markers.customHTML();\n          }\n        }\n\n        Graphics.setAttrs(elMarker, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n\n        if (collapsedSeries || ancillaryCollapsedSeries) {\n          elMarker.classList.add('inactive-legend');\n        }\n\n        var elLegend = document.createElement('div');\n        var elLegendText = document.createElement('span');\n        elLegendText.classList.add('apexcharts-legend-text');\n        elLegendText.innerHTML = text;\n        var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : w.config.legend.labels.colors;\n\n        if (!textColor) {\n          textColor = w.config.chart.foreColor;\n        }\n\n        elLegendText.style.color = textColor;\n        elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';\n        elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;\n        Graphics.setAttrs(elLegendText, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n        elLegend.appendChild(elMarker);\n        elLegend.appendChild(elLegendText);\n        var coreUtils = new CoreUtils(this.ctx);\n\n        if (!w.config.legend.showForZeroSeries) {\n          var total = coreUtils.getSeriesTotalByIndex(i);\n\n          if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n            elLegend.classList.add('apexcharts-hidden-zero-series');\n          }\n        }\n\n        if (!w.config.legend.showForNullSeries) {\n          if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n            elLegend.classList.add('apexcharts-hidden-null-series');\n          }\n        }\n\n        w.globals.dom.elLegendWrap.appendChild(elLegend);\n        w.globals.dom.elLegendWrap.classList.add(w.config.legend.horizontalAlign); // w.globals.dom.elLegendWrap.classList.add(w.config.legend.verticalAlign)\n\n        w.globals.dom.elLegendWrap.classList.add('position-' + w.config.legend.position);\n        elLegend.classList.add('apexcharts-legend-series');\n        elLegend.style.margin = \"\".concat(w.config.legend.itemMargin.horizontal, \"px \").concat(w.config.legend.itemMargin.vertical, \"px\");\n        w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';\n        w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';\n        Graphics.setAttrs(elLegend, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n\n        if (collapsedSeries || ancillaryCollapsedSeries) {\n          elLegend.classList.add('inactive-legend');\n        }\n\n        if (!w.config.legend.onItemClick.toggleDataSeries) {\n          elLegend.classList.add('no-click');\n        }\n      } // for now - just prevent click on heatmap legend - and allow hover only\n\n\n      var clickAllowed = w.config.chart.type !== 'heatmap';\n\n      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {\n        w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true);\n      }\n\n      if (w.config.legend.onItemHover.highlightDataSeries) {\n        w.globals.dom.elWrap.addEventListener('mousemove', self.onLegendHovered, true);\n        w.globals.dom.elWrap.addEventListener('mouseout', self.onLegendHovered, true);\n      }\n    }\n  }, {\n    key: \"getLegendBBox\",\n    value: function getLegendBBox() {\n      var w = this.w;\n      var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var currLegendsWrapRect = currLegendsWrap.getBoundingClientRect();\n      var currLegendsWrapWidth = currLegendsWrapRect.width;\n      var currLegendsWrapHeight = currLegendsWrapRect.height;\n      return {\n        clwh: currLegendsWrapHeight,\n        clww: currLegendsWrapWidth\n      };\n    }\n  }, {\n    key: \"setLegendWrapXY\",\n    value: function setLegendWrapXY(offsetX, offsetY) {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var legendRect = elLegendWrap.getBoundingClientRect();\n      var x = 0;\n      var y = 0;\n\n      if (w.config.legend.position === 'bottom') {\n        y = y + (w.globals.svgHeight - legendRect.height / 2);\n      } else if (w.config.legend.position === 'top') {\n        var dim = new Dimensions(this.ctx);\n        var titleH = dim.getTitleSubtitleCoords('title').height;\n        var subtitleH = dim.getTitleSubtitleCoords('subtitle').height;\n        y = y + (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);\n      }\n\n      elLegendWrap.style.position = 'absolute';\n      x = x + offsetX + w.config.legend.offsetX;\n      y = y + offsetY + w.config.legend.offsetY;\n      elLegendWrap.style.left = x + 'px';\n      elLegendWrap.style.top = y + 'px';\n\n      if (w.config.legend.position === 'bottom') {\n        elLegendWrap.style.top = 'auto';\n        elLegendWrap.style.bottom = 10 + w.config.legend.offsetY + 'px';\n      } else if (w.config.legend.position === 'right') {\n        elLegendWrap.style.left = 'auto';\n        elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';\n      }\n\n      if (elLegendWrap.style.width) {\n        elLegendWrap.style.width = parseInt(w.config.legend.width) + 'px';\n      }\n\n      if (elLegendWrap.style.height) {\n        elLegendWrap.style.height = parseInt(w.config.legend.height) + 'px';\n      }\n    }\n  }, {\n    key: \"legendAlignHorizontal\",\n    value: function legendAlignHorizontal() {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      elLegendWrap.style.right = 0;\n      var lRect = this.getLegendBBox();\n      var dimensions = new Dimensions(this.ctx);\n      var titleRect = dimensions.getTitleSubtitleCoords('title');\n      var subtitleRect = dimensions.getTitleSubtitleCoords('subtitle');\n      var offsetX = 20;\n      var offsetY = 0; // the whole legend box is set to bottom\n\n      if (w.config.legend.position === 'bottom') {\n        offsetY = -lRect.clwh / 1.8;\n      } else if (w.config.legend.position === 'top') {\n        offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 15;\n      }\n\n      this.setLegendWrapXY(offsetX, offsetY);\n    }\n  }, {\n    key: \"legendAlignVertical\",\n    value: function legendAlignVertical() {\n      var w = this.w;\n      var lRect = this.getLegendBBox();\n      var offsetY = 20;\n      var offsetX = 0;\n\n      if (w.config.legend.position === 'left') {\n        offsetX = 20;\n      }\n\n      if (w.config.legend.position === 'right') {\n        offsetX = w.globals.svgWidth - lRect.clww - 10;\n      }\n\n      this.setLegendWrapXY(offsetX, offsetY);\n    }\n  }, {\n    key: \"onLegendHovered\",\n    value: function onLegendHovered(e) {\n      var w = this.w;\n      var hoverOverLegend = e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');\n\n      if (w.config.chart.type !== 'heatmap') {\n        if (!e.target.classList.contains('inactive-legend') && hoverOverLegend) {\n          var series = new Series(this.ctx);\n          series.toggleSeriesOnHover(e, e.target);\n        }\n      } else {\n        // for heatmap handling\n        if (hoverOverLegend) {\n          var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;\n          this.ctx.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);\n\n          var _series = new Series(this.ctx);\n\n          _series.highlightRangeInSeries(e, e.target);\n        }\n      }\n    }\n  }, {\n    key: \"onLegendClick\",\n    value: function onLegendClick(e) {\n      if (e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {\n        var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;\n        var isHidden = e.target.getAttribute('data:collapsed') === 'true';\n        var legendClick = this.w.config.chart.events.legendClick;\n\n        if (typeof legendClick === 'function') {\n          legendClick(this.ctx, seriesCnt, this.w);\n        }\n\n        this.ctx.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);\n        var markerClick = this.w.config.legend.markers.onClick;\n\n        if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {\n          markerClick(this.ctx, seriesCnt, this.w);\n          this.ctx.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);\n        }\n\n        this.toggleDataSeries(seriesCnt, isHidden);\n      }\n    }\n  }, {\n    key: \"getLegendStyles\",\n    value: function getLegendStyles() {\n      var stylesheet = document.createElement('style');\n      stylesheet.setAttribute('type', 'text/css');\n      var text = \"\\n    \\n      .apexcharts-legend {\\n        display: flex;\\n        overflow: auto;\\n        padding: 0 10px;\\n      }\\n\\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\\n        flex-wrap: wrap\\n      }\\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\\n        flex-direction: column;\\n        bottom: 0;\\n      }\\n\\n      .apexcharts-legend.position-bottom.left, .apexcharts-legend.position-top.left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\\n        justify-content: flex-start;\\n      }\\n\\n      .apexcharts-legend.position-bottom.center, .apexcharts-legend.position-top.center {\\n        justify-content: center;  \\n      }\\n\\n      .apexcharts-legend.position-bottom.right, .apexcharts-legend.position-top.right {\\n        justify-content: flex-end;\\n      }\\n\\n      .apexcharts-legend-series {\\n        cursor: pointer;\\n        line-height: normal;\\n      }\\n\\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\\n        display: flex;\\n        align-items: center;\\n      }\\n\\n      .apexcharts-legend-text {\\n        position: relative;\\n        font-size: 14px;\\n      }\\n\\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\\n        pointer-events: none;\\n      }\\n\\n      .apexcharts-legend-marker {\\n        position: relative;\\n        display: inline-block;\\n        cursor: pointer;\\n        margin-right: 3px;\\n      }\\n      \\n      .apexcharts-legend.right .apexcharts-legend-series, .apexcharts-legend.left .apexcharts-legend-series{\\n        display: inline-block;\\n      }\\n\\n      .apexcharts-legend-series.no-click {\\n        cursor: auto;\\n      }\\n\\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\\n        display: none !important;\\n      }\\n\\n      .inactive-legend {\\n        opacity: 0.45;\\n      }\";\n      var rules = document.createTextNode(text);\n      stylesheet.appendChild(rules);\n      return stylesheet;\n    }\n  }, {\n    key: \"resetToggleDataSeries\",\n    value: function resetToggleDataSeries() {\n      var w = this.w;\n      var seriesEls = null;\n      var realIndexes = [];\n\n      if (w.globals.axisCharts) {\n        seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:realIndex]\");\n        seriesEls = Utils.listToArray(seriesEls);\n        seriesEls.forEach(function (v) {\n          realIndexes.push(parseInt(v.getAttribute('data:realIndex')));\n        });\n      } else {\n        seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[rel]\");\n        seriesEls = Utils.listToArray(seriesEls);\n        seriesEls.forEach(function (v) {\n          realIndexes.push(parseInt(v.getAttribute('rel')) - 1);\n        });\n      }\n\n      realIndexes.sort();\n\n      if (w.globals.collapsedSeries.length > 0) {\n        var risingSeries = w.globals.risingSeries.slice();\n        var series = w.config.series.slice();\n\n        for (var c = 0; c < w.globals.collapsedSeries.length; c++) {\n          var index = realIndexes.indexOf(w.globals.collapsedSeries[c].index);\n\n          if (index !== -1) {\n            if (w.globals.axisCharts) {\n              series[index].data = w.globals.collapsedSeries.slice()[c].data.slice();\n            } else {\n              series[index] = w.globals.collapsedSeries.slice()[c].data;\n            }\n\n            risingSeries.push(index);\n          }\n        }\n\n        w.globals.collapsedSeries = [];\n        w.globals.ancillaryCollapsedSeries = [];\n        w.globals.collapsedSeriesIndices = [];\n        w.globals.ancillaryCollapsedSeriesIndices = [];\n        w.globals.risingSeries = risingSeries;\n        w.config.series = series;\n\n        this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n      }\n    }\n  }, {\n    key: \"toggleDataSeries\",\n    value: function toggleDataSeries(seriesCnt, isHidden) {\n      var w = this.w;\n\n      if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n        w.globals.resized = true; // we don't want initial animations again\n\n        var seriesEl = null;\n        var realIndex = null; // yes, make it null. 1 series will rise at a time\n\n        w.globals.risingSeries = [];\n\n        if (w.globals.axisCharts) {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n          realIndex = parseInt(seriesEl.getAttribute('data:realIndex'));\n        } else {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n          realIndex = parseInt(seriesEl.getAttribute('rel')) - 1;\n        }\n\n        if (isHidden) {\n          this.riseCollapsedSeries(w.globals.collapsedSeries, w.globals.collapsedSeriesIndices, realIndex);\n          this.riseCollapsedSeries(w.globals.ancillaryCollapsedSeries, w.globals.ancillaryCollapsedSeriesIndices, realIndex);\n        } else {\n          if (w.globals.axisCharts) {\n            var shouldNotHideYAxis = false;\n\n            if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].show && w.config.yaxis[realIndex].showAlways) {\n              shouldNotHideYAxis = true;\n\n              if (w.globals.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {\n                w.globals.ancillaryCollapsedSeries.push({\n                  index: realIndex,\n                  data: w.config.series[realIndex].data.slice(),\n                  type: seriesEl.parentNode.className.baseVal.split('-')[1]\n                });\n                w.globals.ancillaryCollapsedSeriesIndices.push(realIndex);\n              }\n            }\n\n            if (!shouldNotHideYAxis) {\n              w.globals.collapsedSeries.push({\n                index: realIndex,\n                data: w.config.series[realIndex].data.slice(),\n                type: seriesEl.parentNode.className.baseVal.split('-')[1]\n              });\n              w.globals.collapsedSeriesIndices.push(realIndex);\n              var removeIndexOfRising = w.globals.risingSeries.indexOf(realIndex);\n              w.globals.risingSeries.splice(removeIndexOfRising, 1);\n            } // TODO: AVOID mutating the user's config object below\n\n\n            w.config.series[realIndex].data = [];\n          } else {\n            w.globals.collapsedSeries.push({\n              index: realIndex,\n              data: w.config.series[realIndex]\n            });\n            w.globals.collapsedSeriesIndices.push(realIndex);\n            w.config.series[realIndex] = 0;\n          }\n\n          var seriesChildren = seriesEl.childNodes;\n\n          for (var sc = 0; sc < seriesChildren.length; sc++) {\n            if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {\n              if (seriesChildren[sc].classList.contains('apexcharts-hide')) {\n                seriesChildren[sc].classList.remove('apexcharts-hide');\n              } else {\n                seriesChildren[sc].classList.add('apexcharts-hide');\n              }\n            }\n          }\n\n          w.globals.allSeriesCollapsed = w.globals.collapsedSeries.length === w.globals.series.length;\n\n          this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      } else {\n        // for non-axis charts i.e pie / donuts\n        var _seriesEl = w.globals.dom.Paper.select(\" .apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n\n        _seriesEl.fire('click');\n      }\n    }\n  }, {\n    key: \"riseCollapsedSeries\",\n    value: function riseCollapsedSeries(series, seriesIndices, realIndex) {\n      var w = this.w;\n\n      if (series.length > 0) {\n        for (var c = 0; c < series.length; c++) {\n          if (series[c].index === realIndex) {\n            if (w.globals.axisCharts) {\n              w.config.series[realIndex].data = series[c].data.slice();\n              series.splice(c, 1);\n              seriesIndices.splice(c, 1);\n              w.globals.risingSeries.push(realIndex);\n            } else {\n              w.config.series[realIndex] = series[c].data;\n              series.splice(c, 1);\n              seriesIndices.splice(c, 1);\n              w.globals.risingSeries.push(realIndex);\n            }\n\n            this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Legend;\n}();\n\n/**\n * ApexCharts Responsive Class to override options for different screen sizes.\n *\n * @module Responsive\n **/\n\nvar Responsive =\n/*#__PURE__*/\nfunction () {\n  function Responsive(ctx) {\n    _classCallCheck(this, Responsive);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // the opts parameter if not null has to be set overriding everything\n  // as the opts is set by user externally\n\n\n  _createClass(Responsive, [{\n    key: \"checkResponsiveConfig\",\n    value: function checkResponsiveConfig(opts) {\n      var _this = this;\n\n      var w = this.w;\n      var cnf = w.config; // check if responsive config exists\n\n      if (cnf.responsive.length === 0) return;\n      var res = cnf.responsive.slice();\n      res.sort(function (a, b) {\n        return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;\n      }).reverse();\n      var config = new Config({});\n\n      var iterateResponsiveOptions = function iterateResponsiveOptions() {\n        var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var largestBreakpoint = res[0].breakpoint;\n        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;\n\n        if (width > largestBreakpoint) {\n          var options = CoreUtils.extendArrayProps(config, w.globals.initialConfig);\n          newOptions = Utils.extend(options, newOptions);\n          newOptions = Utils.extend(w.config, newOptions);\n\n          _this.overrideResponsiveOptions(newOptions);\n        } else {\n          for (var i = 0; i < res.length; i++) {\n            if (width < res[i].breakpoint) {\n              newOptions = CoreUtils.extendArrayProps(config, res[i].options);\n              newOptions = Utils.extend(w.config, newOptions);\n\n              _this.overrideResponsiveOptions(newOptions);\n            }\n          }\n        }\n      };\n\n      if (opts) {\n        var options = CoreUtils.extendArrayProps(config, opts);\n        options = Utils.extend(w.config, options);\n        options = Utils.extend(options, opts);\n        iterateResponsiveOptions(options);\n      } else {\n        iterateResponsiveOptions({});\n      }\n    }\n  }, {\n    key: \"overrideResponsiveOptions\",\n    value: function overrideResponsiveOptions(newOptions) {\n      var newConfig = new Config(newOptions).init();\n      this.w.config = newConfig;\n    }\n  }]);\n\n  return Responsive;\n}();\n\n/**\n * ApexCharts Theme Class for setting the colors and palettes.\n *\n * @module Theme\n **/\n\nvar Theme =\n/*#__PURE__*/\nfunction () {\n  function Theme(ctx) {\n    _classCallCheck(this, Theme);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.colors = [];\n  }\n\n  _createClass(Theme, [{\n    key: \"init\",\n    value: function init() {\n      this.setDefaultColors();\n    }\n  }, {\n    key: \"setDefaultColors\",\n    value: function setDefaultColors() {\n      var w = this.w;\n      var utils = new Utils();\n      w.globals.dom.elWrap.classList.add(w.config.theme.mode);\n\n      if (w.config.colors === undefined) {\n        w.globals.colors = this.predefined();\n      } else {\n        w.globals.colors = w.config.colors;\n      }\n\n      if (w.config.theme.monochrome.enabled) {\n        var monoArr = [];\n        var glsCnt = w.globals.series.length;\n\n        if (w.config.plotOptions.bar.distributed && w.config.chart.type === 'bar') {\n          glsCnt = w.globals.series[0].length * w.globals.series.length;\n        }\n\n        var mainColor = w.config.theme.monochrome.color;\n        var part = 1 / (glsCnt / w.config.theme.monochrome.shadeIntensity);\n        var shade = w.config.theme.monochrome.shadeTo;\n        var percent = 0;\n\n        for (var gsl = 0; gsl < glsCnt; gsl++) {\n          var newColor = void 0;\n\n          if (shade === 'dark') {\n            newColor = utils.shadeColor(percent * -1, mainColor);\n            percent = percent + part;\n          } else {\n            newColor = utils.shadeColor(percent, mainColor);\n            percent = percent + part;\n          }\n\n          monoArr.push(newColor);\n        }\n\n        w.globals.colors = monoArr.slice();\n      }\n\n      var defaultColors = w.globals.colors.slice(); // if user specfied less colors than no. of series, push the same colors again\n\n      this.pushExtraColors(w.globals.colors); // The Border colors\n\n      if (w.config.stroke.colors === undefined) {\n        w.globals.stroke.colors = defaultColors;\n      } else {\n        w.globals.stroke.colors = w.config.stroke.colors;\n      }\n\n      this.pushExtraColors(w.globals.stroke.colors); // The FILL colors\n\n      if (w.config.fill.colors === undefined) {\n        w.globals.fill.colors = defaultColors;\n      } else {\n        w.globals.fill.colors = w.config.fill.colors;\n      }\n\n      this.pushExtraColors(w.globals.fill.colors);\n\n      if (w.config.dataLabels.style.colors === undefined) {\n        w.globals.dataLabels.style.colors = defaultColors;\n      } else {\n        w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors;\n      }\n\n      this.pushExtraColors(w.globals.dataLabels.style.colors, 50);\n\n      if (w.config.plotOptions.radar.polygons.fill.colors === undefined) {\n        w.globals.radarPolygons.fill.colors = ['#fff'];\n      } else {\n        w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors;\n      }\n\n      this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20); // The point colors\n\n      if (w.config.markers.colors === undefined) {\n        w.globals.markers.colors = defaultColors;\n      } else {\n        w.globals.markers.colors = w.config.markers.colors;\n      }\n\n      this.pushExtraColors(w.globals.markers.colors);\n    } // When the number of colors provided is less than the number of series, this method\n    // will push same colors to the list\n    // params:\n    // distributed is only valid for distributed column/bar charts\n\n  }, {\n    key: \"pushExtraColors\",\n    value: function pushExtraColors(colorSeries, length) {\n      var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var w = this.w;\n      var len = length || w.globals.series.length;\n\n      if (distributed === null) {\n        distributed = w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.colorScale.inverse;\n      }\n\n      if (distributed) {\n        len = w.globals.series[0].length * w.globals.series.length;\n      }\n\n      if (colorSeries.length < len) {\n        var diff = len - colorSeries.length;\n\n        for (var i = 0; i < diff; i++) {\n          colorSeries.push(colorSeries[i]);\n        }\n      }\n    }\n  }, {\n    key: \"updateThemeOptions\",\n    value: function updateThemeOptions(options) {\n      options.chart = options.chart || {};\n      options.tooltip = options.tooltip || {};\n      var mode = options.theme.mode || 'light';\n      var palette = options.theme.palette ? options.theme.palette : mode === 'dark' ? 'palette4' : 'palette1';\n      var foreColor = options.chart.foreColor ? options.chart.foreColor : mode === 'dark' ? '#f6f7f8' : '#373d3f';\n      options.tooltip.theme = mode;\n      options.chart.foreColor = foreColor;\n      options.theme.palette = palette;\n      return options;\n    }\n  }, {\n    key: \"predefined\",\n    value: function predefined() {\n      var palette = this.w.config.theme.palette; // D6E3F8, FCEFEF, DCE0D9, A5978B, EDDDD4, D6E3F8, FEF5EF\n\n      switch (palette) {\n        case 'palette1':\n          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n          break;\n\n        case 'palette2':\n          this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800'];\n          break;\n\n        case 'palette3':\n          this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B'];\n          break;\n\n        case 'palette4':\n          this.colors = ['#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a', '#546E7A'];\n          break;\n\n        case 'palette5':\n          this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7'];\n          break;\n\n        case 'palette6':\n          this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'];\n          break;\n\n        case 'palette7':\n          this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'];\n          break;\n\n        case 'palette8':\n          this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'];\n          break;\n\n        case 'palette9':\n          this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'];\n          break;\n\n        case 'palette10':\n          this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2'];\n          break;\n\n        default:\n          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n          break;\n      }\n\n      return this.colors;\n    }\n  }]);\n\n  return Theme;\n}();\n\nvar Utils$1 =\n/*#__PURE__*/\nfunction () {\n  function Utils(tooltipContext) {\n    _classCallCheck(this, Utils);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n  }\n  /**\n   ** When hovering over series, you need to capture which series is being hovered on.\n   ** This function will return both capturedseries index as well as inner index of that series\n   * @memberof Utils\n   * @param {object}\n   * - hoverArea = the rect on which user hovers\n   * - elGrid = dimensions of the hover rect (it can be different than hoverarea)\n   */\n\n\n  _createClass(Utils, [{\n    key: \"getNearestValues\",\n    value: function getNearestValues(_ref) {\n      var hoverArea = _ref.hoverArea,\n          elGrid = _ref.elGrid,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY,\n          hasBars = _ref.hasBars;\n      var w = this.w;\n      var hoverWidth = w.globals.gridWidth;\n      var xDivisor = hoverWidth / (w.globals.dataPoints - 1);\n      var seriesBound = elGrid.getBoundingClientRect();\n\n      if (hasBars && w.globals.comboCharts || hasBars) {\n        xDivisor = hoverWidth / w.globals.dataPoints;\n      }\n\n      var hoverX = clientX - seriesBound.left;\n      var hoverY = clientY - seriesBound.top;\n      var inRect = hoverX < 0 || hoverY < 0 || hoverX > w.globals.gridWidth || hoverY > w.globals.gridHeight;\n\n      if (inRect) {\n        hoverArea.classList.remove('hovering-zoom');\n        hoverArea.classList.remove('hovering-pan');\n      } else {\n        if (w.globals.zoomEnabled) {\n          hoverArea.classList.remove('hovering-pan');\n          hoverArea.classList.add('hovering-zoom');\n        } else if (w.globals.panEnabled) {\n          hoverArea.classList.remove('hovering-zoom');\n          hoverArea.classList.add('hovering-pan');\n        }\n      }\n\n      var j = Math.round(hoverX / xDivisor);\n\n      if (hasBars) {\n        j = Math.ceil(hoverX / xDivisor);\n        j = j - 1;\n      }\n\n      var capturedSeries = null;\n      var closest = null;\n      var seriesXValArr = [];\n      var seriesYValArr = [];\n\n      for (var s = 0; s < w.globals.seriesXvalues.length; s++) {\n        seriesXValArr.push([w.globals.seriesXvalues[s][0] - 0.000001].concat(w.globals.seriesXvalues[s]));\n      }\n\n      seriesXValArr = seriesXValArr.map(function (seriesXVal) {\n        return seriesXVal.filter(function (s) {\n          return s;\n        });\n      });\n      seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {\n        return seriesYVal.filter(function (s) {\n          return s;\n        });\n      }); // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value\n\n      if (w.globals.isXNumeric) {\n        closest = this.closestInMultiArray(hoverX, hoverY, seriesXValArr, seriesYValArr);\n        capturedSeries = closest.index;\n        j = closest.j;\n\n        if (capturedSeries !== null) {\n          // initial push, it should be a little smaller than the 1st val\n          seriesXValArr = w.globals.seriesXvalues[capturedSeries];\n          closest = this.closestInArray(hoverX, seriesXValArr);\n          j = closest.index;\n        }\n      }\n\n      if (!j || j < 1) j = 0;\n      return {\n        capturedSeries: capturedSeries,\n        j: j,\n        hoverX: hoverX,\n        hoverY: hoverY\n      };\n    }\n  }, {\n    key: \"closestInMultiArray\",\n    value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {\n      var w = this.w;\n      var activeIndex = 0;\n      var currIndex = null;\n      var j = -1;\n\n      if (w.globals.series.length > 1) {\n        activeIndex = this.getFirstActiveXArray(Xarrays);\n      } else {\n        currIndex = 0;\n      }\n\n      var currY = Yarrays[activeIndex][0];\n      var currX = Xarrays[activeIndex][0];\n      var diffX = Math.abs(hoverX - currX);\n      var diffY = Math.abs(hoverY - currY);\n      var diff = diffY + diffX;\n      Yarrays.map(function (arrY, arrIndex) {\n        arrY.map(function (y, innerKey) {\n          var newdiffY = Math.abs(hoverY - Yarrays[arrIndex][innerKey]);\n          var newdiffX = Math.abs(hoverX - Xarrays[arrIndex][innerKey]);\n          var newdiff = newdiffX + newdiffY;\n\n          if (newdiff < diff) {\n            diff = newdiff;\n            diffX = newdiffX;\n            diffY = newdiffY;\n            currIndex = arrIndex;\n            j = innerKey;\n          }\n        });\n      });\n      return {\n        index: currIndex,\n        j: j\n      };\n    }\n  }, {\n    key: \"getFirstActiveXArray\",\n    value: function getFirstActiveXArray(Xarrays) {\n      var activeIndex = 0;\n      var coreUtils = new CoreUtils(this.ctx);\n      var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {\n        if (xarr.length > 0) {\n          return index;\n        } else {\n          return -1;\n        }\n      });\n\n      for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n        var total = coreUtils.getSeriesTotalByIndex(a);\n\n        if (firstActiveSeriesIndex[a] !== -1 && total !== 0 && !coreUtils.seriesHaveSameValues(a)) {\n          activeIndex = firstActiveSeriesIndex[a];\n          break;\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"closestInArray\",\n    value: function closestInArray(val, arr) {\n      var curr = arr[0];\n      var currIndex = null;\n      var diff = Math.abs(val - curr);\n\n      for (var i = 0; i < arr.length; i++) {\n        var newdiff = Math.abs(val - arr[i]);\n\n        if (newdiff < diff) {\n          diff = newdiff;\n          curr = arr[i];\n          currIndex = i;\n        }\n      }\n\n      return {\n        index: currIndex\n      };\n    }\n    /**\n     * When there are multiple series, it is possible to have different x values for each series.\n     * But it may be possible in those multiple series, that there is same x value for 2 or more\n     * series.\n     * @memberof Utils\n     * @param {int}\n     * - j = is the inner index of series -> (series[i][j])\n     * @return {bool}\n     */\n\n  }, {\n    key: \"isXoverlap\",\n    value: function isXoverlap(j) {\n      var w = this.w;\n      var xSameForAllSeriesJArr = [];\n      var seriesX = w.globals.seriesX.filter(function (s) {\n        return typeof s[0] !== 'undefined';\n      });\n\n      if (seriesX.length > 0) {\n        for (var i = 0; i < seriesX.length - 1; i++) {\n          if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {\n            if (seriesX[i][j] !== seriesX[i + 1][j]) {\n              xSameForAllSeriesJArr.push('unEqual');\n            }\n          }\n        }\n      }\n\n      if (xSameForAllSeriesJArr.length === 0) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isinitialSeriesSameLen\",\n    value: function isinitialSeriesSameLen() {\n      var sameLen = true;\n      var initialSeries = this.w.globals.initialSeries;\n\n      for (var i = 0; i < initialSeries.length - 1; i++) {\n        if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {\n          sameLen = false;\n          break;\n        }\n      }\n\n      return sameLen;\n    }\n  }, {\n    key: \"getBarsHeight\",\n    value: function getBarsHeight(allbars) {\n      var bars = _toConsumableArray(allbars);\n\n      var totalHeight = bars.reduce(function (acc, bar) {\n        return acc + bar.getBBox().height;\n      }, 0);\n      return totalHeight;\n    }\n  }, {\n    key: \"toggleAllTooltipSeriesGroups\",\n    value: function toggleAllTooltipSeriesGroups(state) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.allTooltipSeriesGroups.length === 0) {\n        ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');\n      }\n\n      var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;\n\n      for (var i = 0; i < allTooltipSeriesGroups.length; i++) {\n        if (state === 'enable') {\n          allTooltipSeriesGroups[i].classList.add('active');\n          allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;\n        } else {\n          allTooltipSeriesGroups[i].classList.remove('active');\n          allTooltipSeriesGroups[i].style.display = 'none';\n        }\n      }\n    }\n  }]);\n\n  return Utils;\n}();\n\n/**\n * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.\n *\n * @module Tooltip.Labels\n **/\n\nvar Labels =\n/*#__PURE__*/\nfunction () {\n  function Labels(tooltipContext) {\n    _classCallCheck(this, Labels);\n\n    this.w = tooltipContext.w;\n    this.ctx = tooltipContext.ctx;\n    this.ttCtx = tooltipContext;\n    this.tooltipUtil = new Utils$1(tooltipContext);\n  }\n\n  _createClass(Labels, [{\n    key: \"drawSeriesTexts\",\n    value: function drawSeriesTexts(_ref) {\n      var _ref$shared = _ref.shared,\n          shared = _ref$shared === void 0 ? true : _ref$shared,\n          ttItems = _ref.ttItems,\n          _ref$i = _ref.i,\n          i = _ref$i === void 0 ? 0 : _ref$i,\n          _ref$j = _ref.j,\n          j = _ref$j === void 0 ? null : _ref$j;\n      var w = this.w;\n\n      if (w.config.tooltip.custom !== undefined) {\n        this.handleCustomTooltip({\n          i: i,\n          j: j\n        });\n      } else {\n        this.toggleActiveInactiveSeries(shared);\n      }\n\n      var values = this.getValuesToPrint({\n        i: i,\n        j: j\n      });\n      this.printLabels({\n        i: i,\n        j: j,\n        values: values,\n        ttItems: ttItems,\n        shared: shared\n      }); // Re-calculate tooltip dimensions now that we have drawn the text\n\n      var tooltipEl = this.ttCtx.getElTooltip();\n      this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;\n      this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;\n    }\n  }, {\n    key: \"printLabels\",\n    value: function printLabels(_ref2) {\n      var i = _ref2.i,\n          j = _ref2.j,\n          values = _ref2.values,\n          ttItems = _ref2.ttItems,\n          shared = _ref2.shared;\n      var w = this.w;\n      var val;\n      var xVal = values.xVal,\n          zVal = values.zVal,\n          xAxisTTVal = values.xAxisTTVal;\n      var seriesName = '';\n      var pColor = w.globals.colors[i];\n\n      if (j !== null && w.config.plotOptions.bar.distributed) {\n        pColor = w.globals.colors[j];\n      }\n\n      for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {\n        var f = this.getFormatters(i);\n        seriesName = this.getSeriesName({\n          fn: f.yLbTitleFormatter,\n          index: i,\n          seriesIndex: i,\n          j: j\n        });\n\n        if (shared) {\n          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;\n          f = this.getFormatters(tIndex);\n          seriesName = this.getSeriesName({\n            fn: f.yLbTitleFormatter,\n            index: tIndex,\n            seriesIndex: i,\n            j: j\n          });\n          pColor = w.globals.colors[tIndex]; // for plot charts, not for pie/donuts\n\n          val = f.yLbFormatter(w.globals.series[tIndex][j], {\n            series: w.globals.series,\n            seriesIndex: tIndex,\n            dataPointIndex: j,\n            w: w\n          }); // discard 0 values in BARS\n\n          if (this.ttCtx.hasBars() && w.config.chart.stacked && w.globals.series[tIndex][j] === 0 || typeof w.globals.series[tIndex][j] === 'undefined') {\n            val = undefined;\n          }\n        } else {\n          val = f.yLbFormatter(w.globals.series[i][j], {\n            series: w.globals.series,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        } // for pie / donuts\n\n\n        if (j === null) {\n          val = f.yLbFormatter(w.globals.series[i], w);\n        }\n\n        this.DOMHandling({\n          t: t,\n          ttItems: ttItems,\n          values: {\n            val: val,\n            xVal: xVal,\n            xAxisTTVal: xAxisTTVal,\n            zVal: zVal\n          },\n          seriesName: seriesName,\n          shared: shared,\n          pColor: pColor\n        });\n      }\n    }\n  }, {\n    key: \"getFormatters\",\n    value: function getFormatters(i) {\n      var w = this.w;\n      var yLbFormatter = w.globals.yLabelFormatters[i];\n      var yLbTitleFormatter;\n\n      if (w.globals.ttVal !== undefined) {\n        if (Array.isArray(w.globals.ttVal)) {\n          yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;\n          yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;\n        } else {\n          yLbFormatter = w.globals.ttVal.formatter;\n\n          if (typeof w.globals.ttVal.title.formatter === 'function') {\n            yLbTitleFormatter = w.globals.ttVal.title.formatter;\n          }\n        }\n      } else {\n        yLbTitleFormatter = w.config.tooltip.y.title.formatter;\n      }\n\n      if (typeof yLbFormatter !== 'function') {\n        if (w.globals.yLabelFormatters[0]) {\n          yLbFormatter = w.globals.yLabelFormatters[0];\n        } else {\n          yLbFormatter = function yLbFormatter(label) {\n            return label;\n          };\n        }\n      }\n\n      if (typeof yLbTitleFormatter !== 'function') {\n        yLbTitleFormatter = function yLbTitleFormatter(label) {\n          return label;\n        };\n      }\n\n      return {\n        yLbFormatter: yLbFormatter,\n        yLbTitleFormatter: yLbTitleFormatter\n      };\n    }\n  }, {\n    key: \"getSeriesName\",\n    value: function getSeriesName(_ref3) {\n      var fn = _ref3.fn,\n          index = _ref3.index,\n          seriesIndex = _ref3.seriesIndex,\n          j = _ref3.j;\n      var w = this.w;\n      return fn(String(w.globals.seriesNames[index]), {\n        series: w.globals.series,\n        seriesIndex: seriesIndex,\n        dataPointIndex: j,\n        w: w\n      });\n    }\n  }, {\n    key: \"DOMHandling\",\n    value: function DOMHandling(_ref4) {\n      var t = _ref4.t,\n          ttItems = _ref4.ttItems,\n          values = _ref4.values,\n          seriesName = _ref4.seriesName,\n          shared = _ref4.shared,\n          pColor = _ref4.pColor;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var val = values.val,\n          xVal = values.xVal,\n          xAxisTTVal = values.xAxisTTVal,\n          zVal = values.zVal;\n      var ttItemsChildren = null;\n      ttItemsChildren = ttItems[t].children;\n\n      if (w.config.tooltip.fillSeriesColor) {\n        //  elTooltip.style.backgroundColor = pColor\n        ttItems[t].style.backgroundColor = pColor;\n        ttItemsChildren[0].style.display = 'none';\n      }\n\n      if (ttCtx.showTooltipTitle) {\n        if (ttCtx.tooltipTitle === null) {\n          // get it once if null, and store it in class property\n          ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');\n        }\n\n        ttCtx.tooltipTitle.innerHTML = xVal;\n      } // if xaxis tooltip is constructed, we need to replace the innerHTML\n\n\n      if (ttCtx.blxaxisTooltip) {\n        ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;\n      }\n\n      var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label');\n\n      if (ttYLabel) {\n        ttYLabel.innerHTML = seriesName ? seriesName + ': ' : '';\n      }\n\n      var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value');\n\n      if (ttYVal) {\n        ttYVal.innerHTML = val;\n      }\n\n      if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {\n        ttItemsChildren[0].style.backgroundColor = pColor;\n      }\n\n      if (!w.config.tooltip.marker.show) {\n        ttItemsChildren[0].style.display = 'none';\n      }\n\n      if (zVal !== null) {\n        var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');\n        ttZLabel.innerHTML = w.config.tooltip.z.title;\n        var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');\n        ttZVal.innerHTML = zVal;\n      }\n\n      if (shared && ttItemsChildren[0]) {\n        // hide when no Val or series collapsed\n        if (typeof val === 'undefined' || val === null || w.globals.collapsedSeriesIndices.indexOf(t) > -1) {\n          ttItemsChildren[0].parentNode.style.display = 'none';\n        } else {\n          ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;\n        }\n      }\n    }\n  }, {\n    key: \"toggleActiveInactiveSeries\",\n    value: function toggleActiveInactiveSeries(shared) {\n      var w = this.w;\n\n      if (shared) {\n        // make all tooltips active\n        this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');\n      } else {\n        // disable all tooltip text groups\n        this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); // enable the first tooltip text group\n\n        var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group');\n\n        if (firstTooltipSeriesGroup) {\n          firstTooltipSeriesGroup.classList.add('active');\n          firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;\n        }\n      }\n    }\n  }, {\n    key: \"getValuesToPrint\",\n    value: function getValuesToPrint(_ref5) {\n      var i = _ref5.i,\n          j = _ref5.j;\n      var w = this.w;\n      var filteredSeriesX = this.ctx.series.filteredSeriesX();\n      var xVal = '';\n      var xAxisTTVal = '';\n      var zVal = null;\n      var val = null;\n      var customFormatterOpts = {\n        series: w.globals.series,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      };\n      var zFormatter = w.globals.ttZFormatter;\n\n      if (j === null) {\n        val = w.globals.series[i];\n      } else {\n        if (w.globals.isXNumeric) {\n          xVal = filteredSeriesX[i][j];\n\n          if (filteredSeriesX[i].length === 0) {\n            // a series (possibly the first one) might be collapsed, so get the next active index\n            var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);\n            xVal = filteredSeriesX[firstActiveSeriesIndex][j];\n          }\n        } else {\n          xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';\n        }\n      }\n\n      var bufferXVal = xVal;\n\n      if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {\n        var xFormat = new Formatters(this.ctx);\n        xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal);\n      } else {\n        xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);\n      } // override default x-axis formatter with tooltip formatter\n\n\n      if (w.config.tooltip.x.formatter !== undefined) {\n        xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);\n      }\n\n      if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[0].length > 0) {\n        zVal = zFormatter(w.globals.seriesZ[i][j], w);\n      }\n\n      if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n        xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);\n      } else {\n        xAxisTTVal = xVal;\n      }\n\n      return {\n        val: val,\n        xVal: xVal,\n        xAxisTTVal: xAxisTTVal,\n        zVal: zVal\n      };\n    }\n  }, {\n    key: \"handleCustomTooltip\",\n    value: function handleCustomTooltip(_ref6) {\n      var i = _ref6.i,\n          j = _ref6.j;\n      var w = this.w;\n      var tooltipEl = this.ttCtx.getElTooltip(); // override everything with a custom html tooltip and replace it\n\n      tooltipEl.innerHTML = w.config.tooltip.custom({\n        ctx: this.ctx,\n        series: w.globals.series,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      });\n    }\n  }]);\n\n  return Labels;\n}();\n\n/**\n * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.\n *\n * @module Tooltip.Position\n **/\n\nvar Position =\n/*#__PURE__*/\nfunction () {\n  function Position(tooltipContext) {\n    _classCallCheck(this, Position);\n\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n    this.w = tooltipContext.w;\n  }\n  /**\n   * This will move the crosshair (the vertical/horz line that moves along with mouse)\n   * Along with this, this function also calls the xaxisMove function\n   * @memberof Position\n   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n   */\n\n\n  _createClass(Position, [{\n    key: \"moveXCrosshairs\",\n    value: function moveXCrosshairs(cx) {\n      var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n      var xcrosshairs = ttCtx.getElXCrosshairs();\n      var x = cx - ttCtx.xcrosshairsWidth / 2;\n      var tickAmount = w.globals.labels.slice().length;\n\n      if (j !== null) {\n        x = w.globals.gridWidth / tickAmount * j;\n      }\n\n      if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {\n        if (x + ttCtx.xcrosshairsWidth > w.globals.gridWidth) {\n          x = w.globals.gridWidth - ttCtx.xcrosshairsWidth;\n        }\n      } else {\n        if (j !== null) {\n          x = x + w.globals.gridWidth / tickAmount / 2;\n        }\n      }\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      if (x > w.globals.gridWidth) {\n        x = w.globals.gridWidth;\n      }\n\n      if (xcrosshairs !== null) {\n        xcrosshairs.setAttribute('x', x);\n        xcrosshairs.setAttribute('x1', x);\n        xcrosshairs.setAttribute('x2', x);\n        xcrosshairs.setAttribute('y2', w.globals.gridHeight);\n        xcrosshairs.classList.add('active');\n      }\n\n      if (ttCtx.blxaxisTooltip) {\n        var tx = x;\n\n        if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {\n          tx = x + ttCtx.xcrosshairsWidth / 2;\n        }\n\n        this.moveXAxisTooltip(tx);\n      }\n    }\n    /**\n     * This will move the crosshair (the vertical/horz line that moves along with mouse)\n     * Along with this, this function also calls the xaxisMove function\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n     */\n\n  }, {\n    key: \"moveYCrosshairs\",\n    value: function moveYCrosshairs(cy) {\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.ycrosshairs !== null) {\n        Graphics.setAttrs(ttCtx.ycrosshairs, {\n          y1: cy,\n          y2: cy\n        });\n        Graphics.setAttrs(ttCtx.ycrosshairsHidden, {\n          y1: cy,\n          y2: cy\n        });\n      }\n    }\n    /**\n     ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move\n     */\n\n  }, {\n    key: \"moveXAxisTooltip\",\n    value: function moveXAxisTooltip(cx) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.xaxisTooltip !== null) {\n        ttCtx.xaxisTooltip.classList.add('active');\n        var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;\n        var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();\n        var xaxisTTTextWidth = xaxisTTText.width;\n        cx = cx - xaxisTTTextWidth / 2;\n\n        if (!isNaN(cx)) {\n          cx = cx + w.globals.translateX;\n          var textRect = 0;\n          var graphics = new Graphics(this.ctx);\n          textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);\n          ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';\n          ttCtx.xaxisTooltip.style.left = cx + 'px';\n          ttCtx.xaxisTooltip.style.top = cy + 'px';\n        }\n      }\n    }\n  }, {\n    key: \"moveYAxisTooltip\",\n    value: function moveYAxisTooltip(index) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.yaxisTTEls === null) {\n        ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n      }\n\n      var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'));\n      var cy = w.globals.translateY + ycrosshairsHiddenRectY1;\n      var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();\n      var yAxisTTHeight = yAxisTTRect.height;\n      var cx = w.globals.translateYAxisX[index] - 2;\n\n      if (w.config.yaxis[index].opposite) {\n        cx = cx - 26;\n      }\n\n      cy = cy - yAxisTTHeight / 2;\n\n      if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {\n        ttCtx.yaxisTTEls[index].classList.add('active');\n        ttCtx.yaxisTTEls[index].style.top = cy + 'px';\n        ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';\n      } else {\n        ttCtx.yaxisTTEls[index].classList.remove('active');\n      }\n    }\n    /**\n     ** moves the whole tooltip by changing x, y attrs\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip\n     * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip\n     * @param {int} - r = point's radius\n     */\n\n  }, {\n    key: \"moveTooltip\",\n    value: function moveTooltip(cx, cy) {\n      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var tooltipEl = ttCtx.getElTooltip();\n      var tooltipRect = ttCtx.tooltipRect;\n      var pointR = r !== null ? parseInt(r) : 1;\n      var x = parseInt(cx) + pointR + 5;\n      var y = parseInt(cy) + pointR / 2; // - tooltipRect.ttHeight / 2\n\n      if (x > w.globals.gridWidth / 2) {\n        x = x - tooltipRect.ttWidth - pointR - 15;\n      }\n\n      if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {\n        x = w.globals.gridWidth - tooltipRect.ttWidth;\n      }\n\n      if (x < -20) {\n        x = -20;\n      }\n\n      if (w.config.tooltip.followCursor) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top - tooltipRect.ttHeight / 2;\n      }\n\n      var newPositions = this.positionChecks(tooltipRect, x, y);\n      x = newPositions.x;\n      y = newPositions.y;\n\n      if (!isNaN(x)) {\n        x = x + w.globals.translateX;\n        tooltipEl.style.left = x + 'px';\n        tooltipEl.style.top = y + 'px';\n      }\n    }\n  }, {\n    key: \"positionChecks\",\n    value: function positionChecks(tooltipRect, x, y) {\n      var w = this.w;\n\n      if (tooltipRect.ttHeight + y > w.globals.gridHeight) {\n        y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;\n      }\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"moveMarkers\",\n    value: function moveMarkers(i, j) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (w.globals.markers.size[i] > 0) {\n        var allPoints = w.globals.dom.baseEl.querySelectorAll(\" .apexcharts-series[data\\\\:realIndex='\".concat(i, \"'] .apexcharts-marker\"));\n\n        for (var p = 0; p < allPoints.length; p++) {\n          if (parseInt(allPoints[p].getAttribute('rel')) === j) {\n            ttCtx.marker.resetPointsSize();\n            ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);\n          }\n        }\n      } else {\n        ttCtx.marker.resetPointsSize();\n        this.moveDynamicPointOnHover(j, i);\n      }\n    } // This function is used when you need to show markers/points only on hover -\n    // DIFFERENT X VALUES in multiple series\n\n  }, {\n    key: \"moveDynamicPointOnHover\",\n    value: function moveDynamicPointOnHover(j, capturedSeries) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var cx = 0;\n      var cy = 0;\n      var pointsArr = w.globals.pointsArray;\n      var hoverSize = w.config.markers.hover.size;\n\n      if (hoverSize === undefined) {\n        hoverSize = w.globals.markers.size[capturedSeries] + w.config.markers.hover.sizeOffset;\n      }\n\n      cx = pointsArr[capturedSeries][j][0];\n      cy = pointsArr[capturedSeries][j][1] ? pointsArr[capturedSeries][j][1] : 0;\n      var point = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(capturedSeries, \"'] .apexcharts-series-markers circle\"));\n\n      if (point) {\n        point.setAttribute('r', hoverSize);\n        point.setAttribute('cx', cx);\n        point.setAttribute('cy', cy);\n      } // point.style.opacity = w.config.markers.hover.opacity\n\n\n      this.moveXCrosshairs(cx);\n\n      if (!ttCtx.fixedTooltip) {\n        this.moveTooltip(cx, cy, hoverSize);\n      }\n    } // This function is used when you need to show markers/points only on hover -\n    // SAME X VALUES in multiple series\n\n  }, {\n    key: \"moveDynamicPointsOnHover\",\n    value: function moveDynamicPointsOnHover(j) {\n      var ttCtx = this.ttCtx;\n      var w = ttCtx.w;\n      var cx = 0;\n      var cy = 0;\n      var activeSeries = 0;\n      var pointsArr = w.globals.pointsArray;\n      var series = new Series(this.ctx);\n      activeSeries = series.getActiveSeriesIndex();\n      var hoverSize = w.config.markers.hover.size;\n\n      if (hoverSize === undefined) {\n        hoverSize = w.globals.markers.size[activeSeries] + w.config.markers.hover.sizeOffset;\n      }\n\n      if (pointsArr[activeSeries]) {\n        cx = pointsArr[activeSeries][j][0];\n        cy = pointsArr[activeSeries][j][1];\n      }\n\n      var points = null;\n      var allPoints = ttCtx.getAllMarkers();\n\n      if (allPoints !== null) {\n        points = allPoints;\n      } else {\n        points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle');\n      }\n\n      if (points !== null) {\n        for (var p = 0; p < points.length; p++) {\n          var pointArr = pointsArr[p];\n\n          if (pointArr && pointArr.length) {\n            var pcy = pointsArr[p][j][1];\n            points[p].setAttribute('cx', cx);\n            var realIndex = parseInt(points[p].parentNode.parentNode.parentNode.getAttribute('data:realIndex'));\n\n            if (pcy !== null) {\n              points[realIndex] && points[realIndex].setAttribute('r', hoverSize);\n              points[realIndex] && points[realIndex].setAttribute('cy', pcy);\n            } else {\n              points[realIndex] && points[realIndex].setAttribute('r', 0);\n            }\n          }\n        }\n      }\n\n      this.moveXCrosshairs(cx);\n\n      if (!ttCtx.fixedTooltip) {\n        var tcy = cy || w.globals.gridHeight;\n        this.moveTooltip(cx, tcy, hoverSize);\n      }\n    }\n  }, {\n    key: \"moveStickyTooltipOverBars\",\n    value: function moveStickyTooltipOverBars(j) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var jBar = w.globals.dom.baseEl.querySelector(\".apexcharts-bar-series .apexcharts-series[rel='1'] path[j='\".concat(j, \"'], .apexcharts-candlestick-series .apexcharts-series[rel='1'] path[j='\").concat(j, \"'], .apexcharts-rangebar-series .apexcharts-series[rel='1'] path[j='\").concat(j, \"']\"));\n      var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;\n      var bcy = 0;\n      var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;\n\n      if (w.globals.isXNumeric) {\n        bcx = bcx - bw / 2;\n      } else {\n        bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;\n\n        if (isNaN(bcx)) {\n          bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;\n        }\n      } // tooltip will move vertically along with mouse as it is a shared tooltip\n\n\n      var elGrid = ttCtx.getElGrid();\n      var seriesBound = elGrid.getBoundingClientRect();\n      bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;\n      this.moveXCrosshairs(bcx);\n\n      if (!ttCtx.fixedTooltip) {\n        var tcy = bcy || w.globals.gridHeight;\n        this.moveTooltip(bcx, tcy);\n      }\n    }\n  }]);\n\n  return Position;\n}();\n\n/**\n * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.\n *\n * @module Tooltip.Marker\n **/\n\nvar Marker =\n/*#__PURE__*/\nfunction () {\n  function Marker(tooltipContext) {\n    _classCallCheck(this, Marker);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n    this.tooltipPosition = new Position(tooltipContext);\n  }\n\n  _createClass(Marker, [{\n    key: \"drawDynamicPoints\",\n    value: function drawDynamicPoints() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var marker = new Markers(this.ctx);\n      var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n\n      for (var i = 0; i < elsSeries.length; i++) {\n        var seriesIndex = parseInt(elsSeries[i].getAttribute('data:realIndex'));\n        var pointsMain = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesIndex, \"'] .apexcharts-series-markers-wrap\"));\n\n        if (pointsMain !== null) {\n          // it can be null as we have tooltips in donut/bar charts\n          var point = void 0;\n          var PointClasses = \"apexcharts-marker w\".concat((Math.random() + 1).toString(36).substring(4));\n\n          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n            PointClasses += ' no-pointer-events';\n          }\n\n          var elPointOptions = marker.getMarkerConfig(PointClasses, seriesIndex);\n          point = graphics.drawMarker(0, 0, elPointOptions);\n          point.node.setAttribute('default-marker-size', 0);\n          var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');\n          elPointsG.classList.add('apexcharts-series-markers');\n          elPointsG.appendChild(point.node);\n          pointsMain.appendChild(elPointsG);\n        }\n      }\n    }\n  }, {\n    key: \"enlargeCurrentPoint\",\n    value: function enlargeCurrentPoint(rel, point) {\n      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var w = this.w;\n\n      if (w.config.chart.type !== 'bubble') {\n        this.newPointSize(rel, point);\n      }\n\n      var cx = point.getAttribute('cx');\n      var cy = point.getAttribute('cy');\n\n      if (x !== null && y !== null) {\n        cx = x;\n        cy = y;\n      }\n\n      this.tooltipPosition.moveXCrosshairs(cx);\n\n      if (!this.fixedTooltip) {\n        if (w.config.chart.type === 'radar') {\n          var elGrid = this.ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          cx = this.ttCtx.e.clientX - seriesBound.left;\n        }\n\n        this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);\n      }\n    }\n  }, {\n    key: \"enlargePoints\",\n    value: function enlargePoints(j) {\n      var w = this.w;\n      var me = this;\n      var ttCtx = this.ttCtx;\n      var col = j;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n      var newSize = w.config.markers.hover.size;\n\n      for (var p = 0; p < points.length; p++) {\n        var rel = points[p].getAttribute('rel');\n        var index = points[p].getAttribute('index');\n\n        if (newSize === undefined) {\n          newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n        }\n\n        if (col === parseInt(rel)) {\n          me.newPointSize(col, points[p]);\n          var cx = points[p].getAttribute('cx');\n          var cy = points[p].getAttribute('cy');\n          me.tooltipPosition.moveXCrosshairs(cx);\n\n          if (!ttCtx.fixedTooltip) {\n            me.tooltipPosition.moveTooltip(cx, cy, newSize);\n          }\n        } else {\n          me.oldPointSize(points[p]);\n        }\n      }\n    }\n  }, {\n    key: \"newPointSize\",\n    value: function newPointSize(rel, point) {\n      var w = this.w;\n      var newSize = w.config.markers.hover.size;\n      var elPoint = null;\n\n      if (rel === 0) {\n        elPoint = point.parentNode.firstChild;\n      } else {\n        elPoint = point.parentNode.lastChild;\n      }\n\n      var index = parseInt(elPoint.getAttribute('index'));\n\n      if (newSize === undefined) {\n        newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n      }\n\n      elPoint.setAttribute('r', newSize);\n    }\n  }, {\n    key: \"oldPointSize\",\n    value: function oldPointSize(point) {\n      var size = parseInt(point.getAttribute('default-marker-size'));\n      point.setAttribute('r', size);\n    }\n  }, {\n    key: \"resetPointsSize\",\n    value: function resetPointsSize() {\n      var w = this.w;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n\n      for (var p = 0; p < points.length; p++) {\n        var size = parseInt(points[p].getAttribute('default-marker-size'));\n\n        if (Utils.isNumber(size)) {\n          points[p].setAttribute('r', size);\n        } else {\n          points[p].setAttribute('r', 0);\n        }\n      }\n    }\n  }]);\n\n  return Marker;\n}();\n\n/**\n * ApexCharts Tooltip.Intersect Class.\n *\n * @module Tooltip.Intersect\n **/\n\nvar Intersect =\n/*#__PURE__*/\nfunction () {\n  function Intersect(tooltipContext) {\n    _classCallCheck(this, Intersect);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n  }\n\n  _createClass(Intersect, [{\n    key: \"getAttr\",\n    value: function getAttr(e, attr) {\n      return parseFloat(e.target.getAttribute(attr));\n    }\n  }, {\n    key: \"handleHeatTooltip\",\n    value: function handleHeatTooltip(_ref) {\n      var e = _ref.e,\n          opt = _ref.opt,\n          x = _ref.x,\n          y = _ref.y;\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n\n      if (e.target.classList.contains('apexcharts-heatmap-rect')) {\n        var i = this.getAttr(e, 'i');\n        var j = this.getAttr(e, 'j');\n        var cx = this.getAttr(e, 'cx');\n        var cy = this.getAttr(e, 'cy');\n        var width = this.getAttr(e, 'width');\n        var height = this.getAttr(e, 'height');\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: false\n        });\n        x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;\n        y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;\n        ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);\n\n        if (x > w.globals.gridWidth / 2) {\n          x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;\n        }\n\n        if (ttCtx.w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect(); // x = ttCtx.e.clientX - seriesBound.left\n\n          y = ttCtx.e.clientY - seriesBound.top + w.globals.translateY / 2 - 10;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"handleMarkerTooltip\",\n    value: function handleMarkerTooltip(_ref2) {\n      var e = _ref2.e,\n          opt = _ref2.opt,\n          x = _ref2.x,\n          y = _ref2.y;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var i;\n      var j;\n\n      if (e.target.classList.contains('apexcharts-marker')) {\n        var cx = parseInt(opt.paths.getAttribute('cx'));\n        var cy = parseInt(opt.paths.getAttribute('cy'));\n        var val = parseFloat(opt.paths.getAttribute('val'));\n        j = parseInt(opt.paths.getAttribute('rel'));\n        i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel')) - 1;\n\n        if (ttCtx.intersect) {\n          var el = Utils.findAncestor(opt.paths, 'apexcharts-series');\n\n          if (el) {\n            i = parseInt(el.getAttribute('data:realIndex'));\n          }\n        }\n\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared\n        });\n\n        if (e.type === 'mouseup') {\n          ttCtx.markerClick(e, i, j);\n        }\n\n        x = cx;\n        y = cy + w.globals.translateY - ttCtx.tooltipRect.ttHeight * 1.4;\n\n        if (ttCtx.w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;\n        }\n\n        if (val < 0) {\n          y = cy;\n        }\n\n        ttCtx.marker.enlargeCurrentPoint(j, opt.paths, x, y);\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"handleBarTooltip\",\n    value: function handleBarTooltip(_ref3) {\n      var e = _ref3.e,\n          opt = _ref3.opt;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var tooltipEl = ttCtx.getElTooltip();\n      var bx = 0;\n      var x = 0;\n      var y = 0; // let bW = 0\n\n      var i = 0;\n      var strokeWidth;\n      var barXY = this.getBarTooltipXY({\n        e: e,\n        opt: opt\n      });\n      i = barXY.i;\n      var barHeight = barXY.barHeight;\n      var j = barXY.j;\n\n      if (w.globals.isBarHorizontal && ttCtx.hasBars() || !w.config.tooltip.shared) {\n        x = barXY.x;\n        y = barXY.y;\n        strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width; // bW = barXY.barWidth\n\n        bx = x;\n      } else {\n        if (!w.globals.comboCharts && !w.config.tooltip.shared) {\n          bx = bx / 2;\n        }\n      } // y is NaN, make it touch the bottom of grid area\n\n\n      if (isNaN(y)) {\n        y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;\n      } // x exceeds gridWidth\n\n\n      if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth) {\n        x = x - ttCtx.tooltipRect.ttWidth;\n      } else if (x < 0) {\n        x = x + ttCtx.tooltipRect.ttWidth;\n      }\n\n      if (ttCtx.w.config.tooltip.followCursor) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        y = ttCtx.e.clientY - seriesBound.top;\n      } // if tooltip is still null, querySelector\n\n\n      if (ttCtx.tooltip === null) {\n        ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n      }\n\n      if (!w.config.tooltip.shared) {\n        if (w.globals.comboChartsHasBars) {\n          ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);\n        } else {\n          ttCtx.tooltipPosition.moveXCrosshairs(bx);\n        }\n      } // move tooltip here\n\n\n      if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || w.globals.isBarHorizontal && ttCtx.hasBars())) {\n        if (isReversed) {\n          x = w.globals.gridWidth - x;\n        }\n\n        tooltipEl.style.left = x + w.globals.translateX + 'px';\n        var seriesIndex = parseInt(opt.paths.parentNode.getAttribute('data:realIndex'));\n        var isReversed = w.globals.isMultipleYAxis ? w.config.yaxis[seriesIndex] && w.config.yaxis[seriesIndex].reversed : w.config.yaxis[0].reversed;\n\n        if (isReversed && !(w.globals.isBarHorizontal && ttCtx.hasBars())) {\n          y = y + barHeight - (w.globals.series[i][j] < 0 ? barHeight : 0) * 2;\n        }\n\n        if (ttCtx.tooltipRect.ttHeight + y > w.globals.gridHeight) {\n          y = w.globals.gridHeight - ttCtx.tooltipRect.ttHeight + w.globals.translateY;\n          tooltipEl.style.top = y + 'px';\n        } else {\n          tooltipEl.style.top = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2 + 'px';\n        }\n      }\n    }\n  }, {\n    key: \"getBarTooltipXY\",\n    value: function getBarTooltipXY(_ref4) {\n      var e = _ref4.e,\n          opt = _ref4.opt;\n      var w = this.w;\n      var j = null;\n      var ttCtx = this.ttCtx;\n      var i = 0;\n      var x = 0;\n      var y = 0;\n      var barWidth = 0;\n      var barHeight = 0;\n      var cl = e.target.classList;\n\n      if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area') || cl.contains('apexcharts-rangebar-area')) {\n        var bar = e.target;\n        var barRect = bar.getBoundingClientRect();\n        var seriesBound = opt.elGrid.getBoundingClientRect();\n        var bh = barRect.height;\n        barHeight = barRect.height;\n        var bw = barRect.width;\n        var cx = parseInt(bar.getAttribute('cx'));\n        var cy = parseInt(bar.getAttribute('cy'));\n        barWidth = parseFloat(bar.getAttribute('barWidth'));\n        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n        j = parseInt(bar.getAttribute('j'));\n        i = parseInt(bar.parentNode.getAttribute('rel')) - 1;\n\n        if (w.globals.comboCharts) {\n          i = parseInt(bar.parentNode.getAttribute('data:realIndex'));\n        } // if (w.config.tooltip.shared) {\n        // this check not needed  at the moment\n        //   const yDivisor = w.globals.gridHeight / (w.globals.series.length)\n        //   const hoverY = ttCtx.clientY - ttCtx.seriesBound.top\n        //   j = Math.ceil(hoverY / yDivisor)\n        // }\n\n\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared\n        });\n\n        if (w.config.tooltip.followCursor) {\n          if (w.globals.isBarHorizontal) {\n            x = clientX - seriesBound.left + 15;\n            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;\n          } else {\n            if (w.globals.isXNumeric) {\n              x = cx - bw / 2;\n            } else {\n              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;\n            }\n\n            y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;\n          }\n        } else {\n          if (w.globals.isBarHorizontal) {\n            x = cx;\n\n            if (x < ttCtx.xyRatios.baseLineInvertedY) {\n              x = cx - ttCtx.tooltipRect.ttWidth;\n            }\n\n            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;\n          } else {\n            // if columns\n            if (w.globals.isXNumeric) {\n              x = cx - bw / 2;\n            } else {\n              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;\n            }\n\n            y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        i: i,\n        j: j\n      };\n    }\n  }]);\n\n  return Intersect;\n}();\n\n/**\n * ApexCharts Tooltip.AxesTooltip Class.\n *\n * @module Tooltip.AxesTooltip\n **/\nvar AxesTooltip =\n/*#__PURE__*/\nfunction () {\n  function AxesTooltip(tooltipContext) {\n    _classCallCheck(this, AxesTooltip);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n  }\n  /**\n   * This method adds the secondary tooltip which appears below x axis\n   * @memberof Tooltip\n   **/\n\n\n  _createClass(AxesTooltip, [{\n    key: \"drawXaxisTooltip\",\n    value: function drawXaxisTooltip() {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var isBottom = w.config.xaxis.position === 'bottom';\n      ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : 1;\n      var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';\n      var renderTo = w.globals.dom.elWrap;\n\n      if (ttCtx.blxaxisTooltip) {\n        var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');\n\n        if (xaxisTooltip === null) {\n          ttCtx.xaxisTooltip = document.createElement('div');\n          ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass + ' ' + w.config.tooltip.theme);\n          renderTo.appendChild(ttCtx.xaxisTooltip);\n          ttCtx.xaxisTooltipText = document.createElement('div');\n          ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');\n          ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;\n          ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;\n          ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);\n        }\n      }\n    }\n    /**\n     * This method adds the secondary tooltip which appears below x axis\n     * @memberof Tooltip\n     **/\n\n  }, {\n    key: \"drawYaxisTooltip\",\n    value: function drawYaxisTooltip() {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      for (var i = 0; i < w.config.yaxis.length; i++) {\n        var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;\n        ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;\n        var tooltipCssClass = isRight ? \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-right\") : \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-left\");\n        var renderTo = w.globals.dom.elWrap;\n\n        if (ttCtx.blyaxisTooltip) {\n          var yaxisTooltip = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i));\n\n          if (yaxisTooltip === null) {\n            ttCtx.yaxisTooltip = document.createElement('div');\n            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass + ' ' + w.config.tooltip.theme);\n            renderTo.appendChild(ttCtx.yaxisTooltip);\n            if (i === 0) ttCtx.yaxisTooltipText = [];\n            ttCtx.yaxisTooltipText.push(document.createElement('div'));\n            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');\n            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);\n          }\n        }\n      }\n    }\n    /**\n     * @memberof Tooltip\n     **/\n\n  }, {\n    key: \"setXCrosshairWidth\",\n    value: function setXCrosshairWidth() {\n      var w = this.w;\n      var ttCtx = this.ttCtx; // set xcrosshairs width\n\n      var xcrosshairs = ttCtx.getElXCrosshairs();\n      ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width);\n\n      if (!w.globals.comboCharts) {\n        if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n          var count = w.globals.labels.length;\n          ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;\n        } else if (w.config.xaxis.crosshairs.width === 'barWidth') {\n          var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n          if (bar !== null) {\n            var barWidth = parseFloat(bar.getAttribute('barWidth'));\n            ttCtx.xcrosshairsWidth = barWidth;\n          } else {\n            ttCtx.xcrosshairsWidth = 1;\n          }\n        }\n      } else {\n        var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n        if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {\n          var _barWidth = parseFloat(_bar.getAttribute('barWidth'));\n\n          ttCtx.xcrosshairsWidth = _barWidth;\n        } else {\n          if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n            var _count = w.globals.labels.length;\n            ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;\n          }\n        }\n      }\n\n      if (w.globals.isBarHorizontal) {\n        ttCtx.xcrosshairsWidth = 0;\n      }\n\n      if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {\n        xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);\n      }\n    }\n  }, {\n    key: \"handleYCrosshair\",\n    value: function handleYCrosshair() {\n      var w = this.w;\n      var ttCtx = this.ttCtx; // set ycrosshairs height\n\n      ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');\n      ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');\n    }\n  }, {\n    key: \"drawYaxisTooltipText\",\n    value: function drawYaxisTooltipText(index, clientY, xyRatios) {\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n      var lbFormatter = w.globals.yLabelFormatters[index];\n\n      if (ttCtx.blyaxisTooltip) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[index];\n        var height = w.globals.maxYArr[index] - w.globals.minYArr[index];\n        var val = w.globals.minYArr[index] + (height - hoverY);\n        ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);\n        ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);\n        ttCtx.tooltipPosition.moveYAxisTooltip(index);\n      }\n    }\n  }]);\n\n  return AxesTooltip;\n}();\n\n/**\n * ApexCharts Core Tooltip Class to handle the tooltip generation.\n *\n * @module Tooltip\n **/\n\nvar Tooltip =\n/*#__PURE__*/\nfunction () {\n  function Tooltip(ctx) {\n    _classCallCheck(this, Tooltip);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.tooltipUtil = new Utils$1(this);\n    this.tooltipLabels = new Labels(this);\n    this.tooltipPosition = new Position(this);\n    this.marker = new Marker(this);\n    this.intersect = new Intersect(this);\n    this.axesTooltip = new AxesTooltip(this);\n    this.showOnIntersect = w.config.tooltip.intersect;\n    this.showTooltipTitle = w.config.tooltip.x.show;\n    this.fixedTooltip = w.config.tooltip.fixed.enabled;\n    this.xaxisTooltip = null;\n    this.yaxisTTEls = null;\n    this.isBarShared = !w.globals.isBarHorizontal && w.config.tooltip.shared;\n  }\n\n  _createClass(Tooltip, [{\n    key: \"getElTooltip\",\n    value: function getElTooltip(ctx) {\n      if (!ctx) ctx = this;\n      return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n    }\n  }, {\n    key: \"getElXCrosshairs\",\n    value: function getElXCrosshairs() {\n      return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');\n    }\n  }, {\n    key: \"getElGrid\",\n    value: function getElGrid() {\n      return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n    }\n  }, {\n    key: \"drawTooltip\",\n    value: function drawTooltip(xyRatios) {\n      var w = this.w;\n      this.xyRatios = xyRatios;\n      this.blxaxisTooltip = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;\n      this.blyaxisTooltip = w.config.yaxis[0].tooltip.enabled && w.globals.axisCharts;\n      this.allTooltipSeriesGroups = [];\n\n      if (!w.globals.axisCharts) {\n        this.showTooltipTitle = false;\n      }\n\n      var tooltipEl = document.createElement('div');\n      tooltipEl.classList.add('apexcharts-tooltip');\n      tooltipEl.classList.add(w.config.tooltip.theme);\n      w.globals.dom.elWrap.appendChild(tooltipEl);\n\n      if (w.globals.axisCharts) {\n        this.axesTooltip.drawXaxisTooltip();\n        this.axesTooltip.drawYaxisTooltip();\n        this.axesTooltip.setXCrosshairWidth();\n        this.axesTooltip.handleYCrosshair();\n        var xAxis = new XAxis(this.ctx);\n        this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();\n      } // we forcefully set intersect true for these conditions\n\n\n      if (w.globals.comboCharts && !w.config.tooltip.shared || w.config.tooltip.intersect && !w.config.tooltip.shared || (w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') && !w.config.tooltip.shared) {\n        this.showOnIntersect = true;\n      }\n\n      if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {\n        // when user don't want to show points all the time, but only on when hovering on series\n        this.marker.drawDynamicPoints(this);\n      } // no visible series, exit\n\n\n      if (w.globals.collapsedSeries.length === w.globals.series.length) return;\n      this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n      this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n\n      if (this.showTooltipTitle) {\n        this.tooltipTitle = document.createElement('div');\n        this.tooltipTitle.classList.add('apexcharts-tooltip-title');\n        this.tooltipTitle.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;\n        this.tooltipTitle.style.fontSize = w.config.tooltip.style.fontSize;\n        tooltipEl.appendChild(this.tooltipTitle);\n      }\n\n      var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared\n\n      if ((w.globals.xyCharts || w.globals.comboCharts) && w.config.tooltip.shared) {\n        if (!this.showOnIntersect) {\n          ttItemsCnt = w.globals.series.length;\n        } else {\n          ttItemsCnt = 1;\n        }\n      }\n\n      this.ttItems = this.createTTElements(ttItemsCnt);\n      this.addSVGEvents();\n    }\n  }, {\n    key: \"createTTElements\",\n    value: function createTTElements(ttItemsCnt) {\n      var w = this.w;\n      var ttItems = [];\n      var tooltipEl = this.getElTooltip();\n\n      for (var i = 0; i < ttItemsCnt; i++) {\n        var gTxt = document.createElement('div');\n        gTxt.classList.add('apexcharts-tooltip-series-group');\n        var point = document.createElement('span');\n        point.classList.add('apexcharts-tooltip-marker');\n        point.style.backgroundColor = w.globals.colors[i];\n        gTxt.appendChild(point);\n        var gYZ = document.createElement('div');\n        gYZ.classList.add('apexcharts-tooltip-text');\n        gYZ.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;\n        gYZ.style.fontSize = w.config.tooltip.style.fontSize; // y values group\n\n        var gYValText = document.createElement('div');\n        gYValText.classList.add('apexcharts-tooltip-y-group');\n        var txtLabel = document.createElement('span');\n        txtLabel.classList.add('apexcharts-tooltip-text-label');\n        gYValText.appendChild(txtLabel);\n        var txtValue = document.createElement('span');\n        txtValue.classList.add('apexcharts-tooltip-text-value');\n        gYValText.appendChild(txtValue); // z values group\n\n        var gZValText = document.createElement('div');\n        gZValText.classList.add('apexcharts-tooltip-z-group');\n        var txtZLabel = document.createElement('span');\n        txtZLabel.classList.add('apexcharts-tooltip-text-z-label');\n        gZValText.appendChild(txtZLabel);\n        var txtZValue = document.createElement('span');\n        txtZValue.classList.add('apexcharts-tooltip-text-z-value');\n        gZValText.appendChild(txtZValue);\n        gYZ.appendChild(gYValText);\n        gYZ.appendChild(gZValText);\n        gTxt.appendChild(gYZ);\n        tooltipEl.appendChild(gTxt);\n        ttItems.push(gTxt);\n      }\n\n      return ttItems;\n    }\n  }, {\n    key: \"addSVGEvents\",\n    value: function addSVGEvents() {\n      var w = this.w;\n      var type = w.config.chart.type;\n      var tooltipEl = this.getElTooltip();\n      var commonBar = !!(type === 'bar' || type === 'candlestick' || type === 'rangeBar');\n      var hoverArea = w.globals.dom.Paper.node;\n      var elGrid = this.getElGrid();\n\n      if (elGrid) {\n        this.seriesBound = elGrid.getBoundingClientRect();\n      }\n\n      var tooltipY = [];\n      var tooltipX = [];\n      var seriesHoverParams = {\n        hoverArea: hoverArea,\n        elGrid: elGrid,\n        tooltipEl: tooltipEl,\n        tooltipY: tooltipY,\n        tooltipX: tooltipX,\n        ttItems: this.ttItems\n      };\n      var points;\n\n      if (w.globals.axisCharts) {\n        if (type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble') {\n          points = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:longestSeries='true'] .apexcharts-marker\");\n        } else if (commonBar) {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area');\n        } else if (type === 'heatmap') {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap');\n        } else if (type === 'radar') {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-marker');\n        }\n\n        if (points && points.length) {\n          for (var p = 0; p < points.length; p++) {\n            tooltipY.push(points[p].getAttribute('cy'));\n            tooltipX.push(points[p].getAttribute('cx'));\n          }\n        }\n      }\n\n      var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || commonBar && this.hasBars() && w.config.tooltip.shared;\n\n      if (validSharedChartTypes) {\n        this.addPathsEventListeners([hoverArea], seriesHoverParams);\n      } else if (commonBar && !w.globals.comboCharts) {\n        this.addBarsEventListeners(seriesHoverParams);\n      } else if (type === 'bubble' || type === 'scatter' || type === 'radar' || this.showOnIntersect && (type === 'area' || type === 'line')) {\n        this.addPointsEventsListeners(seriesHoverParams);\n      } else if (!w.globals.axisCharts || type === 'heatmap') {\n        var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n        this.addPathsEventListeners(seriesAll, seriesHoverParams);\n      }\n\n      if (this.showOnIntersect) {\n        var linePoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker');\n\n        if (linePoints.length > 0) {\n          // if we find any lineSeries, addEventListeners for them\n          this.addPathsEventListeners(linePoints, seriesHoverParams);\n        }\n\n        var areaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-marker');\n\n        if (areaPoints.length > 0) {\n          // if we find any areaSeries, addEventListeners for them\n          this.addPathsEventListeners(areaPoints, seriesHoverParams);\n        } // combo charts may have bars, so add event listeners here too\n\n\n        if (this.hasBars() && !w.config.tooltip.shared) {\n          this.addBarsEventListeners(seriesHoverParams);\n        }\n      }\n    }\n  }, {\n    key: \"drawFixedTooltipRect\",\n    value: function drawFixedTooltipRect() {\n      var w = this.w;\n      var tooltipEl = this.getElTooltip();\n      var tooltipRect = tooltipEl.getBoundingClientRect();\n      var ttWidth = tooltipRect.width + 10;\n      var ttHeight = tooltipRect.height + 10;\n      var x = w.config.tooltip.fixed.offsetX;\n      var y = w.config.tooltip.fixed.offsetY;\n\n      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('right') > -1) {\n        x = x + w.globals.svgWidth - ttWidth + 10;\n      }\n\n      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('bottom') > -1) {\n        y = y + w.globals.svgHeight - ttHeight - 10;\n      }\n\n      tooltipEl.style.left = x + 'px';\n      tooltipEl.style.top = y + 'px';\n      return {\n        x: x,\n        y: y,\n        ttWidth: ttWidth,\n        ttHeight: ttHeight\n      };\n    }\n  }, {\n    key: \"addPointsEventsListeners\",\n    value: function addPointsEventsListeners(seriesHoverParams) {\n      var w = this.w;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');\n      this.addPathsEventListeners(points, seriesHoverParams);\n    }\n  }, {\n    key: \"addBarsEventListeners\",\n    value: function addBarsEventListeners(seriesHoverParams) {\n      var w = this.w;\n      var bars = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area');\n      this.addPathsEventListeners(bars, seriesHoverParams);\n    }\n  }, {\n    key: \"addPathsEventListeners\",\n    value: function addPathsEventListeners(paths, opts) {\n      var _this = this;\n\n      var self = this;\n\n      var _loop = function _loop(p) {\n        var extendedOpts = {\n          paths: paths[p],\n          tooltipEl: opts.tooltipEl,\n          tooltipY: opts.tooltipY,\n          tooltipX: opts.tooltipX,\n          elGrid: opts.elGrid,\n          hoverArea: opts.hoverArea,\n          ttItems: opts.ttItems\n        };\n        _this.w.globals.tooltipOpts = extendedOpts;\n        var events = ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'];\n        events.map(function (ev) {\n          return paths[p].addEventListener(ev, self.seriesHover.bind(self, extendedOpts), {\n            capture: false,\n            passive: true\n          });\n        });\n      };\n\n      for (var p = 0; p < paths.length; p++) {\n        _loop(p);\n      }\n    }\n    /*\n     ** The actual series hover function\n     */\n\n  }, {\n    key: \"seriesHover\",\n    value: function seriesHover(opt, e) {\n      var _this2 = this;\n\n      var chartGroups = [];\n      var w = this.w; // if user has more than one charts in group, we need to sync\n\n      if (w.config.chart.group) {\n        chartGroups = this.ctx.getGroupedCharts();\n      }\n\n      if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {\n        return;\n      }\n\n      if (chartGroups.length) {\n        chartGroups.forEach(function (ch) {\n          var tooltipEl = _this2.getElTooltip(ch);\n\n          var newOpts = {\n            paths: opt.paths,\n            tooltipEl: tooltipEl,\n            tooltipY: opt.tooltipY,\n            tooltipX: opt.tooltipX,\n            elGrid: opt.elGrid,\n            hoverArea: opt.hoverArea,\n            ttItems: ch.w.globals.tooltip.ttItems // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly\n\n          };\n\n          if (ch.w.globals.minX === _this2.w.globals.minX && ch.w.globals.maxX === _this2.w.globals.maxX) {\n            ch.w.globals.tooltip.seriesHoverByContext({\n              chartCtx: ch,\n              ttCtx: ch.w.globals.tooltip,\n              opt: newOpts,\n              e: e\n            });\n          }\n        });\n      } else {\n        this.seriesHoverByContext({\n          chartCtx: this.ctx,\n          ttCtx: this.w.globals.tooltip,\n          opt: opt,\n          e: e\n        });\n      }\n    }\n  }, {\n    key: \"seriesHoverByContext\",\n    value: function seriesHoverByContext(_ref) {\n      var chartCtx = _ref.chartCtx,\n          ttCtx = _ref.ttCtx,\n          opt = _ref.opt,\n          e = _ref.e;\n      var w = chartCtx.w;\n      var tooltipEl = this.getElTooltip(); // tooltipRect is calculated on every mousemove, because the text is dynamic\n\n      ttCtx.tooltipRect = {\n        x: 0,\n        y: 0,\n        ttWidth: tooltipEl.getBoundingClientRect().width,\n        ttHeight: tooltipEl.getBoundingClientRect().height\n      };\n      ttCtx.e = e; // highlight the current hovered bars\n\n      if (ttCtx.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {\n        if (w.config.tooltip.onDatasetHover.highlightDataSeries) {\n          var series = new Series(chartCtx);\n          series.toggleSeriesOnHover(e, e.target.parentNode);\n        }\n      }\n\n      if (ttCtx.fixedTooltip) {\n        ttCtx.drawFixedTooltipRect();\n      }\n\n      if (w.globals.axisCharts) {\n        ttCtx.axisChartsTooltips({\n          e: e,\n          opt: opt,\n          tooltipRect: ttCtx.tooltipRect\n        });\n      } else {\n        // non-plot charts i.e pie/donut/circle\n        ttCtx.nonAxisChartsTooltips({\n          e: e,\n          opt: opt,\n          tooltipRect: ttCtx.tooltipRect\n        });\n      }\n    } // tooltip handling for line/area/bar/columns/scatter\n\n  }, {\n    key: \"axisChartsTooltips\",\n    value: function axisChartsTooltips(_ref2) {\n      var e = _ref2.e,\n          opt = _ref2.opt;\n      var w = this.w;\n      var j, x, y;\n      var self = this;\n      var capj = null;\n      var seriesBound = opt.elGrid.getBoundingClientRect();\n      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n      var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;\n      this.clientY = clientY;\n      this.clientX = clientX;\n\n      if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {\n        self.handleMouseOut(opt);\n        return;\n      }\n\n      var tooltipEl = this.getElTooltip();\n      var xcrosshairs = this.getElXCrosshairs();\n      var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !w.globals.isBarHorizontal && this.hasBars() && w.config.tooltip.shared || w.globals.comboCharts && this.hasBars;\n\n      if (w.globals.isBarHorizontal && this.hasBars()) {\n        isStickyTooltip = false;\n      }\n\n      if (e.type === 'mousemove' || e.type === 'touchmove' || e.type === 'mouseup') {\n        if (xcrosshairs !== null) {\n          xcrosshairs.classList.add('active');\n        }\n\n        if (self.ycrosshairs !== null && self.blyaxisTooltip) {\n          self.ycrosshairs.classList.add('active');\n        }\n\n        if (isStickyTooltip && !self.showOnIntersect) {\n          capj = self.tooltipUtil.getNearestValues({\n            context: self,\n            hoverArea: opt.hoverArea,\n            elGrid: opt.elGrid,\n            clientX: clientX,\n            clientY: clientY,\n            hasBars: self.hasBars\n          });\n          j = capj.j;\n          var capturedSeries = capj.capturedSeries;\n\n          if (capj.hoverX < 0 || capj.hoverX > w.globals.gridWidth) {\n            self.handleMouseOut(opt);\n            return;\n          }\n\n          if (capturedSeries !== null) {\n            var ignoreNull = w.globals.series[capturedSeries][j] === null;\n\n            if (ignoreNull) {\n              opt.tooltipEl.classList.remove('active');\n              return;\n            }\n\n            if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {\n              if (w.config.tooltip.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isinitialSeriesSameLen()) {\n                this.create(e, self, capturedSeries, j, opt.ttItems);\n              } else {\n                this.create(e, self, capturedSeries, j, opt.ttItems, false);\n              }\n            } else {\n              if (this.tooltipUtil.isXoverlap(j)) {\n                self.create(e, self, 0, j, opt.ttItems);\n              }\n            }\n          } else {\n            // couldn't capture any series. check if shared X is same,\n            // if yes, draw a grouped tooltip\n            if (this.tooltipUtil.isXoverlap(j)) {\n              self.create(e, self, 0, j, opt.ttItems);\n            }\n          }\n        } else {\n          if (w.config.chart.type === 'heatmap') {\n            var markerXY = this.intersect.handleHeatTooltip({\n              e: e,\n              opt: opt,\n              x: x,\n              y: y\n            });\n            x = markerXY.x;\n            y = markerXY.y;\n            tooltipEl.style.left = x + 'px';\n            tooltipEl.style.top = y + 'px';\n          } else {\n            if (this.hasBars) {\n              this.intersect.handleBarTooltip({\n                e: e,\n                opt: opt\n              });\n            }\n\n            if (this.hasMarkers) {\n              // intersect - line/area/scatter/bubble\n              this.intersect.handleMarkerTooltip({\n                e: e,\n                opt: opt,\n                x: x,\n                y: y\n              });\n            }\n          }\n        }\n\n        if (this.blyaxisTooltip) {\n          for (var yt = 0; yt < w.config.yaxis.length; yt++) {\n            self.axesTooltip.drawYaxisTooltipText(yt, clientY, self.xyRatios);\n          }\n        }\n\n        opt.tooltipEl.classList.add('active');\n      } else if (e.type === 'mouseout' || e.type === 'touchend') {\n        this.handleMouseOut(opt);\n      }\n    } // tooltip handling for pie/donuts\n\n  }, {\n    key: \"nonAxisChartsTooltips\",\n    value: function nonAxisChartsTooltips(_ref3) {\n      var e = _ref3.e,\n          opt = _ref3.opt,\n          tooltipRect = _ref3.tooltipRect;\n      var w = this.w;\n      var rel = opt.paths.getAttribute('rel');\n      var tooltipEl = this.getElTooltip();\n      var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();\n\n      if (e.type === 'mousemove' || e.type === 'touchmove') {\n        tooltipEl.classList.add('active');\n        this.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: parseInt(rel) - 1,\n          shared: false\n        });\n        var x = w.globals.clientX - seriesBound.left - tooltipRect.ttWidth / 2;\n        var y = w.globals.clientY - seriesBound.top - tooltipRect.ttHeight - 10;\n        tooltipEl.style.left = x + 'px';\n        tooltipEl.style.top = y + 'px';\n      } else if (e.type === 'mouseout' || e.type === 'touchend') {\n        tooltipEl.classList.remove('active');\n      }\n    }\n  }, {\n    key: \"deactivateHoverFilter\",\n    value: function deactivateHoverFilter() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var allPaths = w.globals.dom.Paper.select(\".apexcharts-bar-area\");\n\n      for (var b = 0; b < allPaths.length; b++) {\n        graphics.pathMouseLeave(allPaths[b]);\n      }\n    }\n  }, {\n    key: \"handleMouseOut\",\n    value: function handleMouseOut(opt) {\n      var w = this.w;\n      var xcrosshairs = this.getElXCrosshairs();\n      opt.tooltipEl.classList.remove('active');\n      this.deactivateHoverFilter();\n\n      if (w.config.chart.type !== 'bubble') {\n        this.marker.resetPointsSize();\n      }\n\n      if (xcrosshairs !== null) {\n        xcrosshairs.classList.remove('active');\n      }\n\n      if (this.ycrosshairs !== null) {\n        this.ycrosshairs.classList.remove('active');\n      }\n\n      if (this.blxaxisTooltip) {\n        this.xaxisTooltip.classList.remove('active');\n      }\n\n      if (this.blyaxisTooltip) {\n        if (this.yaxisTTEls === null) {\n          this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n        }\n\n        for (var i = 0; i < this.yaxisTTEls.length; i++) {\n          this.yaxisTTEls[i].classList.remove('active');\n        }\n      }\n    }\n  }, {\n    key: \"getElMarkers\",\n    value: function getElMarkers() {\n      return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers');\n    }\n  }, {\n    key: \"getAllMarkers\",\n    value: function getAllMarkers() {\n      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');\n    }\n  }, {\n    key: \"hasMarkers\",\n    value: function hasMarkers() {\n      var markers = this.getElMarkers();\n      return markers.length > 0;\n    }\n  }, {\n    key: \"getElBars\",\n    value: function getElBars() {\n      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series');\n    }\n  }, {\n    key: \"hasBars\",\n    value: function hasBars() {\n      var bars = this.getElBars();\n      return bars.length > 0;\n    }\n  }, {\n    key: \"markerClick\",\n    value: function markerClick(e, seriesIndex, dataPointIndex) {\n      var w = this.w;\n\n      if (typeof w.config.chart.events.markerClick === 'function') {\n        w.config.chart.events.markerClick(e, this.ctx, {\n          seriesIndex: seriesIndex,\n          dataPointIndex: dataPointIndex,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('markerClick', [e, this.ctx, {\n        seriesIndex: seriesIndex,\n        dataPointIndex: dataPointIndex,\n        w: w\n      }]);\n    }\n  }, {\n    key: \"create\",\n    value: function create(e, context, capturedSeries, j, ttItems) {\n      var shared = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var w = this.w;\n      var ttCtx = context;\n\n      if (e.type === 'mouseup') {\n        this.markerClick(e, capturedSeries, j);\n      }\n\n      if (shared === null) shared = w.config.tooltip.shared;\n      var hasMarkers = this.hasMarkers();\n      var bars = this.getElBars();\n\n      if (shared) {\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: ttItems,\n          i: capturedSeries,\n          j: j,\n          shared: this.showOnIntersect ? false : w.config.tooltip.shared\n        });\n\n        if (hasMarkers) {\n          if (w.globals.markers.largestSize > 0) {\n            ttCtx.marker.enlargePoints(j);\n          } else {\n            ttCtx.tooltipPosition.moveDynamicPointsOnHover(j);\n          }\n        }\n\n        if (this.hasBars()) {\n          this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);\n\n          if (this.barSeriesHeight > 0) {\n            // hover state, activate snap filter\n            var graphics = new Graphics(this.ctx);\n            var paths = w.globals.dom.Paper.select(\".apexcharts-bar-area[j='\".concat(j, \"']\")); // de-activate first\n\n            this.deactivateHoverFilter();\n            this.tooltipPosition.moveStickyTooltipOverBars(j);\n\n            for (var b = 0; b < paths.length; b++) {\n              graphics.pathMouseEnter(paths[b]);\n            }\n          }\n        }\n      } else {\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          shared: false,\n          ttItems: ttItems,\n          i: capturedSeries,\n          j: j\n        });\n\n        if (this.hasBars()) {\n          ttCtx.tooltipPosition.moveStickyTooltipOverBars(j);\n        }\n\n        if (hasMarkers) {\n          ttCtx.tooltipPosition.moveMarkers(capturedSeries, j);\n        }\n      }\n    }\n  }]);\n\n  return Tooltip;\n}();\n\nvar icoPan = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <defs>\\n        <path d=\\\"M0 0h24v24H0z\\\" id=\\\"a\\\"/>\\n    </defs>\\n    <clipPath id=\\\"b\\\">\\n        <use overflow=\\\"visible\\\" xlink:href=\\\"#a\\\"/>\\n    </clipPath>\\n    <path clip-path=\\\"url(#b)\\\" d=\\\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\\\"/>\\n</svg>\";\n\nvar icoZoom = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <path d=\\\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\\\"/>\\n    <path d=\\\"M0 0h24v24H0V0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\\\"/>\\n</svg>\";\n\nvar icoReset = \"<svg fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\\\"/>\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n</svg>\";\n\nvar icoZoomIn = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\nvar icoZoomOut = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\nvar icoSelect = \"<svg fill=\\\"#6E8192\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\\\"/>\\n</svg>\";\n\nvar icoMenu = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path fill=\\\"none\\\" d=\\\"M0 0h24v24H0V0z\\\"/><path d=\\\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\\\"/></svg>\";\n\n/**\n * ApexCharts Toolbar Class for creating toolbar in axis based charts.\n *\n * @module Toolbar\n **/\n\nvar Toolbar =\n/*#__PURE__*/\nfunction () {\n  function Toolbar(ctx) {\n    _classCallCheck(this, Toolbar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.ev = this.w.config.chart.events;\n    this.localeValues = this.w.globals.locale.toolbar;\n  }\n\n  _createClass(Toolbar, [{\n    key: \"createToolbar\",\n    value: function createToolbar() {\n      var w = this.w;\n      var elToolbarWrap = document.createElement('div');\n      elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');\n      w.globals.dom.elWrap.appendChild(elToolbarWrap);\n      this.elZoom = document.createElement('div');\n      this.elZoomIn = document.createElement('div');\n      this.elZoomOut = document.createElement('div');\n      this.elPan = document.createElement('div');\n      this.elSelection = document.createElement('div');\n      this.elZoomReset = document.createElement('div');\n      this.elMenuIcon = document.createElement('div');\n      this.elMenu = document.createElement('div');\n      this.elCustomIcons = [];\n      this.t = w.config.chart.toolbar.tools;\n\n      if (Array.isArray(this.t.customIcons)) {\n        for (var i = 0; i < this.t.customIcons.length; i++) {\n          this.elCustomIcons.push(document.createElement('div'));\n        }\n      }\n\n      this.elMenuItems = [];\n      var toolbarControls = [];\n\n      if (this.t.zoomin && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomIn,\n          icon: typeof this.t.zoomin === 'string' ? this.t.zoomin : icoZoomIn,\n          title: this.localeValues.zoomIn,\n          class: 'apexcharts-zoom-in-icon'\n        });\n      }\n\n      if (this.t.zoomout && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomOut,\n          icon: typeof this.t.zoomout === 'string' ? this.t.zoomout : icoZoomOut,\n          title: this.localeValues.zoomOut,\n          class: 'apexcharts-zoom-out-icon'\n        });\n      }\n\n      if (this.t.zoom && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoom,\n          icon: typeof this.t.zoom === 'string' ? this.t.zoom : icoZoom,\n          title: this.localeValues.selectionZoom,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-zoom-icon'\n        });\n      }\n\n      if (this.t.selection && w.config.chart.selection.enabled) {\n        toolbarControls.push({\n          el: this.elSelection,\n          icon: typeof this.t.selection === 'string' ? this.t.selection : icoSelect,\n          title: this.localeValues.selection,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-selection-icon'\n        });\n      }\n\n      if (this.t.pan && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elPan,\n          icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,\n          title: this.localeValues.pan,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-pan-icon'\n        });\n      }\n\n      if (this.t.reset && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomReset,\n          icon: typeof this.t.reset === 'string' ? this.t.reset : icoReset,\n          title: this.localeValues.reset,\n          class: 'apexcharts-reset-zoom-icon'\n        });\n      }\n\n      if (this.t.download) {\n        toolbarControls.push({\n          el: this.elMenuIcon,\n          icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,\n          title: this.localeValues.menu,\n          class: 'apexcharts-menu-icon'\n        });\n      }\n\n      for (var _i = 0; _i < this.elCustomIcons.length; _i++) {\n        toolbarControls.push({\n          el: this.elCustomIcons[_i],\n          icon: this.t.customIcons[_i].icon,\n          title: this.t.customIcons[_i].title,\n          index: this.t.customIcons[_i].index,\n          class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class\n        });\n      }\n\n      toolbarControls.forEach(function (t, index) {\n        if (t.index) {\n          Utils.moveIndexInArray(toolbarControls, index, t.index);\n        }\n      });\n\n      for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {\n        Graphics.setAttrs(toolbarControls[_i2].el, {\n          class: toolbarControls[_i2].class,\n          title: toolbarControls[_i2].title\n        });\n        toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;\n        elToolbarWrap.appendChild(toolbarControls[_i2].el);\n      }\n\n      elToolbarWrap.appendChild(this.elMenu);\n      Graphics.setAttrs(this.elMenu, {\n        class: 'apexcharts-menu'\n      });\n      var menuItems = [{\n        name: 'exportSVG',\n        title: this.localeValues.exportToSVG\n      }, {\n        name: 'exportPNG',\n        title: this.localeValues.exportToPNG\n      }];\n\n      for (var _i3 = 0; _i3 < menuItems.length; _i3++) {\n        this.elMenuItems.push(document.createElement('div'));\n        this.elMenuItems[_i3].innerHTML = menuItems[_i3].title;\n        Graphics.setAttrs(this.elMenuItems[_i3], {\n          class: \"apexcharts-menu-item \".concat(menuItems[_i3].name),\n          title: menuItems[_i3].title\n        });\n        this.elMenu.appendChild(this.elMenuItems[_i3]);\n      }\n\n      if (w.globals.zoomEnabled) {\n        this.elZoom.classList.add('selected');\n      } else if (w.globals.panEnabled) {\n        this.elPan.classList.add('selected');\n      } else if (w.globals.selectionEnabled) {\n        this.elSelection.classList.add('selected');\n      }\n\n      this.addToolbarEventListeners();\n    }\n  }, {\n    key: \"addToolbarEventListeners\",\n    value: function addToolbarEventListeners() {\n      var _this = this;\n\n      this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));\n      this.elSelection.addEventListener('click', this.toggleSelection.bind(this));\n      this.elZoom.addEventListener('click', this.toggleZooming.bind(this));\n      this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));\n      this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));\n      this.elPan.addEventListener('click', this.togglePanning.bind(this));\n      this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));\n      this.elMenuItems.forEach(function (m) {\n        if (m.classList.contains('exportSVG')) {\n          m.addEventListener('click', _this.downloadSVG.bind(_this));\n        } else if (m.classList.contains('exportPNG')) {\n          m.addEventListener('click', _this.downloadPNG.bind(_this));\n        }\n      });\n\n      for (var i = 0; i < this.t.customIcons.length; i++) {\n        this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click);\n      }\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      this.toggleOtherControls();\n      this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled;\n\n      if (!this.elSelection.classList.contains('selected')) {\n        this.elSelection.classList.add('selected');\n      } else {\n        this.elSelection.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"toggleZooming\",\n    value: function toggleZooming() {\n      this.toggleOtherControls();\n      this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled;\n\n      if (!this.elZoom.classList.contains('selected')) {\n        this.elZoom.classList.add('selected');\n      } else {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"getToolbarIconsReference\",\n    value: function getToolbarIconsReference() {\n      var w = this.w;\n\n      if (!this.elZoom) {\n        this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');\n      }\n\n      if (!this.elPan) {\n        this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');\n      }\n\n      if (!this.elSelection) {\n        this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');\n      }\n    }\n  }, {\n    key: \"enableZooming\",\n    value: function enableZooming() {\n      this.toggleOtherControls();\n      this.w.globals.zoomEnabled = true;\n\n      if (this.elZoom) {\n        this.elZoom.classList.add('selected');\n      }\n\n      if (this.elPan) {\n        this.elPan.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"enablePanning\",\n    value: function enablePanning() {\n      this.toggleOtherControls();\n      this.w.globals.panEnabled = true;\n\n      if (this.elPan) {\n        this.elPan.classList.add('selected');\n      }\n\n      if (this.elZoom) {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"togglePanning\",\n    value: function togglePanning() {\n      this.toggleOtherControls();\n      this.w.globals.panEnabled = !this.w.globals.panEnabled;\n\n      if (!this.elPan.classList.contains('selected')) {\n        this.elPan.classList.add('selected');\n      } else {\n        this.elPan.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"toggleOtherControls\",\n    value: function toggleOtherControls() {\n      var w = this.w;\n      w.globals.panEnabled = false;\n      w.globals.zoomEnabled = false;\n      w.globals.selectionEnabled = false;\n      this.getToolbarIconsReference();\n\n      if (this.elPan) {\n        this.elPan.classList.remove('selected');\n      }\n\n      if (this.elSelection) {\n        this.elSelection.classList.remove('selected');\n      }\n\n      if (this.elZoom) {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"handleZoomIn\",\n    value: function handleZoomIn() {\n      var w = this.w;\n      var centerX = (w.globals.minX + w.globals.maxX) / 2;\n      var newMinX = (w.globals.minX + centerX) / 2;\n      var newMaxX = (w.globals.maxX + centerX) / 2;\n\n      if (!w.globals.disableZoomIn) {\n        this.zoomUpdateOptions(newMinX, newMaxX);\n      }\n    }\n  }, {\n    key: \"handleZoomOut\",\n    value: function handleZoomOut() {\n      var w = this.w; // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis\n\n      if (w.config.xaxis.type === 'datetime' && new Date(w.globals.minX).getUTCFullYear() < 1000) {\n        return;\n      }\n\n      var centerX = (w.globals.minX + w.globals.maxX) / 2;\n      var newMinX = w.globals.minX - (centerX - w.globals.minX);\n      var newMaxX = w.globals.maxX - (centerX - w.globals.maxX);\n\n      if (!w.globals.disableZoomOut) {\n        this.zoomUpdateOptions(newMinX, newMaxX);\n      }\n    }\n  }, {\n    key: \"zoomUpdateOptions\",\n    value: function zoomUpdateOptions(newMinX, newMaxX) {\n      var xaxis = {\n        min: newMinX,\n        max: newMaxX\n      };\n      var beforeZoomRange = this.getBeforeZoomRange(xaxis);\n\n      if (beforeZoomRange) {\n        xaxis = beforeZoomRange.xaxis;\n      }\n\n      this.w.globals.zoomed = true;\n\n      this.ctx._updateOptions({\n        xaxis: xaxis\n      }, false, this.w.config.chart.animations.dynamicAnimation.enabled);\n\n      this.zoomCallback(xaxis);\n    }\n  }, {\n    key: \"zoomCallback\",\n    value: function zoomCallback(xaxis, yaxis) {\n      if (typeof this.ev.zoomed === 'function') {\n        this.ev.zoomed(this.ctx, {\n          xaxis: xaxis,\n          yaxis: yaxis\n        });\n      }\n    }\n  }, {\n    key: \"getBeforeZoomRange\",\n    value: function getBeforeZoomRange(xaxis, yaxis) {\n      var newRange = null;\n\n      if (typeof this.ev.beforeZoom === 'function') {\n        newRange = this.ev.beforeZoom(this, {\n          xaxis: xaxis,\n          yaxis: yaxis\n        });\n      }\n\n      return newRange;\n    }\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu() {\n      if (this.elMenu.classList.contains('open')) {\n        this.elMenu.classList.remove('open');\n      } else {\n        this.elMenu.classList.add('open');\n      }\n    }\n  }, {\n    key: \"downloadPNG\",\n    value: function downloadPNG() {\n      var downloadPNG = new Exports(this.ctx);\n      downloadPNG.exportToPng(this.ctx);\n      this.toggleMenu();\n    }\n  }, {\n    key: \"downloadSVG\",\n    value: function downloadSVG() {\n      var downloadSVG = new Exports(this.ctx);\n      downloadSVG.exportToSVG();\n      this.toggleMenu();\n    }\n  }, {\n    key: \"handleZoomReset\",\n    value: function handleZoomReset(e) {\n      var _this2 = this;\n\n      var charts = this.ctx.getSyncedCharts();\n      charts.forEach(function (ch) {\n        var w = ch.w;\n\n        if (w.globals.minX !== w.globals.initialminX && w.globals.maxX !== w.globals.initialmaxX) {\n          ch.revertDefaultAxisMinMax();\n\n          if (typeof w.config.chart.events.zoomed === 'function') {\n            _this2.zoomCallback({\n              min: w.config.xaxis.min,\n              max: w.config.xaxis.max\n            });\n          }\n\n          w.globals.zoomed = false;\n\n          ch._updateSeries(w.globals.initialSeries, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.elZoomReset) {\n        this.elZoomReset.removeEventListener('click', this.handleZoomReset.bind(this));\n        this.elSelection.removeEventListener('click', this.toggleSelection.bind(this));\n        this.elZoom.removeEventListener('click', this.toggleZooming.bind(this));\n        this.elZoomIn.removeEventListener('click', this.handleZoomIn.bind(this));\n        this.elZoomOut.removeEventListener('click', this.handleZoomOut.bind(this));\n        this.elPan.removeEventListener('click', this.togglePanning.bind(this));\n        this.elMenuIcon.removeEventListener('click', this.toggleMenu.bind(this));\n      }\n\n      this.elZoom = null;\n      this.elZoomIn = null;\n      this.elZoomOut = null;\n      this.elPan = null;\n      this.elSelection = null;\n      this.elZoomReset = null;\n      this.elMenuIcon = null;\n    }\n  }]);\n\n  return Toolbar;\n}();\n\n/**\n * ApexCharts Zoom Class for handling zooming and panning on axes based charts.\n *\n * @module ZoomPanSelection\n **/\n\nvar ZoomPanSelection =\n/*#__PURE__*/\nfunction (_Toolbar) {\n  _inherits(ZoomPanSelection, _Toolbar);\n\n  function ZoomPanSelection(ctx) {\n    var _this;\n\n    _classCallCheck(this, ZoomPanSelection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZoomPanSelection).call(this, ctx));\n    _this.ctx = ctx;\n    _this.w = ctx.w;\n    _this.dragged = false;\n    _this.graphics = new Graphics(_this.ctx);\n    _this.eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];\n    _this.clientX = 0;\n    _this.clientY = 0;\n    _this.startX = 0;\n    _this.endX = 0;\n    _this.dragX = 0;\n    _this.startY = 0;\n    _this.endY = 0;\n    _this.dragY = 0;\n    return _this;\n  }\n\n  _createClass(ZoomPanSelection, [{\n    key: \"init\",\n    value: function init(_ref) {\n      var _this2 = this;\n\n      var xyRatios = _ref.xyRatios;\n      var w = this.w;\n      var me = this;\n      this.xyRatios = xyRatios;\n      this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);\n      this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);\n      this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n      this.zoomRect.node.classList.add('apexcharts-zoom-rect');\n      this.selectionRect.node.classList.add('apexcharts-selection-rect');\n      w.globals.dom.elGraphical.add(this.zoomRect);\n      w.globals.dom.elGraphical.add(this.selectionRect);\n\n      if (w.config.chart.selection.type === 'x') {\n        this.slDraggableRect = this.selectionRect.draggable({\n          minX: 0,\n          minY: 0,\n          maxX: w.globals.gridWidth,\n          maxY: w.globals.gridHeight\n        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      } else if (w.config.chart.selection.type === 'y') {\n        this.slDraggableRect = this.selectionRect.draggable({\n          minX: 0,\n          maxX: w.globals.gridWidth\n        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      } else {\n        this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      }\n\n      this.preselectedSelection();\n      this.hoverArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);\n      this.hoverArea.classList.add('zoomable');\n      this.eventList.forEach(function (event) {\n        _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {\n          capture: false,\n          passive: true\n        });\n      });\n    } // remove the event listeners which were previously added on hover area\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n\n      var me = this;\n      this.eventList.forEach(function (event) {\n        if (_this3.hoverArea) {\n          _this3.hoverArea.removeEventListener(event, me.svgMouseEvents.bind(me, me.xyRatios), {\n            capture: false,\n            passive: true\n          });\n        }\n      });\n\n      if (this.slDraggableRect) {\n        this.slDraggableRect.draggable(false);\n        this.slDraggableRect.off();\n        this.selectionRect.off();\n      }\n\n      this.selectionRect = null;\n      this.zoomRect = null;\n      this.gridRect = null;\n    }\n  }, {\n    key: \"svgMouseEvents\",\n    value: function svgMouseEvents(xyRatios, e) {\n      var w = this.w;\n      var me = this;\n      var toolbar = this.ctx.toolbar;\n      var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;\n\n      if (e.shiftKey) {\n        this.shiftWasPressed = true;\n        toolbar.enablePanning();\n      } else {\n        if (this.shiftWasPressed) {\n          toolbar.enableZooming();\n          this.shiftWasPressed = false;\n        }\n      }\n\n      var falsePositives = e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar');\n      if (falsePositives) return;\n      me.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;\n      me.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;\n\n      if (e.type === 'mousedown' && e.which === 1) {\n        var gridRectDim = me.gridRect.getBoundingClientRect();\n        me.startX = me.clientX - gridRectDim.left;\n        me.startY = me.clientY - gridRectDim.top;\n        me.dragged = false;\n        me.w.globals.mousedown = true;\n      }\n\n      if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {\n        me.dragged = true;\n\n        if (w.globals.panEnabled) {\n          w.globals.selection = null;\n\n          if (me.w.globals.mousedown) {\n            me.panDragging({\n              context: me,\n              zoomtype: zoomtype,\n              xyRatios: xyRatios\n            });\n          }\n        } else {\n          if (me.w.globals.mousedown && w.globals.zoomEnabled || me.w.globals.mousedown && w.globals.selectionEnabled) {\n            me.selection = me.selectionDrawing({\n              context: me,\n              zoomtype: zoomtype\n            });\n          }\n        }\n      }\n\n      if (e.type === 'mouseup' || e.type === 'touchend') {\n        // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup\n        var _gridRectDim = me.gridRect.getBoundingClientRect();\n\n        if (me.w.globals.mousedown) {\n          // user released the drag, now do all the calculations\n          me.endX = me.clientX - _gridRectDim.left;\n          me.endY = me.clientY - _gridRectDim.top;\n          me.dragX = Math.abs(me.endX - me.startX);\n          me.dragY = Math.abs(me.endY - me.startY);\n\n          if (w.globals.zoomEnabled || w.globals.selectionEnabled) {\n            me.selectionDrawn({\n              context: me,\n              zoomtype: zoomtype\n            });\n          }\n        }\n\n        if (w.globals.zoomEnabled) {\n          me.hideSelectionRect(this.selectionRect);\n        }\n\n        me.dragged = false;\n        me.w.globals.mousedown = false;\n      }\n\n      this.makeSelectionRectDraggable();\n    }\n  }, {\n    key: \"makeSelectionRectDraggable\",\n    value: function makeSelectionRectDraggable() {\n      var w = this.w;\n      if (!this.selectionRect) return;\n      var rectDim = this.selectionRect.node.getBoundingClientRect();\n\n      if (rectDim.width > 0 && rectDim.height > 0) {\n        this.slDraggableRect.selectize().resize({\n          constraint: {\n            minX: 0,\n            minY: 0,\n            maxX: w.globals.gridWidth,\n            maxY: w.globals.gridHeight\n          }\n        }).on('resizing', this.selectionDragging.bind(this, 'resizing'));\n      }\n    }\n  }, {\n    key: \"preselectedSelection\",\n    value: function preselectedSelection() {\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n\n      if (!w.globals.zoomEnabled) {\n        if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {\n          this.drawSelectionRect(w.globals.selection);\n        } else {\n          if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {\n            var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;\n            var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;\n            var selectionRect = {\n              x: x,\n              y: 0,\n              width: width,\n              height: w.globals.gridHeight,\n              translateX: 0,\n              translateY: 0,\n              selectionEnabled: true\n            };\n            this.drawSelectionRect(selectionRect);\n            this.makeSelectionRectDraggable();\n\n            if (typeof w.config.chart.events.selection === 'function') {\n              w.config.chart.events.selection(this.ctx, {\n                xaxis: {\n                  min: w.config.chart.selection.xaxis.min,\n                  max: w.config.chart.selection.xaxis.max\n                },\n                yaxis: {}\n              });\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"drawSelectionRect\",\n    value: function drawSelectionRect(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y,\n          width = _ref2.width,\n          height = _ref2.height,\n          translateX = _ref2.translateX,\n          translateY = _ref2.translateY;\n      var w = this.w;\n      var zoomRect = this.zoomRect;\n      var selectionRect = this.selectionRect;\n\n      if (this.dragged || w.globals.selection !== null) {\n        var scalingAttrs = {\n          transform: 'translate(' + translateX + ', ' + translateY + ')' // change styles based on zoom or selection\n          // zoom is Enabled and user has dragged, so draw blue rect\n\n        };\n\n        if (w.globals.zoomEnabled && this.dragged) {\n          zoomRect.attr({\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            fill: w.config.chart.zoom.zoomedArea.fill.color,\n            'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,\n            stroke: w.config.chart.zoom.zoomedArea.stroke.color,\n            'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,\n            'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity\n          });\n          Graphics.setAttrs(zoomRect.node, scalingAttrs);\n        } // selection is enabled\n\n\n        if (w.globals.selectionEnabled) {\n          selectionRect.attr({\n            x: x,\n            y: y,\n            width: width > 0 ? width : 0,\n            height: height > 0 ? height : 0,\n            fill: w.config.chart.selection.fill.color,\n            'fill-opacity': w.config.chart.selection.fill.opacity,\n            stroke: w.config.chart.selection.stroke.color,\n            'stroke-width': w.config.chart.selection.stroke.width,\n            'stroke-dasharray': w.config.chart.selection.stroke.dashArray,\n            'stroke-opacity': w.config.chart.selection.stroke.opacity\n          });\n          Graphics.setAttrs(selectionRect.node, scalingAttrs);\n        }\n      }\n    }\n  }, {\n    key: \"hideSelectionRect\",\n    value: function hideSelectionRect(rect) {\n      if (rect) {\n        rect.attr({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        });\n      }\n    }\n  }, {\n    key: \"selectionDrawing\",\n    value: function selectionDrawing(_ref3) {\n      var context = _ref3.context,\n          zoomtype = _ref3.zoomtype;\n      var w = this.w;\n      var me = context;\n      var gridRectDim = this.gridRect.getBoundingClientRect();\n      var startX = me.startX - 1;\n      var startY = me.startY;\n      var selectionWidth = me.clientX - gridRectDim.left - startX;\n      var selectionHeight = me.clientY - gridRectDim.top - startY;\n      var translateX = 0;\n      var translateY = 0;\n      var selectionRect = {};\n\n      if (Math.abs(selectionWidth + startX) > w.globals.gridWidth || me.clientX - gridRectDim.left < 0) {\n        // user dragged the mouse outside drawing area\n        // TODO: test the selectionRect and make sure it doesn't crosses drawing area\n        me.hideSelectionRect(this.zoomRect);\n        me.dragged = false;\n        me.w.globals.mousedown = false;\n      } // inverse selection X\n\n\n      if (startX > me.clientX - gridRectDim.left) {\n        selectionWidth = Math.abs(selectionWidth);\n        translateX = -selectionWidth;\n      } // inverse selection Y\n\n\n      if (startY > me.clientY - gridRectDim.top) {\n        selectionHeight = Math.abs(selectionHeight);\n        translateY = -selectionHeight;\n      }\n\n      if (zoomtype === 'x') {\n        selectionRect = {\n          x: startX,\n          y: 0,\n          width: selectionWidth,\n          height: w.globals.gridHeight,\n          translateX: translateX,\n          translateY: 0\n        };\n      } else if (zoomtype === 'y') {\n        selectionRect = {\n          x: 0,\n          y: startY,\n          width: w.globals.gridWidth,\n          height: selectionHeight,\n          translateX: 0,\n          translateY: translateY\n        };\n      } else {\n        selectionRect = {\n          x: startX,\n          y: startY,\n          width: selectionWidth,\n          height: selectionHeight,\n          translateX: translateX,\n          translateY: translateY\n        };\n      }\n\n      me.drawSelectionRect(selectionRect);\n      me.selectionDragging('resizing');\n      return selectionRect;\n    }\n  }, {\n    key: \"selectionDragging\",\n    value: function selectionDragging(type, e) {\n      var _this4 = this;\n\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n      var selRect = this.selectionRect;\n      var timerInterval = 0;\n\n      if (type === 'resizing') {\n        timerInterval = 30;\n      }\n\n      if (typeof w.config.chart.events.selection === 'function') {\n        // a small debouncer is required when resizing to avoid freezing the chart\n        clearTimeout(this.w.globals.selectionResizeTimer);\n        this.w.globals.selectionResizeTimer = window.setTimeout(function () {\n          var gridRectDim = _this4.gridRect.getBoundingClientRect();\n\n          var selectionRect = selRect.node.getBoundingClientRect();\n          var minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;\n          var maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;\n          var minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];\n          var maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];\n          w.config.chart.events.selection(_this4.ctx, {\n            xaxis: {\n              min: minX,\n              max: maxX\n            },\n            yaxis: {\n              min: minY,\n              max: maxY\n            }\n          });\n        }, timerInterval);\n      }\n    }\n  }, {\n    key: \"selectionDrawn\",\n    value: function selectionDrawn(_ref4) {\n      var context = _ref4.context,\n          zoomtype = _ref4.zoomtype;\n      var w = this.w;\n      var me = context;\n      var xyRatios = this.xyRatios;\n      var toolbar = this.ctx.toolbar;\n\n      if (me.startX > me.endX) {\n        var tempX = me.startX;\n        me.startX = me.endX;\n        me.endX = tempX;\n      }\n\n      if (me.startY > me.endY) {\n        var tempY = me.startY;\n        me.startY = me.endY;\n        me.endY = tempY;\n      }\n\n      var xLowestValue = w.globals.xAxisScale.niceMin + me.startX * xyRatios.xRatio;\n      var xHighestValue = w.globals.xAxisScale.niceMin + me.endX * xyRatios.xRatio; // TODO: we will consider the 1st y axis values here for getting highest and lowest y\n\n      var yHighestValue = [];\n      var yLowestValue = [];\n      w.config.yaxis.forEach(function (yaxe, index) {\n        yHighestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.startY));\n        yLowestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.endY));\n      });\n\n      if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {\n        if (w.globals.zoomEnabled) {\n          var yaxis = Utils.clone(w.config.yaxis); // before zooming in/out, store the last yaxis and xaxis range, so that when user hits the RESET button, we get the original range\n          // also - make sure user is not already zoomed in/out - otherwise we will store zoomed values in lastAxis\n\n          if (!w.globals.zoomed) {\n            w.globals.lastXAxis = Utils.clone(w.config.xaxis);\n            w.globals.lastYAxis = Utils.clone(w.config.yaxis);\n          }\n\n          var xaxis = {\n            min: xLowestValue,\n            max: xHighestValue\n          };\n\n          if (zoomtype === 'xy' || zoomtype === 'y') {\n            yaxis.forEach(function (yaxe, index) {\n              yaxis[index].min = yLowestValue[index];\n              yaxis[index].max = yHighestValue[index];\n            });\n          }\n\n          if (w.config.chart.zoom.autoScaleYaxis) {\n            var scale = new Range(me.ctx);\n            yaxis = scale.autoScaleY(me.ctx, {\n              xaxis: xaxis\n            });\n          }\n\n          if (toolbar) {\n            var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);\n\n            if (beforeZoomRange) {\n              xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;\n              yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxe : yaxis;\n            }\n          }\n\n          if (zoomtype === 'x') {\n            me.ctx._updateOptions({\n              xaxis: xaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          } else if (zoomtype === 'y') {\n            me.ctx._updateOptions({\n              yaxis: yaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          } else {\n            me.ctx._updateOptions({\n              xaxis: xaxis,\n              yaxis: yaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          }\n\n          if (typeof w.config.chart.events.zoomed === 'function') {\n            toolbar.zoomCallback(xaxis, yaxis);\n          }\n\n          w.globals.zoomed = true;\n        } else if (w.globals.selectionEnabled) {\n          var _yaxis = null;\n          var _xaxis = null;\n          _xaxis = {\n            min: xLowestValue,\n            max: xHighestValue\n          };\n\n          if (zoomtype === 'xy' || zoomtype === 'y') {\n            _yaxis = Utils.clone(w.config.yaxis);\n\n            _yaxis.forEach(function (yaxe, index) {\n              _yaxis[index].min = yLowestValue[index];\n              _yaxis[index].max = yHighestValue[index];\n            });\n          }\n\n          w.globals.selection = me.selection;\n\n          if (typeof w.config.chart.events.selection === 'function') {\n            w.config.chart.events.selection(me.ctx, {\n              xaxis: _xaxis,\n              yaxis: _yaxis\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"panDragging\",\n    value: function panDragging(_ref5) {\n      var context = _ref5.context,\n          zoomtype = _ref5.zoomtype;\n      var w = this.w;\n      var me = context;\n      var moveDirection; // check to make sure there is data to compare against\n\n      if (typeof w.globals.lastClientPosition.x !== 'undefined') {\n        // get the change from last position to this position\n        var deltaX = w.globals.lastClientPosition.x - me.clientX;\n        var deltaY = w.globals.lastClientPosition.y - me.clientY; // check which direction had the highest amplitude and then figure out direction by checking if the value is greater or less than zero\n\n        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {\n          moveDirection = 'left';\n        } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {\n          moveDirection = 'right';\n        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {\n          moveDirection = 'up';\n        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {\n          moveDirection = 'down';\n        }\n      } // set the new last position to the current for next time (to get the position of drag)\n\n\n      w.globals.lastClientPosition = {\n        x: me.clientX,\n        y: me.clientY\n      };\n      var xLowestValue = w.globals.minX;\n      var xHighestValue = w.globals.maxX;\n      this.panScrolled(moveDirection, xLowestValue, xHighestValue);\n    }\n  }, {\n    key: \"panScrolled\",\n    value: function panScrolled(moveDirection, xLowestValue, xHighestValue) {\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n      var yaxis = Utils.clone(w.config.yaxis);\n\n      if (moveDirection === 'left') {\n        xLowestValue = w.globals.minX + w.globals.gridWidth / 15 * xyRatios.xRatio;\n        xHighestValue = w.globals.maxX + w.globals.gridWidth / 15 * xyRatios.xRatio;\n      } else if (moveDirection === 'right') {\n        xLowestValue = w.globals.minX - w.globals.gridWidth / 15 * xyRatios.xRatio;\n        xHighestValue = w.globals.maxX - w.globals.gridWidth / 15 * xyRatios.xRatio;\n      }\n\n      if (xLowestValue < w.globals.initialminX || xHighestValue > w.globals.initialmaxX) {\n        xLowestValue = w.globals.minX;\n        xHighestValue = w.globals.maxX;\n      }\n\n      var xaxis = {\n        min: xLowestValue,\n        max: xHighestValue\n      };\n\n      if (w.config.chart.zoom.autoScaleYaxis) {\n        var scale = new Range(me.ctx);\n        yaxis = scale.autoScaleY(me.ctx, {\n          xaxis: xaxis\n        });\n      }\n\n      this.ctx._updateOptions({\n        xaxis: {\n          min: xLowestValue,\n          max: xHighestValue\n        },\n        yaxis: yaxis\n      }, false, false);\n\n      if (typeof w.config.chart.events.scrolled === 'function') {\n        w.config.chart.events.scrolled(this.ctx, {\n          xaxis: {\n            min: xLowestValue,\n            max: xHighestValue\n          }\n        });\n      }\n    }\n  }]);\n\n  return ZoomPanSelection;\n}(Toolbar);\n\nvar TitleSubtitle =\n/*#__PURE__*/\nfunction () {\n  function TitleSubtitle(ctx) {\n    _classCallCheck(this, TitleSubtitle);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(TitleSubtitle, [{\n    key: \"draw\",\n    value: function draw() {\n      this.drawTitleSubtitle('title');\n      this.drawTitleSubtitle('subtitle');\n    }\n  }, {\n    key: \"drawTitleSubtitle\",\n    value: function drawTitleSubtitle(type) {\n      var w = this.w;\n      var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;\n      var x = w.globals.svgWidth / 2;\n      var y = tsConfig.offsetY;\n      var textAnchor = 'middle';\n\n      if (tsConfig.align === 'left') {\n        x = 10;\n        textAnchor = 'start';\n      } else if (tsConfig.align === 'right') {\n        x = w.globals.svgWidth - 10;\n        textAnchor = 'end';\n      }\n\n      x = x + tsConfig.offsetX;\n      y = y + parseInt(tsConfig.style.fontSize) + 2;\n\n      if (tsConfig.text !== undefined) {\n        var graphics = new Graphics(this.ctx);\n        var titleText = graphics.drawText({\n          x: x,\n          y: y,\n          text: tsConfig.text,\n          textAnchor: textAnchor,\n          fontSize: tsConfig.style.fontSize,\n          fontFamily: tsConfig.style.fontFamily,\n          foreColor: tsConfig.style.color,\n          opacity: 1\n        });\n        titleText.node.setAttribute('class', \"apexcharts-\".concat(type, \"-text\"));\n        w.globals.dom.Paper.add(titleText);\n      }\n    }\n  }]);\n\n  return TitleSubtitle;\n}();\n\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    define(function () {\n      return factory(root, root.document);\n    });\n    /* below check fixes #412 */\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined') {\n    module.exports = root.document ? factory(root, root.document) : function (w) {\n      return factory(w, w.document);\n    };\n  } else {\n    root.SVG = factory(root, root.document);\n  }\n})(typeof window !== 'undefined' ? window : undefined, function (window, document) {\n  // Find global reference - uses 'this' by default when available,\n  // falls back to 'window' otherwise (for bundlers like Webpack)\n  var globalRef = typeof this !== 'undefined' ? this : window; // The main wrapping element\n\n  var SVG = globalRef.SVG = function (element) {\n    if (SVG.supported) {\n      element = new SVG.Doc(element);\n\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      return element;\n    }\n  }; // Default namespaces\n\n\n  SVG.ns = 'http://www.w3.org/2000/svg';\n  SVG.xmlns = 'http://www.w3.org/2000/xmlns/';\n  SVG.xlink = 'http://www.w3.org/1999/xlink';\n  SVG.svgjs = 'http://svgjs.com/svgjs'; // Svg support test\n\n  SVG.supported = function () {\n    return true; // !!document.createElementNS &&\n    //     !! document.createElementNS(SVG.ns,'svg').createSVGRect\n  }(); // Don't bother to continue if SVG is not supported\n\n\n  if (!SVG.supported) return false; // Element id sequence\n\n  SVG.did = 1000; // Get next named element id\n\n  SVG.eid = function (name) {\n    return 'Svgjs' + capitalize(name) + SVG.did++;\n  }; // Method for element creation\n\n\n  SVG.create = function (name) {\n    // create element\n    var element = document.createElementNS(this.ns, name); // apply unique id\n\n    element.setAttribute('id', this.eid(name));\n    return element;\n  }; // Method for extending objects\n\n\n  SVG.extend = function () {\n    var modules, methods, key, i; // Get list of modules\n\n    modules = [].slice.call(arguments); // Get object with extensions\n\n    methods = modules.pop();\n\n    for (i = modules.length - 1; i >= 0; i--) {\n      if (modules[i]) {\n        for (key in methods) {\n          modules[i].prototype[key] = methods[key];\n        }\n      }\n    } // Make sure SVG.Set inherits any newly added methods\n\n\n    if (SVG.Set && SVG.Set.inherit) {\n      SVG.Set.inherit();\n    }\n  }; // Invent new element\n\n\n  SVG.invent = function (config) {\n    // Create element initializer\n    var initializer = typeof config.create === 'function' ? config.create : function () {\n      this.constructor.call(this, SVG.create(config.create));\n    }; // Inherit prototype\n\n    if (config.inherit) {\n      initializer.prototype = new config.inherit();\n    } // Extend with methods\n\n\n    if (config.extend) {\n      SVG.extend(initializer, config.extend);\n    } // Attach construct method to parent\n\n\n    if (config.construct) {\n      SVG.extend(config.parent || SVG.Container, config.construct);\n    }\n\n    return initializer;\n  }; // Adopt existing svg elements\n\n\n  SVG.adopt = function (node) {\n    // check for presence of node\n    if (!node) return null; // make sure a node isn't already adopted\n\n    if (node.instance) return node.instance; // initialize variables\n\n    var element; // adopt with element-specific settings\n\n    if (node.nodeName == 'svg') {\n      element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();\n    } else if (node.nodeName == 'linearGradient') {\n      element = new SVG.Gradient('linear');\n    } else if (node.nodeName == 'radialGradient') {\n      element = new SVG.Gradient('radial');\n    } else if (SVG[capitalize(node.nodeName)]) {\n      element = new SVG[capitalize(node.nodeName)]();\n    } else {\n      element = new SVG.Element(node);\n    } // ensure references\n\n\n    element.type = node.nodeName;\n    element.node = node;\n    node.instance = element; // SVG.Class specific preparations\n\n    if (element instanceof SVG.Doc) {\n      element.namespace().defs();\n    } // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n\n\n    element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n    return element;\n  }; // Initialize parsing element\n\n\n  SVG.prepare = function () {\n    // Select document body and create invisible svg element\n    var body = document.getElementsByTagName('body')[0],\n        draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object\n\n    SVG.parser = {\n      body: body || document.documentElement,\n      draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node,\n      poly: draw.polyline().node,\n      path: draw.path().node,\n      native: SVG.create('svg')\n    };\n  };\n\n  SVG.parser = {\n    native: SVG.create('svg')\n  };\n  document.addEventListener('DOMContentLoaded', function () {\n    if (!SVG.parser.draw) {\n      SVG.prepare();\n    }\n  }, false); // Storage for regular expressions\n\n  SVG.regex = {\n    // Parse unit value\n    numberAndUnit: /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i,\n    // Parse hex value\n    hex: /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n    // Parse rgb value\n    rgb: /rgb\\((\\d+),(\\d+),(\\d+)\\)/,\n    // Parse reference id\n    reference: /#([a-z0-9\\-_]+)/i,\n    // splits a transformation chain\n    transforms: /\\)\\s*,?\\s*/,\n    // Whitespace\n    whitespace: /\\s/g,\n    // Test hex value\n    isHex: /^#[a-f0-9]{3,6}$/i,\n    // Test rgb value\n    isRgb: /^rgb\\(/,\n    // Test css declaration\n    isCss: /[^:]+:[^;]+;?/,\n    // Test for blank string\n    isBlank: /^(\\s+)?$/,\n    // Test for numeric string\n    isNumber: /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n    // Test for percent value\n    isPercent: /^-?[\\d\\.]+%$/,\n    // Test for image url\n    isImage: /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i,\n    // split at whitespace and comma\n    delimiter: /[\\s,]+/,\n    // The following regex are used to parse the d attribute of a path\n    // Matches all hyphens which are not after an exponent\n    hyphen: /([^e])\\-/gi,\n    // Replaces and tests for all path letters\n    pathLetters: /[MLHVCSQTAZ]/gi,\n    // yes we need this one, too\n    isPathLetter: /[MLHVCSQTAZ]/i,\n    // matches 0.154.23.45\n    numbersWithDots: /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi,\n    // matches .\n    dots: /\\./g\n  };\n  SVG.utils = {\n    // Map function\n    map: function map(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        result.push(block(array[i]));\n      }\n\n      return result;\n    },\n    // Filter function\n    filter: function filter(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        if (block(array[i])) {\n          result.push(array[i]);\n        }\n      }\n\n      return result;\n    },\n    // Degrees to radians\n    radians: function radians(d) {\n      return d % 360 * Math.PI / 180;\n    },\n    // Radians to degrees\n    degrees: function degrees(r) {\n      return r * 180 / Math.PI % 360;\n    },\n    filterSVGElements: function filterSVGElements(nodes) {\n      return this.filter(nodes, function (el) {\n        return el instanceof window.SVGElement;\n      });\n    }\n  };\n  SVG.defaults = {\n    // Default attribute values\n    attrs: {\n      // fill and stroke\n      'fill-opacity': 1,\n      'stroke-opacity': 1,\n      'stroke-width': 0,\n      'stroke-linejoin': 'miter',\n      'stroke-linecap': 'butt',\n      fill: '#000000',\n      stroke: '#000000',\n      opacity: 1,\n      // position\n      x: 0,\n      y: 0,\n      cx: 0,\n      cy: 0,\n      // size\n      width: 0,\n      height: 0,\n      // radius\n      r: 0,\n      rx: 0,\n      ry: 0,\n      // gradient\n      offset: 0,\n      'stop-opacity': 1,\n      'stop-color': '#000000',\n      // text\n      'font-size': 16,\n      'font-family': 'Helvetica, Arial, sans-serif',\n      'text-anchor': 'start'\n    } // Module for color convertions\n\n  };\n\n  SVG.Color = function (color) {\n    var match; // initialize defaults\n\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    if (!color) return; // parse color\n\n    if (typeof color === 'string') {\n      if (SVG.regex.isRgb.test(color)) {\n        // get rgb values\n        match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values\n\n        this.r = parseInt(match[1]);\n        this.g = parseInt(match[2]);\n        this.b = parseInt(match[3]);\n      } else if (SVG.regex.isHex.test(color)) {\n        // get hex values\n        match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values\n\n        this.r = parseInt(match[1], 16);\n        this.g = parseInt(match[2], 16);\n        this.b = parseInt(match[3], 16);\n      }\n    } else if (_typeof(color) === 'object') {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n    }\n  };\n\n  SVG.extend(SVG.Color, {\n    // Default to hex conversion\n    toString: function toString() {\n      return this.toHex();\n    },\n    // Build hex value\n    toHex: function toHex() {\n      return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);\n    },\n    // Build rgb value\n    toRgb: function toRgb() {\n      return 'rgb(' + [this.r, this.g, this.b].join() + ')';\n    },\n    // Calculate true brightness\n    brightness: function brightness() {\n      return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;\n    },\n    // Make color morphable\n    morph: function morph(color) {\n      this.destination = new SVG.Color(color);\n      return this;\n    },\n    // Get morphed color at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // normalise pos\n\n      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color\n\n      return new SVG.Color({\n        r: ~~(this.r + (this.destination.r - this.r) * pos),\n        g: ~~(this.g + (this.destination.g - this.g) * pos),\n        b: ~~(this.b + (this.destination.b - this.b) * pos)\n      });\n    }\n  }); // Testers\n  // Test if given value is a color string\n\n  SVG.Color.test = function (color) {\n    color += '';\n    return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);\n  }; // Test if given value is a rgb object\n\n\n  SVG.Color.isRgb = function (color) {\n    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n  }; // Test if given value is a color\n\n\n  SVG.Color.isColor = function (color) {\n    return SVG.Color.isRgb(color) || SVG.Color.test(color);\n  }; // Module for array conversion\n\n\n  SVG.Array = function (array, fallback) {\n    array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback\n\n    if (array.length == 0 && fallback) {\n      array = fallback.valueOf();\n    } // parse array\n\n\n    this.value = this.parse(array);\n  };\n\n  SVG.extend(SVG.Array, {\n    // Make array morphable\n    morph: function morph(array) {\n      this.destination = this.parse(array); // normalize length of arrays\n\n      if (this.value.length != this.destination.length) {\n        var lastValue = this.value[this.value.length - 1],\n            lastDestination = this.destination[this.destination.length - 1];\n\n        while (this.value.length > this.destination.length) {\n          this.destination.push(lastDestination);\n        }\n\n        while (this.value.length < this.destination.length) {\n          this.value.push(lastValue);\n        }\n      }\n\n      return this;\n    },\n    // Clean up any duplicate points\n    settle: function settle() {\n      // find all unique values\n      for (var i = 0, il = this.value.length, seen = []; i < il; i++) {\n        if (seen.indexOf(this.value[i]) == -1) {\n          seen.push(this.value[i]);\n        }\n      } // set new value\n\n\n      return this.value = seen;\n    },\n    // Get morphed array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed array\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos);\n      }\n\n      return new SVG.Array(array);\n    },\n    // Convert array to string\n    toString: function toString() {\n      return this.value.join(' ');\n    },\n    // Real value\n    valueOf: function valueOf() {\n      return this.value;\n    },\n    // Parse whitespace separated string\n    parse: function parse(array) {\n      array = array.valueOf(); // if already is an array, no need to parse it\n\n      if (Array.isArray(array)) return array;\n      return this.split(array);\n    },\n    // Strip unnecessary whitespace\n    split: function split(string) {\n      return string.trim().split(SVG.regex.delimiter).map(parseFloat);\n    },\n    // Reverse array\n    reverse: function reverse() {\n      this.value.reverse();\n      return this;\n    },\n    clone: function clone() {\n      var clone = new this.constructor();\n      clone.value = array_clone(this.value);\n      return clone;\n    }\n  }); // Poly points array\n\n  SVG.PointArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [[0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PointArray.prototype = new SVG.Array();\n  SVG.PointArray.prototype.constructor = SVG.PointArray;\n  SVG.extend(SVG.PointArray, {\n    // Convert array to string\n    toString: function toString() {\n      // convert to a poly point string\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i].join(','));\n      }\n\n      return array.join(' ');\n    },\n    // Convert array to line object\n    toLine: function toLine() {\n      return {\n        x1: this.value[0][0],\n        y1: this.value[0][1],\n        x2: this.value[1][0],\n        y2: this.value[1][1]\n      };\n    },\n    // Get morphed array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed point string\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);\n      }\n\n      return new SVG.PointArray(array);\n    },\n    // Parse point string and flat array\n    parse: function parse(array) {\n      var points = [];\n      array = array.valueOf(); // if it is an array\n\n      if (Array.isArray(array)) {\n        // and it is not flat, there is no need to parse it\n        if (Array.isArray(array[0])) {\n          // make sure to use a clone\n          return array.map(function (el) {\n            return el.slice();\n          });\n        } else if (array[0].x != null) {\n          // allow point objects to be passed\n          return array.map(function (el) {\n            return [el.x, el.y];\n          });\n        }\n      } else {\n        // Else, it is considered as a string\n        // parse points\n        array = array.trim().split(SVG.regex.delimiter).map(parseFloat);\n      } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n\n\n      if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples and parse points as floats\n\n      for (var i = 0, len = array.length; i < len; i = i + 2) {\n        points.push([array[i], array[i + 1]]);\n      }\n\n      return points;\n    },\n    // Move point string\n    move: function move(x, y) {\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y; // move every point\n\n      if (!isNaN(x) && !isNaN(y)) {\n        for (var i = this.value.length - 1; i >= 0; i--) {\n          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];\n        }\n      }\n\n      return this;\n    },\n    // Resize poly string\n    size: function size(width, height) {\n      var i,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        if (box.width) this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;\n        if (box.height) this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n      }\n\n      return this;\n    },\n    // Get bounding box of points\n    bbox: function bbox() {\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      SVG.parser.poly.setAttribute('points', this.toString());\n      return SVG.parser.poly.getBBox();\n    }\n  });\n  var pathHandlers = {\n    M: function M(c, p, p0) {\n      p.x = p0.x = c[0];\n      p.y = p0.y = c[1];\n      return ['M', p.x, p.y];\n    },\n    L: function L(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['L', c[0], c[1]];\n    },\n    H: function H(c, p) {\n      p.x = c[0];\n      return ['H', c[0]];\n    },\n    V: function V(c, p) {\n      p.y = c[0];\n      return ['V', c[0]];\n    },\n    C: function C(c, p) {\n      p.x = c[4];\n      p.y = c[5];\n      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n    },\n    S: function S(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['S', c[0], c[1], c[2], c[3]];\n    },\n    Q: function Q(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['Q', c[0], c[1], c[2], c[3]];\n    },\n    T: function T(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['T', c[0], c[1]];\n    },\n    Z: function Z(c, p, p0) {\n      p.x = p0.x;\n      p.y = p0.y;\n      return ['Z'];\n    },\n    A: function A(c, p) {\n      p.x = c[5];\n      p.y = c[6];\n      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n    }\n  };\n  var mlhvqtcsa = 'mlhvqtcsaz'.split('');\n\n  for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {\n    pathHandlers[mlhvqtcsa[i]] = function (i) {\n      return function (c, p, p0) {\n        if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {\n          c[5] = c[5] + p.x, c[6] = c[6] + p.y;\n        } else {\n          for (var j = 0, jl = c.length; j < jl; ++j) {\n            c[j] = c[j] + (j % 2 ? p.y : p.x);\n          }\n        }\n        return pathHandlers[i](c, p, p0);\n      };\n    }(mlhvqtcsa[i].toUpperCase());\n  } // Path points array\n\n\n  SVG.PathArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [['M', 0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PathArray.prototype = new SVG.Array();\n  SVG.PathArray.prototype.constructor = SVG.PathArray;\n  SVG.extend(SVG.PathArray, {\n    // Convert array to string\n    toString: function toString() {\n      return arrayToString(this.value);\n    },\n    // Move path string\n    move: function move(x, y) {\n      // get bounding box of current situation\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y;\n\n      if (!isNaN(x) && !isNaN(y)) {\n        // move every point\n        for (var l, i = this.value.length - 1; i >= 0; i--) {\n          l = this.value[i][0];\n\n          if (l == 'M' || l == 'L' || l == 'T') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n          } else if (l == 'H') {\n            this.value[i][1] += x;\n          } else if (l == 'V') {\n            this.value[i][1] += y;\n          } else if (l == 'C' || l == 'S' || l == 'Q') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n            this.value[i][3] += x;\n            this.value[i][4] += y;\n\n            if (l == 'C') {\n              this.value[i][5] += x;\n              this.value[i][6] += y;\n            }\n          } else if (l == 'A') {\n            this.value[i][6] += x;\n            this.value[i][7] += y;\n          }\n        }\n      }\n\n      return this;\n    },\n    // Resize path string\n    size: function size(width, height) {\n      // get bounding box of current situation\n      var i,\n          l,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        l = this.value[i][0];\n\n        if (l == 'M' || l == 'L' || l == 'T') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n        } else if (l == 'H') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n        } else if (l == 'V') {\n          this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n        } else if (l == 'C' || l == 'S' || l == 'Q') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n          this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;\n          this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;\n\n          if (l == 'C') {\n            this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;\n            this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y;\n          }\n        } else if (l == 'A') {\n          // resize radii\n          this.value[i][1] = this.value[i][1] * width / box.width;\n          this.value[i][2] = this.value[i][2] * height / box.height; // move position values\n\n          this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;\n          this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y;\n        }\n      }\n\n      return this;\n    },\n    // Test if the passed path array use the same path data commands as this path array\n    equalCommands: function equalCommands(pathArray) {\n      var i, il, equalCommands;\n      pathArray = new SVG.PathArray(pathArray);\n      equalCommands = this.value.length === pathArray.value.length;\n\n      for (i = 0, il = this.value.length; equalCommands && i < il; i++) {\n        equalCommands = this.value[i][0] === pathArray.value[i][0];\n      }\n\n      return equalCommands;\n    },\n    // Make path array morphable\n    morph: function morph(pathArray) {\n      pathArray = new SVG.PathArray(pathArray);\n\n      if (this.equalCommands(pathArray)) {\n        this.destination = pathArray;\n      } else {\n        this.destination = null;\n      }\n\n      return this;\n    },\n    // Get morphed path array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this;\n      var sourceArray = this.value,\n          destinationArray = this.destination.value,\n          array = [],\n          pathArray = new SVG.PathArray(),\n          i,\n          il,\n          j,\n          jl; // Animate has specified in the SVG spec\n      // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\n\n      for (i = 0, il = sourceArray.length; i < il; i++) {\n        array[i] = [sourceArray[i][0]];\n\n        for (j = 1, jl = sourceArray[i].length; j < jl; j++) {\n          array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;\n        } // For the two flags of the elliptical arc command, the SVG spec say:\n        // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\n        // Elliptical arc command as an array followed by corresponding indexes:\n        // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        //   0    1   2        3                 4             5      6  7\n\n\n        if (array[i][0] === 'A') {\n          array[i][4] = +(array[i][4] != 0);\n          array[i][5] = +(array[i][5] != 0);\n        }\n      } // Directly modify the value of a path array, this is done this way for performance\n\n\n      pathArray.value = array;\n      return pathArray;\n    },\n    // Absolutize and parse path to array\n    parse: function parse(array) {\n      // if it's already a patharray, no need to parse it\n      if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing\n\n      var s,\n          arr,\n          paramCnt = {\n        'M': 2,\n        'L': 2,\n        'H': 1,\n        'V': 1,\n        'C': 6,\n        'S': 4,\n        'Q': 4,\n        'T': 2,\n        'A': 7,\n        'Z': 0\n      };\n\n      if (typeof array === 'string') {\n        array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\n        .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen\n        .trim() // trim\n        .split(SVG.regex.delimiter); // split into array\n      } else {\n        array = array.reduce(function (prev, curr) {\n          return [].concat.call(prev, curr);\n        }, []);\n      } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n\n      var arr = [],\n          p = new SVG.Point(),\n          p0 = new SVG.Point(),\n          index = 0,\n          len = array.length;\n\n      do {\n        // Test if we have a path letter\n        if (SVG.regex.isPathLetter.test(array[index])) {\n          s = array[index];\n          ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n        } else if (s == 'M') {\n          s = 'L';\n        } else if (s == 'm') {\n          s = 'l';\n        }\n\n        arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));\n      } while (len > index);\n\n      return arr;\n    },\n    // Get bounding box of path\n    bbox: function bbox() {\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      SVG.parser.path.setAttribute('d', this.toString());\n      return SVG.parser.path.getBBox();\n    }\n  }); // Module for unit convertions\n\n  SVG.Number = SVG.invent({\n    // Initialize\n    create: function create(value, unit) {\n      // initialize defaults\n      this.value = 0;\n      this.unit = unit || ''; // parse value\n\n      if (typeof value === 'number') {\n        // ensure a valid numeric value\n        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n      } else if (typeof value === 'string') {\n        unit = value.match(SVG.regex.numberAndUnit);\n\n        if (unit) {\n          // make value numeric\n          this.value = parseFloat(unit[1]); // normalize\n\n          if (unit[5] == '%') {\n            this.value /= 100;\n          } else if (unit[5] == 's') {\n            this.value *= 1000;\n          } // store unit\n\n\n          this.unit = unit[5];\n        }\n      } else {\n        if (value instanceof SVG.Number) {\n          this.value = value.valueOf();\n          this.unit = value.unit;\n        }\n      }\n    },\n    // Add methods\n    extend: {\n      // Stringalize\n      toString: function toString() {\n        return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;\n      },\n      toJSON: function toJSON() {\n        return this.toString();\n      },\n      // Convert to primitive\n      valueOf: function valueOf() {\n        return this.value;\n      },\n      // Add number\n      plus: function plus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this + number, this.unit || number.unit);\n      },\n      // Subtract number\n      minus: function minus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this - number, this.unit || number.unit);\n      },\n      // Multiply number\n      times: function times(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this * number, this.unit || number.unit);\n      },\n      // Divide number\n      divide: function divide(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this / number, this.unit || number.unit);\n      },\n      // Convert to different unit\n      to: function to(unit) {\n        var number = new SVG.Number(this);\n\n        if (typeof unit === 'string') {\n          number.unit = unit;\n        }\n\n        return number;\n      },\n      // Make number morphable\n      morph: function morph(number) {\n        this.destination = new SVG.Number(number);\n\n        if (number.relative) {\n          this.destination.value += this.value;\n        }\n\n        return this;\n      },\n      // Get morphed number at given position\n      at: function at(pos) {\n        // Make sure a destination is defined\n        if (!this.destination) return this; // Generate new morphed number\n\n        return new SVG.Number(this.destination).minus(this).times(pos).plus(this);\n      }\n    }\n  });\n  SVG.Element = SVG.invent({\n    // Initialize node\n    create: function create(node) {\n      // make stroke value accessible dynamically\n      this._stroke = SVG.defaults.attrs.stroke;\n      this._event = null; // initialize data object\n\n      this.dom = {}; // create circular reference\n\n      if (this.node = node) {\n        this.type = node.nodeName;\n        this.node.instance = this; // store current attribute value\n\n        this._stroke = node.getAttribute('stroke') || this._stroke;\n      }\n    },\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x) {\n        return this.attr('x', _x);\n      },\n      // Move over y-axis\n      y: function y(_y) {\n        return this.attr('y', _y);\n      },\n      // Move by center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n      },\n      // Move by center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n      },\n      // Move element to given x and y values\n      move: function move(x, y) {\n        return this.x(x).y(y);\n      },\n      // Move element by its center\n      center: function center(x, y) {\n        return this.cx(x).cy(y);\n      },\n      // Set width of element\n      width: function width(_width) {\n        return this.attr('width', _width);\n      },\n      // Set height of element\n      height: function height(_height) {\n        return this.attr('height', _height);\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));\n      },\n      // Clone element\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // clone element and assign new id\n\n        var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) parent.add(clone);else this.after(clone);\n        return clone;\n      },\n      // Remove element\n      remove: function remove() {\n        if (this.parent()) {\n          this.parent().removeElement(this);\n        }\n\n        return this;\n      },\n      // Replace element\n      replace: function replace(element) {\n        this.after(element).remove();\n        return element;\n      },\n      // Add element to given container and return self\n      addTo: function addTo(parent) {\n        return parent.put(this);\n      },\n      // Add element to given container and return container\n      putIn: function putIn(parent) {\n        return parent.add(this);\n      },\n      // Get / set id\n      id: function id(_id) {\n        return this.attr('id', _id);\n      },\n      // Checks whether the given point inside the bounding box of the element\n      inside: function inside(x, y) {\n        var box = this.bbox();\n        return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n      },\n      // Show element\n      show: function show() {\n        return this.style('display', '');\n      },\n      // Hide element\n      hide: function hide() {\n        return this.style('display', 'none');\n      },\n      // Is element visible?\n      visible: function visible() {\n        return this.style('display') != 'none';\n      },\n      // Return id on string conversion\n      toString: function toString() {\n        return this.attr('id');\n      },\n      // Return array of classes on the node\n      classes: function classes() {\n        var attr = this.attr('class');\n        return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);\n      },\n      // Return true if class exists on the node, false otherwise\n      hasClass: function hasClass(name) {\n        return this.classes().indexOf(name) != -1;\n      },\n      // Add class to the node\n      addClass: function addClass(name) {\n        if (!this.hasClass(name)) {\n          var array = this.classes();\n          array.push(name);\n          this.attr('class', array.join(' '));\n        }\n\n        return this;\n      },\n      // Remove class from the node\n      removeClass: function removeClass(name) {\n        if (this.hasClass(name)) {\n          this.attr('class', this.classes().filter(function (c) {\n            return c != name;\n          }).join(' '));\n        }\n\n        return this;\n      },\n      // Toggle the presence of a class on the node\n      toggleClass: function toggleClass(name) {\n        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n      },\n      // Get referenced element form attribute value\n      reference: function reference(attr) {\n        return SVG.get(this.attr(attr));\n      },\n      // Returns the parent element instance\n      parent: function parent(type) {\n        var parent = this; // check for parent\n\n        if (!parent.node.parentNode) return null; // get parent element\n\n        parent = SVG.adopt(parent.node.parentNode);\n        if (!type) return parent; // loop trough ancestors if type is given\n\n        while (parent && parent.node instanceof window.SVGElement) {\n          if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n          if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document') return null; // #759, #720\n\n          parent = SVG.adopt(parent.node.parentNode);\n        }\n      },\n      // Get parent document\n      doc: function doc() {\n        return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);\n      },\n      // return array of all ancestors of given type up to the root svg\n      parents: function parents(type) {\n        var parents = [],\n            parent = this;\n\n        do {\n          parent = parent.parent(type);\n          if (!parent || !parent.node) break;\n          parents.push(parent);\n        } while (parent.parent);\n\n        return parents;\n      },\n      // matches the element vs a css selector\n      matches: function matches(selector) {\n        return _matches(this.node, selector);\n      },\n      // Returns the svg node to call native svg methods on it\n      native: function native() {\n        return this.node;\n      },\n      // Import raw svg\n      svg: function svg(_svg) {\n        // create temporary holder\n        var well = document.createElement('svg'); // act as a setter if svg is given\n\n        if (_svg && this instanceof SVG.Parent) {\n          // dump raw svg\n          well.innerHTML = '<svg>' + _svg.replace(/\\n/, '').replace(/<([\\w:-]+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes\n\n          for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {\n            this.node.appendChild(well.firstChild.firstChild);\n          } // otherwise act as a getter\n\n        } else {\n          // create a wrapping svg element in case of partial content\n          well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom\n\n          this.writeDataToDom(); // insert a copy of this node\n\n          _svg.appendChild(this.node.cloneNode(true)); // return target element\n\n\n          return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '');\n        }\n\n        return this;\n      },\n      // write svgjs data to the dom\n      writeDataToDom: function writeDataToDom() {\n        // dump variables recursively\n        if (this.each || this.lines) {\n          var fn = this.each ? this : this.lines();\n          fn.each(function () {\n            this.writeDataToDom();\n          });\n        } // remove previously set data\n\n\n        this.node.removeAttribute('svgjs:data');\n\n        if (Object.keys(this.dom).length) {\n          this.node.setAttribute('svgjs:data', JSON.stringify(this.dom));\n        } // see #428\n\n\n        return this;\n      },\n      // set given data to the elements data property\n      setData: function setData(o) {\n        this.dom = o;\n        return this;\n      },\n      is: function is(obj) {\n        return _is(this, obj);\n      }\n    }\n  });\n  SVG.easing = {\n    '-': function _(pos) {\n      return pos;\n    },\n    '<>': function _(pos) {\n      return -Math.cos(pos * Math.PI) / 2 + 0.5;\n    },\n    '>': function _(pos) {\n      return Math.sin(pos * Math.PI / 2);\n    },\n    '<': function _(pos) {\n      return -Math.cos(pos * Math.PI / 2) + 1;\n    }\n  };\n\n  SVG.morph = function (pos) {\n    return function (from, to) {\n      return new SVG.MorphObj(from, to).at(pos);\n    };\n  };\n\n  SVG.Situation = SVG.invent({\n    create: function create(o) {\n      this.init = false;\n      this.reversed = false;\n      this.reversing = false;\n      this.duration = new SVG.Number(o.duration).valueOf();\n      this.delay = new SVG.Number(o.delay).valueOf();\n      this.start = +new Date() + this.delay;\n      this.finish = this.start + this.duration;\n      this.ease = o.ease; // this.loop is incremented from 0 to this.loops\n      // it is also incremented when in an infinite loop (when this.loops is true)\n\n      this.loop = 0;\n      this.loops = false;\n      this.animations = {// functionToCall: [list of morphable objects]\n        // e.g. move: [SVG.Number, SVG.Number]\n      };\n      this.attrs = {// holds all attributes which are not represented from a function svg.js provides\n        // e.g. someAttr: SVG.Number\n      };\n      this.styles = {// holds all styles which should be animated\n        // e.g. fill-color: SVG.Color\n      };\n      this.transforms = [// holds all transformations as transformation objects\n        // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\n      ];\n      this.once = {// functions to fire at a specific position\n        // e.g. \"0.5\": function foo(){}\n      };\n    }\n  });\n  SVG.FX = SVG.invent({\n    create: function create(element) {\n      this._target = element;\n      this.situations = [];\n      this.active = false;\n      this.situation = null;\n      this.paused = false;\n      this.lastPos = 0;\n      this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\n      // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\n\n      this.absPos = 0;\n      this._speed = 1;\n    },\n    extend: {\n      /**\n       * sets or returns the target of this animation\n       * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\n       * @param ease function || string Function which should be used for easing or easing keyword\n       * @param delay Number indicating the delay before the animation starts\n       * @return target || this\n       */\n      animate: function animate(o, ease, delay) {\n        if (_typeof(o) === 'object') {\n          ease = o.ease;\n          delay = o.delay;\n          o = o.duration;\n        }\n\n        var situation = new SVG.Situation({\n          duration: o || 1000,\n          delay: delay || 0,\n          ease: SVG.easing[ease || '-'] || ease\n        });\n        this.queue(situation);\n        return this;\n      },\n\n      /**\n      * sets a delay before the next element of the queue is called\n      * @param delay Duration of delay in milliseconds\n      * @return this.target()\n      */\n      delay: function delay(_delay) {\n        // The delay is performed by an empty situation with its duration\n        // attribute set to the duration of the delay\n        var situation = new SVG.Situation({\n          duration: _delay,\n          delay: 0,\n          ease: SVG.easing['-']\n        });\n        return this.queue(situation);\n      },\n\n      /**\n      * sets or returns the target of this animation\n      * @param null || target SVG.Element which should be set as new target\n      * @return target || this\n      */\n      target: function target(_target) {\n        if (_target && _target instanceof SVG.Element) {\n          this._target = _target;\n          return this;\n        }\n\n        return this._target;\n      },\n      // returns the absolute position at a given time\n      timeToAbsPos: function timeToAbsPos(timestamp) {\n        return (timestamp - this.situation.start) / (this.situation.duration / this._speed);\n      },\n      // returns the timestamp from a given absolute positon\n      absPosToTime: function absPosToTime(absPos) {\n        return this.situation.duration / this._speed * absPos + this.situation.start;\n      },\n      // starts the animationloop\n      startAnimFrame: function startAnimFrame() {\n        this.stopAnimFrame();\n        this.animationFrame = window.requestAnimationFrame(function () {\n          this.step();\n        }.bind(this));\n      },\n      // cancels the animationframe\n      stopAnimFrame: function stopAnimFrame() {\n        window.cancelAnimationFrame(this.animationFrame);\n      },\n      // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\n      start: function start() {\n        // dont start if already started\n        if (!this.active && this.situation) {\n          this.active = true;\n          this.startCurrent();\n        }\n\n        return this;\n      },\n      // start the current situation\n      startCurrent: function startCurrent() {\n        this.situation.start = +new Date() + this.situation.delay / this._speed;\n        this.situation.finish = this.situation.start + this.situation.duration / this._speed;\n        return this.initAnimations().step();\n      },\n\n      /**\n      * adds a function / Situation to the animation queue\n      * @param fn function / situation to add\n      * @return this\n      */\n      queue: function queue(fn) {\n        if (typeof fn === 'function' || fn instanceof SVG.Situation) {\n          this.situations.push(fn);\n        }\n\n        if (!this.situation) this.situation = this.situations.shift();\n        return this;\n      },\n\n      /**\n      * pulls next element from the queue and execute it\n      * @return this\n      */\n      dequeue: function dequeue() {\n        // stop current animation\n        this.stop(); // get next animation from queue\n\n        this.situation = this.situations.shift();\n\n        if (this.situation) {\n          if (this.situation instanceof SVG.Situation) {\n            this.start();\n          } else {\n            // If it is not a SVG.Situation, then it is a function, we execute it\n            this.situation.call(this);\n          }\n        }\n\n        return this;\n      },\n      // updates all animations to the current state of the element\n      // this is important when one property could be changed from another property\n      initAnimations: function initAnimations() {\n        var i, j, source;\n        var s = this.situation;\n        if (s.init) return this;\n\n        for (i in s.animations) {\n          source = this.target()[i]();\n\n          if (!Array.isArray(source)) {\n            source = [source];\n          }\n\n          if (!Array.isArray(s.animations[i])) {\n            s.animations[i] = [s.animations[i]];\n          } // if(s.animations[i].length > source.length) {\n          //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\n          // }\n\n\n          for (j = source.length; j--;) {\n            // The condition is because some methods return a normal number instead\n            // of a SVG.Number\n            if (s.animations[i][j] instanceof SVG.Number) {\n              source[j] = new SVG.Number(source[j]);\n            }\n\n            s.animations[i][j] = source[j].morph(s.animations[i][j]);\n          }\n        }\n\n        for (i in s.attrs) {\n          s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);\n        }\n\n        for (i in s.styles) {\n          s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);\n        }\n\n        s.initialTransformation = this.target().matrixify();\n        s.init = true;\n        return this;\n      },\n      clearQueue: function clearQueue() {\n        this.situations = [];\n        return this;\n      },\n      clearCurrent: function clearCurrent() {\n        this.situation = null;\n        return this;\n      },\n\n      /** stops the animation immediately\n      * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\n      * @param clearQueue A Boolean indicating whether to remove queued animation as well.\n      * @return this\n      */\n      stop: function stop(jumpToEnd, clearQueue) {\n        var active = this.active;\n        this.active = false;\n\n        if (clearQueue) {\n          this.clearQueue();\n        }\n\n        if (jumpToEnd && this.situation) {\n          // initialize the situation if it was not\n          !active && this.startCurrent();\n          this.atEnd();\n        }\n\n        this.stopAnimFrame();\n        return this.clearCurrent();\n      },\n\n      /** resets the element to the state where the current element has started\n      * @return this\n      */\n      reset: function reset() {\n        if (this.situation) {\n          var temp = this.situation;\n          this.stop();\n          this.situation = temp;\n          this.atStart();\n        }\n\n        return this;\n      },\n      // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\n      finish: function finish() {\n        this.stop(true, false);\n\n        while (this.dequeue().situation && this.stop(true, false)) {\n        }\n\n        this.clearQueue().clearCurrent();\n        return this;\n      },\n      // set the internal animation pointer at the start position, before any loops, and updates the visualisation\n      atStart: function atStart() {\n        return this.at(0, true);\n      },\n      // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\n      atEnd: function atEnd() {\n        if (this.situation.loops === true) {\n          // If in a infinite loop, we end the current iteration\n          this.situation.loops = this.situation.loop + 1;\n        }\n\n        if (typeof this.situation.loops === 'number') {\n          // If performing a finite number of loops, we go after all the loops\n          return this.at(this.situation.loops, true);\n        } else {\n          // If no loops, we just go at the end\n          return this.at(1, true);\n        }\n      },\n      // set the internal animation pointer to the specified position and updates the visualisation\n      // if isAbsPos is true, pos is treated as an absolute position\n      at: function at(pos, isAbsPos) {\n        var durDivSpd = this.situation.duration / this._speed;\n        this.absPos = pos; // If pos is not an absolute position, we convert it into one\n\n        if (!isAbsPos) {\n          if (this.situation.reversed) this.absPos = 1 - this.absPos;\n          this.absPos += this.situation.loop;\n        }\n\n        this.situation.start = +new Date() - this.absPos * durDivSpd;\n        this.situation.finish = this.situation.start + durDivSpd;\n        return this.step(true);\n      },\n\n      /**\n      * sets or returns the speed of the animations\n      * @param speed null || Number The new speed of the animations\n      * @return Number || this\n      */\n      speed: function speed(_speed) {\n        if (_speed === 0) return this.pause();\n\n        if (_speed) {\n          this._speed = _speed; // We use an absolute position here so that speed can affect the delay before the animation\n\n          return this.at(this.absPos, true);\n        } else return this._speed;\n      },\n      // Make loopable\n      loop: function loop(times, reverse) {\n        var c = this.last(); // store total loops\n\n        c.loops = times != null ? times : true;\n        c.loop = 0;\n        if (reverse) c.reversing = true;\n        return this;\n      },\n      // pauses the animation\n      pause: function pause() {\n        this.paused = true;\n        this.stopAnimFrame();\n        return this;\n      },\n      // unpause the animation\n      play: function play() {\n        if (!this.paused) return this;\n        this.paused = false; // We use an absolute position here so that the delay before the animation can be paused\n\n        return this.at(this.absPos, true);\n      },\n\n      /**\n      * toggle or set the direction of the animation\n      * true sets direction to backwards while false sets it to forwards\n      * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\n      * @return this\n      */\n      reverse: function reverse(reversed) {\n        var c = this.last();\n        if (typeof reversed === 'undefined') c.reversed = !c.reversed;else c.reversed = reversed;\n        return this;\n      },\n\n      /**\n      * returns a float from 0-1 indicating the progress of the current animation\n      * @param eased Boolean indicating whether the returned position should be eased or not\n      * @return number\n      */\n      progress: function progress(easeIt) {\n        return easeIt ? this.situation.ease(this.pos) : this.pos;\n      },\n\n      /**\n      * adds a callback function which is called when the current animation is finished\n      * @param fn Function which should be executed as callback\n      * @return number\n      */\n      after: function after(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, c);\n            this.off('finished.fx', wrapper); // prevent memory leak\n          }\n        };\n\n        this.target().on('finished.fx', wrapper);\n        return this._callStart();\n      },\n      // adds a callback which is called whenever one animation step is performed\n      during: function during(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);\n          }\n        }; // see above\n\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.after(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      },\n      // calls after ALL animations in the queue are finished\n      afterAll: function afterAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this);\n          this.off('allfinished.fx', wrapper);\n        }; // see above\n\n\n        this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);\n        return this._callStart();\n      },\n      // calls on every animation step for all animations\n      duringAll: function duringAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation);\n        };\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.afterAll(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      },\n      last: function last() {\n        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;\n      },\n      // adds one property to the animations\n      add: function add(method, args, type) {\n        this.last()[type || 'animations'][method] = args;\n        return this._callStart();\n      },\n\n      /** perform one step of the animation\n      *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\n      *  @return this\n      */\n      step: function step(ignoreTime) {\n        // convert current time to an absolute position\n        if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position\n\n        if (this.situation.loops !== false) {\n          var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0\n\n          absPos = Math.max(this.absPos, 0);\n          absPosInt = Math.floor(absPos);\n\n          if (this.situation.loops === true || absPosInt < this.situation.loops) {\n            this.pos = absPos - absPosInt;\n            lastLoop = this.situation.loop;\n            this.situation.loop = absPosInt;\n          } else {\n            this.absPos = this.situation.loops;\n            this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed\n\n            lastLoop = this.situation.loop - 1;\n            this.situation.loop = this.situation.loops;\n          }\n\n          if (this.situation.reversing) {\n            // Toggle reversed if an odd number of loops as occured since the last call of step\n            this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);\n          }\n        } else {\n          // If there are no loop, the absolute position must not be above 1\n          this.absPos = Math.min(this.absPos, 1);\n          this.pos = this.absPos;\n        } // while the absolute position can be below 0, the position must not be below 0\n\n\n        if (this.pos < 0) this.pos = 0;\n        if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing\n\n        var eased = this.situation.ease(this.pos); // call once-callbacks\n\n        for (var i in this.situation.once) {\n          if (i > this.lastPos && i <= eased) {\n            this.situation.once[i].call(this.target(), this.pos, eased);\n            delete this.situation.once[i];\n          }\n        } // fire during callback with position, eased position and current situation as parameter\n\n\n        if (this.active) this.target().fire('during', {\n          pos: this.pos,\n          eased: eased,\n          fx: this,\n          situation: this.situation\n        }); // the user may call stop or finish in the during callback\n        // so make sure that we still have a valid situation\n\n        if (!this.situation) {\n          return this;\n        } // apply the actual animation to every property\n\n\n        this.eachAt(); // do final code when situation is finished\n\n        if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {\n          // stop animation callback\n          this.stopAnimFrame(); // fire finished callback with current situation as parameter\n\n          this.target().fire('finished', {\n            fx: this,\n            situation: this.situation\n          });\n\n          if (!this.situations.length) {\n            this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback\n\n            if (!this.situations.length) {\n              this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...\n\n              this.active = false;\n            }\n          } // start next animation\n\n\n          if (this.active) this.dequeue();else this.clearCurrent();\n        } else if (!this.paused && this.active) {\n          // we continue animating when we are not at the end\n          this.startAnimFrame();\n        } // save last eased position for once callback triggering\n\n\n        this.lastPos = eased;\n        return this;\n      },\n      // calculates the step for every property and calls block with it\n      eachAt: function eachAt() {\n        var i,\n            len,\n            at,\n            self = this,\n            target = this.target(),\n            s = this.situation; // apply animations which can be called trough a method\n\n        for (i in s.animations) {\n          at = [].concat(s.animations[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target[i].apply(target, at);\n        } // apply animation which has to be applied with attr()\n\n\n        for (i in s.attrs) {\n          at = [i].concat(s.attrs[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.attr.apply(target, at);\n        } // apply animation which has to be applied with style()\n\n\n        for (i in s.styles) {\n          at = [i].concat(s.styles[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.style.apply(target, at);\n        } // animate initialTransformation which has to be chained\n\n\n        if (s.transforms.length) {\n          // get initial initialTransformation\n          at = s.initialTransformation;\n\n          for (i = 0, len = s.transforms.length; i < len; i++) {\n            // get next transformation in chain\n            var a = s.transforms[i]; // multiply matrix directly\n\n            if (a instanceof SVG.Matrix) {\n              if (a.relative) {\n                at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));\n              } else {\n                at = at.morph(a).at(s.ease(this.pos));\n              }\n\n              continue;\n            } // when transformation is absolute we have to reset the needed transformation first\n\n\n            if (!a.relative) {\n              a.undo(at.extract());\n            } // and reapply it after\n\n\n            at = at.multiply(a.at(s.ease(this.pos)));\n          } // set new matrix on element\n\n\n          target.matrix(at);\n        }\n\n        return this;\n      },\n      // adds an once-callback which is called at a specific position and never again\n      once: function once(pos, fn, isEased) {\n        var c = this.last();\n        if (!isEased) pos = c.ease(pos);\n        c.once[pos] = fn;\n        return this;\n      },\n      _callStart: function _callStart() {\n        setTimeout(function () {\n          this.start();\n        }.bind(this), 0);\n        return this;\n      }\n    },\n    parent: SVG.Element,\n    // Add method to parent elements\n    construct: {\n      // Get fx module or create a new one, then animate with given duration and ease\n      animate: function animate(o, ease, delay) {\n        return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);\n      },\n      delay: function delay(_delay2) {\n        return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay2);\n      },\n      stop: function stop(jumpToEnd, clearQueue) {\n        if (this.fx) {\n          this.fx.stop(jumpToEnd, clearQueue);\n        }\n\n        return this;\n      },\n      finish: function finish() {\n        if (this.fx) {\n          this.fx.finish();\n        }\n\n        return this;\n      },\n      // Pause current animation\n      pause: function pause() {\n        if (this.fx) {\n          this.fx.pause();\n        }\n\n        return this;\n      },\n      // Play paused current animation\n      play: function play() {\n        if (this.fx) {\n          this.fx.play();\n        }\n\n        return this;\n      },\n      // Set/Get the speed of the animations\n      speed: function speed(_speed2) {\n        if (this.fx) {\n          if (_speed2 == null) {\n            return this.fx.speed();\n          } else {\n            this.fx.speed(_speed2);\n          }\n        }\n\n        return this;\n      }\n    }\n  }); // MorphObj is used whenever no morphable object is given\n\n  SVG.MorphObj = SVG.invent({\n    create: function create(from, to) {\n      // prepare color for morphing\n      if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values\n\n      if (SVG.regex.delimiter.test(from)) {\n        // prepare path for morphing\n        if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing\n        else return new SVG.Array(from).morph(to);\n      } // prepare number for morphing\n\n\n      if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing\n\n      this.value = from;\n      this.destination = to;\n    },\n    extend: {\n      at: function at(pos, real) {\n        return real < 1 ? this.value : this.destination;\n      },\n      valueOf: function valueOf() {\n        return this.value;\n      }\n    }\n  });\n  SVG.extend(SVG.FX, {\n    // Add animatable attributes\n    attr: function attr(a, v, relative) {\n      // apply attributes individually\n      if (_typeof(a) === 'object') {\n        for (var key in a) {\n          this.attr(key, a[key]);\n        }\n      } else {\n        this.add(a, v, 'attrs');\n      }\n\n      return this;\n    },\n    // Add animatable styles\n    style: function style(s, v) {\n      if (_typeof(s) === 'object') {\n        for (var key in s) {\n          this.style(key, s[key]);\n        }\n      } else {\n        this.add(s, v, 'styles');\n      }\n\n      return this;\n    },\n    // Animatable x-axis\n    x: function x(_x2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          x: _x2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_x2);\n      num.relative = relative;\n      return this.add('x', num);\n    },\n    // Animatable y-axis\n    y: function y(_y2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          y: _y2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_y2);\n      num.relative = relative;\n      return this.add('y', num);\n    },\n    // Animatable center x-axis\n    cx: function cx(x) {\n      return this.add('cx', new SVG.Number(x));\n    },\n    // Animatable center y-axis\n    cy: function cy(y) {\n      return this.add('cy', new SVG.Number(y));\n    },\n    // Add animatable move\n    move: function move(x, y) {\n      return this.x(x).y(y);\n    },\n    // Add animatable center\n    center: function center(x, y) {\n      return this.cx(x).cy(y);\n    },\n    // Add animatable size\n    size: function size(width, height) {\n      if (this.target() instanceof SVG.Text) {\n        // animate font size for Text elements\n        this.attr('font-size', width);\n      } else {\n        // animate bbox based size for all other elements\n        var box;\n\n        if (!width || !height) {\n          box = this.target().bbox();\n        }\n\n        if (!width) {\n          width = box.width / box.height * height;\n        }\n\n        if (!height) {\n          height = box.height / box.width * width;\n        }\n\n        this.add('width', new SVG.Number(width)).add('height', new SVG.Number(height));\n      }\n\n      return this;\n    },\n    // Add animatable width\n    width: function width(_width2) {\n      return this.add('width', new SVG.Number(_width2));\n    },\n    // Add animatable height\n    height: function height(_height2) {\n      return this.add('height', new SVG.Number(_height2));\n    },\n    // Add animatable plot\n    plot: function plot(a, b, c, d) {\n      // Lines can be plotted with 4 arguments\n      if (arguments.length == 4) {\n        return this.plot([a, b, c, d]);\n      }\n\n      return this.add('plot', new (this.target().morphArray)(a));\n    },\n    // Add leading method\n    leading: function leading(value) {\n      return this.target().leading ? this.add('leading', new SVG.Number(value)) : this;\n    },\n    // Add animatable viewbox\n    viewbox: function viewbox(x, y, width, height) {\n      if (this.target() instanceof SVG.Container) {\n        this.add('viewbox', new SVG.ViewBox(x, y, width, height));\n      }\n\n      return this;\n    },\n    update: function update(o) {\n      if (this.target() instanceof SVG.Stop) {\n        if (typeof o === 'number' || o instanceof SVG.Number) {\n          return this.update({\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          });\n        }\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', o.offset);\n      }\n\n      return this;\n    }\n  });\n  SVG.Box = SVG.invent({\n    create: function create(x, y, width, height) {\n      if (_typeof(x) === 'object' && !(x instanceof SVG.Element)) {\n        // chromes getBoundingClientRect has no x and y property\n        return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);\n      } else if (arguments.length == 4) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n      } // add center, right, bottom...\n\n\n      fullBox(this);\n    },\n    extend: {\n      // Merge rect box with another, return a new instance\n      merge: function merge(box) {\n        var b = new this.constructor(); // merge boxes\n\n        b.x = Math.min(this.x, box.x);\n        b.y = Math.min(this.y, box.y);\n        b.width = Math.max(this.x + this.width, box.x + box.width) - b.x;\n        b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;\n        return fullBox(b);\n      },\n      transform: function transform(m) {\n        var xMin = Infinity,\n            xMax = -Infinity,\n            yMin = Infinity,\n            yMax = -Infinity,\n            bbox;\n        var pts = [new SVG.Point(this.x, this.y), new SVG.Point(this.x2, this.y), new SVG.Point(this.x, this.y2), new SVG.Point(this.x2, this.y2)];\n        pts.forEach(function (p) {\n          p = p.transform(m);\n          xMin = Math.min(xMin, p.x);\n          xMax = Math.max(xMax, p.x);\n          yMin = Math.min(yMin, p.y);\n          yMax = Math.max(yMax, p.y);\n        });\n        bbox = new this.constructor();\n        bbox.x = xMin;\n        bbox.width = xMax - xMin;\n        bbox.y = yMin;\n        bbox.height = yMax - yMin;\n        fullBox(bbox);\n        return bbox;\n      }\n    }\n  });\n  SVG.BBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given\n\n      if (element instanceof SVG.Element) {\n        var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\n\n        try {\n          if (!document.documentElement.contains) {\n            // This is IE - it does not support contains() for top-level SVGs\n            var topParent = element.node;\n\n            while (topParent.parentNode) {\n              topParent = topParent.parentNode;\n            }\n\n            if (topParent != document) throw new Error('Element not in the dom');\n          } // the element is NOT in the dom, throw error\n          // disabling the check below which fixes issue #76\n          // if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\n          // find native bbox\n\n\n          box = element.node.getBBox();\n        } catch (e) {\n          if (element instanceof SVG.Shape) {\n            if (!SVG.parser.draw) {\n              // fixes apexcharts/vue-apexcharts #14\n              SVG.prepare();\n            }\n\n            var clone = element.clone(SVG.parser.draw.instance).show();\n            box = clone.node.getBBox();\n            clone.remove();\n          } else {\n            box = {\n              x: element.node.clientLeft,\n              y: element.node.clientTop,\n              width: element.node.clientWidth,\n              height: element.node.clientHeight\n            };\n          }\n        }\n\n        SVG.Box.call(this, box);\n      }\n    },\n    // Define ancestor\n    inherit: SVG.Box,\n    // Define Parent\n    parent: SVG.Element,\n    // Constructor\n    construct: {\n      // Get bounding box\n      bbox: function bbox() {\n        return new SVG.BBox(this);\n      }\n    }\n  });\n  SVG.BBox.prototype.constructor = SVG.BBox;\n  SVG.extend(SVG.Element, {\n    tbox: function tbox() {\n      console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.');\n      return this.rbox(this.doc());\n    }\n  });\n  SVG.RBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments));\n\n      if (element instanceof SVG.Element) {\n        SVG.Box.call(this, element.node.getBoundingClientRect());\n      }\n    },\n    inherit: SVG.Box,\n    // define Parent\n    parent: SVG.Element,\n    extend: {\n      addOffset: function addOffset() {\n        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n        this.x += window.pageXOffset;\n        this.y += window.pageYOffset;\n        return this;\n      }\n    },\n    // Constructor\n    construct: {\n      // Get rect box\n      rbox: function rbox(el) {\n        if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse());\n        return new SVG.RBox(this).addOffset();\n      }\n    }\n  });\n  SVG.RBox.prototype.constructor = SVG.RBox;\n  SVG.Matrix = SVG.invent({\n    // Initialize\n    create: function create(source) {\n      var i,\n          base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n      source = source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : _typeof(source) === 'object' ? source : base; // merge source\n\n      for (i = abcdef.length - 1; i >= 0; --i) {\n        this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];\n      }\n    },\n    // Add methods\n    extend: {\n      // Extract individual transformations\n      extract: function extract() {\n        // find delta transform points\n        var px = deltaTransformPoint(this, 0, 1),\n            py = deltaTransformPoint(this, 1, 0),\n            skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n        return {\n          // translation\n          x: this.e,\n          y: this.f,\n          transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),\n          transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),\n          // skew\n          skewX: -skewX,\n          skewY: 180 / Math.PI * Math.atan2(py.y, py.x),\n          // scale\n          scaleX: Math.sqrt(this.a * this.a + this.b * this.b),\n          scaleY: Math.sqrt(this.c * this.c + this.d * this.d),\n          // rotation\n          rotation: skewX,\n          a: this.a,\n          b: this.b,\n          c: this.c,\n          d: this.d,\n          e: this.e,\n          f: this.f,\n          matrix: new SVG.Matrix(this)\n        };\n      },\n      // Clone matrix\n      clone: function clone() {\n        return new SVG.Matrix(this);\n      },\n      // Morph one matrix into another\n      morph: function morph(matrix) {\n        // store new destination\n        this.destination = new SVG.Matrix(matrix);\n        return this;\n      },\n      // Get morphed matrix at a given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var matrix = new SVG.Matrix({\n          a: this.a + (this.destination.a - this.a) * pos,\n          b: this.b + (this.destination.b - this.b) * pos,\n          c: this.c + (this.destination.c - this.c) * pos,\n          d: this.d + (this.destination.d - this.d) * pos,\n          e: this.e + (this.destination.e - this.e) * pos,\n          f: this.f + (this.destination.f - this.f) * pos\n        });\n        return matrix;\n      },\n      // Multiplies by given matrix\n      multiply: function multiply(matrix) {\n        return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));\n      },\n      // Inverses matrix\n      inverse: function inverse() {\n        return new SVG.Matrix(this.native().inverse());\n      },\n      // Translate matrix\n      translate: function translate(x, y) {\n        return new SVG.Matrix(this.native().translate(x || 0, y || 0));\n      },\n      // Scale matrix\n      scale: function scale(x, y, cx, cy) {\n        // support uniformal scale\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        }\n\n        return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0));\n      },\n      // Rotate matrix\n      rotate: function rotate(r, cx, cy) {\n        // convert degrees to radians\n        r = SVG.utils.radians(r);\n        return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0));\n      },\n      // Flip matrix on x or y, at a given offset\n      flip: function flip(a, o) {\n        return a == 'x' ? this.scale(-1, 1, o, 0) : a == 'y' ? this.scale(1, -1, 0, o) : this.scale(-1, -1, a, o != null ? o : a);\n      },\n      // Skew\n      skew: function skew(x, y, cx, cy) {\n        // support uniformal skew\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        } // convert degrees to radians\n\n\n        x = SVG.utils.radians(x);\n        y = SVG.utils.radians(y);\n        return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0));\n      },\n      // SkewX\n      skewX: function skewX(x, cx, cy) {\n        return this.skew(x, 0, cx, cy);\n      },\n      // SkewY\n      skewY: function skewY(y, cx, cy) {\n        return this.skew(0, y, cx, cy);\n      },\n      // Transform around a center point\n      around: function around(cx, cy, matrix) {\n        return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0));\n      },\n      // Convert to native SVGMatrix\n      native: function native() {\n        // create new matrix\n        var matrix = SVG.parser.native.createSVGMatrix(); // update with current values\n\n        for (var i = abcdef.length - 1; i >= 0; i--) {\n          matrix[abcdef[i]] = this[abcdef[i]];\n        }\n\n        return matrix;\n      },\n      // Convert matrix to string\n      toString: function toString() {\n        // Construct the matrix directly, avoid values that are too small\n        return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';\n      }\n    },\n    // Define parent\n    parent: SVG.Element,\n    // Add parent method\n    construct: {\n      // Get current matrix\n      ctm: function ctm() {\n        return new SVG.Matrix(this.node.getCTM());\n      },\n      // Get current screen matrix\n      screenCTM: function screenCTM() {\n        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n           This is needed because FF does not return the transformation matrix\n           for the inner coordinate system when getScreenCTM() is called on nested svgs.\n           However all other Browsers do that */\n        if (this instanceof SVG.Nested) {\n          var rect = this.rect(1, 1);\n          var m = rect.node.getScreenCTM();\n          rect.remove();\n          return new SVG.Matrix(m);\n        }\n\n        return new SVG.Matrix(this.node.getScreenCTM());\n      }\n    }\n  });\n  SVG.Point = SVG.invent({\n    // Initialize\n    create: function create(x, y) {\n      var source,\n          base = {\n        x: 0,\n        y: 0 // ensure source as object\n\n      };\n      source = Array.isArray(x) ? {\n        x: x[0],\n        y: x[1]\n      } : _typeof(x) === 'object' ? {\n        x: x.x,\n        y: x.y\n      } : x != null ? {\n        x: x,\n        y: y != null ? y : x\n      } : base; // If y has no value, then x is used has its value\n      // merge source\n\n      this.x = source.x;\n      this.y = source.y;\n    },\n    // Add methods\n    extend: {\n      // Clone point\n      clone: function clone() {\n        return new SVG.Point(this);\n      },\n      // Morph one point into another\n      morph: function morph(x, y) {\n        // store new destination\n        this.destination = new SVG.Point(x, y);\n        return this;\n      },\n      // Get morphed point at a given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var point = new SVG.Point({\n          x: this.x + (this.destination.x - this.x) * pos,\n          y: this.y + (this.destination.y - this.y) * pos\n        });\n        return point;\n      },\n      // Convert to native SVGPoint\n      native: function native() {\n        // create new point\n        var point = SVG.parser.native.createSVGPoint(); // update with current values\n\n        point.x = this.x;\n        point.y = this.y;\n        return point;\n      },\n      // transform point with matrix\n      transform: function transform(matrix) {\n        return new SVG.Point(this.native().matrixTransform(matrix.native()));\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Get point\n    point: function point(x, y) {\n      return new SVG.Point(x, y).transform(this.screenCTM().inverse());\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Set svg element attribute\n    attr: function attr(a, v, n) {\n      // act as full getter\n      if (a == null) {\n        // get an object of attributes\n        a = {};\n        v = this.node.attributes;\n\n        for (n = v.length - 1; n >= 0; n--) {\n          a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;\n        }\n\n        return a;\n      } else if (_typeof(a) === 'object') {\n        // apply every attribute individually if an object is passed\n        for (v in a) {\n          this.attr(v, a[v]);\n        }\n      } else if (v === null) {\n        // remove value\n        this.node.removeAttribute(a);\n      } else if (v == null) {\n        // act as a getter if the first and only argument is not an object\n        v = this.node.getAttribute(a);\n        return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;\n      } else {\n        // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\n        if (a == 'stroke-width') {\n          this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);\n        } else if (a == 'stroke') {\n          this._stroke = v;\n        } // convert image fill and stroke to patterns\n\n\n        if (a == 'fill' || a == 'stroke') {\n          if (SVG.regex.isImage.test(v)) {\n            v = this.doc().defs().image(v, 0, 0);\n          }\n\n          if (v instanceof SVG.Image) {\n            v = this.doc().defs().pattern(0, 0, function () {\n              this.add(v);\n            });\n          }\n        } // ensure correct numeric values (also accepts NaN and Infinity)\n\n\n        if (typeof v === 'number') {\n          v = new SVG.Number(v);\n        } // ensure full hex color\n        else if (SVG.Color.isColor(v)) {\n            v = new SVG.Color(v);\n          } // parse array values\n          else if (Array.isArray(v)) {\n              v = new SVG.Array(v);\n            } // if the passed attribute is leading...\n\n\n        if (a == 'leading') {\n          // ... call the leading method instead\n          if (this.leading) {\n            this.leading(v);\n          }\n        } else {\n          // set given attribute on node\n          typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());\n        } // rebuild if required\n\n\n        if (this.rebuild && (a == 'font-size' || a == 'x')) {\n          this.rebuild(a, v);\n        }\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Add transformations\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this,\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // get current matrix\n\n\n      matrix = new SVG.Matrix(target); // ensure relative flag\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = relative // relative\n        ? matrix.multiply(new SVG.Matrix(o)) // absolute\n        : new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = relative // relative\n        ? matrix.rotate(o.rotation, o.cx, o.cy) // absolute\n        : matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n\n        if (!relative) {\n          // absolute; multiply inversed values\n          var e = matrix.extract();\n          o.scaleX = o.scaleX * 1 / e.scaleX;\n          o.scaleY = o.scaleY * 1 / e.scaleY;\n        }\n\n        matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skew != null || o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0;\n\n        if (!relative) {\n          // absolute; reset skew values\n          var e = matrix.extract();\n          matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse());\n        }\n\n        matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        if (relative) {\n          // relative\n          matrix = matrix.translate(o.x, o.y);\n        } else {\n          // absolute\n          if (o.x != null) matrix.e = o.x;\n          if (o.y != null) matrix.f = o.y;\n        }\n      }\n\n      return this.attr('transform', matrix);\n    }\n  });\n  SVG.extend(SVG.FX, {\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this.target(),\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // ensure relative flag\n\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = new SVG.Rotate(o.rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n        matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skewY != null ? o.skewY : 0;\n        matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        matrix = new SVG.Translate(o.x, o.y);\n      }\n\n      if (!matrix) return this;\n      matrix.relative = relative;\n      this.last().transforms.push(matrix);\n      return this._callStart();\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Reset all transformations\n    untransform: function untransform() {\n      return this.attr('transform', null);\n    },\n    // merge the whole transformation chain into one matrix and returns it\n    matrixify: function matrixify() {\n      var matrix = (this.attr('transform') || ''). // split transformations\n      split(SVG.regex.transforms).slice(0, -1).map(function (str) {\n        // generate key => value pairs\n        var kv = str.trim().split('(');\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {\n          return parseFloat(str);\n        })];\n      }) // merge every transformation into one matrix\n      .reduce(function (matrix, transform) {\n        if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));\n        return matrix[transform[0]].apply(matrix, transform[1]);\n      }, new SVG.Matrix());\n      return matrix;\n    },\n    // add an element to another parent without changing the visual representation on the screen\n    toParent: function toParent(parent) {\n      if (this == parent) return this;\n      var ctm = this.screenCTM();\n      var pCtm = parent.screenCTM().inverse();\n      this.addTo(parent).untransform().transform(pCtm.multiply(ctm));\n      return this;\n    },\n    // same as above with parent equals root-svg\n    toDoc: function toDoc() {\n      return this.toParent(this.doc());\n    }\n  });\n  SVG.Transformation = SVG.invent({\n    create: function create(source, inversed) {\n      if (arguments.length > 1 && typeof inversed !== 'boolean') {\n        return this.constructor.call(this, [].slice.call(arguments));\n      }\n\n      if (Array.isArray(source)) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[i];\n        }\n      } else if (_typeof(source) === 'object') {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[this.arguments[i]];\n        }\n      }\n\n      this.inversed = false;\n\n      if (inversed === true) {\n        this.inversed = true;\n      }\n    },\n    extend: {\n      arguments: [],\n      method: '',\n      at: function at(pos) {\n        var params = [];\n\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          params.push(this[this.arguments[i]]);\n        }\n\n        var m = this._undo || new SVG.Matrix();\n        m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          o[this.arguments[i]] = typeof this[this.arguments[i]] === 'undefined' ? 0 : o[this.arguments[i]];\n        } // The method SVG.Matrix.extract which was used before calling this\n        // method to obtain a value for the parameter o doesn't return a cx and\n        // a cy so we use the ones that were provided to this object at its creation\n\n\n        o.cx = this.cx;\n        o.cy = this.cy;\n        this._undo = new SVG[capitalize(this.method)](o, true).at(1);\n        return this;\n      }\n    }\n  });\n  SVG.Translate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['transformedX', 'transformedY'],\n      method: 'translate'\n    }\n  });\n  SVG.Rotate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['rotation', 'cx', 'cy'],\n      method: 'rotate',\n      at: function at(pos) {\n        var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        this._undo = o;\n        return this;\n      }\n    }\n  });\n  SVG.Scale = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['scaleX', 'scaleY', 'cx', 'cy'],\n      method: 'scale'\n    }\n  });\n  SVG.Skew = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['skewX', 'skewY', 'cx', 'cy'],\n      method: 'skew'\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Dynamic style generator\n    style: function style(s, v) {\n      if (arguments.length == 0) {\n        // get full style\n        return this.node.style.cssText || '';\n      } else if (arguments.length < 2) {\n        // apply every style individually if an object is passed\n        if (_typeof(s) === 'object') {\n          for (v in s) {\n            this.style(v, s[v]);\n          }\n        } else if (SVG.regex.isCss.test(s)) {\n          // parse css string\n          s = s.split(/\\s*;\\s*/) // filter out suffix ; and stuff like ;;\n          .filter(function (e) {\n            return !!e;\n          }).map(function (e) {\n            return e.split(/\\s*:\\s*/);\n          }); // apply every definition individually\n\n          while (v = s.pop()) {\n            this.style(v[0], v[1]);\n          }\n        } else {\n          // act as a getter if the first and only argument is not an object\n          return this.node.style[camelCase(s)];\n        }\n      } else {\n        this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;\n      }\n\n      return this;\n    }\n  });\n  SVG.Parent = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Element,\n    // Add class methods\n    extend: {\n      // Returns all child elements\n      children: function children() {\n        return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {\n          return SVG.adopt(node);\n        });\n      },\n      // Add given element at a position\n      add: function add(element, i) {\n        if (i == null) {\n          this.node.appendChild(element.node);\n        } else if (element.node != this.node.childNodes[i]) {\n          this.node.insertBefore(element.node, this.node.childNodes[i]);\n        }\n\n        return this;\n      },\n      // Basically does the same as `add()` but returns the added element instead\n      put: function put(element, i) {\n        this.add(element, i);\n        return element;\n      },\n      // Checks if the given element is a child\n      has: function has(element) {\n        return this.index(element) >= 0;\n      },\n      // Gets index of given element\n      index: function index(element) {\n        return [].slice.call(this.node.childNodes).indexOf(element.node);\n      },\n      // Get a element at the given index\n      get: function get(i) {\n        return SVG.adopt(this.node.childNodes[i]);\n      },\n      // Get first child\n      first: function first() {\n        return this.get(0);\n      },\n      // Get the last child\n      last: function last() {\n        return this.get(this.node.childNodes.length - 1);\n      },\n      // Iterates over all children and invokes a given block\n      each: function each(block, deep) {\n        var i,\n            il,\n            children = this.children();\n\n        for (i = 0, il = children.length; i < il; i++) {\n          if (children[i] instanceof SVG.Element) {\n            block.apply(children[i], [i, children]);\n          }\n\n          if (deep && children[i] instanceof SVG.Container) {\n            children[i].each(block, deep);\n          }\n        }\n\n        return this;\n      },\n      // Remove a given child\n      removeElement: function removeElement(element) {\n        this.node.removeChild(element.node);\n        return this;\n      },\n      // Remove all elements in this container\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs;\n        return this;\n      },\n      // Get defs\n      defs: function defs() {\n        return this.doc().defs();\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    ungroup: function ungroup(parent, depth) {\n      if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;\n      parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));\n      depth = depth || Infinity;\n      this.each(function () {\n        if (this instanceof SVG.Defs) return this;\n        if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);\n        return this.toParent(parent);\n      });\n      this.node.firstChild || this.remove();\n      return this;\n    },\n    flatten: function flatten(parent, depth) {\n      return this.ungroup(parent, depth);\n    }\n  });\n  SVG.Container = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Parent\n  });\n  SVG.ViewBox = SVG.invent({\n    create: function create(source) {\n      var base = [0, 0, 0, 0];\n      var x,\n          y,\n          width,\n          height,\n          box,\n          view,\n          we,\n          he,\n          wm = 1,\n          // width multiplier\n      hm = 1,\n          // height multiplier\n      reg = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi;\n\n      if (source instanceof SVG.Element) {\n        we = source;\n        he = source;\n        view = (source.attr('viewBox') || '').match(reg);\n        box = source.bbox; // get dimensions of current node\n\n        width = new SVG.Number(source.width());\n        height = new SVG.Number(source.height()); // find nearest non-percentual dimensions\n\n        while (width.unit == '%') {\n          wm *= width.value;\n          width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());\n          we = we.parent();\n        }\n\n        while (height.unit == '%') {\n          hm *= height.value;\n          height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());\n          he = he.parent();\n        } // ensure defaults\n\n\n        this.x = 0;\n        this.y = 0;\n        this.width = width * wm;\n        this.height = height * hm;\n        this.zoom = 1;\n\n        if (view) {\n          // get width and height from viewbox\n          x = parseFloat(view[0]);\n          y = parseFloat(view[1]);\n          width = parseFloat(view[2]);\n          height = parseFloat(view[3]); // calculate zoom accoring to viewbox\n\n          this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width; // calculate real pixel dimensions on parent SVG.Doc element\n\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        }\n      } else {\n        // ensure source as object\n        source = typeof source === 'string' ? source.match(reg).map(function (el) {\n          return parseFloat(el);\n        }) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.x, source.y, source.width, source.height] : arguments.length == 4 ? [].slice.call(arguments) : base;\n        this.x = source[0];\n        this.y = source[1];\n        this.width = source[2];\n        this.height = source[3];\n      }\n    },\n    extend: {\n      toString: function toString() {\n        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n      },\n      morph: function morph(x, y, width, height) {\n        this.destination = new SVG.ViewBox(x, y, width, height);\n        return this;\n      },\n      at: function at(pos) {\n        if (!this.destination) return this;\n        return new SVG.ViewBox([this.x + (this.destination.x - this.x) * pos, this.y + (this.destination.y - this.y) * pos, this.width + (this.destination.width - this.width) * pos, this.height + (this.destination.height - this.height) * pos]);\n      }\n    },\n    // Define parent\n    parent: SVG.Container,\n    // Add parent method\n    construct: {\n      // get/set viewbox\n      viewbox: function viewbox(x, y, width, height) {\n        if (arguments.length == 0) // act as a getter if there are no arguments\n          {\n            return new SVG.ViewBox(this);\n          } // otherwise act as a setter\n\n\n        return this.attr('viewBox', new SVG.ViewBox(x, y, width, height));\n      }\n    }\n  }) // Add events to elements\n  ;\n  ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', // , 'mouseenter' -> not supported by IE\n  // , 'mouseleave' -> not supported by IE\n  'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {\n    // add event to SVG.Element\n    SVG.Element.prototype[event] = function (f) {\n      // bind event to element rather than element node\n      SVG.on(this.node, event, f);\n      return this;\n    };\n  }); // Initialize listeners stack\n\n  SVG.listeners = [];\n  SVG.handlerMap = [];\n  SVG.listenerId = 0; // Add event binder in the SVG namespace\n\n  SVG.on = function (node, event, listener, binding, options) {\n    // create listener, get object-index\n    var l = listener.bind(binding || node.instance || node),\n        index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,\n        ev = event.split('.')[0],\n        ns = event.split('.')[1] || '*'; // ensure valid object\n\n    SVG.listeners[index] = SVG.listeners[index] || {};\n    SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};\n    SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};\n\n    if (!listener._svgjsListenerId) {\n      listener._svgjsListenerId = ++SVG.listenerId;\n    } // reference listener\n\n\n    SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l; // add listener\n\n    node.addEventListener(ev, l, options || false);\n  }; // Add event unbinder in the SVG namespace\n\n\n  SVG.off = function (node, event, listener) {\n    var index = SVG.handlerMap.indexOf(node),\n        ev = event && event.split('.')[0],\n        ns = event && event.split('.')[1],\n        namespace = '';\n    if (index == -1) return;\n\n    if (listener) {\n      if (typeof listener === 'function') listener = listener._svgjsListenerId;\n      if (!listener) return; // remove listener reference\n\n      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\n        // remove listener\n        node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false);\n        delete SVG.listeners[index][ev][ns || '*'][listener];\n      }\n    } else if (ns && ev) {\n      // remove all listeners for a namespaced event\n      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\n        for (listener in SVG.listeners[index][ev][ns]) {\n          SVG.off(node, [ev, ns].join('.'), listener);\n        }\n\n        delete SVG.listeners[index][ev][ns];\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in SVG.listeners[index]) {\n        for (namespace in SVG.listeners[index][event]) {\n          if (ns === namespace) {\n            SVG.off(node, [event, ns].join('.'));\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (SVG.listeners[index][ev]) {\n        for (namespace in SVG.listeners[index][ev]) {\n          SVG.off(node, [ev, namespace].join('.'));\n        }\n\n        delete SVG.listeners[index][ev];\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in SVG.listeners[index]) {\n        SVG.off(node, event);\n      }\n\n      delete SVG.listeners[index];\n      delete SVG.handlerMap[index];\n    }\n  }; //\n\n\n  SVG.extend(SVG.Element, {\n    // Bind given event to listener\n    on: function on(event, listener, binding, options) {\n      SVG.on(this.node, event, listener, binding, options);\n      return this;\n    },\n    // Unbind event from listener\n    off: function off(event, listener) {\n      SVG.off(this.node, event, listener);\n      return this;\n    },\n    // Fire given event\n    fire: function fire(event, data) {\n      // Dispatch event\n      if (event instanceof window.Event) {\n        this.node.dispatchEvent(event);\n      } else {\n        this.node.dispatchEvent(event = new SVG.CustomEvent(event, {\n          detail: data,\n          cancelable: true\n        }));\n      }\n\n      this._event = event;\n      return this;\n    },\n    event: function event() {\n      return this._event;\n    }\n  });\n  SVG.Defs = SVG.invent({\n    // Initialize node\n    create: 'defs',\n    // Inherit from\n    inherit: SVG.Container\n  });\n  SVG.G = SVG.invent({\n    // Initialize node\n    create: 'g',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x3) {\n        return _x3 == null ? this.transform('x') : this.transform({\n          x: _x3 - this.x()\n        }, true);\n      },\n      // Move over y-axis\n      y: function y(_y3) {\n        return _y3 == null ? this.transform('y') : this.transform({\n          y: _y3 - this.y()\n        }, true);\n      },\n      // Move by center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2);\n      },\n      // Move by center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2);\n      },\n      gbox: function gbox() {\n        var bbox = this.bbox(),\n            trans = this.transform();\n        bbox.x += trans.x;\n        bbox.x2 += trans.x;\n        bbox.cx += trans.x;\n        bbox.y += trans.y;\n        bbox.y2 += trans.y;\n        bbox.cy += trans.y;\n        return bbox;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a group element\n      group: function group() {\n        return this.put(new SVG.G());\n      }\n    }\n  });\n  SVG.Doc = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      if (element) {\n        // ensure the presence of a dom element\n        element = typeof element === 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.\n        // This allows svg.js to work with svg documents as well.\n\n        if (element.nodeName == 'svg') {\n          this.constructor.call(this, element);\n        } else {\n          this.constructor.call(this, SVG.create('svg'));\n          element.appendChild(this.node);\n          this.size('100%', '100%');\n        } // set svg element attributes and ensure defs node\n\n\n        this.namespace().defs();\n      }\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Add namespaces\n      namespace: function namespace() {\n        return this.attr({\n          xmlns: SVG.ns,\n          version: '1.1'\n        }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);\n      },\n      // Creates and returns defs element\n      defs: function defs() {\n        if (!this._defs) {\n          var defs; // Find or create a defs element in this instance\n\n          if (defs = this.node.getElementsByTagName('defs')[0]) {\n            this._defs = SVG.adopt(defs);\n          } else {\n            this._defs = new SVG.Defs();\n          } // Make sure the defs node is at the end of the stack\n\n\n          this.node.appendChild(this._defs.node);\n        }\n\n        return this._defs;\n      },\n      // custom parent method\n      parent: function parent() {\n        if (!this.node.parentNode || this.node.parentNode.nodeName == '#document') return null;\n        return this.node.parentNode;\n      },\n      // Fix for possible sub-pixel offset. See:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\n      spof: function spof() {\n        var pos = this.node.getScreenCTM();\n\n        if (pos) {\n          this.style('left', -pos.e % 1 + 'px').style('top', -pos.f % 1 + 'px');\n        }\n\n        return this;\n      },\n      // Removes the doc from the DOM\n      remove: function remove() {\n        if (this.parent()) {\n          this.parent().removeChild(this.node);\n        }\n\n        return this;\n      },\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs; // add back parser\n\n        if (SVG.parser.draw && !SVG.parser.draw.parentNode) {\n          this.node.appendChild(SVG.parser.draw);\n        }\n\n        return this;\n      },\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // get reference to node\n\n        var node = this.node; // clone element and assign new id\n\n        var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) {\n          (parent.node || parent).appendChild(clone.node);\n        } else {\n          node.parentNode.insertBefore(clone.node, node.nextSibling);\n        }\n\n        return clone;\n      }\n    }\n  }); // ### This module adds backward / forward functionality to elements.\n  //\n\n  SVG.extend(SVG.Element, {\n    // Get all siblings, including myself\n    siblings: function siblings() {\n      return this.parent().children();\n    },\n    // Get the curent position siblings\n    position: function position() {\n      return this.parent().index(this);\n    },\n    // Get the next element (will return null if there is none)\n    next: function next() {\n      return this.siblings()[this.position() + 1];\n    },\n    // Get the next element (will return null if there is none)\n    previous: function previous() {\n      return this.siblings()[this.position() - 1];\n    },\n    // Send given element one step forward\n    forward: function forward() {\n      var i = this.position() + 1,\n          p = this.parent(); // move node one step forward\n\n      p.removeElement(this).add(this, i); // make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) {\n        p.node.appendChild(p.defs().node);\n      }\n\n      return this;\n    },\n    // Send given element one step backward\n    backward: function backward() {\n      var i = this.position();\n\n      if (i > 0) {\n        this.parent().removeElement(this).add(this, i - 1);\n      }\n\n      return this;\n    },\n    // Send given element all the way to the front\n    front: function front() {\n      var p = this.parent(); // Move node forward\n\n      p.node.appendChild(this.node); // Make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) {\n        p.node.appendChild(p.defs().node);\n      }\n\n      return this;\n    },\n    // Send given element all the way to the back\n    back: function back() {\n      if (this.position() > 0) {\n        this.parent().removeElement(this).add(this, 0);\n      }\n\n      return this;\n    },\n    // Inserts a given element before the targeted element\n    before: function before(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i);\n      return this;\n    },\n    // Insters a given element after the targeted element\n    after: function after(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i + 1);\n      return this;\n    }\n  });\n  SVG.Mask = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('mask')); // keep references to masked elements\n\n      this.targets = [];\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Unmask all masked elements and remove itself\n      remove: function remove() {\n        // unmask all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) {\n            this.targets[i].unmask();\n          }\n        }\n\n        this.targets = []; // remove mask from parent\n\n        SVG.Element.prototype.remove.call(this);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create masking element\n      mask: function mask() {\n        return this.defs().put(new SVG.Mask());\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Distribute mask to svg element\n    maskWith: function maskWith(element) {\n      // use given mask or create a new one\n      this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element); // store reverence on self in mask\n\n      this.masker.targets.push(this); // apply mask\n\n      return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")');\n    },\n    // Unmask element\n    unmask: function unmask() {\n      delete this.masker;\n      return this.attr('mask', null);\n    }\n  });\n  SVG.ClipPath = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('clipPath')); // keep references to clipped elements\n\n      this.targets = [];\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Unclip all clipped elements and remove itself\n      remove: function remove() {\n        // unclip all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) {\n            this.targets[i].unclip();\n          }\n        }\n\n        this.targets = []; // remove clipPath from parent\n\n        this.parent().removeElement(this);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create clipping element\n      clip: function clip() {\n        return this.defs().put(new SVG.ClipPath());\n      }\n    }\n  }); //\n\n  SVG.extend(SVG.Element, {\n    // Distribute clipPath to svg element\n    clipWith: function clipWith(element) {\n      // use given clip or create a new one\n      this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element); // store reverence on self in mask\n\n      this.clipper.targets.push(this); // apply mask\n\n      return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")');\n    },\n    // Unclip element\n    unclip: function unclip() {\n      delete this.clipper;\n      return this.attr('clip-path', null);\n    }\n  });\n  SVG.Gradient = SVG.invent({\n    // Initialize node\n    create: function create(type) {\n      this.constructor.call(this, SVG.create(type + 'Gradient')); // store type\n\n      this.type = type;\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Add a color stop\n      at: function at(offset, color, opacity) {\n        return this.put(new SVG.Stop()).update(offset, color, opacity);\n      },\n      // Update gradient\n      update: function update(block) {\n        // remove all stops\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Return the fill id\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      },\n      // Alias string convertion to fill\n      toString: function toString() {\n        return this.fill();\n      },\n      // custom attr to handle transform\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'gradientTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create gradient element in defs\n      gradient: function gradient(type, block) {\n        return this.defs().gradient(type, block);\n      }\n    }\n  }); // Add animatable methods to both gradient and fx module\n\n  SVG.extend(SVG.Gradient, SVG.FX, {\n    // From position\n    from: function from(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        fx: new SVG.Number(x),\n        fy: new SVG.Number(y)\n      }) : this.attr({\n        x1: new SVG.Number(x),\n        y1: new SVG.Number(y)\n      });\n    },\n    // To position\n    to: function to(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        cx: new SVG.Number(x),\n        cy: new SVG.Number(y)\n      }) : this.attr({\n        x2: new SVG.Number(x),\n        y2: new SVG.Number(y)\n      });\n    }\n  }); // Base gradient generation\n\n  SVG.extend(SVG.Defs, {\n    // define gradient\n    gradient: function gradient(type, block) {\n      return this.put(new SVG.Gradient(type)).update(block);\n    }\n  });\n  SVG.Stop = SVG.invent({\n    // Initialize node\n    create: 'stop',\n    // Inherit from\n    inherit: SVG.Element,\n    // Add class methods\n    extend: {\n      // add color stops\n      update: function update(o) {\n        if (typeof o === 'number' || o instanceof SVG.Number) {\n          o = {\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          };\n        } // set attributes\n\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));\n        return this;\n      }\n    }\n  });\n  SVG.Pattern = SVG.invent({\n    // Initialize node\n    create: 'pattern',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Return the fill id\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      },\n      // Update pattern by rebuilding\n      update: function update(block) {\n        // remove content\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Alias string convertion to fill\n      toString: function toString() {\n        return this.fill();\n      },\n      // custom attr to handle transform\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'patternTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create pattern element in defs\n      pattern: function pattern(width, height, block) {\n        return this.defs().pattern(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Define gradient\n    pattern: function pattern(width, height, block) {\n      return this.put(new SVG.Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    }\n  });\n  SVG.Shape = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Element\n  });\n  SVG.Bare = SVG.invent({\n    // Initialize\n    create: function create(element, inherit) {\n      // construct element\n      this.constructor.call(this, SVG.create(element)); // inherit custom methods\n\n      if (inherit) {\n        for (var method in inherit.prototype) {\n          if (typeof inherit.prototype[method] === 'function') {\n            this[method] = inherit.prototype[method];\n          }\n        }\n      }\n    },\n    // Inherit from\n    inherit: SVG.Element,\n    // Add methods\n    extend: {\n      // Insert some plain text\n      words: function words(text) {\n        // remove contents\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // create text node\n\n\n        this.node.appendChild(document.createTextNode(text));\n        return this;\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    // Create an element that is not described by SVG.js\n    element: function element(_element, inherit) {\n      return this.put(new SVG.Bare(_element, inherit));\n    }\n  });\n  SVG.Symbol = SVG.invent({\n    // Initialize node\n    create: 'symbol',\n    // Inherit from\n    inherit: SVG.Container,\n    construct: {\n      // create symbol\n      symbol: function symbol() {\n        return this.put(new SVG.Symbol());\n      }\n    }\n  });\n  SVG.Use = SVG.invent({\n    // Initialize node\n    create: 'use',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Use element as a reference\n      element: function element(_element2, file) {\n        // Set lined element\n        return this.attr('href', (file || '') + '#' + _element2, SVG.xlink);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a use element\n      use: function use(element, file) {\n        return this.put(new SVG.Use()).element(element, file);\n      }\n    }\n  });\n  SVG.Rect = SVG.invent({\n    // Initialize node\n    create: 'rect',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a rect element\n      rect: function rect(width, height) {\n        return this.put(new SVG.Rect()).size(width, height);\n      }\n    }\n  });\n  SVG.Circle = SVG.invent({\n    // Initialize node\n    create: 'circle',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create circle element, based on ellipse\n      circle: function circle(size) {\n        return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Circle, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx) {\n      return this.attr('r', _rx);\n    },\n    // Alias radius x value\n    ry: function ry(_ry) {\n      return this.rx(_ry);\n    }\n  });\n  SVG.Ellipse = SVG.invent({\n    // Initialize node\n    create: 'ellipse',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create an ellipse\n      ellipse: function ellipse(width, height) {\n        return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx2) {\n      return this.attr('rx', _rx2);\n    },\n    // Radius y value\n    ry: function ry(_ry2) {\n      return this.attr('ry', _ry2);\n    }\n  }); // Add common method\n\n  SVG.extend(SVG.Circle, SVG.Ellipse, {\n    // Move over x-axis\n    x: function x(_x4) {\n      return _x4 == null ? this.cx() - this.rx() : this.cx(_x4 + this.rx());\n    },\n    // Move over y-axis\n    y: function y(_y4) {\n      return _y4 == null ? this.cy() - this.ry() : this.cy(_y4 + this.ry());\n    },\n    // Move by center over x-axis\n    cx: function cx(x) {\n      return x == null ? this.attr('cx') : this.attr('cx', x);\n    },\n    // Move by center over y-axis\n    cy: function cy(y) {\n      return y == null ? this.attr('cy') : this.attr('cy', y);\n    },\n    // Set width of element\n    width: function width(_width3) {\n      return _width3 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width3).divide(2));\n    },\n    // Set height of element\n    height: function height(_height3) {\n      return _height3 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height3).divide(2));\n    },\n    // Custom size function\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));\n    }\n  });\n  SVG.Line = SVG.invent({\n    // Initialize node\n    create: 'line',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Get array\n      array: function array() {\n        return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n      },\n      // Overwrite native plot() method\n      plot: function plot(x1, y1, x2, y2) {\n        if (x1 == null) {\n          return this.array();\n        } else if (typeof y1 !== 'undefined') {\n          x1 = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n          };\n        } else {\n          x1 = new SVG.PointArray(x1).toLine();\n        }\n\n        return this.attr(x1);\n      },\n      // Move by left top corner\n      move: function move(x, y) {\n        return this.attr(this.array().move(x, y).toLine());\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr(this.array().size(p.width, p.height).toLine());\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a line element\n      line: function line(x1, y1, x2, y2) {\n        // make sure plot is called as a setter\n        // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\n        return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);\n      }\n    }\n  });\n  SVG.Polyline = SVG.invent({\n    // Initialize node\n    create: 'polyline',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a wrapped polyline element\n      polyline: function polyline(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());\n      }\n    }\n  });\n  SVG.Polygon = SVG.invent({\n    // Initialize node\n    create: 'polygon',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a wrapped polygon element\n      polygon: function polygon(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());\n      }\n    }\n  }); // Add polygon-specific functions\n\n  SVG.extend(SVG.Polyline, SVG.Polygon, {\n    // Get array\n    array: function array() {\n      return this._array || (this._array = new SVG.PointArray(this.attr('points')));\n    },\n    // Plot new path\n    plot: function plot(p) {\n      return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new SVG.PointArray(p));\n    },\n    // Clear array cache\n    clear: function clear() {\n      delete this._array;\n      return this;\n    },\n    // Move by left top corner\n    move: function move(x, y) {\n      return this.attr('points', this.array().move(x, y));\n    },\n    // Set element size to given width and height\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.attr('points', this.array().size(p.width, p.height));\n    }\n  }); // unify all point to point elements\n\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\n    // Define morphable array\n    morphArray: SVG.PointArray,\n    // Move by left top corner over x-axis\n    x: function x(_x5) {\n      return _x5 == null ? this.bbox().x : this.move(_x5, this.bbox().y);\n    },\n    // Move by left top corner over y-axis\n    y: function y(_y5) {\n      return _y5 == null ? this.bbox().y : this.move(this.bbox().x, _y5);\n    },\n    // Set width of element\n    width: function width(_width4) {\n      var b = this.bbox();\n      return _width4 == null ? b.width : this.size(_width4, b.height);\n    },\n    // Set height of element\n    height: function height(_height4) {\n      var b = this.bbox();\n      return _height4 == null ? b.height : this.size(b.width, _height4);\n    }\n  });\n  SVG.Path = SVG.invent({\n    // Initialize node\n    create: 'path',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Define morphable array\n      morphArray: SVG.PathArray,\n      // Get array\n      array: function array() {\n        return this._array || (this._array = new SVG.PathArray(this.attr('d')));\n      },\n      // Plot new path\n      plot: function plot(d) {\n        return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new SVG.PathArray(d));\n      },\n      // Clear array cache\n      clear: function clear() {\n        delete this._array;\n        return this;\n      },\n      // Move by left top corner\n      move: function move(x, y) {\n        return this.attr('d', this.array().move(x, y));\n      },\n      // Move by left top corner over x-axis\n      x: function x(_x6) {\n        return _x6 == null ? this.bbox().x : this.move(_x6, this.bbox().y);\n      },\n      // Move by left top corner over y-axis\n      y: function y(_y6) {\n        return _y6 == null ? this.bbox().y : this.move(this.bbox().x, _y6);\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr('d', this.array().size(p.width, p.height));\n      },\n      // Set width of element\n      width: function width(_width5) {\n        return _width5 == null ? this.bbox().width : this.size(_width5, this.bbox().height);\n      },\n      // Set height of element\n      height: function height(_height5) {\n        return _height5 == null ? this.bbox().height : this.size(this.bbox().width, _height5);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a wrapped path element\n      path: function path(d) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Path()).plot(d || new SVG.PathArray());\n      }\n    }\n  });\n  SVG.Image = SVG.invent({\n    // Initialize node\n    create: 'image',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // (re)load image\n      load: function load(url) {\n        if (!url) return this;\n        var self = this,\n            img = new window.Image(); // preload image\n\n        SVG.on(img, 'load', function () {\n          SVG.off(img);\n          var p = self.parent(SVG.Pattern);\n          if (p === null) return; // ensure image size\n\n          if (self.width() == 0 && self.height() == 0) {\n            self.size(img.width, img.height);\n          } // ensure pattern size if not set\n\n\n          if (p && p.width() == 0 && p.height() == 0) {\n            p.size(self.width(), self.height());\n          } // callback\n\n\n          if (typeof self._loaded === 'function') {\n            self._loaded.call(self, {\n              width: img.width,\n              height: img.height,\n              ratio: img.width / img.height,\n              url: url\n            });\n          }\n        });\n        SVG.on(img, 'error', function (e) {\n          SVG.off(img);\n\n          if (typeof self._error === 'function') {\n            self._error.call(self, e);\n          }\n        });\n        return this.attr('href', img.src = this.src = url, SVG.xlink);\n      },\n      // Add loaded callback\n      loaded: function loaded(_loaded) {\n        this._loaded = _loaded;\n        return this;\n      },\n      error: function error(_error) {\n        this._error = _error;\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // create image element, load image and set its size\n      image: function image(source, width, height) {\n        return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);\n      }\n    }\n  });\n  SVG.Text = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('text'));\n      this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding\n\n      this._rebuild = true; // enable automatic updating of dy values\n\n      this._build = false; // disable build mode for adding multiple lines\n      // set default font\n\n      this.attr('font-family', SVG.defaults.attrs['font-family']);\n    },\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x7) {\n        // act as getter\n        if (_x7 == null) {\n          return this.attr('x');\n        }\n\n        return this.attr('x', _x7);\n      },\n      // Move over y-axis\n      y: function y(_y7) {\n        var oy = this.attr('y'),\n            o = typeof oy === 'number' ? oy - this.bbox().y : 0; // act as getter\n\n        if (_y7 == null) {\n          return typeof oy === 'number' ? oy - o : oy;\n        }\n\n        return this.attr('y', typeof _y7.valueOf() === 'number' ? _y7 + o : _y7);\n      },\n      // Move center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2);\n      },\n      // Move center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2);\n      },\n      // Set the text content\n      text: function text(_text) {\n        // act as getter\n        if (typeof _text === 'undefined') {\n          var _text = '';\n          var children = this.node.childNodes;\n\n          for (var i = 0, len = children.length; i < len; ++i) {\n            // add newline if its not the first child and newLined is set to true\n            if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {\n              _text += '\\n';\n            } // add content of this node\n\n\n            _text += children[i].textContent;\n          }\n\n          return _text;\n        } // remove existing content\n\n\n        this.clear().build(true);\n\n        if (typeof _text === 'function') {\n          // call block\n          _text.call(this, this);\n        } else {\n          // store text and make sure text is not blank\n          _text = _text.split('\\n'); // build new lines\n\n          for (var i = 0, il = _text.length; i < il; i++) {\n            this.tspan(_text[i]).newLine();\n          }\n        } // disable build mode and rebuild lines\n\n\n        return this.build(false).rebuild();\n      },\n      // Set font size\n      size: function size(_size) {\n        return this.attr('font-size', _size).rebuild();\n      },\n      // Set / get leading\n      leading: function leading(value) {\n        // act as getter\n        if (value == null) {\n          return this.dom.leading;\n        } // act as setter\n\n\n        this.dom.leading = new SVG.Number(value);\n        return this.rebuild();\n      },\n      // Get all the first level lines\n      lines: function lines() {\n        var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances\n\n        var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {\n          return SVG.adopt(el);\n        }); // return an instance of SVG.set\n\n        return new SVG.Set(lines);\n      },\n      // Rebuild appearance type\n      rebuild: function rebuild(_rebuild) {\n        // store new rebuild flag if given\n        if (typeof _rebuild === 'boolean') {\n          this._rebuild = _rebuild;\n        } // define position of all lines\n\n\n        if (this._rebuild) {\n          var self = this,\n              blankLineOffset = 0,\n              dy = this.dom.leading * new SVG.Number(this.attr('font-size'));\n          this.lines().each(function () {\n            if (this.dom.newLined) {\n              if (!self.textPath()) {\n                this.attr('x', self.attr('x'));\n              }\n\n              if (this.text() == '\\n') {\n                blankLineOffset += dy;\n              } else {\n                this.attr('dy', dy + blankLineOffset);\n                blankLineOffset = 0;\n              }\n            }\n          });\n          this.fire('rebuild');\n        }\n\n        return this;\n      },\n      // Enable / disable build mode\n      build: function build(_build) {\n        this._build = !!_build;\n        return this;\n      },\n      // overwrite method from parent to set data properly\n      setData: function setData(o) {\n        this.dom = o;\n        this.dom.leading = new SVG.Number(o.leading || 1.3);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create text element\n      text: function text(_text2) {\n        return this.put(new SVG.Text()).text(_text2);\n      },\n      // Create plain text element\n      plain: function plain(text) {\n        return this.put(new SVG.Text()).plain(text);\n      }\n    }\n  });\n  SVG.Tspan = SVG.invent({\n    // Initialize node\n    create: 'tspan',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Set text content\n      text: function text(_text3) {\n        if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n        typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);\n        return this;\n      },\n      // Shortcut dx\n      dx: function dx(_dx) {\n        return this.attr('dx', _dx);\n      },\n      // Shortcut dy\n      dy: function dy(_dy) {\n        return this.attr('dy', _dy);\n      },\n      // Create new line\n      newLine: function newLine() {\n        // fetch text parent\n        var t = this.parent(SVG.Text); // mark new line\n\n        this.dom.newLined = true; // apply new hy¡n\n\n        return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());\n      }\n    }\n  });\n  SVG.extend(SVG.Text, SVG.Tspan, {\n    // Create plain text node\n    plain: function plain(text) {\n      // clear if build mode is disabled\n      if (this._build === false) {\n        this.clear();\n      } // create text node\n\n\n      this.node.appendChild(document.createTextNode(text));\n      return this;\n    },\n    // Create a tspan\n    tspan: function tspan(text) {\n      var node = (this.textPath && this.textPath() || this).node,\n          tspan = new SVG.Tspan(); // clear if build mode is disabled\n\n      if (this._build === false) {\n        this.clear();\n      } // add new tspan\n\n\n      node.appendChild(tspan.node);\n      return tspan.text(text);\n    },\n    // Clear all lines\n    clear: function clear() {\n      var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes\n\n      while (node.hasChildNodes()) {\n        node.removeChild(node.lastChild);\n      }\n\n      return this;\n    },\n    // Get length of text element\n    length: function length() {\n      return this.node.getComputedTextLength();\n    }\n  });\n  SVG.TextPath = SVG.invent({\n    // Initialize node\n    create: 'textPath',\n    // Inherit from\n    inherit: SVG.Parent,\n    // Define parent class\n    parent: SVG.Text,\n    // Add parent method\n    construct: {\n      morphArray: SVG.PathArray,\n      // Create path for text to run on\n      path: function path(d) {\n        // create textPath element\n        var path = new SVG.TextPath(),\n            track = this.doc().defs().path(d); // move lines to textpath\n\n        while (this.node.hasChildNodes()) {\n          path.node.appendChild(this.node.firstChild);\n        } // add textPath element as child node\n\n\n        this.node.appendChild(path.node); // link textPath to path and add content\n\n        path.attr('href', '#' + track, SVG.xlink);\n        return this;\n      },\n      // return the array of the path track element\n      array: function array() {\n        var track = this.track();\n        return track ? track.array() : null;\n      },\n      // Plot path if any\n      plot: function plot(d) {\n        var track = this.track(),\n            pathArray = null;\n\n        if (track) {\n          pathArray = track.plot(d);\n        }\n\n        return d == null ? pathArray : this;\n      },\n      // Get the path track element\n      track: function track() {\n        var path = this.textPath();\n\n        if (path) {\n          return path.reference('href');\n        }\n      },\n      // Get the textPath child\n      textPath: function textPath() {\n        if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') {\n          return SVG.adopt(this.node.firstChild);\n        }\n      }\n    }\n  });\n  SVG.Nested = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('svg'));\n      this.style('overflow', 'visible');\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add parent method\n    construct: {\n      // Create nested svg document\n      nested: function nested() {\n        return this.put(new SVG.Nested());\n      }\n    }\n  });\n  SVG.A = SVG.invent({\n    // Initialize node\n    create: 'a',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Link url\n      to: function to(url) {\n        return this.attr('href', url, SVG.xlink);\n      },\n      // Link show attribute\n      show: function show(target) {\n        return this.attr('show', target, SVG.xlink);\n      },\n      // Link target attribute\n      target: function target(_target2) {\n        return this.attr('target', _target2);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a hyperlink element\n      link: function link(url) {\n        return this.put(new SVG.A()).to(url);\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Create a hyperlink element\n    linkTo: function linkTo(url) {\n      var link = new SVG.A();\n\n      if (typeof url === 'function') {\n        url.call(link, link);\n      } else {\n        link.to(url);\n      }\n\n      return this.parent().put(link).put(this);\n    }\n  });\n  SVG.Marker = SVG.invent({\n    // Initialize node\n    create: 'marker',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Set width of element\n      width: function width(_width6) {\n        return this.attr('markerWidth', _width6);\n      },\n      // Set height of element\n      height: function height(_height6) {\n        return this.attr('markerHeight', _height6);\n      },\n      // Set marker refX and refY\n      ref: function ref(x, y) {\n        return this.attr('refX', x).attr('refY', y);\n      },\n      // Update marker\n      update: function update(block) {\n        // remove all content\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Return the fill id\n      toString: function toString() {\n        return 'url(#' + this.id() + ')';\n      }\n    },\n    // Add parent method\n    construct: {\n      marker: function marker(width, height, block) {\n        // Create marker element in defs\n        return this.defs().marker(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Create marker\n    marker: function marker(width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new SVG.Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    }\n  });\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\n    // Create and attach markers\n    marker: function marker(_marker, width, height, block) {\n      var attr = ['marker']; // Build attribute name\n\n      if (_marker != 'all') attr.push(_marker);\n      attr = attr.join('-'); // Set marker attribute\n\n      _marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);\n      return this.attr(attr, _marker);\n    }\n  }); // Define list of available attributes for stroke and fill\n\n  var sugar = {\n    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n    fill: ['color', 'opacity', 'rule'],\n    prefix: function prefix(t, a) {\n      return a == 'color' ? t : t + '-' + a;\n    } // Add sugar for fill and stroke\n\n  };\n  ['fill', 'stroke'].forEach(function (m) {\n    var i,\n        extension = {};\n\n    extension[m] = function (o) {\n      if (typeof o === 'undefined') {\n        return this;\n      }\n\n      if (typeof o === 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') {\n        this.attr(m, o);\n      } else // set all attributes from sugar.fill and sugar.stroke list\n        {\n          for (i = sugar[m].length - 1; i >= 0; i--) {\n            if (o[sugar[m][i]] != null) {\n              this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n            }\n          }\n        }\n\n      return this;\n    };\n\n    SVG.extend(SVG.Element, SVG.FX, extension);\n  });\n  SVG.extend(SVG.Element, SVG.FX, {\n    // Map rotation to transform\n    rotate: function rotate(d, cx, cy) {\n      return this.transform({\n        rotation: d,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map skew to transform\n    skew: function skew(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        skew: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        skewX: x,\n        skewY: y,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map scale to transform\n    scale: function scale(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        scale: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        scaleX: x,\n        scaleY: y,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map translate to transform\n    translate: function translate(x, y) {\n      return this.transform({\n        x: x,\n        y: y\n      });\n    },\n    // Map flip to transform\n    flip: function flip(a, o) {\n      o = typeof a === 'number' ? a : o;\n      return this.transform({\n        flip: a || 'both',\n        offset: o\n      });\n    },\n    // Map matrix to transform\n    matrix: function matrix(m) {\n      return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));\n    },\n    // Opacity\n    opacity: function opacity(value) {\n      return this.attr('opacity', value);\n    },\n    // Relative move over x axis\n    dx: function dx(x) {\n      return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);\n    },\n    // Relative move over y axis\n    dy: function dy(y) {\n      return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);\n    },\n    // Relative move over x and y axes\n    dmove: function dmove(x, y) {\n      return this.dx(x).dy(y);\n    }\n  });\n  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\n    // Add x and y radius\n    radius: function radius(x, y) {\n      var type = (this._target || this).type;\n      return type == 'radial' || type == 'circle' ? this.attr('r', new SVG.Number(x)) : this.rx(x).ry(y == null ? x : y);\n    }\n  });\n  SVG.extend(SVG.Path, {\n    // Get path length\n    length: function length() {\n      return this.node.getTotalLength();\n    },\n    // Get point at length\n    pointAt: function pointAt(length) {\n      return this.node.getPointAtLength(length);\n    }\n  });\n  SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\n    // Set font\n    font: function font(a, v) {\n      if (_typeof(a) === 'object') {\n        for (v in a) {\n          this.font(v, a[v]);\n        }\n      }\n\n      return a == 'leading' ? this.leading(v) : a == 'anchor' ? this.attr('text-anchor', v) : a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n    }\n  });\n  SVG.Set = SVG.invent({\n    // Initialize\n    create: function create(members) {\n      // Set initial state\n      Array.isArray(members) ? this.members = members : this.clear();\n    },\n    // Add class methods\n    extend: {\n      // Add element to set\n      add: function add() {\n        var i,\n            il,\n            elements = [].slice.call(arguments);\n\n        for (i = 0, il = elements.length; i < il; i++) {\n          this.members.push(elements[i]);\n        }\n\n        return this;\n      },\n      // Remove element from set\n      remove: function remove(element) {\n        var i = this.index(element); // remove given child\n\n        if (i > -1) {\n          this.members.splice(i, 1);\n        }\n\n        return this;\n      },\n      // Iterate over all members\n      each: function each(block) {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          block.apply(this.members[i], [i, this.members]);\n        }\n\n        return this;\n      },\n      // Restore to defaults\n      clear: function clear() {\n        // initialize store\n        this.members = [];\n        return this;\n      },\n      // Get the length of a set\n      length: function length() {\n        return this.members.length;\n      },\n      // Checks if a given element is present in set\n      has: function has(element) {\n        return this.index(element) >= 0;\n      },\n      // retuns index of given element in set\n      index: function index(element) {\n        return this.members.indexOf(element);\n      },\n      // Get member at given index\n      get: function get(i) {\n        return this.members[i];\n      },\n      // Get first member\n      first: function first() {\n        return this.get(0);\n      },\n      // Get last member\n      last: function last() {\n        return this.get(this.members.length - 1);\n      },\n      // Default value\n      valueOf: function valueOf() {\n        return this.members;\n      },\n      // Get the bounding box of all members included or empty box if set has no items\n      bbox: function bbox() {\n        // return an empty box of there are no members\n        if (this.members.length == 0) {\n          return new SVG.RBox();\n        } // get the first rbox and update the target bbox\n\n\n        var rbox = this.members[0].rbox(this.members[0].doc());\n        this.each(function () {\n          // user rbox for correct position and visual representation\n          rbox = rbox.merge(this.rbox(this.doc()));\n        });\n        return rbox;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a new set\n      set: function set(members) {\n        return new SVG.Set(members);\n      }\n    }\n  });\n  SVG.FX.Set = SVG.invent({\n    // Initialize node\n    create: function create(set) {\n      // store reference to set\n      this.set = set;\n    }\n  }); // Alias methods\n\n  SVG.Set.inherit = function () {\n    var m,\n        methods = []; // gather shape methods\n\n    for (var m in SVG.Shape.prototype) {\n      if (typeof SVG.Shape.prototype[m] === 'function' && typeof SVG.Set.prototype[m] !== 'function') {\n        methods.push(m);\n      }\n    } // apply shape aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.Set.prototype[method] = function () {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          if (this.members[i] && typeof this.members[i][method] === 'function') {\n            this.members[i][method].apply(this.members[i], arguments);\n          }\n        }\n\n        return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;\n      };\n    }); // clear methods for the next round\n\n    methods = []; // gather fx methods\n\n    for (var m in SVG.FX.prototype) {\n      if (typeof SVG.FX.prototype[m] === 'function' && typeof SVG.FX.Set.prototype[m] !== 'function') {\n        methods.push(m);\n      }\n    } // apply fx aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.FX.Set.prototype[method] = function () {\n        for (var i = 0, il = this.set.members.length; i < il; i++) {\n          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);\n        }\n\n        return this;\n      };\n    });\n  };\n\n  SVG.extend(SVG.Element, {\n    // Store data values on svg nodes\n    data: function data(a, v, r) {\n      if (_typeof(a) === 'object') {\n        for (v in a) {\n          this.data(v, a[v]);\n        }\n      } else if (arguments.length < 2) {\n        try {\n          return JSON.parse(this.attr('data-' + a));\n        } catch (e) {\n          return this.attr('data-' + a);\n        }\n      } else {\n        this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Remember arbitrary data\n    remember: function remember(k, v) {\n      // remember every item in an object individually\n      if (_typeof(arguments[0]) === 'object') {\n        for (var v in k) {\n          this.remember(v, k[v]);\n        }\n      } // retrieve memory\n      else if (arguments.length == 1) {\n          return this.memory()[k];\n        } // store memory\n        else {\n            this.memory()[k] = v;\n          }\n\n      return this;\n    },\n    // Erase a given memory\n    forget: function forget() {\n      if (arguments.length == 0) {\n        this._memory = {};\n      } else {\n        for (var i = arguments.length - 1; i >= 0; i--) {\n          delete this.memory()[arguments[i]];\n        }\n      }\n\n      return this;\n    },\n    // Initialize or return local memory object\n    memory: function memory() {\n      return this._memory || (this._memory = {});\n    }\n  }); // Method for getting an element by id\n\n  SVG.get = function (id) {\n    var node = document.getElementById(idFromReference(id) || id);\n    return SVG.adopt(node);\n  }; // Select elements by query string\n\n\n  SVG.select = function (query, parent) {\n    return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {\n      return SVG.adopt(node);\n    }));\n  };\n\n  SVG.extend(SVG.Parent, {\n    // Scoped select method\n    select: function select(query) {\n      return SVG.select(query, this.node);\n    }\n  });\n\n  function pathRegReplace(a, b, c, d) {\n    return c + d.replace(SVG.regex.dots, ' .');\n  } // creates deep clone of array\n\n\n  function array_clone(arr) {\n    var clone = arr.slice(0);\n\n    for (var i = clone.length; i--;) {\n      if (Array.isArray(clone[i])) {\n        clone[i] = array_clone(clone[i]);\n      }\n    }\n\n    return clone;\n  } // tests if a given element is instance of an object\n\n\n  function _is(el, obj) {\n    return el instanceof obj;\n  } // tests if a given selector matches an element\n\n\n  function _matches(el, selector) {\n    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n  } // Convert dash-separated-string to camelCase\n\n\n  function camelCase(s) {\n    return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n      return g.toUpperCase();\n    });\n  } // Capitalize first letter of a string\n\n\n  function capitalize(s) {\n    return s.charAt(0).toUpperCase() + s.slice(1);\n  } // Ensure to six-based hex\n\n\n  function fullHex(hex) {\n    return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n  } // Component to hex value\n\n\n  function compToHex(comp) {\n    var hex = comp.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n  } // Calculate proportional width and height values when necessary\n\n\n  function proportionalSize(element, width, height) {\n    if (width == null || height == null) {\n      var box = element.bbox();\n\n      if (width == null) {\n        width = box.width / box.height * height;\n      } else if (height == null) {\n        height = box.height / box.width * width;\n      }\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  } // Delta transform point\n\n\n  function deltaTransformPoint(matrix, x, y) {\n    return {\n      x: x * matrix.a + y * matrix.c + 0,\n      y: x * matrix.b + y * matrix.d + 0\n    };\n  } // Map matrix array to object\n\n\n  function arrayToMatrix(a) {\n    return {\n      a: a[0],\n      b: a[1],\n      c: a[2],\n      d: a[3],\n      e: a[4],\n      f: a[5]\n    };\n  } // Parse matrix if required\n\n\n  function parseMatrix(matrix) {\n    if (!(matrix instanceof SVG.Matrix)) {\n      matrix = new SVG.Matrix(matrix);\n    }\n\n    return matrix;\n  } // Add centre point to transform object\n\n\n  function ensureCentre(o, target) {\n    o.cx = o.cx == null ? target.bbox().cx : o.cx;\n    o.cy = o.cy == null ? target.bbox().cy : o.cy;\n  } // PathArray Helpers\n\n\n  function arrayToString(a) {\n    for (var i = 0, il = a.length, s = ''; i < il; i++) {\n      s += a[i][0];\n\n      if (a[i][1] != null) {\n        s += a[i][1];\n\n        if (a[i][2] != null) {\n          s += ' ';\n          s += a[i][2];\n\n          if (a[i][3] != null) {\n            s += ' ';\n            s += a[i][3];\n            s += ' ';\n            s += a[i][4];\n\n            if (a[i][5] != null) {\n              s += ' ';\n              s += a[i][5];\n              s += ' ';\n              s += a[i][6];\n\n              if (a[i][7] != null) {\n                s += ' ';\n                s += a[i][7];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s + ' ';\n  } // Deep new id assignment\n\n\n  function assignNewId(node) {\n    // do the same for SVG child nodes as well\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      if (node.childNodes[i] instanceof window.SVGElement) {\n        assignNewId(node.childNodes[i]);\n      }\n    }\n\n    return SVG.adopt(node).id(SVG.eid(node.nodeName));\n  } // Add more bounding box properties\n\n\n  function fullBox(b) {\n    if (b.x == null) {\n      b.x = 0;\n      b.y = 0;\n      b.width = 0;\n      b.height = 0;\n    }\n\n    b.w = b.width;\n    b.h = b.height;\n    b.x2 = b.x + b.width;\n    b.y2 = b.y + b.height;\n    b.cx = b.x + b.width / 2;\n    b.cy = b.y + b.height / 2;\n    return b;\n  } // Get id from reference string\n\n\n  function idFromReference(url) {\n    var m = (url || '').toString().match(SVG.regex.reference);\n    if (m) return m[1];\n  } // If values like 1e-88 are passed, this is not a valid 32 bit float,\n  // but in those cases, we are so close to 0 that 0 works well!\n\n\n  function float32String(v) {\n    return Math.abs(v) > 1e-37 ? v : 0;\n  } // Create matrix array for looping\n\n\n  var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10\n\n  if (typeof window.CustomEvent !== 'function') {\n    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n    var CustomEventPoly = function CustomEventPoly(event, options) {\n      options = options || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var e = document.createEvent('CustomEvent');\n      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);\n      return e;\n    };\n\n    CustomEventPoly.prototype = window.Event.prototype;\n    SVG.CustomEvent = CustomEventPoly;\n  } else {\n    SVG.CustomEvent = window.CustomEvent;\n  } // requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\n\n\n  (function (w) {\n    var lastTime = 0;\n    var vendors = ['moz', 'webkit'];\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n      w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];\n      w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'] || w[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    w.requestAnimationFrame = w.requestAnimationFrame || function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = w.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n    w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\n  })(window);\n\n  return SVG;\n});\n\n/*! svg.filter.js - v2.0.2 - 2016-02-24\r\n* https://github.com/wout/svg.filter.js\r\n* Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n(function() {\r\n\r\n  // Main filter class\r\n  SVG.Filter = SVG.invent({\r\n    create: 'filter',\r\n    inherit: SVG.Parent,\r\n    extend: {\r\n      // Static strings\r\n      source:           'SourceGraphic',\r\n      sourceAlpha:      'SourceAlpha',\r\n      background:       'BackgroundImage',\r\n      backgroundAlpha:  'BackgroundAlpha',\r\n      fill:             'FillPaint',\r\n      stroke:           'StrokePaint',\r\n\r\n      autoSetIn: true,\r\n      // Custom put method for leaner code\r\n      put: function(element, i) {\r\n        this.add(element, i);\r\n\r\n        if(!element.attr('in') && this.autoSetIn){\r\n          element.attr('in',this.source);\r\n        }\r\n        if(!element.attr('result')){\r\n          element.attr('result',element);\r\n        }\r\n\r\n        return element\r\n      },\r\n      // Blend effect\r\n      blend: function(in1, in2, mode) {\r\n        return this.put(new SVG.BlendEffect(in1, in2, mode))\r\n      },\r\n      // ColorMatrix effect\r\n      colorMatrix: function(type, values) {\r\n        return this.put(new SVG.ColorMatrixEffect(type, values))\r\n      },\r\n      // ConvolveMatrix effect\r\n      convolveMatrix: function(matrix) {\r\n        return this.put(new SVG.ConvolveMatrixEffect(matrix))\r\n      },\r\n      // ComponentTransfer effect\r\n      componentTransfer: function(components) {\r\n        return this.put(new SVG.ComponentTransferEffect(components))\r\n      },\r\n      // Composite effect\r\n      composite: function(in1, in2, operator) {\r\n        return this.put(new SVG.CompositeEffect(in1, in2, operator))\r\n      },\r\n      // Flood effect\r\n      flood: function(color, opacity) {\r\n        return this.put(new SVG.FloodEffect(color, opacity))\r\n      },\r\n      // Offset effect\r\n      offset: function(x, y) {\r\n        return this.put(new SVG.OffsetEffect(x,y))\r\n      },\r\n      // Image effect\r\n      image: function(src) {\r\n        return this.put(new SVG.ImageEffect(src))\r\n      },\r\n      // Merge effect\r\n      merge: function() {\r\n        //pass the array of arguments to the constructor because we dont know if the user gave us an array as the first arguemnt or wether they listed the effects in the arguments\r\n        var args = [undefined];\r\n        for(var i in arguments) args.push(arguments[i]);\r\n        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect,args)))\r\n      },\r\n      // Gaussian Blur effect\r\n      gaussianBlur: function(x,y) {\r\n        return this.put(new SVG.GaussianBlurEffect(x,y))\r\n      },\r\n      // Morphology effect\r\n      morphology: function(operator,radius){\r\n        return this.put(new SVG.MorphologyEffect(operator,radius))\r\n      },\r\n      // DiffuseLighting effect\r\n      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n        return this.put(new SVG.DiffuseLightingEffect(surfaceScale,diffuseConstant,kernelUnitLength))\r\n      },\r\n      // DisplacementMap effect\r\n      displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n        return this.put(new SVG.DisplacementMapEffect(in1,in2,scale,xChannelSelector,yChannelSelector))\r\n      },\r\n      // SpecularLighting effect\r\n      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n        return this.put(new SVG.SpecularLightingEffect(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength))\r\n      },\r\n      // Tile effect\r\n      tile: function(){\r\n        return this.put(new SVG.TileEffect());\r\n      },\r\n      // Turbulence effect\r\n      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n        return this.put(new SVG.TurbulenceEffect(baseFrequency,numOctaves,seed,stitchTiles,type))\r\n      },\r\n      // Default string value\r\n      toString: function() {\r\n        return 'url(#' + this.attr('id') + ')'\r\n      }\r\n    }\r\n  });\r\n\r\n  //add .filter function\r\n  SVG.extend(SVG.Defs, {\r\n    // Define filter\r\n    filter: function(block) {\r\n      var filter = this.put(new SVG.Filter);\r\n\r\n      /* invoke passed block */\r\n      if (typeof block === 'function')\r\n        block.call(filter, filter);\r\n\r\n      return filter\r\n    }\r\n  });\r\n  SVG.extend(SVG.Container, {\r\n    // Define filter on defs\r\n    filter: function(block) {\r\n      return this.defs().filter(block)\r\n    }\r\n  });\r\n  SVG.extend(SVG.Element, SVG.G, SVG.Nested, {\r\n    // Create filter element in defs and store reference\r\n    filter: function(block) {\r\n      this.filterer = block instanceof SVG.Element ?\r\n        block : this.doc().filter(block);\r\n\r\n      if(this.doc() && this.filterer.doc() !== this.doc()){\r\n        this.doc().defs().add(this.filterer);\r\n      }\r\n\r\n      this.attr('filter', this.filterer);\r\n\r\n      return this.filterer\r\n    },\r\n    // Remove filter\r\n    unfilter: function(remove) {\r\n      /* also remove the filter node */\r\n      if (this.filterer && remove === true)\r\n        this.filterer.remove();\r\n\r\n      /* delete reference to filterer */\r\n      delete this.filterer;\r\n\r\n      /* remove filter attribute */\r\n      return this.attr('filter', null)\r\n    }\r\n  });\r\n\r\n  // Create SVG.Effect class\r\n  SVG.Effect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Element,\r\n    extend: {\r\n      // Set in attribute\r\n      in: function(effect) {\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n      },\r\n      // Named result\r\n      result: function(result) {\r\n        return result == null? this.attr('result') : this.attr('result',result)\r\n      },\r\n      // Stringification\r\n      toString: function() {\r\n        return this.result()\r\n      }\r\n    }\r\n  });\r\n\r\n  // create class for parent effects like merge\r\n  // Inherit from SVG.Parent\r\n  SVG.ParentEffect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Parent,\r\n    extend: {\r\n      // Set in attribute\r\n      in: function(effect) {\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n      },\r\n      // Named result\r\n      result: function(result) {\r\n        return result == null? this.attr('result') : this.attr('result',result)\r\n      },\r\n      // Stringification\r\n      toString: function() {\r\n        return this.result()\r\n      }\r\n    }\r\n  });\r\n\r\n  //chaining\r\n  var chainingEffects = {\r\n    // Blend effect\r\n    blend: function(in2, mode) {\r\n      return this.parent() && this.parent().blend(this, in2, mode) //pass this as the first input\r\n    },\r\n    // ColorMatrix effect\r\n    colorMatrix: function(type, values) {\r\n      return this.parent() && this.parent().colorMatrix(type, values).in(this)\r\n    },\r\n    // ConvolveMatrix effect\r\n    convolveMatrix: function(matrix) {\r\n      return this.parent() && this.parent().convolveMatrix(matrix).in(this)\r\n    },\r\n    // ComponentTransfer effect\r\n    componentTransfer: function(components) {\r\n      return this.parent() && this.parent().componentTransfer(components).in(this)\r\n    },\r\n    // Composite effect\r\n    composite: function(in2, operator) {\r\n      return this.parent() && this.parent().composite(this, in2, operator) //pass this as the first input\r\n    },\r\n    // Flood effect\r\n    flood: function(color, opacity) {\r\n      return this.parent() && this.parent().flood(color, opacity) //this effect dont have inputs\r\n    },\r\n    // Offset effect\r\n    offset: function(x, y) {\r\n      return this.parent() && this.parent().offset(x,y).in(this)\r\n    },\r\n    // Image effect\r\n    image: function(src) {\r\n      return this.parent() && this.parent().image(src) //this effect dont have inputs\r\n    },\r\n    // Merge effect\r\n    merge: function() {\r\n      return this.parent() && this.parent().merge.apply(this.parent(),[this].concat(arguments)) //pass this as the first argument\r\n    },\r\n    // Gaussian Blur effect\r\n    gaussianBlur: function(x,y) {\r\n      return this.parent() && this.parent().gaussianBlur(x,y).in(this)\r\n    },\r\n    // Morphology effect\r\n    morphology: function(operator,radius){\r\n      return this.parent() && this.parent().morphology(operator,radius).in(this)\r\n    },\r\n    // DiffuseLighting effect\r\n    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n      return this.parent() && this.parent().diffuseLighting(surfaceScale,diffuseConstant,kernelUnitLength).in(this)\r\n    },\r\n    // DisplacementMap effect\r\n    displacementMap: function(in2,scale,xChannelSelector,yChannelSelector){\r\n      return this.parent() && this.parent().displacementMap(this,in2,scale,xChannelSelector,yChannelSelector) //pass this as the first input\r\n    },\r\n    // SpecularLighting effect\r\n    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n      return this.parent() && this.parent().specularLighting(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength).in(this)\r\n    },\r\n    // Tile effect\r\n    tile: function(){\r\n      return this.parent() && this.parent().tile().in(this)\r\n    },\r\n    // Turbulence effect\r\n    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n      return this.parent() && this.parent().turbulence(baseFrequency,numOctaves,seed,stitchTiles,type).in(this)\r\n    }\r\n  };\r\n  SVG.extend(SVG.Effect,chainingEffects);\r\n  SVG.extend(SVG.ParentEffect,chainingEffects);\r\n\r\n  //crea class for child effects, like MergeNode, FuncR and lights\r\n  SVG.ChildEffect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Element,\r\n    extend: {\r\n    in: function(effect){\r\n      this.attr('in',effect);\r\n    }\r\n    //dont include any \"result\" functions because these types of nodes dont have them\r\n    }\r\n  });\r\n\r\n  // Create all different effects\r\n  var effects = {\r\n    blend: function(in1,in2,mode){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        mode: mode || 'normal'\r\n      });\r\n    },\r\n    colorMatrix: function(type,values){\r\n      if (type == 'matrix')\r\n        values = normaliseMatrix(values);\r\n\r\n      this.attr({\r\n        type:   type\r\n      , values: typeof values == 'undefined' ? null : values\r\n      });\r\n    },\r\n    convolveMatrix: function(matrix){\r\n      matrix = normaliseMatrix(matrix);\r\n\r\n      this.attr({\r\n        order:        Math.sqrt(matrix.split(' ').length)\r\n      , kernelMatrix: matrix\r\n      });\r\n    },\r\n    composite: function(in1, in2, operator){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        operator: operator\r\n      });\r\n    },\r\n    flood: function(color,opacity){\r\n      this.attr('flood-color',color);\r\n      if(opacity != null) this.attr('flood-opacity',opacity);\r\n    },\r\n    offset: function(x,y){\r\n      this.attr({\r\n        dx: x,\r\n        dy: y\r\n      });\r\n    },\r\n    image: function(src){\r\n      this.attr('href', src, SVG.xlink);\r\n    },\r\n    displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        scale: scale,\r\n        xChannelSelector: xChannelSelector,\r\n        yChannelSelector: yChannelSelector\r\n      });\r\n    },\r\n    gaussianBlur: function(x,y){\r\n      if(x != null || y != null)\r\n        this.attr('stdDeviation', listString(Array.prototype.slice.call(arguments)));\r\n      else\r\n        this.attr('stdDeviation', '0 0');\r\n    },\r\n    morphology: function(operator,radius){\r\n      this.attr({\r\n        operator: operator,\r\n        radius: radius\r\n      });\r\n    },\r\n    tile: function(){\r\n\r\n    },\r\n    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n      this.attr({\r\n        numOctaves: numOctaves,\r\n        seed: seed,\r\n        stitchTiles: stitchTiles,\r\n        baseFrequency: baseFrequency,\r\n        type: type\r\n      });\r\n    }\r\n  };\r\n\r\n  // Create all parent effects\r\n  var parentEffects = {\r\n    merge: function(){\r\n      var children;\r\n\r\n      //test to see if we have a set\r\n      if(arguments[0] instanceof SVG.Set){\r\n        var that = this;\r\n        arguments[0].each(function(i){\r\n          if(this instanceof SVG.MergeNode)\r\n            that.put(this);\r\n          else if(this instanceof SVG.Effect || this instanceof SVG.ParentEffect)\r\n            that.put(new SVG.MergeNode(this));\r\n        });\r\n      }\r\n      else{\r\n        //if the first argument is an array use it\r\n        if(Array.isArray(arguments[0]))\r\n          children = arguments[0];\r\n        else\r\n          children = arguments;\r\n\r\n        for(var i = 0; i < children.length; i++){\r\n          if(children[i] instanceof SVG.MergeNode){\r\n            this.put(children[i]);\r\n          }\r\n          else this.put(new SVG.MergeNode(children[i]));\r\n        }\r\n      }\r\n    },\r\n    componentTransfer: function(compontents){\r\n      /* create rgb set */\r\n      this.rgb = new SVG.Set\r\n\r\n      /* create components */\r\n      ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n        /* create component */\r\n        this[c] = new SVG['Func' + c.toUpperCase()]('identity');\r\n\r\n        /* store component in set */\r\n        this.rgb.add(this[c]);\r\n\r\n        /* add component node */\r\n        this.node.appendChild(this[c].node);\r\n      }.bind(this)); //lost context in foreach\r\n\r\n      /* set components */\r\n      if (compontents) {\r\n        if (compontents.rgb) {\r\n(['r', 'g', 'b']).forEach(function(c) {\r\n            this[c].attr(compontents.rgb);\r\n          }.bind(this));\r\n\r\n          delete compontents.rgb;\r\n        }\r\n\r\n        /* set individual components */\r\n        for (var c in compontents)\r\n          this[c].attr(compontents[c]);\r\n      }\r\n    },\r\n    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n      this.attr({\r\n        surfaceScale: surfaceScale,\r\n        diffuseConstant: diffuseConstant,\r\n        kernelUnitLength: kernelUnitLength\r\n      });\r\n    },\r\n    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n      this.attr({\r\n        surfaceScale: surfaceScale,\r\n        diffuseConstant: diffuseConstant,\r\n        specularExponent: specularExponent,\r\n        kernelUnitLength: kernelUnitLength\r\n      });\r\n    },\r\n  };\r\n\r\n  // Create child effects like PointLight and MergeNode\r\n  var childEffects = {\r\n    distantLight: function(azimuth, elevation){\r\n      this.attr({\r\n        azimuth: azimuth,\r\n        elevation: elevation\r\n      });\r\n    },\r\n    pointLight: function(x,y,z){\r\n      this.attr({\r\n        x: x,\r\n        y: y,\r\n        z: z\r\n      });\r\n    },\r\n    spotLight: function(x,y,z,pointsAtX,pointsAtY,pointsAtZ){\r\n      this.attr({\r\n        x: x,\r\n        y: y,\r\n        z: z,\r\n        pointsAtX: pointsAtX,\r\n        pointsAtY: pointsAtY,\r\n        pointsAtZ: pointsAtZ\r\n      });\r\n    },\r\n    mergeNode: function(in1){\r\n      this.attr('in',in1);\r\n    }\r\n  }\r\n\r\n  // Create compontent functions\r\n  ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n    /* create class */\r\n    childEffects['Func' + c.toUpperCase()] = function(type) {\r\n      this.attr('type',type);\r\n\r\n      // take diffent arguments based on the type\r\n      switch(type){\r\n        case 'table':\r\n          this.attr('tableValues',arguments[1]);\r\n          break\r\n        case 'linear':\r\n          this.attr('slope',arguments[1]);\r\n          this.attr('intercept',arguments[2]);\r\n          break\r\n        case 'gamma':\r\n          this.attr('amplitude',arguments[1]);\r\n          this.attr('exponent',arguments[2]);\r\n          this.attr('offset',arguments[2]);\r\n          break\r\n      }\r\n    };\r\n  });\r\n\r\n  //create effects\r\n  foreach(effects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name + 'Effect'] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n\r\n        //set the result\r\n        this.result(this.attr('id') + 'Out');\r\n      },\r\n      inherit: SVG.Effect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  //create parent effects\r\n  foreach(parentEffects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name + 'Effect'] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n\r\n        //set the result\r\n        this.result(this.attr('id') + 'Out');\r\n      },\r\n      inherit: SVG.ParentEffect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  //create child effects\r\n  foreach(childEffects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n      },\r\n      inherit: SVG.ChildEffect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  // Effect-specific extensions\r\n  SVG.extend(SVG.MergeEffect,{\r\n    in: function(effect){\r\n      if(effect instanceof SVG.MergeNode)\r\n        this.add(effect,0);\r\n      else\r\n        this.add(new SVG.MergeNode(effect),0);\r\n\r\n      return this\r\n    }\r\n  });\r\n  SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{\r\n    in2: function(effect){\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in2')+'\"]').get(0) || this.attr('in2') : this.attr('in2', effect)\r\n    }\r\n  });\r\n\r\n  // Presets\r\n  SVG.filter = {\r\n    sepiatone:  [ .343, .669, .119, 0, 0\r\n                , .249, .626, .130, 0, 0\r\n                , .172, .334, .111, 0, 0\r\n                , .000, .000, .000, 1, 0 ]\r\n  };\r\n\r\n  // Helpers\r\n  function normaliseMatrix(matrix) {\r\n    /* convert possible array value to string */\r\n    if (Array.isArray(matrix))\r\n      matrix = new SVG.Array(matrix);\r\n\r\n    /* ensure there are no leading, tailing or double spaces */\r\n    return matrix.toString().replace(/^\\s+/, '').replace(/\\s+$/, '').replace(/\\s+/g, ' ')\r\n  }\r\n\r\n  function listString(list) {\r\n    if (!Array.isArray(list))\r\n      return list\r\n\r\n    for (var i = 0, l = list.length, s = []; i < l; i++)\r\n      s.push(list[i]);\r\n\r\n    return s.join(' ')\r\n  }\r\n\r\n  function foreach(){ //loops through mutiple objects\r\n    var fn = function(){};\r\n    if(typeof arguments[arguments.length-1] == 'function'){\r\n      fn = arguments[arguments.length-1];\r\n      Array.prototype.splice.call(arguments,arguments.length-1,1);\r\n    }\r\n    for(var k in arguments){\r\n      for(var i in arguments[k]){\r\n        fn(arguments[k][i],i,arguments[k]);\r\n      }\r\n    }\r\n  }\r\n\r\n}).call(undefined);\n\n(function() {\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  morph: function(array) {\r\n\r\n    var startArr = this.value\r\n      ,  destArr = this.parse(array);\r\n\r\n    var startOffsetM = 0\r\n      ,  destOffsetM = 0;\r\n\r\n    var startOffsetNextM = false\r\n      ,  destOffsetNextM = false;\r\n\r\n    while(true){\r\n      // stop if there is no M anymore\r\n      if(startOffsetM === false && destOffsetM === false) break\r\n\r\n      // find the next M in path array\r\n      startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM+1);\r\n       destOffsetNextM = findNextM( destArr,  destOffsetM === false ? false :  destOffsetM+1);\r\n\r\n      // We have to add one M to the startArray\r\n      if(startOffsetM === false){\r\n        var bbox = new SVG.PathArray(result.start).bbox();\r\n\r\n        // when the last block had no bounding box we simply take the first M we got\r\n        if(bbox.height == 0 || bbox.width == 0){\r\n          startOffsetM =  startArr.push(startArr[0]) - 1;\r\n        }else{\r\n          // we take the middle of the bbox instead when we got one\r\n          startOffsetM = startArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n        }\r\n      }\r\n\r\n      // We have to add one M to the destArray\r\n      if( destOffsetM === false){\r\n        var bbox = new SVG.PathArray(result.dest).bbox();\r\n\r\n        if(bbox.height == 0 || bbox.width == 0){\r\n          destOffsetM =  destArr.push(destArr[0]) - 1;\r\n        }else{\r\n          destOffsetM =  destArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n        }\r\n      }\r\n\r\n      // handle block from M to next M\r\n      var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);\r\n\r\n      // update the arrays to their new values\r\n      startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));\r\n       destArr =  destArr.slice(0,  destOffsetM).concat(result.dest ,  destOffsetNextM === false ? [] :  destArr.slice( destOffsetNextM));\r\n\r\n      // update offsets\r\n      startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;\r\n       destOffsetM =  destOffsetNextM === false ? false :  destOffsetM + result.dest.length;\r\n\r\n    }\r\n\r\n    // copy back arrays\r\n    this.value = startArr;\r\n    this.destination = new SVG.PathArray();\r\n    this.destination.value = destArr;\r\n\r\n    return this\r\n  }\r\n});\r\n\r\n\r\n\r\n// sorry for the long declaration\r\n// slices out one block (from M to M) and syncronize it so the types and length match\r\nfunction handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM, undefined){\r\n\r\n  // slice out the block we need\r\n  var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined)\r\n    ,  destArrTemp =  destArr.slice( destOffsetM,  destOffsetNextM || undefined);\r\n\r\n  var i = 0\r\n    , posStart = {pos:[0,0], start:[0,0]}\r\n    , posDest  = {pos:[0,0], start:[0,0]};\r\n\r\n  do{\r\n\r\n    // convert shorthand types to long form\r\n    startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);\r\n     destArrTemp[i] = simplyfy.call(posDest ,  destArrTemp[i]);\r\n\r\n    // check if both shape types match\r\n    // 2 elliptical arc curve commands ('A'), are considered different if the\r\n    // flags (large-arc-flag, sweep-flag) don't match\r\n    if(startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' ||\r\n        (startArrTemp[i][0] == 'A' &&\r\n          (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])\r\n        )\r\n      ) {\r\n\r\n      // if not, convert shapes to beziere\r\n      Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));\r\n       Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));\r\n\r\n    } else {\r\n\r\n      // only update positions otherwise\r\n      startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);\r\n       destArrTemp[i] = setPosAndReflection.call(posDest ,  destArrTemp[i]);\r\n\r\n    }\r\n\r\n    // we are at the end at both arrays. stop here\r\n    if(++i == startArrTemp.length && i == destArrTemp.length) break\r\n\r\n    // destArray is longer. Add one element\r\n    if(i == startArrTemp.length){\r\n      startArrTemp.push([\r\n        'C',\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n      ]);\r\n    }\r\n\r\n    // startArr is longer. Add one element\r\n    if(i == destArrTemp.length){\r\n      destArrTemp.push([\r\n        'C',\r\n        posDest.pos[0],\r\n        posDest.pos[1],\r\n        posDest.pos[0],\r\n        posDest.pos[1],\r\n        posDest.pos[0],\r\n        posDest.pos[1]\r\n      ]);\r\n    }\r\n\r\n\r\n  }while(true)\r\n\r\n  // return the updated block\r\n  return {start:startArrTemp, dest:destArrTemp}\r\n}\r\n\r\n// converts shorthand types to long form\r\nfunction simplyfy(val){\r\n\r\n  switch(val[0]){\r\n    case 'z': // shorthand line to start\r\n    case 'Z':\r\n      val[0] = 'L';\r\n      val[1] = this.start[0];\r\n      val[2] = this.start[1];\r\n      break\r\n    case 'H': // shorthand horizontal line\r\n      val[0] = 'L';\r\n      val[2] = this.pos[1];\r\n      break\r\n    case 'V': // shorthand vertical line\r\n      val[0] = 'L';\r\n      val[2] = val[1];\r\n      val[1] = this.pos[0];\r\n      break\r\n    case 'T': // shorthand quadratic beziere\r\n      val[0] = 'Q';\r\n      val[3] = val[1];\r\n      val[4] = val[2];\r\n      val[1] = this.reflection[1];\r\n      val[2] = this.reflection[0];\r\n      break\r\n    case 'S': // shorthand cubic beziere\r\n      val[0] = 'C';\r\n      val[6] = val[4];\r\n      val[5] = val[3];\r\n      val[4] = val[2];\r\n      val[3] = val[1];\r\n      val[2] = this.reflection[1];\r\n      val[1] = this.reflection[0];\r\n      break\r\n  }\r\n\r\n  return val\r\n\r\n}\r\n\r\n// updates reflection point and current position\r\nfunction setPosAndReflection(val){\r\n\r\n  var len = val.length;\r\n\r\n  this.pos = [ val[len-2], val[len-1] ];\r\n\r\n  if('SCQT'.indexOf(val[0]) != -1)\r\n    this.reflection = [ 2 * this.pos[0] - val[len-4], 2 * this.pos[1] - val[len-3] ];\r\n\r\n  return val\r\n}\r\n\r\n// converts all types to cubic beziere\r\nfunction toBeziere(val){\r\n  var retVal = [val];\r\n\r\n  switch(val[0]){\r\n    case 'M': // special handling for M\r\n      this.pos = this.start = [val[1], val[2]];\r\n      return retVal\r\n    case 'L':\r\n      val[5] = val[3] = val[1];\r\n      val[6] = val[4] = val[2];\r\n      val[1] = this.pos[0];\r\n      val[2] = this.pos[1];\r\n      break\r\n    case 'Q':\r\n      val[6] = val[4];\r\n      val[5] = val[3];\r\n      val[4] = val[4] * 1/3 + val[2] * 2/3;\r\n      val[3] = val[3] * 1/3 + val[1] * 2/3;\r\n      val[2] = this.pos[1] * 1/3 + val[2] * 2/3;\r\n      val[1] = this.pos[0] * 1/3 + val[1] * 2/3;\r\n      break\r\n    case 'A':\r\n      retVal = arcToBeziere(this.pos, val);\r\n      val = retVal[0];\r\n      break\r\n  }\r\n\r\n  val[0] = 'C';\r\n  this.pos = [val[5], val[6]];\r\n  this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];\r\n\r\n  return retVal\r\n\r\n}\r\n\r\n// finds the next position of type M\r\nfunction findNextM(arr, offset){\r\n\r\n  if(offset === false) return false\r\n\r\n  for(var i = offset, len = arr.length;i < len;++i){\r\n\r\n    if(arr[i][0] == 'M') return i\r\n\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n\r\n\r\n// Convert an arc segment into equivalent cubic Bezier curves\r\n// Depending on the arc, up to 4 curves might be used to represent it since a\r\n// curve gives a good approximation for only a quarter of an ellipse\r\n// The curves are returned as an array of SVG curve commands:\r\n// [ ['C', x1, y1, x2, y2, x, y] ... ]\r\nfunction arcToBeziere(pos, val) {\r\n    // Parameters extraction, handle out-of-range parameters as specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters\r\n    var rx = Math.abs(val[1]), ry = Math.abs(val[2]), xAxisRotation = val[3] % 360\r\n      , largeArcFlag = val[4], sweepFlag = val[5], x = val[6], y = val[7]\r\n      , A = new SVG.Point(pos), B = new SVG.Point(x, y)\r\n      , primedCoord, lambda, mat, k, c, cSquare, t, O, OA, OB, tetaStart, tetaEnd\r\n      , deltaTeta, nbSectors, f, arcSegPoints, angle, sinAngle, cosAngle, pt, i, il\r\n      , retVal = [], x1, y1, x2, y2;\r\n\r\n    // Ensure radii are non-zero\r\n    if(rx === 0 || ry === 0 || (A.x === B.x && A.y === B.y)) {\r\n      // treat this arc as a straight line segment\r\n      return [['C', A.x, A.y, B.x, B.y, B.x, B.y]]\r\n    }\r\n\r\n    // Ensure radii are large enough using the algorithm provided in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii\r\n    primedCoord = new SVG.Point((A.x-B.x)/2, (A.y-B.y)/2).transform(new SVG.Matrix().rotate(xAxisRotation));\r\n    lambda = (primedCoord.x * primedCoord.x) / (rx * rx) + (primedCoord.y * primedCoord.y) / (ry * ry);\r\n    if(lambda > 1) {\r\n      lambda = Math.sqrt(lambda);\r\n      rx = lambda*rx;\r\n      ry = lambda*ry;\r\n    }\r\n\r\n    // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse\r\n    mat = new SVG.Matrix().rotate(xAxisRotation).scale(1/rx, 1/ry).rotate(-xAxisRotation);\r\n    A = A.transform(mat);\r\n    B = B.transform(mat);\r\n\r\n    // Calculate the horizontal and vertical distance between the initial and final point of the arc\r\n    k = [B.x-A.x, B.y-A.y];\r\n\r\n    // Find the length of the chord formed by A and B\r\n    cSquare = k[0]*k[0] + k[1]*k[1];\r\n    c = Math.sqrt(cSquare);\r\n\r\n    // Calculate the ratios of the horizontal and vertical distance on the length of the chord\r\n    k[0] /= c;\r\n    k[1] /= c;\r\n\r\n    // Calculate the distance between the circle center and the chord midpoint\r\n    // using this formula: t = sqrt(r^2 - c^2 / 4)\r\n    // where t is the distance between the cirle center and the chord midpoint,\r\n    //       r is the rayon of the circle and c is the chord length\r\n    // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php\r\n    // Because of the imprecision of floating point numbers, cSquare might end\r\n    // up being slightly above 4 which would result in a negative radicand\r\n    // To prevent that, a test is made before computing the square root\r\n    t = (cSquare < 4) ? Math.sqrt(1 - cSquare/4) : 0;\r\n\r\n    // For most situations, there are actually two different ellipses that\r\n    // satisfy the constraints imposed by the points A and B, the radii rx and ry,\r\n    // and the xAxisRotation\r\n    // When the flags largeArcFlag and sweepFlag are equal, it means that the\r\n    // second ellipse is used as a solution\r\n    // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\r\n    if(largeArcFlag === sweepFlag) {\r\n        t *= -1;\r\n    }\r\n\r\n    // Calculate the coordinates of the center of the circle from the midpoint of the chord\r\n    // This is done by multiplying the ratios calculated previously by the distance between\r\n    // the circle center and the chord midpoint and using these values to go from the midpoint\r\n    // to the center of the circle\r\n    // The negative of the vertical distance ratio is used to modify the x coordinate while\r\n    // the horizontal distance ratio is used to modify the y coordinate\r\n    // That is because the center of the circle is perpendicular to the chord and perpendicular\r\n    // lines are negative reciprocals\r\n    O = new SVG.Point((B.x+A.x)/2 + t*-k[1], (B.y+A.y)/2 + t*k[0]);\r\n    // Move the center of the circle at the origin\r\n    OA = new SVG.Point(A.x-O.x, A.y-O.y);\r\n    OB = new SVG.Point(B.x-O.x, B.y-O.y);\r\n\r\n    // Calculate the start and end angle\r\n    tetaStart = Math.acos(OA.x/Math.sqrt(OA.x*OA.x + OA.y*OA.y));\r\n    if (OA.y < 0) {\r\n      tetaStart *= -1;\r\n    }\r\n    tetaEnd = Math.acos(OB.x/Math.sqrt(OB.x*OB.x + OB.y*OB.y));\r\n    if (OB.y < 0) {\r\n      tetaEnd *= -1;\r\n    }\r\n\r\n    // If sweep-flag is '1', then the arc will be drawn in a \"positive-angle\" direction,\r\n    // make sure that the end angle is above the start angle\r\n    if (sweepFlag && tetaStart > tetaEnd) {\r\n      tetaEnd += 2*Math.PI;\r\n    }\r\n    // If sweep-flag is '0', then the arc will be drawn in a \"negative-angle\" direction,\r\n    // make sure that the end angle is below the start angle\r\n    if (!sweepFlag && tetaStart < tetaEnd) {\r\n      tetaEnd -= 2*Math.PI;\r\n    }\r\n\r\n    // Find the number of Bezier curves that are required to represent the arc\r\n    // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle\r\n    nbSectors = Math.ceil(Math.abs(tetaStart-tetaEnd) * 2/Math.PI);\r\n\r\n    // Calculate the coordinates of the points of all the Bezier curves required to represent the arc\r\n    // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic\r\n    arcSegPoints = [];\r\n    angle = tetaStart;\r\n    deltaTeta = (tetaEnd-tetaStart)/nbSectors;\r\n    f = 4*Math.tan(deltaTeta/4)/3;\r\n    for (i = 0; i <= nbSectors; i++) { // The <= is because a Bezier curve have a start and a endpoint\r\n      cosAngle = Math.cos(angle);\r\n      sinAngle = Math.sin(angle);\r\n\r\n      pt = new SVG.Point(O.x+cosAngle, O.y+sinAngle);\r\n      arcSegPoints[i] = [new SVG.Point(pt.x+f*sinAngle, pt.y-f*cosAngle), pt, new SVG.Point(pt.x-f*sinAngle, pt.y+f*cosAngle)];\r\n\r\n      angle += deltaTeta;\r\n    }\r\n\r\n    // Remove the first control point of the first segment point and remove the second control point of the last segment point\r\n    // These two control points are not used in the approximation of the arc, that is why they are removed\r\n    arcSegPoints[0][0] = arcSegPoints[0][1].clone();\r\n    arcSegPoints[arcSegPoints.length-1][2] = arcSegPoints[arcSegPoints.length-1][1].clone();\r\n\r\n    // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse\r\n    mat = new SVG.Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);\r\n    for (i = 0, il = arcSegPoints.length; i < il; i++) {\r\n      arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);\r\n      arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);\r\n      arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);\r\n    }\r\n\r\n\r\n    // Convert the segments points to SVG curve commands\r\n    for (i = 1, il = arcSegPoints.length; i < il; i++) {\r\n      pt = arcSegPoints[i-1][2];\r\n      x1 = pt.x;\r\n      y1 = pt.y;\r\n\r\n      pt = arcSegPoints[i][0];\r\n      x2 = pt.x;\r\n      y2 = pt.y;\r\n\r\n      pt = arcSegPoints[i][1];\r\n      x = pt.x;\r\n      y = pt.y;\r\n\r\n      retVal.push(['C', x1, y1, x2, y2, x, y]);\r\n    }\r\n\r\n    return retVal\r\n}\r\n}());\n\n/*! svg.draggable.js - v2.2.1 - 2016-08-25\r\n* https://github.com/wout/svg.draggable.js\r\n* Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n(function() {\r\n\r\n  // creates handler, saves it\r\n  function DragHandler(el){\r\n    el.remember('_draggable', this);\r\n    this.el = el;\r\n  }\r\n\r\n\r\n  // Sets new parameter, starts dragging\r\n  DragHandler.prototype.init = function(constraint, val){\r\n    var _this = this;\r\n    this.constraint = constraint;\r\n    this.value = val;\r\n    this.el.on('mousedown.drag', function(e){ _this.start(e); });\r\n    this.el.on('touchstart.drag', function(e){ _this.start(e); });\r\n  };\r\n\r\n  // transforms one point from screen to user coords\r\n  DragHandler.prototype.transformPoint = function(event, offset){\r\n      event = event || window.event;\r\n      var touches = event.changedTouches && event.changedTouches[0] || event;\r\n      this.p.x = touches.pageX - (offset || 0);\r\n      this.p.y = touches.pageY;\r\n      return this.p.matrixTransform(this.m)\r\n  };\r\n  \r\n  // gets elements bounding box with special handling of groups, nested and use\r\n  DragHandler.prototype.getBBox = function(){\r\n\r\n    var box = this.el.bbox();\r\n\r\n    if(this.el instanceof SVG.Nested) box = this.el.rbox();\r\n    \r\n    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\r\n      box.x = this.el.x();\r\n      box.y = this.el.y();\r\n    }\r\n\r\n    return box\r\n  };\r\n\r\n  // start dragging\r\n  DragHandler.prototype.start = function(e){\r\n\r\n    // check for left button\r\n    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\r\n      if((e.which || e.buttons) != 1){\r\n          return\r\n      }\r\n    }\r\n  \r\n    var _this = this;\r\n\r\n    // fire beforedrag event\r\n    this.el.fire('beforedrag', { event: e, handler: this });\r\n\r\n    // search for parent on the fly to make sure we can call\r\n    // draggable() even when element is not in the dom currently\r\n    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc);\r\n    this.p = this.parent.node.createSVGPoint();\r\n\r\n    // save current transformation matrix\r\n    this.m = this.el.node.getScreenCTM().inverse();\r\n\r\n    var box = this.getBBox();\r\n    \r\n    var anchorOffset;\r\n    \r\n    // fix text-anchor in text-element (#37)\r\n    if(this.el instanceof SVG.Text){\r\n      anchorOffset = this.el.node.getComputedTextLength();\r\n        \r\n      switch(this.el.attr('text-anchor')){\r\n        case 'middle':\r\n          anchorOffset /= 2;\r\n          break\r\n        case 'start':\r\n          anchorOffset = 0;\r\n          break;\r\n      }\r\n    }\r\n    \r\n    this.startPoints = {\r\n      // We take absolute coordinates since we are just using a delta here\r\n      point: this.transformPoint(e, anchorOffset),\r\n      box:   box,\r\n      transform: this.el.transform()\r\n    };\r\n    \r\n    // add drag and end events to window\r\n    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e); });\r\n    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e); });\r\n    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e); });\r\n    SVG.on(window, 'touchend.drag', function(e){ _this.end(e); });\r\n\r\n    // fire dragstart event\r\n    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this});\r\n\r\n    // prevent browser drag behavior\r\n    e.preventDefault();\r\n\r\n    // prevent propagation to a parent that might also have dragging enabled\r\n    e.stopPropagation();\r\n  };\r\n\r\n  // while dragging\r\n  DragHandler.prototype.drag = function(e){\r\n\r\n    var box = this.getBBox()\r\n      , p   = this.transformPoint(e)\r\n      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\r\n      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\r\n      , c   = this.constraint\r\n      , gx  = p.x - this.startPoints.point.x\r\n      , gy  = p.y - this.startPoints.point.y;\r\n      \r\n    var event = new CustomEvent('dragmove', {\r\n        detail: {\r\n            event: e\r\n          , p: p\r\n          , m: this.m\r\n          , handler: this\r\n        }\r\n      , cancelable: true\r\n    });\r\n      \r\n    this.el.fire(event);\r\n    \r\n    if(event.defaultPrevented) return p\r\n\r\n    // move the element to its new position, if possible by constraint\r\n    if (typeof c == 'function') {\r\n\r\n      var coord = c.call(this.el, x, y, this.m);\r\n\r\n      // bool, just show us if movement is allowed or not\r\n      if (typeof coord == 'boolean') {\r\n        coord = {\r\n          x: coord,\r\n          y: coord\r\n        };\r\n      }\r\n\r\n      // if true, we just move. If !false its a number and we move it there\r\n      if (coord.x === true) {\r\n        this.el.x(x);\r\n      } else if (coord.x !== false) {\r\n        this.el.x(coord.x);\r\n      }\r\n\r\n      if (coord.y === true) {\r\n        this.el.y(y);\r\n      } else if (coord.y !== false) {\r\n        this.el.y(coord.y);\r\n      }\r\n\r\n    } else if (typeof c == 'object') {\r\n\r\n      // keep element within constrained box\r\n      if (c.minX != null && x < c.minX)\r\n        x = c.minX;\r\n      else if (c.maxX != null && x > c.maxX - box.width){\r\n        x = c.maxX - box.width;\r\n      }if (c.minY != null && y < c.minY)\r\n        y = c.minY;\r\n      else if (c.maxY != null && y > c.maxY - box.height)\r\n        y = c.maxY - box.height;\r\n        \r\n      if(this.el instanceof SVG.G)\r\n        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true);\r\n      else\r\n        this.el.move(x, y);\r\n    }\r\n    \r\n    // so we can use it in the end-method, too\r\n    return p\r\n  };\r\n\r\n  DragHandler.prototype.end = function(e){\r\n\r\n    // final drag\r\n    var p = this.drag(e);\r\n\r\n    // fire dragend event\r\n    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this });\r\n\r\n    // unbind events\r\n    SVG.off(window, 'mousemove.drag');\r\n    SVG.off(window, 'touchmove.drag');\r\n    SVG.off(window, 'mouseup.drag');\r\n    SVG.off(window, 'touchend.drag');\r\n\r\n  };\r\n\r\n  SVG.extend(SVG.Element, {\r\n    // Make element draggable\r\n    // Constraint might be an object (as described in readme.md) or a function in the form \"function (x, y)\" that gets called before every move.\r\n    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \"False\" skips moving, true moves to raw x, y.\r\n    draggable: function(value, constraint) {\r\n\r\n      // Check the parameters and reassign if needed\r\n      if (typeof value == 'function' || typeof value == 'object') {\r\n        constraint = value;\r\n        value = true;\r\n      }\r\n\r\n      var dragHandler = this.remember('_draggable') || new DragHandler(this);\r\n\r\n      // When no parameter is given, value is true\r\n      value = typeof value === 'undefined' ? true : value;\r\n\r\n      if(value) dragHandler.init(constraint || {}, value);\r\n      else {\r\n        this.off('mousedown.drag');\r\n        this.off('touchstart.drag');\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n  });\r\n\r\n}).call(undefined);\n\n(function() {\n\nfunction SelectHandler(el) {\r\n\r\n    this.el = el;\r\n    el.remember('_selectHandler', this);\r\n    this.pointSelection = {isSelected: false};\r\n    this.rectSelection = {isSelected: false};\r\n\r\n}\r\n\r\nSelectHandler.prototype.init = function (value, options) {\r\n\r\n    var bbox = this.el.bbox();\r\n    this.options = {};\r\n\r\n    // Merging the defaults and the options-object together\r\n    for (var i in this.el.selectize.defaults) {\r\n        this.options[i] = this.el.selectize.defaults[i];\r\n        if (options[i] !== undefined) {\r\n            this.options[i] = options[i];\r\n        }\r\n    }\r\n\r\n    this.parent = this.el.parent();\r\n    this.nested = (this.nested || this.parent.group());\r\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n    // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving\r\n    if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {\r\n        this.selectPoints(value);\r\n    } else {\r\n        this.selectRect(value);\r\n    }\r\n\r\n    this.observe();\r\n    this.cleanup();\r\n\r\n};\r\n\r\nSelectHandler.prototype.selectPoints = function (value) {\r\n\r\n    this.pointSelection.isSelected = value;\r\n\r\n    // When set is already there we dont have to create one\r\n    if (this.pointSelection.set) {\r\n        return this;\r\n    }\r\n\r\n    // Create our set of elements\r\n    this.pointSelection.set = this.parent.set();\r\n    // draw the circles and mark the element as selected\r\n    this.drawCircles();\r\n\r\n    return this;\r\n\r\n};\r\n\r\n// create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon\r\nSelectHandler.prototype.getPointArray = function () {\r\n    var bbox = this.el.bbox();\r\n\r\n    return this.el.array().valueOf().map(function (el) {\r\n        return [el[0] - bbox.x, el[1] - bbox.y];\r\n    });\r\n};\r\n\r\n// The function to draw the circles\r\nSelectHandler.prototype.drawCircles = function () {\r\n\r\n    var _this = this, array = this.getPointArray();\r\n\r\n    // go through the array of points\r\n    for (var i = 0, len = array.length; i < len; ++i) {\r\n\r\n        var curriedEvent = (function (k) {\r\n            return function (ev) {\r\n                ev = ev || window.event;\r\n                ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n                ev.stopPropagation();\r\n\r\n                var x = ev.pageX || ev.touches[0].pageX;\r\n                var y = ev.pageY || ev.touches[0].pageY;\r\n                _this.el.fire('point', {x: x, y: y, i: k, event: ev});\r\n            };\r\n        })(i);\r\n\r\n        // add every point to the set\r\n        this.pointSelection.set.add(\r\n            // a circle with our css-classes and a touchstart-event which fires our event for moving points\r\n            this.nested.circle(this.options.radius)\r\n                .center(array[i][0], array[i][1])\r\n                .addClass(this.options.classPoints)\r\n                .addClass(this.options.classPoints + '_point')\r\n                .on('touchstart', curriedEvent)\r\n                .on('mousedown', curriedEvent)\r\n        );\r\n    }\r\n\r\n};\r\n\r\n// every time a circle is moved, we have to update the positions of our circle\r\nSelectHandler.prototype.updatePointSelection = function () {\r\n    var array = this.getPointArray();\r\n\r\n    this.pointSelection.set.each(function (i) {\r\n        if (this.cx() === array[i][0] && this.cy() === array[i][1]) {\r\n            return;\r\n        }\r\n        this.center(array[i][0], array[i][1]);\r\n    });\r\n};\r\n\r\nSelectHandler.prototype.updateRectSelection = function () {\r\n    var bbox = this.el.bbox();\r\n\r\n    this.rectSelection.set.get(0).attr({\r\n        width: bbox.width,\r\n        height: bbox.height\r\n    });\r\n\r\n    // set.get(1) is always in the upper left corner. no need to move it\r\n    if (this.options.points) {\r\n        this.rectSelection.set.get(2).center(bbox.width, 0);\r\n        this.rectSelection.set.get(3).center(bbox.width, bbox.height);\r\n        this.rectSelection.set.get(4).center(0, bbox.height);\r\n\r\n        this.rectSelection.set.get(5).center(bbox.width / 2, 0);\r\n        this.rectSelection.set.get(6).center(bbox.width, bbox.height / 2);\r\n        this.rectSelection.set.get(7).center(bbox.width / 2, bbox.height);\r\n        this.rectSelection.set.get(8).center(0, bbox.height / 2);\r\n    }\r\n\r\n    if (this.options.rotationPoint) {\r\n        if (this.options.points) {\r\n            this.rectSelection.set.get(9).center(bbox.width / 2, 20);\r\n        } else {\r\n            this.rectSelection.set.get(1).center(bbox.width / 2, 20);\r\n        }\r\n    }\r\n};\r\n\r\nSelectHandler.prototype.selectRect = function (value) {\r\n\r\n    var _this = this, bbox = this.el.bbox();\r\n\r\n    this.rectSelection.isSelected = value;\r\n\r\n    // when set is already p\r\n    this.rectSelection.set = this.rectSelection.set || this.parent.set();\r\n\r\n    // helperFunction to create a mouse-down function which triggers the event specified in `eventName`\r\n    function getMoseDownFunc(eventName) {\r\n        return function (ev) {\r\n            ev = ev || window.event;\r\n            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n            ev.stopPropagation();\r\n\r\n            var x = ev.pageX || ev.touches[0].pageX;\r\n            var y = ev.pageY || ev.touches[0].pageY;\r\n            _this.el.fire(eventName, {x: x, y: y, event: ev});\r\n        };\r\n    }\r\n\r\n    // create the selection-rectangle and add the css-class\r\n    if (!this.rectSelection.set.get(0)) {\r\n        this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));\r\n    }\r\n\r\n    // Draw Points at the edges, if enabled\r\n    if (this.options.points && !this.rectSelection.set.get(1)) {\r\n        var ename =\"touchstart\", mname = \"mousedown\";\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', this.options.classPoints + '_lt').on(mname, getMoseDownFunc('lt')).on(ename, getMoseDownFunc('lt')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, 0).attr('class', this.options.classPoints + '_rt').on(mname, getMoseDownFunc('rt')).on(ename, getMoseDownFunc('rt')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height).attr('class', this.options.classPoints + '_rb').on(mname, getMoseDownFunc('rb')).on(ename, getMoseDownFunc('rb')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height).attr('class', this.options.classPoints + '_lb').on(mname, getMoseDownFunc('lb')).on(ename, getMoseDownFunc('lb')));\r\n\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 0).attr('class', this.options.classPoints + '_t').on(mname, getMoseDownFunc('t')).on(ename, getMoseDownFunc('t')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height / 2).attr('class', this.options.classPoints + '_r').on(mname, getMoseDownFunc('r')).on(ename, getMoseDownFunc('r')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, bbox.height).attr('class', this.options.classPoints + '_b').on(mname, getMoseDownFunc('b')).on(ename, getMoseDownFunc('b')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height / 2).attr('class', this.options.classPoints + '_l').on(mname, getMoseDownFunc('l')).on(ename, getMoseDownFunc('l')));\r\n\r\n        this.rectSelection.set.each(function () {\r\n            this.addClass(_this.options.classPoints);\r\n        });\r\n    }\r\n\r\n    // draw rotationPint, if enabled\r\n    if (this.options.rotationPoint && ((this.options.points && !this.rectSelection.set.get(9)) || (!this.options.points && !this.rectSelection.set.get(1)))) {\r\n\r\n        var curriedEvent = function (ev) {\r\n            ev = ev || window.event;\r\n            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n            ev.stopPropagation();\r\n\r\n            var x = ev.pageX || ev.touches[0].pageX;\r\n            var y = ev.pageY || ev.touches[0].pageY;\r\n            _this.el.fire('rot', {x: x, y: y, event: ev});\r\n        };\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 20).attr('class', this.options.classPoints + '_rot')\r\n            .on(\"touchstart\", curriedEvent).on(\"mousedown\", curriedEvent));\r\n\r\n    }\r\n\r\n};\r\n\r\nSelectHandler.prototype.handler = function () {\r\n\r\n    var bbox = this.el.bbox();\r\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n    if (this.rectSelection.isSelected) {\r\n        this.updateRectSelection();\r\n    }\r\n\r\n    if (this.pointSelection.isSelected) {\r\n        this.updatePointSelection();\r\n    }\r\n\r\n};\r\n\r\nSelectHandler.prototype.observe = function () {\r\n    var _this = this;\r\n\r\n    if (MutationObserver) {\r\n        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n            this.observerInst = this.observerInst || new MutationObserver(function () {\r\n                _this.handler();\r\n            });\r\n            this.observerInst.observe(this.el.node, {attributes: true});\r\n        } else {\r\n            try {\r\n                this.observerInst.disconnect();\r\n                delete this.observerInst;\r\n            } catch (e) {\r\n            }\r\n        }\r\n    } else {\r\n        this.el.off('DOMAttrModified.select');\r\n\r\n        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n            this.el.on('DOMAttrModified.select', function () {\r\n                _this.handler();\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nSelectHandler.prototype.cleanup = function () {\r\n\r\n    //var _this = this;\r\n\r\n    if (!this.rectSelection.isSelected && this.rectSelection.set) {\r\n        // stop watching the element, remove the selection\r\n        this.rectSelection.set.each(function () {\r\n            this.remove();\r\n        });\r\n\r\n        this.rectSelection.set.clear();\r\n        delete this.rectSelection.set;\r\n    }\r\n\r\n    if (!this.pointSelection.isSelected && this.pointSelection.set) {\r\n        // Remove all points, clear the set, stop watching the element\r\n        this.pointSelection.set.each(function () {\r\n            this.remove();\r\n        });\r\n\r\n        this.pointSelection.set.clear();\r\n        delete this.pointSelection.set;\r\n    }\r\n\r\n    if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {\r\n        this.nested.remove();\r\n        delete this.nested;\r\n\r\n    }\r\n};\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n    // Select element with mouse\r\n    selectize: function (value, options) {\r\n\r\n        // Check the parameters and reassign if needed\r\n        if (typeof value === 'object') {\r\n            options = value;\r\n            value = true;\r\n        }\r\n\r\n        var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);\r\n\r\n        selectHandler.init(value === undefined ? true : value, options || {});\r\n\r\n        return this;\r\n\r\n    }\r\n});\r\n\r\nSVG.Element.prototype.selectize.defaults = {\r\n    points: true,                            // If true, points at the edges are drawn. Needed for resize!\r\n    classRect: 'svg_select_boundingRect',    // Css-class added to the rect\r\n    classPoints: 'svg_select_points',        // Css-class added to the points\r\n    radius: 7,                               // radius of the points\r\n    rotationPoint: true,                     // If true, rotation point is drawn. Needed for rotation!\r\n    deepSelect: false                        // If true, moving of single points is possible (only line, polyline, polyon)\r\n};\n}());\n\n(function() {\n(function () {\r\n\r\n    function ResizeHandler(el) {\r\n\r\n        el.remember('_resizeHandler', this);\r\n\r\n        this.el = el;\r\n        this.parameters = {};\r\n        this.lastUpdateCall = null;\r\n        this.p = el.doc().node.createSVGPoint();\r\n    }\r\n\r\n    ResizeHandler.prototype.transformPoint = function(x, y, m){\r\n\r\n        this.p.x = x - (this.offset.x - window.pageXOffset);\r\n        this.p.y = y - (this.offset.y - window.pageYOffset);\r\n\r\n        return this.p.matrixTransform(m || this.m);\r\n\r\n    };\r\n\r\n    ResizeHandler.prototype._extractPosition = function(event) {\r\n        // Extract a position from a mouse/touch event.\r\n        // Returns { x: .., y: .. }\r\n        return {\r\n            x: event.clientX != null ? event.clientX : event.touches[0].clientX,\r\n            y: event.clientY != null ? event.clientY : event.touches[0].clientY\r\n        }\r\n    };\r\n\r\n    ResizeHandler.prototype.init = function (options) {\r\n\r\n        var _this = this;\r\n\r\n        this.stop();\r\n\r\n        if (options === 'stop') {\r\n            return;\r\n        }\r\n\r\n        this.options = {};\r\n\r\n        // Merge options and defaults\r\n        for (var i in this.el.resize.defaults) {\r\n            this.options[i] = this.el.resize.defaults[i];\r\n            if (typeof options[i] !== 'undefined') {\r\n                this.options[i] = options[i];\r\n            }\r\n        }\r\n\r\n        // We listen to all these events which are specifying different edges\r\n        this.el.on('lt.resize', function(e){ _this.resize(e || window.event); });  // Left-Top\r\n        this.el.on('rt.resize', function(e){ _this.resize(e || window.event); });  // Right-Top\r\n        this.el.on('rb.resize', function(e){ _this.resize(e || window.event); });  // Right-Bottom\r\n        this.el.on('lb.resize', function(e){ _this.resize(e || window.event); });  // Left-Bottom\r\n\r\n        this.el.on('t.resize', function(e){ _this.resize(e || window.event); });   // Top\r\n        this.el.on('r.resize', function(e){ _this.resize(e || window.event); });   // Right\r\n        this.el.on('b.resize', function(e){ _this.resize(e || window.event); });   // Bottom\r\n        this.el.on('l.resize', function(e){ _this.resize(e || window.event); });   // Left\r\n\r\n        this.el.on('rot.resize', function(e){ _this.resize(e || window.event); }); // Rotation\r\n\r\n        this.el.on('point.resize', function(e){ _this.resize(e || window.event); }); // Point-Moving\r\n\r\n        // This call ensures, that the plugin reacts to a change of snapToGrid immediately\r\n        this.update();\r\n\r\n    };\r\n\r\n    ResizeHandler.prototype.stop = function(){\r\n        this.el.off('lt.resize');\r\n        this.el.off('rt.resize');\r\n        this.el.off('rb.resize');\r\n        this.el.off('lb.resize');\r\n\r\n        this.el.off('t.resize');\r\n        this.el.off('r.resize');\r\n        this.el.off('b.resize');\r\n        this.el.off('l.resize');\r\n\r\n        this.el.off('rot.resize');\r\n\r\n        this.el.off('point.resize');\r\n\r\n        return this;\r\n    };\r\n\r\n    ResizeHandler.prototype.resize = function (event) {\r\n\r\n        var _this = this;\r\n\r\n        this.m = this.el.node.getScreenCTM().inverse();\r\n        this.offset = { x: window.pageXOffset, y: window.pageYOffset };\r\n\r\n        var txPt = this._extractPosition(event.detail.event);\r\n        this.parameters = {\r\n            type: this.el.type, // the type of element\r\n            p: this.transformPoint(txPt.x, txPt.y),\r\n            x: event.detail.x,      // x-position of the mouse when resizing started\r\n            y: event.detail.y,      // y-position of the mouse when resizing started\r\n            box: this.el.bbox(),    // The bounding-box of the element\r\n            rotation: this.el.transform().rotation  // The current rotation of the element\r\n        };\r\n\r\n        // Add font-size parameter if the element type is text\r\n        if (this.el.type === \"text\") {\r\n            this.parameters.fontSize = this.el.attr()[\"font-size\"];\r\n        }\r\n\r\n        // the i-param in the event holds the index of the point which is moved, when using `deepSelect`\r\n        if (event.detail.i !== undefined) {\r\n\r\n            // get the point array\r\n            var array = this.el.array().valueOf();\r\n\r\n            // Save the index and the point which is moved\r\n            this.parameters.i = event.detail.i;\r\n            this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];\r\n        }\r\n\r\n        // Lets check which edge of the bounding-box was clicked and resize the this.el according to this\r\n        switch (event.type) {\r\n\r\n            // Left-Top-Edge\r\n            case 'lt':\r\n                // We build a calculating function for every case which gives us the new position of the this.el\r\n                this.calc = function (diffX, diffY) {\r\n                    // The procedure is always the same\r\n                    // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)\r\n                    var snap = this.snapToGrid(diffX, diffY);\r\n\r\n                    // Now we check if the new height and width still valid (> 0)\r\n                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                        // ...if valid, we resize the this.el (which can include moving because the coord-system starts at the left-top and this edge is moving sometimes when resized)\r\n\r\n                        /*\r\n                         * but first check if the element is text box, so we can change the font size instead of\r\n                         * the width and height\r\n                         */\r\n\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1]).size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right-Top\r\n            case 'rt':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right-Bottom\r\n            case 'rb':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Left-Bottom\r\n            case 'lb':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1);\r\n                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Top\r\n            case 't':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                    if (this.parameters.box.height - snap[1] > 0) {\r\n                        // Disable the font-resizing if it is not from the corner of bounding-box\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).height(this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right\r\n            case 'r':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.width + snap[0] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + snap[0]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Bottom\r\n            case 'b':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Left\r\n            case 'l':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1);\r\n                    if (this.parameters.box.width - snap[0] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).width(this.parameters.box.width - snap[0]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Rotation\r\n            case 'rot':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n\r\n                    // yes this is kinda stupid but we need the mouse coords back...\r\n                    var current = {x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y};\r\n\r\n                    // start minus middle\r\n                    var sAngle = Math.atan2((this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2), (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                    // end minus middle\r\n                    var pAngle = Math.atan2((current.y - this.parameters.box.y - this.parameters.box.height / 2), (current.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                    var angle = (pAngle - sAngle) * 180 / Math.PI;\r\n\r\n                    // We have to move the element to the center of the box first and change the rotation afterwards\r\n                    // because rotation always works around a rotation-center, which is changed when moving the element\r\n                    // We also set the new rotation center to the center of the box.\r\n                    this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(this.parameters.rotation + angle - angle % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);\r\n                };\r\n                break;\r\n\r\n            // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)\r\n            case 'point':\r\n                this.calc = function (diffX, diffY) {\r\n\r\n                    // Snapping the point to the grid\r\n                    var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);\r\n\r\n                    // Get the point array\r\n                    var array = this.el.array().valueOf();\r\n\r\n                    // Changing the moved point in the array\r\n                    array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];\r\n                    array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];\r\n\r\n                    // And plot the new this.el\r\n                    this.el.plot(array);\r\n                };\r\n        }\r\n\r\n        this.el.fire('resizestart', {dx: this.parameters.x, dy: this.parameters.y, event: event});\r\n        // When resizing started, we have to register events for...\r\n        // Touches.\r\n        SVG.on(window, 'touchmove.resize', function(e) {\r\n            _this.update(e || window.event);\r\n        });\r\n        SVG.on(window, 'touchend.resize', function() {\r\n            _this.done();\r\n        });\r\n        // Mouse.\r\n        SVG.on(window, 'mousemove.resize', function (e) {\r\n            _this.update(e || window.event);\r\n        });\r\n        SVG.on(window, 'mouseup.resize', function () {\r\n            _this.done();\r\n        });\r\n\r\n    };\r\n\r\n    // The update-function redraws the element every time the mouse is moving\r\n    ResizeHandler.prototype.update = function (event) {\r\n\r\n        if (!event) {\r\n            if (this.lastUpdateCall) {\r\n                this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Calculate the difference between the mouseposition at start and now\r\n        var txPt = this._extractPosition(event);\r\n        var p = this.transformPoint(txPt.x, txPt.y);\r\n\r\n        var diffX = p.x - this.parameters.p.x,\r\n            diffY = p.y - this.parameters.p.y;\r\n\r\n        this.lastUpdateCall = [diffX, diffY];\r\n\r\n        // Calculate the new position and height / width of the element\r\n        this.calc(diffX, diffY);\r\n\r\n       // Emit an event to say we have changed.\r\n        this.el.fire('resizing', {dx: diffX, dy: diffY, event: event});\r\n    };\r\n\r\n    // Is called on mouseup.\r\n    // Removes the update-function from the mousemove event\r\n    ResizeHandler.prototype.done = function () {\r\n        this.lastUpdateCall = null;\r\n        SVG.off(window, 'mousemove.resize');\r\n        SVG.off(window, 'mouseup.resize');\r\n        SVG.off(window, 'touchmove.resize');\r\n        SVG.off(window, 'touchend.resize');\r\n        this.el.fire('resizedone');\r\n    };\r\n\r\n    // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)\r\n    // In this cases the temp-values are calculated differently\r\n    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {\r\n\r\n        var temp;\r\n\r\n        // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value\r\n        if (typeof pointCoordsY !== 'undefined') {\r\n            // Note that flag = pointCoordsX in this case\r\n            temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];\r\n        } else {\r\n            // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)\r\n            flag = flag == null ? 1 | 1 << 1 : flag;\r\n            temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid];\r\n        }\r\n\r\n\r\n        diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2 ?\r\n                  temp[0] :\r\n                  temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n        diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2 ?\r\n                  temp[1] :\r\n                  temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n\r\n        return this.constraintToBox(diffX, diffY, flag, pointCoordsY);\r\n\r\n    };\r\n\r\n    // keep element within constrained box\r\n    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {\r\n        //return [diffX, diffY]\r\n        var c = this.options.constraint || {};\r\n        var orgX, orgY;\r\n\r\n        if (typeof pointCoordsY !== 'undefined') {\r\n          orgX = flag;\r\n          orgY = pointCoordsY;\r\n        } else {\r\n          orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);\r\n          orgY = this.parameters.box.y + (flag & (1<<1) ? 0 : this.parameters.box.height);\r\n        }\r\n\r\n        if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {\r\n          diffX = c.minX - orgX;\r\n        }\r\n\r\n        if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {\r\n          diffX = c.maxX - orgX;\r\n        }\r\n\r\n        if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {\r\n          diffY = c.minY - orgY;\r\n        }\r\n\r\n        if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {\r\n          diffY = c.maxY - orgY;\r\n        }\r\n\r\n        return [diffX, diffY];\r\n    };\r\n\r\n    ResizeHandler.prototype.checkAspectRatio = function (snap) {\r\n        if (!this.options.saveAspectRatio) {\r\n            return snap;\r\n        }\r\n\r\n        var updatedSnap = snap.slice();\r\n        var aspectRatio = this.parameters.box.width / this.parameters.box.height;\r\n        var newW = this.parameters.box.width + snap[0];\r\n        var newH = this.parameters.box.height - snap[1];\r\n        var newAspectRatio = newW / newH;\r\n\r\n        if (newAspectRatio < aspectRatio) {\r\n            // Height is too big. Adapt it\r\n            updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;\r\n        } else if (newAspectRatio > aspectRatio) {\r\n            // Width is too big. Adapt it\r\n            updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;\r\n        }\r\n\r\n        return updatedSnap;\r\n\r\n    };\r\n\r\n    SVG.extend(SVG.Element, {\r\n        // Resize element with mouse\r\n        resize: function (options) {\r\n\r\n            (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n    });\r\n\r\n    SVG.Element.prototype.resize.defaults = {\r\n        snapToAngle: 0.1,       // Specifies the speed the rotation is happening when moving the mouse\r\n        snapToGrid: 1,          // Snaps to a grid of `snapToGrid` Pixels\r\n        constraint: {},         // keep element within constrained box\r\n        saveAspectRatio: false  // Save aspect ratio when resizing using lt, rt, rb or lb points\r\n    };\r\n\r\n}).call(this);\n}());\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".apexcharts-canvas {\\n  position: relative;\\n  user-select: none;\\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\\n}\\n\\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\\n.apexcharts-canvas ::-webkit-scrollbar {\\n  -webkit-appearance: none;\\n  width: 6px;\\n}\\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\\n  border-radius: 4px;\\n  background-color: rgba(0,0,0,.5);\\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\\n}\\n.apexcharts-canvas.dark {\\n  background: #343F57;\\n}\\n\\n.apexcharts-inner {\\n  position: relative;\\n}\\n\\n.legend-mouseover-inactive {\\n  transition: 0.15s ease all;\\n  opacity: 0.20;\\n}\\n\\n.apexcharts-series-collapsed {\\n  opacity: 0;\\n}\\n\\n.apexcharts-gridline, .apexcharts-text {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-tooltip {\\n  border-radius: 5px;\\n  box-shadow: 2px 2px 6px -4px #999;\\n  cursor: default;\\n  font-size: 14px;\\n  left: 62px;\\n  opacity: 0;\\n  pointer-events: none;\\n  position: absolute;\\n  top: 20px;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  z-index: 12;\\n  transition: 0.15s ease all;\\n}\\n.apexcharts-tooltip.light {\\n  border: 1px solid #e3e3e3;\\n  background: rgba(255, 255, 255, 0.96);\\n}\\n.apexcharts-tooltip.dark {\\n  color: #fff;\\n  background: rgba(30,30,30, 0.8);\\n}\\n.apexcharts-tooltip * {\\n  font-family: inherit;\\n}\\n\\n.apexcharts-tooltip .apexcharts-marker,\\n.apexcharts-area-series .apexcharts-area,\\n.apexcharts-line {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-tooltip.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-tooltip-title {\\n  padding: 6px;\\n  font-size: 15px;\\n  margin-bottom: 4px;\\n}\\n.apexcharts-tooltip.light .apexcharts-tooltip-title {\\n  background: #ECEFF1;\\n  border-bottom: 1px solid #ddd;\\n}\\n.apexcharts-tooltip.dark .apexcharts-tooltip-title {\\n  background: rgba(0, 0, 0, 0.7);\\n  border-bottom: 1px solid #333;\\n}\\n\\n.apexcharts-tooltip-text-value,\\n.apexcharts-tooltip-text-z-value {\\n  display: inline-block;\\n  font-weight: 600;\\n  margin-left: 5px;\\n}\\n\\n.apexcharts-tooltip-text-z-label:empty,\\n.apexcharts-tooltip-text-z-value:empty {\\n  display: none;\\n}\\n\\n.apexcharts-tooltip-text-value, \\n.apexcharts-tooltip-text-z-value {\\n  font-weight: 600;\\n}\\n\\n.apexcharts-tooltip-marker {\\n  width: 12px;\\n  height: 12px;\\n  position: relative;\\n  top: 0px;\\n  margin-right: 10px;\\n  border-radius: 50%;\\n}\\n\\n.apexcharts-tooltip-series-group {\\n  padding: 0 10px;\\n  display: none;\\n  text-align: left;\\n  justify-content: left;\\n  align-items: center;\\n}\\n\\n.apexcharts-tooltip-series-group.active .apexcharts-tooltip-marker {\\n  opacity: 1;\\n}\\n.apexcharts-tooltip-series-group.active, .apexcharts-tooltip-series-group:last-child {\\n  padding-bottom: 4px;\\n}\\n.apexcharts-tooltip-y-group {\\n  padding: 6px 0 5px;\\n}\\n.apexcharts-tooltip-candlestick {\\n  padding: 4px 8px;\\n}\\n.apexcharts-tooltip-candlestick > div {\\n  margin: 4px 0;\\n}\\n.apexcharts-tooltip-candlestick span.value {\\n  font-weight: bold;\\n}\\n\\n.apexcharts-tooltip-rangebar {\\n  padding: 5px 8px;\\n}\\n\\n.apexcharts-tooltip-rangebar .category {\\n  font-weight: 600;\\n  color: #777;\\n}\\n\\n.apexcharts-tooltip-rangebar .series-name {\\n  font-weight: bold;\\n  display: block;\\n  margin-bottom: 5px;\\n}\\n\\n.apexcharts-xaxistooltip {\\n  opacity: 0;\\n  padding: 9px 10px;\\n  pointer-events: none;\\n  color: #373d3f;\\n  font-size: 13px;\\n  text-align: center;\\n  border-radius: 2px;\\n  position: absolute;\\n  z-index: 10;\\n\\tbackground: #ECEFF1;\\n  border: 1px solid #90A4AE;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-xaxistooltip.dark {\\n  background: rgba(0, 0, 0, 0.7);\\n  border: 1px solid rgba(0, 0, 0, 0.5);\\n  color: #fff;\\n}\\n\\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\\n\\tleft: 50%;\\n\\tborder: solid transparent;\\n\\tcontent: \\\" \\\";\\n\\theight: 0;\\n\\twidth: 0;\\n\\tposition: absolute;\\n\\tpointer-events: none;\\n}\\n\\n.apexcharts-xaxistooltip:after {\\n\\tborder-color: rgba(236, 239, 241, 0);\\n\\tborder-width: 6px;\\n\\tmargin-left: -6px;\\n}\\n.apexcharts-xaxistooltip:before {\\n\\tborder-color: rgba(144, 164, 174, 0);\\n\\tborder-width: 7px;\\n\\tmargin-left: -7px;\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\\n  bottom: 100%;\\n}\\n\\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\\n  top: 100%;\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after {\\n  border-bottom-color: #ECEFF1;\\n}\\n.apexcharts-xaxistooltip-bottom:before {\\n  border-bottom-color: #90A4AE;\\n}\\n\\n.apexcharts-xaxistooltip-bottom.dark:after {\\n  border-bottom-color: rgba(0, 0, 0, 0.5);\\n}\\n.apexcharts-xaxistooltip-bottom.dark:before {\\n  border-bottom-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.apexcharts-xaxistooltip-top:after {\\n  border-top-color:#ECEFF1\\n}\\n.apexcharts-xaxistooltip-top:before {\\n  border-top-color: #90A4AE;\\n}\\n.apexcharts-xaxistooltip-top.dark:after {\\n  border-top-color:rgba(0, 0, 0, 0.5);\\n}\\n.apexcharts-xaxistooltip-top.dark:before {\\n  border-top-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n\\n.apexcharts-xaxistooltip.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-yaxistooltip {\\n  opacity: 0;\\n  padding: 4px 10px;\\n  pointer-events: none;\\n  color: #373d3f;\\n  font-size: 13px;\\n  text-align: center;\\n  border-radius: 2px;\\n  position: absolute;\\n  z-index: 10;\\n\\tbackground: #ECEFF1;\\n  border: 1px solid #90A4AE;\\n}\\n\\n.apexcharts-yaxistooltip.dark {\\n  background: rgba(0, 0, 0, 0.7);\\n  border: 1px solid rgba(0, 0, 0, 0.5);\\n  color: #fff;\\n}\\n\\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\\n\\ttop: 50%;\\n\\tborder: solid transparent;\\n\\tcontent: \\\" \\\";\\n\\theight: 0;\\n\\twidth: 0;\\n\\tposition: absolute;\\n\\tpointer-events: none;\\n}\\n.apexcharts-yaxistooltip:after {\\n\\tborder-color: rgba(236, 239, 241, 0);\\n\\tborder-width: 6px;\\n\\tmargin-top: -6px;\\n}\\n.apexcharts-yaxistooltip:before {\\n\\tborder-color: rgba(144, 164, 174, 0);\\n\\tborder-width: 7px;\\n\\tmargin-top: -7px;\\n}\\n\\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\\n  left: 100%;\\n}\\n\\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\\n  right: 100%;\\n}\\n\\n.apexcharts-yaxistooltip-left:after {\\n  border-left-color: #ECEFF1;\\n}\\n.apexcharts-yaxistooltip-left:before {\\n  border-left-color: #90A4AE;\\n}\\n.apexcharts-yaxistooltip-left.dark:after {\\n  border-left-color: rgba(0, 0, 0, 0.5);\\n}\\n.apexcharts-yaxistooltip-left.dark:before {\\n  border-left-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.apexcharts-yaxistooltip-right:after {\\n  border-right-color: #ECEFF1;\\n}\\n.apexcharts-yaxistooltip-right:before {\\n  border-right-color: #90A4AE;\\n}\\n.apexcharts-yaxistooltip-right.dark:after {\\n  border-right-color: rgba(0, 0, 0, 0.5);\\n}\\n.apexcharts-yaxistooltip-right.dark:before {\\n  border-right-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.apexcharts-yaxistooltip.active {\\n  opacity: 1;\\n}\\n\\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\\n  pointer-events: none;\\n  opacity: 0;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-xcrosshairs.active, .apexcharts-ycrosshairs.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-ycrosshairs-hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-zoom-rect {\\n  pointer-events: none;\\n}\\n.apexcharts-selection-rect {\\n  cursor: move;\\n}\\n\\n.svg_select_points, .svg_select_points_rot {\\n  opacity: 0;\\n  visibility: hidden;\\n}\\n.svg_select_points_l, .svg_select_points_r {\\n  cursor: ew-resize;\\n  opacity: 1;\\n  visibility: visible;\\n  fill: #888;\\n}\\n.apexcharts-canvas.zoomable .hovering-zoom {\\n  cursor: crosshair\\n}\\n.apexcharts-canvas.zoomable .hovering-pan {\\n  cursor: move\\n}\\n\\n.apexcharts-xaxis,\\n.apexcharts-yaxis {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-zoom-icon, \\n.apexcharts-zoom-in-icon,\\n.apexcharts-zoom-out-icon,\\n.apexcharts-reset-zoom-icon, \\n.apexcharts-pan-icon, \\n.apexcharts-selection-icon,\\n.apexcharts-menu-icon, \\n.apexcharts-toolbar-custom-icon {\\n  cursor: pointer;\\n  width: 20px;\\n  height: 20px;\\n  line-height: 24px;\\n  color: #6E8192;\\n  text-align: center;\\n}\\n\\n\\n.apexcharts-zoom-icon svg, \\n.apexcharts-zoom-in-icon svg,\\n.apexcharts-zoom-out-icon svg,\\n.apexcharts-reset-zoom-icon svg,\\n.apexcharts-menu-icon svg {\\n  fill: #6E8192;\\n}\\n.apexcharts-selection-icon svg {\\n  fill: #444;\\n  transform: scale(0.76)\\n}\\n\\n.dark .apexcharts-zoom-icon svg, \\n.dark .apexcharts-zoom-in-icon svg,\\n.dark .apexcharts-zoom-out-icon svg,\\n.dark .apexcharts-reset-zoom-icon svg, \\n.dark .apexcharts-pan-icon svg, \\n.dark .apexcharts-selection-icon svg,\\n.dark .apexcharts-menu-icon svg, \\n.dark .apexcharts-toolbar-custom-icon svg{\\n  fill: #f3f4f5;\\n}\\n\\n.apexcharts-canvas .apexcharts-zoom-icon.selected svg, \\n.apexcharts-canvas .apexcharts-selection-icon.selected svg, \\n.apexcharts-canvas .apexcharts-reset-zoom-icon.selected svg {\\n  fill: #008FFB;\\n}\\n.light .apexcharts-selection-icon:not(.selected):hover svg,\\n.light .apexcharts-zoom-icon:not(.selected):hover svg, \\n.light .apexcharts-zoom-in-icon:hover svg, \\n.light .apexcharts-zoom-out-icon:hover svg, \\n.light .apexcharts-reset-zoom-icon:hover svg, \\n.light .apexcharts-menu-icon:hover svg {\\n  fill: #333;\\n}\\n\\n.apexcharts-selection-icon, .apexcharts-menu-icon {\\n  position: relative;\\n}\\n.apexcharts-reset-zoom-icon {\\n  margin-left: 5px;\\n}\\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\\n  transform: scale(0.85);\\n}\\n\\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\\n  transform: scale(0.7)\\n}\\n\\n.apexcharts-zoom-out-icon {\\n  margin-right: 3px;\\n}\\n\\n.apexcharts-pan-icon {\\n  transform: scale(0.62);\\n  position: relative;\\n  left: 1px;\\n  top: 0px;\\n}\\n.apexcharts-pan-icon svg {\\n  fill: #fff;\\n  stroke: #6E8192;\\n  stroke-width: 2;\\n}\\n.apexcharts-pan-icon.selected svg {\\n  stroke: #008FFB;\\n}\\n.apexcharts-pan-icon:not(.selected):hover svg {\\n  stroke: #333;\\n}\\n\\n.apexcharts-toolbar {\\n  position: absolute;\\n  z-index: 11;\\n  top: 0px;\\n  right: 3px;\\n  max-width: 176px;\\n  text-align: right;\\n  border-radius: 3px;\\n  padding: 0px 6px 2px 6px;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center; \\n}\\n\\n.apexcharts-toolbar svg {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-menu {\\n  background: #fff;\\n  position: absolute;\\n  top: 100%;\\n  border: 1px solid #ddd;\\n  border-radius: 3px;\\n  padding: 3px;\\n  right: 10px;\\n  opacity: 0;\\n  min-width: 110px;\\n  transition: 0.15s ease all;\\n  pointer-events: none;\\n}\\n\\n.apexcharts-menu.open {\\n  opacity: 1;\\n  pointer-events: all;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-menu-item {\\n  padding: 6px 7px;\\n  font-size: 12px;\\n  cursor: pointer;\\n}\\n.light .apexcharts-menu-item:hover {\\n  background: #eee;\\n}\\n.dark .apexcharts-menu {\\n  background: rgba(0, 0, 0, 0.7);\\n  color: #fff;\\n}\\n\\n@media screen and (min-width: 768px) {\\n  .apexcharts-toolbar {\\n    /*opacity: 0;*/\\n  }\\n\\n  .apexcharts-canvas:hover .apexcharts-toolbar {\\n    opacity: 1;\\n  } \\n}\\n\\n.apexcharts-datalabel.hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-pie-label,\\n.apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\\n  cursor: default;\\n  pointer-events: none;\\n}\\n\\n.apexcharts-pie-label-delay {\\n  opacity: 0;\\n  animation-name: opaque;\\n  animation-duration: 0.3s;\\n  animation-fill-mode: forwards;\\n  animation-timing-function: ease;\\n}\\n\\n.apexcharts-canvas .hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-hide .apexcharts-series-points {\\n  opacity: 0;\\n}\\n\\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\\n  pointer-events: none;\\n}\\n\\n/* markers */\\n\\n.apexcharts-marker {\\n  transition: 0.15s ease all;\\n}\\n\\n@keyframes opaque {\\n  0% {\\n    opacity: 0;\\n  }\\n  100% {\\n    opacity: 1;\\n  }\\n}\";\nstyleInject(css);\n\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 1.2.20171210\n *\n * By Eli Grey, http://eligrey.com\n * License: Dedicated to the public domain.\n *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\nif (\"document\" in self) {\n  // Full polyfill for browsers with no classList support\n  // Including IE < Edge missing SVGElement.classList\n  if (!(\"classList\" in document.createElement(\"_\")) || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"))) {\n    (function (view) {\n\n      if (!('Element' in view)) return;\n\n      var classListProp = \"classList\",\n          protoProp = \"prototype\",\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          strTrim = String[protoProp].trim || function () {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n      },\n          arrIndexOf = Array[protoProp].indexOf || function (item) {\n        var i = 0,\n            len = this.length;\n\n        for (; i < len; i++) {\n          if (i in this && this[i] === item) {\n            return i;\n          }\n        }\n\n        return -1;\n      } // Vendors: please allow content code to instantiate DOMExceptions\n      ,\n          DOMEx = function DOMEx(type, message) {\n        this.name = type;\n        this.code = DOMException[type];\n        this.message = message;\n      },\n          checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {\n        if (token === \"\") {\n          throw new DOMEx(\"SYNTAX_ERR\", \"The token must not be empty.\");\n        }\n\n        if (/\\s/.test(token)) {\n          throw new DOMEx(\"INVALID_CHARACTER_ERR\", \"The token must not contain space characters.\");\n        }\n\n        return arrIndexOf.call(classList, token);\n      },\n          ClassList = function ClassList(elem) {\n        var trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\"),\n            classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : [],\n            i = 0,\n            len = classes.length;\n\n        for (; i < len; i++) {\n          this.push(classes[i]);\n        }\n\n        this._updateClassName = function () {\n          elem.setAttribute(\"class\", this.toString());\n        };\n      },\n          classListProto = ClassList[protoProp] = [],\n          classListGetter = function classListGetter() {\n        return new ClassList(this);\n      }; // Most DOMException implementations don't allow calling DOMException's toString()\n      // on non-DOMExceptions. Error's toString() is sufficient here.\n\n\n      DOMEx[protoProp] = Error[protoProp];\n\n      classListProto.item = function (i) {\n        return this[i] || null;\n      };\n\n      classListProto.contains = function (token) {\n        return ~checkTokenAndGetIndex(this, token + \"\");\n      };\n\n      classListProto.add = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false;\n\n        do {\n          token = tokens[i] + \"\";\n\n          if (!~checkTokenAndGetIndex(this, token)) {\n            this.push(token);\n            updated = true;\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n\n      classListProto.remove = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false,\n            index;\n\n        do {\n          token = tokens[i] + \"\";\n          index = checkTokenAndGetIndex(this, token);\n\n          while (~index) {\n            this.splice(index, 1);\n            updated = true;\n            index = checkTokenAndGetIndex(this, token);\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n\n      classListProto.toggle = function (token, force) {\n        var result = this.contains(token),\n            method = result ? force !== true && \"remove\" : force !== false && \"add\";\n\n        if (method) {\n          this[method](token);\n        }\n\n        if (force === true || force === false) {\n          return force;\n        } else {\n          return !result;\n        }\n      };\n\n      classListProto.replace = function (token, replacement_token) {\n        var index = checkTokenAndGetIndex(token + \"\");\n\n        if (~index) {\n          this.splice(index, 1, replacement_token);\n\n          this._updateClassName();\n        }\n      };\n\n      classListProto.toString = function () {\n        return this.join(\" \");\n      };\n\n      if (objCtr.defineProperty) {\n        var classListPropDesc = {\n          get: classListGetter,\n          enumerable: true,\n          configurable: true\n        };\n\n        try {\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        } catch (ex) {\n          // IE 8 doesn't support enumerable:true\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          }\n        }\n      } else if (objCtr[protoProp].__defineGetter__) {\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\n      }\n    })(self);\n  } // There is full or partial native classList support, so just check if we need\n  // to normalize the add/remove and toggle APIs.\n\n\n  (function () {\n\n    var testElement = document.createElement(\"_\");\n    testElement.classList.add(\"c1\", \"c2\"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and\n    // classList.remove exist but support only one argument at a time.\n\n    if (!testElement.classList.contains(\"c2\")) {\n      var createMethod = function createMethod(method) {\n        var original = DOMTokenList.prototype[method];\n\n        DOMTokenList.prototype[method] = function (token) {\n          var i,\n              len = arguments.length;\n\n          for (i = 0; i < len; i++) {\n            token = arguments[i];\n            original.call(this, token);\n          }\n        };\n      };\n\n      createMethod('add');\n      createMethod('remove');\n    }\n\n    testElement.classList.toggle(\"c3\", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n    // support the second argument.\n\n    if (testElement.classList.contains(\"c3\")) {\n      var _toggle = DOMTokenList.prototype.toggle;\n\n      DOMTokenList.prototype.toggle = function (token, force) {\n        if (1 in arguments && !this.contains(token) === !force) {\n          return force;\n        } else {\n          return _toggle.call(this, token);\n        }\n      };\n    } // replace() polyfill\n\n\n    if (!(\"replace\" in document.createElement(\"_\").classList)) {\n      DOMTokenList.prototype.replace = function (token, replacement_token) {\n        var tokens = this.toString().split(\" \"),\n            index = tokens.indexOf(token + \"\");\n\n        if (~index) {\n          tokens = tokens.slice(index);\n          this.remove.apply(this, tokens);\n          this.add(replacement_token);\n          this.add.apply(this, tokens.slice(1));\n        }\n      };\n    }\n\n    testElement = null;\n  })();\n}\n\n/**\n* Detect Element Resize\n*\n* https://github.com/sdecima/javascript-detect-element-resize\n* Sebastian Decima\n*\n* version: 0.5.3\n**/\n(function () {\n  var stylesCreated = false;\n\n  function resetTriggers(element) {\n    var triggers = element.__resizeTriggers__,\n        expand = triggers.firstElementChild,\n        contract = triggers.lastElementChild,\n        expandChild = expand.firstElementChild;\n    contract.scrollLeft = contract.scrollWidth;\n    contract.scrollTop = contract.scrollHeight;\n    expandChild.style.width = expand.offsetWidth + 1 + 'px';\n    expandChild.style.height = expand.offsetHeight + 1 + 'px';\n    expand.scrollLeft = expand.scrollWidth;\n    expand.scrollTop = expand.scrollHeight;\n  }\n\n  function checkTriggers(element) {\n    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;\n  }\n\n  function scrollListener(e) {\n    var element = this;\n    resetTriggers(this);\n    if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);\n    this.__resizeRAF__ = requestFrame(function () {\n      if (checkTriggers(element)) {\n        element.__resizeLast__.width = element.offsetWidth;\n        element.__resizeLast__.height = element.offsetHeight;\n\n        element.__resizeListeners__.forEach(function (fn) {\n          fn.call(e);\n        });\n      }\n    });\n  }\n\n  function createStyles() {\n    if (!stylesCreated) {\n      // opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\n      var css = (animationKeyframes || '') + '.resize-triggers { ' + (animationStyle || '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \\\" \\\"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n          head = document.head || document.getElementsByTagName('head')[0],\n          style = document.createElement('style');\n      style.type = 'text/css';\n\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(document.createTextNode(css));\n      }\n\n      head.appendChild(style);\n      stylesCreated = true;\n    }\n  }\n\n  var requestFrame = function () {\n    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n      return window.setTimeout(fn, 20);\n    };\n\n    return function (fn) {\n      return raf(fn);\n    };\n  }();\n\n  var cancelFrame = function () {\n    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;\n    return function (id) {\n      return cancel(id);\n    };\n  }();\n  /* Detect CSS Animations support to detect element display/re-attach */\n\n\n  var animation = false,\n      keyframeprefix = '',\n      animationstartevent = 'animationstart',\n      domPrefixes = 'Webkit Moz O ms'.split(' '),\n      startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),\n      pfx = '';\n  {\n    var elm = document.createElement('fakeelement');\n\n    if (elm.style.animationName !== undefined) {\n      animation = true;\n    }\n\n    if (animation === false) {\n      for (var i = 0; i < domPrefixes.length; i++) {\n        if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {\n          pfx = domPrefixes[i];\n          keyframeprefix = '-' + pfx.toLowerCase() + '-';\n          animationstartevent = startEvents[i];\n          break;\n        }\n      }\n    }\n  }\n  var animationName = 'resizeanim';\n  var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';\n  var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';\n\n  window.addResizeListener = function (element, fn) {\n    if (!element.__resizeTriggers__) {\n      if (getComputedStyle(element).position == 'static') element.style.position = 'relative';\n      createStyles();\n      element.__resizeLast__ = {};\n      element.__resizeListeners__ = [];\n      (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';\n      element.__resizeTriggers__.innerHTML = '<div class=\"expand-trigger\"><div></div></div>' + '<div class=\"contract-trigger\"></div>';\n      element.appendChild(element.__resizeTriggers__);\n      resetTriggers(element);\n      element.addEventListener('scroll', scrollListener, true);\n      /* Listen for a css animation to detect element display/re-attach */\n\n      animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function (e) {\n        if (e.animationName == animationName) {\n          resetTriggers(element);\n        }\n      });\n    }\n\n    element.__resizeListeners__.push(fn);\n  };\n\n  window.removeResizeListener = function (element, fn) {\n    if (element) {\n      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n\n      if (!element.__resizeListeners__.length) {\n        element.removeEventListener('scroll', scrollListener);\n        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);\n      }\n    }\n  };\n})();\n\nwindow.Apex = {};\n/**\n *\n * @module ApexCharts\n **/\n\nvar ApexCharts$1 =\n/*#__PURE__*/\nfunction () {\n  function ApexCharts(el, opts) {\n    _classCallCheck(this, ApexCharts);\n\n    this.opts = opts;\n    this.ctx = this; // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.\n\n    this.w = new Base(opts).init();\n    this.el = el;\n    this.w.globals.cuid = (Math.random() + 1).toString(36).substring(4);\n    this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid;\n    this.initModules();\n    this.create = Utils.bind(this.create, this);\n    this.windowResizeHandler = this.windowResize.bind(this);\n  }\n  /**\n   * The primary method user will call to render the chart.\n   */\n\n\n  _createClass(ApexCharts, [{\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      // main method\n      return new Promise$1(function (resolve, reject) {\n        // only draw chart, if element found\n        if (_this.el !== null) {\n          if (typeof Apex._chartInstances === 'undefined') {\n            Apex._chartInstances = [];\n          }\n\n          if (_this.w.config.chart.id) {\n            Apex._chartInstances.push({\n              id: _this.w.globals.chartID,\n              group: _this.w.config.chart.group,\n              chart: _this\n            });\n          } // set the locale here\n\n\n          _this.setLocale(_this.w.config.chart.defaultLocale);\n\n          var beforeMount = _this.w.config.chart.events.beforeMount;\n\n          if (typeof beforeMount === 'function') {\n            beforeMount(_this, _this.w);\n          }\n\n          _this.fireEvent('beforeMount', [_this, _this.w]);\n\n          window.addEventListener('resize', _this.windowResizeHandler);\n          window.addResizeListener(_this.el.parentNode, _this.parentResizeCallback.bind(_this));\n\n          var graphData = _this.create(_this.w.config.series, {});\n\n          if (!graphData) return resolve(_this);\n\n          _this.mount(graphData).then(function () {\n            resolve(graphData);\n\n            if (typeof _this.w.config.chart.events.mounted === 'function') {\n              _this.w.config.chart.events.mounted(_this, _this.w);\n            }\n\n            _this.fireEvent('mounted', [_this, _this.w]);\n          }).catch(function (e) {\n            reject(e); // handle error in case no data or element not found\n          });\n        } else {\n          reject(new Error('Element not found'));\n        }\n      });\n    }\n  }, {\n    key: \"initModules\",\n    value: function initModules() {\n      this.animations = new Animations(this);\n      this.annotations = new Annotations(this);\n      this.core = new Core(this.el, this);\n      this.grid = new Grid(this);\n      this.coreUtils = new CoreUtils(this);\n      this.config = new Config({});\n      this.crosshairs = new Crosshairs(this);\n      this.options = new Options();\n      this.responsive = new Responsive(this);\n      this.series = new Series(this);\n      this.theme = new Theme(this);\n      this.formatters = new Formatters(this);\n      this.titleSubtitle = new TitleSubtitle(this);\n      this.legend = new Legend(this);\n      this.toolbar = new Toolbar(this);\n      this.dimensions = new Dimensions(this);\n      this.zoomPanSelection = new ZoomPanSelection(this);\n      this.w.globals.tooltip = new Tooltip(this);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(name$$1, handler) {\n      var w = this.w;\n\n      if (w.globals.events.hasOwnProperty(name$$1)) {\n        w.globals.events[name$$1].push(handler);\n      } else {\n        w.globals.events[name$$1] = [handler];\n      }\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name$$1, handler) {\n      var w = this.w;\n\n      if (!w.globals.events.hasOwnProperty(name$$1)) {\n        return;\n      }\n\n      var index = w.globals.events[name$$1].indexOf(handler);\n\n      if (index !== -1) {\n        w.globals.events[name$$1].splice(index, 1);\n      }\n    }\n  }, {\n    key: \"fireEvent\",\n    value: function fireEvent(name$$1, args) {\n      var w = this.w;\n\n      if (!w.globals.events.hasOwnProperty(name$$1)) {\n        return;\n      }\n\n      if (!args || !args.length) {\n        args = [];\n      }\n\n      var evs = w.globals.events[name$$1];\n      var l = evs.length;\n\n      for (var i = 0; i < l; i++) {\n        evs[i].apply(null, args);\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(ser, opts) {\n      var w = this.w;\n      this.initModules();\n      var gl = this.w.globals;\n      gl.noData = false;\n      gl.animationEnded = false;\n      this.responsive.checkResponsiveConfig(opts);\n\n      if (this.el === null) {\n        gl.animationEnded = true;\n        return null;\n      }\n\n      this.core.setupElements();\n\n      if (gl.svgWidth === 0) {\n        // if the element is hidden, skip drawing\n        gl.animationEnded = true;\n        return null;\n      }\n\n      var combo = CoreUtils.checkComboSeries(ser);\n      gl.comboCharts = combo.comboCharts;\n      gl.comboChartsHasBars = combo.comboChartsHasBars;\n\n      if (ser.length === 0 || ser.length === 1 && ser[0].data && ser[0].data.length === 0) {\n        this.series.handleNoData();\n      }\n\n      this.setupEventHandlers(); // Handle the data inputted by user and set some of the global variables (for eg, if data is datetime / numeric / category). Don't calculate the range / min / max at this time\n\n      this.core.parseData(ser); // this is a good time to set theme colors first\n\n      this.theme.init(); // as markers accepts array, we need to setup global markers for easier access\n\n      var markers = new Markers(this);\n      markers.setGlobalMarkerSize(); // labelFormatters should be called before dimensions as in dimensions we need text labels width\n\n      this.formatters.setLabelFormatters();\n      this.titleSubtitle.draw(); // legend is calculated here before coreCalculations because it affects the plottable area\n\n      this.legend.init(); // check whether in multiple series, all series share the same X\n\n      this.series.hasAllSeriesEqualX(); // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals\n\n      if (gl.axisCharts) {\n        this.core.coreCalculations();\n\n        if (w.config.xaxis.type !== 'category') {\n          // as we have minX and maxX values, determine the default DateTimeFormat for time series\n          this.formatters.setLabelFormatters();\n        }\n      } // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function\n      // Also we need to do this before calcuting Dimentions plotCoords() method of Dimensions\n\n\n      this.formatters.heatmapLabelFormatters(); // We got plottable area here, next task would be to calculate axis areas\n\n      this.dimensions.plotCoords();\n      var xyRatios = this.core.xySettings();\n      this.grid.createGridMask();\n      var elGraph = this.core.plotChartType(ser, xyRatios); // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends\n\n      this.core.shiftGraphPosition();\n      var dim = {\n        plot: {\n          left: w.globals.translateX,\n          top: w.globals.translateY,\n          width: w.globals.gridWidth,\n          height: w.globals.gridHeight\n        }\n      };\n      return {\n        elGraph: elGraph,\n        xyRatios: xyRatios,\n        elInner: w.globals.dom.elGraphical,\n        dimensions: dim\n      };\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var me = this;\n      var w = me.w;\n      return new Promise$1(function (resolve, reject) {\n        // no data to display\n        if (me.el === null) {\n          return reject(new Error('Not enough data to display or target element not found'));\n        } else if (graphData === null || w.globals.allSeriesCollapsed) {\n          me.series.handleNoData();\n        }\n\n        me.core.drawAxis(w.config.chart.type, graphData.xyRatios);\n        me.grid = new Grid(me);\n\n        if (w.config.grid.position === 'back') {\n          me.grid.drawGrid();\n        }\n\n        if (w.config.annotations.position === 'back') {\n          me.annotations.drawAnnotations();\n        }\n\n        if (graphData.elGraph instanceof Array) {\n          for (var g = 0; g < graphData.elGraph.length; g++) {\n            w.globals.dom.elGraphical.add(graphData.elGraph[g]);\n          }\n        } else {\n          w.globals.dom.elGraphical.add(graphData.elGraph);\n        }\n\n        if (w.config.grid.position === 'front') {\n          me.grid.drawGrid();\n        }\n\n        if (w.config.xaxis.crosshairs.position === 'front') {\n          me.crosshairs.drawXCrosshairs();\n        }\n\n        if (w.config.yaxis[0].crosshairs.position === 'front') {\n          me.crosshairs.drawYCrosshairs();\n        }\n\n        if (w.config.annotations.position === 'front') {\n          me.annotations.drawAnnotations();\n        }\n\n        if (!w.globals.noData) {\n          // draw tooltips at the end\n          if (w.config.tooltip.enabled && !w.globals.noData) {\n            me.w.globals.tooltip.drawTooltip(graphData.xyRatios);\n          }\n\n          if (w.globals.axisCharts && w.globals.isXNumeric) {\n            if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {\n              me.zoomPanSelection.init({\n                xyRatios: graphData.xyRatios\n              });\n            }\n          } else {\n            var tools = w.config.chart.toolbar.tools;\n            tools.zoom = false;\n            tools.zoomin = false;\n            tools.zoomout = false;\n            tools.selection = false;\n            tools.pan = false;\n            tools.reset = false;\n          }\n\n          if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {\n            me.toolbar.createToolbar();\n          }\n        }\n\n        if (w.globals.memory.methodsToExec.length > 0) {\n          w.globals.memory.methodsToExec.forEach(function (fn) {\n            fn.method(fn.params, false, fn.context);\n          });\n        }\n\n        resolve(me);\n      });\n    }\n  }, {\n    key: \"clearPreviousPaths\",\n    value: function clearPreviousPaths() {\n      var w = this.w;\n      w.globals.previousPaths = [];\n      w.globals.allSeriesCollapsed = false;\n      w.globals.collapsedSeries = [];\n      w.globals.collapsedSeriesIndices = [];\n    }\n    /**\n     * Allows users to update Options after the chart has rendered.\n     *\n     * @param {object} options - A new config object can be passed which will be merged with the existing config object\n     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n     * @param {boolean} animate - should animate or not on updating Options\n     */\n\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(options$$1) {\n      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var w = this.w;\n\n      if (options$$1.series) {\n        if (options$$1.series[0].data) {\n          options$$1.series = options$$1.series.map(function (s, i) {\n            return _objectSpread({}, w.config.series[i], {\n              name: s.name ? s.name : w.config.series[i] && w.config.series[i].name,\n              type: s.type ? s.type : w.config.series[i] && w.config.series[i].type,\n              data: s.data ? s.data : w.config.series[i] && w.config.series[i].data\n            });\n          });\n        } // user updated the series via updateOptions() function.\n        // Hence, we need to reset axis min/max to avoid zooming issues\n\n\n        this.revertDefaultAxisMinMax();\n      } // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max\n\n\n      if (options$$1.xaxis) {\n        if (options$$1.xaxis.min || options$$1.xaxis.max) {\n          this.forceXAxisUpdate(options$$1);\n        }\n        /* fixes apexcharts.js#369 and react-apexcharts#46 */\n\n\n        if (options$$1.xaxis.categories && options$$1.xaxis.categories.length && w.config.xaxis.convertedCatToNumeric) {\n          options$$1 = Defaults.convertCatToNumeric(options$$1);\n        }\n      }\n\n      if (w.globals.collapsedSeriesIndices.length > 0) {\n        this.clearPreviousPaths();\n      }\n      /* update theme mode#459 */\n\n\n      if (options$$1.theme) {\n        options$$1 = this.theme.updateThemeOptions(options$$1);\n      }\n\n      return this._updateOptions(options$$1, redraw, animate, overwriteInitialConfig);\n    }\n    /**\n     * private method to update Options.\n     *\n     * @param {object} options - A new config object can be passed which will be merged with the existing config object\n     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n     * @param {boolean} animate - should animate or not on updating Options\n     * @param {boolean} overwriteInitialConfig - should update the initial config or not\n     */\n\n  }, {\n    key: \"_updateOptions\",\n    value: function _updateOptions(options$$1) {\n      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var charts = this.getSyncedCharts();\n      charts.forEach(function (ch) {\n        var w = ch.w;\n        w.globals.shouldAnimate = animate;\n\n        if (!redraw) {\n          w.globals.resized = true;\n          w.globals.dataChanged = true;\n\n          if (animate) {\n            ch.series.getPreviousPaths();\n          }\n        }\n\n        if (options$$1 && _typeof(options$$1) === 'object') {\n          ch.config = new Config(options$$1);\n          options$$1 = CoreUtils.extendArrayProps(ch.config, options$$1);\n          w.config = Utils.extend(w.config, options$$1);\n\n          if (overwriteInitialConfig) {\n            // we need to forget the lastXAxis and lastYAxis is user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.\n            w.globals.lastXAxis = [];\n            w.globals.lastYAxis = []; // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries\n\n            w.globals.initialConfig = Utils.extend({}, w.config);\n            w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));\n          }\n        }\n\n        return ch.update(options$$1);\n      });\n    }\n    /**\n     * Allows users to update Series after the chart has rendered.\n     *\n     * @param {array} series - New series which will override the existing\n     */\n\n  }, {\n    key: \"updateSeries\",\n    value: function updateSeries() {\n      var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      this.revertDefaultAxisMinMax();\n      return this._updateSeries(newSeries, animate, overwriteInitialSeries);\n    }\n    /**\n     * Allows users to append a new series after the chart has rendered.\n     *\n     * @param {array} newSerie - New serie which will be appended to the existing series\n     */\n\n  }, {\n    key: \"appendSeries\",\n    value: function appendSeries(newSerie) {\n      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var newSeries = this.w.config.series.slice();\n      newSeries.push(newSerie);\n      this.revertDefaultAxisMinMax();\n      return this._updateSeries(newSeries, animate);\n    }\n    /**\n     * Private method to update Series.\n     *\n     * @param {array} series - New series which will override the existing\n     */\n\n  }, {\n    key: \"_updateSeries\",\n    value: function _updateSeries(newSeries, animate) {\n      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var w = this.w;\n      this.w.globals.shouldAnimate = animate;\n      w.globals.dataChanged = true; // if user has collapsed some series with legend, we need to clear those\n\n      if (w.globals.allSeriesCollapsed) {\n        w.globals.allSeriesCollapsed = false;\n      }\n\n      if (animate) {\n        this.series.getPreviousPaths();\n      }\n\n      var existingSeries; // axis charts\n\n      if (w.globals.axisCharts) {\n        existingSeries = newSeries.map(function (s, i) {\n          return _objectSpread({}, w.config.series[i], {\n            name: s.name ? s.name : w.config.series[i] && w.config.series[i].name,\n            type: s.type ? s.type : w.config.series[i] && w.config.series[i].type,\n            data: s.data ? s.data : w.config.series[i] && w.config.series[i].data\n          });\n        });\n\n        if (existingSeries.length === 0) {\n          existingSeries = [{\n            data: []\n          }];\n        }\n\n        w.config.series = existingSeries;\n      } else {\n        // non-axis chart (pie/radialbar)\n        w.config.series = newSeries.slice();\n      }\n\n      if (overwriteInitialSeries) {\n        w.globals.initialConfig.series = JSON.parse(JSON.stringify(w.config.series));\n        w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));\n      }\n\n      return this.update();\n    }\n    /**\n     * Get all charts in the same \"group\" (including the instance which is called upon) to sync them when user zooms in/out or pan.\n     */\n\n  }, {\n    key: \"getSyncedCharts\",\n    value: function getSyncedCharts() {\n      var chartGroups = this.getGroupedCharts();\n      var allCharts = [this];\n\n      if (chartGroups.length) {\n        allCharts = [];\n        chartGroups.forEach(function (ch) {\n          allCharts.push(ch);\n        });\n      }\n\n      return allCharts;\n    }\n    /**\n     * Get charts in the same \"group\" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)\n     */\n\n  }, {\n    key: \"getGroupedCharts\",\n    value: function getGroupedCharts() {\n      var _this2 = this;\n\n      return Apex._chartInstances.filter(function (ch) {\n        if (ch.group) {\n          return true;\n        }\n      }).map(function (ch) {\n        return _this2.w.config.chart.group === ch.group ? ch.chart : _this2;\n      });\n    }\n    /**\n     * Allows users to append Data to series.\n     *\n     * @param {array} newData - New data in the same format as series\n     */\n\n  }, {\n    key: \"appendData\",\n    value: function appendData(newData) {\n      var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var me = this;\n      me.w.globals.dataChanged = true;\n      me.series.getPreviousPaths();\n      var newSeries = me.w.config.series.slice();\n\n      for (var i = 0; i < newSeries.length; i++) {\n        if (typeof newData[i] !== 'undefined') {\n          for (var j = 0; j < newData[i].data.length; j++) {\n            newSeries[i].data.push(newData[i].data[j]);\n          }\n        }\n      }\n\n      me.w.config.series = newSeries;\n\n      if (overwriteInitialSeries) {\n        me.w.globals.initialSeries = JSON.parse(JSON.stringify(me.w.config.series));\n      }\n\n      return this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update(options$$1) {\n      var _this3 = this;\n\n      return new Promise$1(function (resolve, reject) {\n        _this3.clear();\n\n        var graphData = _this3.create(_this3.w.config.series, options$$1);\n\n        if (!graphData) return resolve(_this3);\n\n        _this3.mount(graphData).then(function () {\n          if (typeof _this3.w.config.chart.events.updated === 'function') {\n            _this3.w.config.chart.events.updated(_this3, _this3.w);\n          }\n\n          _this3.fireEvent('updated', [_this3, _this3.w]);\n\n          _this3.w.globals.isDirty = true;\n          resolve(_this3);\n        }).catch(function (e) {\n          reject(e);\n        });\n      });\n    }\n  }, {\n    key: \"forceXAxisUpdate\",\n    value: function forceXAxisUpdate(options$$1) {\n      var w = this.w;\n\n      if (typeof options$$1.xaxis.min !== 'undefined') {\n        w.config.xaxis.min = options$$1.xaxis.min;\n        w.globals.lastXAxis.min = options$$1.xaxis.min;\n      }\n\n      if (typeof options$$1.xaxis.max !== 'undefined') {\n        w.config.xaxis.max = options$$1.xaxis.max;\n        w.globals.lastXAxis.max = options$$1.xaxis.max;\n      }\n    }\n    /**\n     * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.\n     * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max\n     * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally\n     */\n\n  }, {\n    key: \"revertDefaultAxisMinMax\",\n    value: function revertDefaultAxisMinMax() {\n      var w = this.w;\n      w.config.xaxis.min = w.globals.lastXAxis.min;\n      w.config.xaxis.max = w.globals.lastXAxis.max;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (w.globals.zoomed) {\n          // if user has zoomed, and this function is called\n          // then we need to get the lastAxis min and max\n          if (typeof w.globals.lastYAxis[index] !== 'undefined') {\n            yaxe.min = w.globals.lastYAxis[index].min;\n            yaxe.max = w.globals.lastYAxis[index].max;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.zoomPanSelection) {\n        this.zoomPanSelection.destroy();\n      }\n\n      if (this.toolbar) {\n        this.toolbar.destroy();\n      }\n\n      this.animations = null;\n      this.annotations = null;\n      this.core = null;\n      this.grid = null;\n      this.series = null;\n      this.responsive = null;\n      this.theme = null;\n      this.formatters = null;\n      this.titleSubtitle = null;\n      this.legend = null;\n      this.dimensions = null;\n      this.options = null;\n      this.crosshairs = null;\n      this.zoomPanSelection = null;\n      this.toolbar = null;\n      this.w.globals.tooltip = null;\n      this.clearDomElements();\n    }\n  }, {\n    key: \"killSVG\",\n    value: function killSVG(draw) {\n      return new Promise$1(function (resolve, reject) {\n        draw.each(function (i, children) {\n          this.removeClass('*');\n          this.off();\n          this.stop();\n        }, true);\n        draw.ungroup();\n        draw.clear();\n        resolve('done');\n      });\n    }\n  }, {\n    key: \"clearDomElements\",\n    value: function clearDomElements() {\n      var domEls = this.w.globals.dom;\n\n      if (this.el !== null) {\n        // remove all child elements - resetting the whole chart\n        while (this.el.firstChild) {\n          this.el.removeChild(this.el.firstChild);\n        }\n      }\n\n      this.killSVG(domEls.Paper);\n      domEls.Paper.remove();\n      domEls.elWrap = null;\n      domEls.elGraphical = null;\n      domEls.elLegendWrap = null;\n      domEls.baseEl = null;\n      domEls.elGridRect = null;\n      domEls.elGridRectMask = null;\n      domEls.elGridRectMarkerMask = null;\n      domEls.elDefs = null;\n    }\n    /**\n     * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clear(); // remove the chart's instance from the global Apex._chartInstances\n\n      var chartID = this.w.config.chart.id;\n\n      if (chartID) {\n        Apex._chartInstances.forEach(function (c, i) {\n          if (c.id === chartID) {\n            Apex._chartInstances.splice(i, 1);\n          }\n        });\n      }\n\n      window.removeEventListener('resize', this.windowResizeHandler);\n      window.removeResizeListener(this.el.parentNode, this.parentResizeCallback.bind(this));\n    }\n    /**\n     * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute\n     */\n\n  }, {\n    key: \"toggleSeries\",\n    value: function toggleSeries(seriesName) {\n      var targetElement = this.series.getSeriesByName(seriesName);\n      var seriesCnt = parseInt(targetElement.getAttribute('data:realIndex'));\n      var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');\n      this.legend.toggleDataSeries(seriesCnt, isHidden);\n    }\n  }, {\n    key: \"resetToggleSeries\",\n    value: function resetToggleSeries() {\n      this.legend.resetToggleDataSeries();\n    }\n  }, {\n    key: \"setupEventHandlers\",\n    value: function setupEventHandlers() {\n      var w = this.w;\n      var me = this;\n      var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);\n      var eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];\n      eventList.forEach(function (event) {\n        clickableArea.addEventListener(event, function (e) {\n          if (e.type === 'mousedown' && e.which === 1) ; else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {\n            if (typeof w.config.chart.events.click === 'function') {\n              w.config.chart.events.click(e, me, w);\n            }\n\n            me.fireEvent('click', [e, me, w]);\n          }\n        }, {\n          capture: false,\n          passive: true\n        });\n      });\n      eventList.forEach(function (event) {\n        document.addEventListener(event, function (e) {\n          w.globals.clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n          w.globals.clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;\n        });\n      });\n      this.core.setupBrushHandler();\n    }\n  }, {\n    key: \"addXaxisAnnotation\",\n    value: function addXaxisAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"addYaxisAnnotation\",\n    value: function addYaxisAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"addPointAnnotation\",\n    value: function addPointAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"clearAnnotations\",\n    value: function clearAnnotations() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.clearAnnotations(me);\n    } // This method is never used internally and will be only called externally on the chart instance.\n    // Hence, we need to keep all these elements in memory when the chart gets updated and redraw again\n\n  }, {\n    key: \"addText\",\n    value: function addText(options$$1) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addText(options$$1, pushToMemory, me);\n    }\n  }, {\n    key: \"getChartArea\",\n    value: function getChartArea() {\n      var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');\n      return el;\n    }\n  }, {\n    key: \"getSeriesTotalXRange\",\n    value: function getSeriesTotalXRange(minX, maxX) {\n      return this.coreUtils.getSeriesTotalsXRange(minX, maxX);\n    }\n  }, {\n    key: \"getHighestValueInSeries\",\n    value: function getHighestValueInSeries() {\n      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var range = new Range$1(this.ctx);\n      var minYmaxY = range.getMinYMaxY(seriesIndex);\n      return minYmaxY.highestY;\n    }\n  }, {\n    key: \"getLowestValueInSeries\",\n    value: function getLowestValueInSeries() {\n      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var range = new Range$1(this.ctx);\n      var minYmaxY = range.getMinYMaxY(seriesIndex);\n      return minYmaxY.lowestY;\n    }\n  }, {\n    key: \"getSeriesTotal\",\n    value: function getSeriesTotal() {\n      return this.w.globals.seriesTotals;\n    }\n  }, {\n    key: \"setLocale\",\n    value: function setLocale(localeName) {\n      this.setCurrentLocaleValues(localeName);\n    }\n  }, {\n    key: \"setCurrentLocaleValues\",\n    value: function setCurrentLocaleValues(localeName) {\n      var locales = this.w.config.chart.locales; // check if user has specified locales in global Apex variable\n      // if yes - then extend those with local chart's locale\n\n      if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {\n        locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);\n      } // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)\n\n\n      var selectedLocale = locales.filter(function (c) {\n        return c.name === localeName;\n      })[0];\n\n      if (selectedLocale) {\n        // create a complete locale object by extending defaults so you don't get undefined errors.\n        var ret = Utils.extend(en, selectedLocale); // store these locale options in global var for ease access\n\n        this.w.globals.locale = ret.options;\n      } else {\n        throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');\n      }\n    }\n  }, {\n    key: \"dataURI\",\n    value: function dataURI() {\n      var exp = new Exports(this.ctx);\n      return exp.dataURI();\n    }\n  }, {\n    key: \"paper\",\n    value: function paper() {\n      return this.w.globals.dom.Paper;\n    }\n  }, {\n    key: \"parentResizeCallback\",\n    value: function parentResizeCallback() {\n      if (this.w.globals.animationEnded) {\n        this.windowResize();\n      }\n    }\n    /**\n     * Handle window resize and re-draw the whole chart.\n     */\n\n  }, {\n    key: \"windowResize\",\n    value: function windowResize() {\n      var _this4 = this;\n\n      clearTimeout(this.w.globals.resizeTimer);\n      this.w.globals.resizeTimer = window.setTimeout(function () {\n        _this4.w.globals.resized = true;\n        _this4.w.globals.dataChanged = false; // we need to redraw the whole chart on window resize (with a small delay).\n\n        _this4.update();\n      }, 150);\n    }\n  }], [{\n    key: \"initOnLoad\",\n    value: function initOnLoad() {\n      var els = document.querySelectorAll('[data-apexcharts]');\n\n      for (var i = 0; i < els.length; i++) {\n        var el = els[i];\n        var options$$1 = JSON.parse(els[i].getAttribute('data-options'));\n        var apexChart = new ApexCharts(el, options$$1);\n        apexChart.render();\n      }\n    }\n    /**\n     * This static method allows users to call chart methods without necessarily from the\n     * instance of the chart in case user has assigned chartID to the targetted chart.\n     * The chartID is used for mapping the instance stored in Apex._chartInstances global variable\n     *\n     * This is helpful in cases when you don't have reference of the chart instance\n     * easily and need to call the method from anywhere.\n     * For eg, in React/Vue applications when you have many parent/child components,\n     * and need easy reference to other charts for performing dynamic operations\n     *\n     * @param {string} chartID - The unique identifier which will be used to call methods\n     * on that chart instance\n     * @param {function} fn - The method name to call\n     * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(chartID, fn) {\n      var chart = this.getChartByID(chartID);\n      if (!chart) return;\n\n      for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        opts[_key - 2] = arguments[_key];\n      }\n\n      switch (fn) {\n        case 'updateOptions':\n          {\n            return chart.updateOptions.apply(chart, opts);\n          }\n\n        case 'updateSeries':\n          {\n            return chart.updateSeries.apply(chart, opts);\n          }\n\n        case 'appendData':\n          {\n            return chart.appendData.apply(chart, opts);\n          }\n\n        case 'appendSeries':\n          {\n            return chart.appendSeries.apply(chart, opts);\n          }\n\n        case 'toggleSeries':\n          {\n            return chart.toggleSeries.apply(chart, opts);\n          }\n\n        case 'dataURI':\n          {\n            return chart.dataURI.apply(chart, opts);\n          }\n\n        case 'addXaxisAnnotation':\n          {\n            return chart.addXaxisAnnotation.apply(chart, opts);\n          }\n\n        case 'addYaxisAnnotation':\n          {\n            return chart.addYaxisAnnotation.apply(chart, opts);\n          }\n\n        case 'addPointAnnotation':\n          {\n            return chart.addPointAnnotation.apply(chart, opts);\n          }\n\n        case 'addText':\n          {\n            return chart.addText.apply(chart, opts);\n          }\n\n        case 'clearAnnotations':\n          {\n            return chart.clearAnnotations.apply(chart, opts);\n          }\n\n        case 'paper':\n          {\n            return chart.paper.apply(chart, opts);\n          }\n\n        case 'destroy':\n          {\n            return chart.destroy();\n          }\n      }\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(target, source) {\n      return Utils.extend(target, source);\n    }\n  }, {\n    key: \"getChartByID\",\n    value: function getChartByID(chartID) {\n      var c = Apex._chartInstances.filter(function (ch) {\n        return ch.id === chartID;\n      })[0];\n\n      return c.chart;\n    }\n  }]);\n\n  return ApexCharts;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ApexCharts$1);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBleGNoYXJ0cy9kaXN0L2FwZXhjaGFydHMuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FwZXhjaGFydHMvZGlzdC9hcGV4Y2hhcnRzLmVzbS5qcz9lMTIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQXBleENoYXJ0cyB2My42LjhcbiAqIChjKSAyMDE4LTIwMTkgSnVuZWQgQ2hoaXBhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG4vKlxuICoqIEdlbmVyaWMgZnVuY3Rpb25zIHdoaWNoIGFyZSBub3QgZGVwZW5kZW50IG9uIEFwZXhDaGFydHNcbiAqL1xudmFyIFV0aWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVdGlscywgW3tcbiAgICBrZXk6IFwic2hhZGVSR0JDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZVJHQkNvbG9yKHBlcmNlbnQsIGNvbG9yKSB7XG4gICAgICB2YXIgZiA9IGNvbG9yLnNwbGl0KCcsJyksXG4gICAgICAgICAgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NSxcbiAgICAgICAgICBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50LFxuICAgICAgICAgIFIgPSBwYXJzZUludChmWzBdLnNsaWNlKDQpKSxcbiAgICAgICAgICBHID0gcGFyc2VJbnQoZlsxXSksXG4gICAgICAgICAgQiA9IHBhcnNlSW50KGZbMl0pO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIChNYXRoLnJvdW5kKCh0IC0gUikgKiBwKSArIFIpICsgJywnICsgKE1hdGgucm91bmQoKHQgLSBHKSAqIHApICsgRykgKyAnLCcgKyAoTWF0aC5yb3VuZCgodCAtIEIpICogcCkgKyBCKSArICcpJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hhZGVIZXhDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZUhleENvbG9yKHBlcmNlbnQsIGNvbG9yKSB7XG4gICAgICB2YXIgZiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNiksXG4gICAgICAgICAgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NSxcbiAgICAgICAgICBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50LFxuICAgICAgICAgIFIgPSBmID4+IDE2LFxuICAgICAgICAgIEcgPSBmID4+IDggJiAweDAwZmYsXG4gICAgICAgICAgQiA9IGYgJiAweDAwMDBmZjtcbiAgICAgIHJldHVybiAnIycgKyAoMHgxMDAwMDAwICsgKE1hdGgucm91bmQoKHQgLSBSKSAqIHApICsgUikgKiAweDEwMDAwICsgKE1hdGgucm91bmQoKHQgLSBHKSAqIHApICsgRykgKiAweDEwMCArIChNYXRoLnJvdW5kKCh0IC0gQikgKiBwKSArIEIpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfSAvLyBiZWF1dGlmdWwgY29sb3Igc2hhZGluZyBibGVuZGluZyBjb2RlXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3Itb3ItcmdiLWFuZC1ibGVuZC1jb2xvcnNcblxuICB9LCB7XG4gICAga2V5OiBcInNoYWRlQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hhZGVDb2xvcihwLCBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA+IDcpIHJldHVybiB0aGlzLnNoYWRlUkdCQ29sb3IocCwgY29sb3IpO2Vsc2UgcmV0dXJuIHRoaXMuc2hhZGVIZXhDb2xvcihwLCBjb2xvcik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiYmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKGZuLCBtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gJiYgX3R5cGVvZihpdGVtKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgaXRlbSAhPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXN0VG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0VG9BcnJheShsaXN0KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBhcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGxpc3RbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9IC8vIHRvIGV4dGVuZCBkZWZhdWx0cyB3aXRoIHVzZXIgb3B0aW9uc1xuICAgIC8vIGNyZWRpdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzkzNjc3Mi9kZWVwLW9iamVjdC1tZXJnaW5nLWluLWVzNi1lczcjYW5zd2VyLTM0NzQ5ODczXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9zb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChfc291cmNlICE9PSB1bmRlZmluZWQgJiYgX3NvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gX3NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9zb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gX3NvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKHRoaXMuaXNPYmplY3QodGFyZ2V0KSAmJiB0aGlzLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHNvdXJjZVtrZXldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IF90aGlzLmV4dGVuZCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHNvdXJjZVtrZXldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQXJyYXkoYXJyVG9FeHRlbmQsIHJlc3VsdEFycikge1xuICAgICAgdmFyIGV4dGVuZGVkQXJyID0gW107XG4gICAgICBhcnJUb0V4dGVuZC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgZXh0ZW5kZWRBcnIucHVzaChVdGlscy5leHRlbmQocmVzdWx0QXJyLCBpdGVtKSk7XG4gICAgICB9KTtcbiAgICAgIGFyclRvRXh0ZW5kID0gZXh0ZW5kZWRBcnI7XG4gICAgICByZXR1cm4gYXJyVG9FeHRlbmQ7XG4gICAgfSAvLyBJZiBtb250aCBjb3VudGVyIGV4Y2VlZHMgMTIsIGl0IHN0YXJ0cyBhZ2FpbiBmcm9tIDFcblxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoTW9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoTW9kKG1vbnRoKSB7XG4gICAgICByZXR1cm4gbW9udGggJSAxMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvcHMob2JqLCBhcnIsIHZhbCkge1xuICAgICAgaWYgKHR5cGVvZiBhcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFyciA9IGFyci5zcGxpdCgnLicpO1xuICAgICAgfVxuXG4gICAgICBvYmpbYXJyWzBdXSA9IG9ialthcnJbMF1dIHx8IHt9O1xuICAgICAgdmFyIHRtcE9iaiA9IG9ialthcnJbMF1dO1xuXG4gICAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYXJyLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcHModG1wT2JqLCBhcnIsIHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbYXJyWzBdXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNvdXJjZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgdmFyIGNsb25lUmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjbG9uZVJlc3VsdFtpXSA9IHRoaXMuY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZVJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihzb3VyY2UpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgX2Nsb25lUmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBfY2xvbmVSZXN1bHRbcHJvcF0gPSB0aGlzLmNsb25lKHNvdXJjZVtwcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jbG9uZVJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZzEwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRUb0Jhc2UxMFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZFRvQmFzZTEwKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZzEwKHgpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kVG9CYXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kVG9CYXNlKHgsIGJhc2UpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhiYXNlLCBNYXRoLmZsb29yKE1hdGgubG9nKHgpIC8gTWF0aC5sb2coYmFzZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VOdW1iZXIodmFsKSB7XG4gICAgICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gdmFsO1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsKSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdmFyIGVsZW1lbnRIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgZWxlbWVudFdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0IC09IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wKSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgIGVsZW1lbnRXaWR0aCAtPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICByZXQucHVzaChlbGVtZW50V2lkdGgpO1xuICAgICAgcmV0LnB1c2goZWxlbWVudEhlaWdodCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgICAgIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICB4OiByZWN0LngsXG4gICAgICAgIHk6IHJlY3QueVxuICAgICAgfTtcbiAgICB9IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiI2Fuc3dlci0xMjM0MjI3NVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGV4VG9SZ2JhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhleFRvUmdiYSgpIHtcbiAgICAgIHZhciBoZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcjOTk5OTk5JztcbiAgICAgIHZhciBvcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwLjY7XG5cbiAgICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDEpICE9PSAnIycpIHtcbiAgICAgICAgaGV4ID0gJyM5OTk5OTknO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IGhleC5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgaCA9IGgubWF0Y2gobmV3IFJlZ0V4cCgnKC57JyArIGgubGVuZ3RoIC8gMyArICd9KScsICdnJykpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaFtpXSA9IHBhcnNlSW50KGhbaV0ubGVuZ3RoID09PSAxID8gaFtpXSArIGhbaV0gOiBoW2ldLCAxNik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIGgucHVzaChvcGFjaXR5KTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgaC5qb2luKCcsJykgKyAnKSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wYWNpdHlGcm9tUkdCQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcGFjaXR5RnJvbVJHQkEocmdiYSkge1xuICAgICAgcmdiYSA9IHJnYmEubWF0Y2goL15yZ2JhP1tcXHMrXT9cXChbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPy9pKTtcbiAgICAgIHJldHVybiByZ2JhWzNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZ2IyaGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJnYjJoZXgocmdiKSB7XG4gICAgICByZ2IgPSByZ2IubWF0Y2goL15yZ2JhP1tcXHMrXT9cXChbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPyxbXFxzK10/KFxcZCspW1xccytdPy9pKTtcbiAgICAgIHJldHVybiByZ2IgJiYgcmdiLmxlbmd0aCA9PT0gNCA/ICcjJyArICgnMCcgKyBwYXJzZUludChyZ2JbMV0sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArICgnMCcgKyBwYXJzZUludChyZ2JbMl0sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArICgnMCcgKyBwYXJzZUludChyZ2JbM10sIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSA6ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0NvbG9ySGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ29sb3JIZXgoY29sb3IpIHtcbiAgICAgIHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChjb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvbGFyVG9DYXJ0ZXNpYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgICB2YXIgYW5nbGVJblJhZGlhbnMgPSAoYW5nbGVJbkRlZ3JlZXMgLSA5MCkgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpLFxuICAgICAgICB5OiBjZW50ZXJZICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlc2NhcGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgICAgdmFyIGVzY2FwZVdpdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd4JztcbiAgICAgIHZhciBuZXdTdHIgPSBzdHIudG9TdHJpbmcoKS5zbGljZSgpO1xuICAgICAgbmV3U3RyID0gbmV3U3RyLnJlcGxhY2UoL1tgIH4hQCMkJV4mKigpX3wrXFwtPT87OidcIiwuPD5cXHtcXH1cXFtcXF1cXFxcXFwvXS9naSwgZXNjYXBlV2l0aCk7XG4gICAgICByZXR1cm4gbmV3U3RyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWdUb1plcm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVnVG9aZXJvKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCA8IDAgPyAwIDogdmFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlSW5kZXhJbkFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVJbmRleEluQXJyYXkoYXJyLCBvbGRfaW5kZXgsIG5ld19pbmRleCkge1xuICAgICAgaWYgKG5ld19pbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrID0gbmV3X2luZGV4IC0gYXJyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgd2hpbGUgKGstLSkge1xuICAgICAgICAgIGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJyLnNwbGljZShuZXdfaW5kZXgsIDAsIGFyci5zcGxpY2Uob2xkX2luZGV4LCAxKVswXSk7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0TnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3ROdW1iZXIocykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocy5yZXBsYWNlKC9bXlxcZFxcLl0qL2csICcnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmRvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5kb21TdHJpbmcobGVuKSB7XG4gICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgdmFyIHBvc3NpYmxlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRleHQgKz0gcG9zc2libGUuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvc3NpYmxlLmxlbmd0aCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEFuY2VzdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBbmNlc3RvcihlbCwgY2xzKSB7XG4gICAgICB3aGlsZSAoKGVsID0gZWwucGFyZW50RWxlbWVudCkgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKSB7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RUxzdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RUxzdHlsZXMoZWwsIHN0eWxlcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBlbC5zdHlsZS5rZXkgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc051bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuICFpc05hTih2YWx1ZSkgJiYgcGFyc2VGbG9hdChOdW1iZXIodmFsdWUpKSA9PT0gdmFsdWUgJiYgIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Zsb2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmxvYXQobikge1xuICAgICAgcmV0dXJuIE51bWJlcihuKSA9PT0gbiAmJiBuICUgMSAhPT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTYWZhcmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXJlZm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSUUxMVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lFMTEoKSB7XG4gICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpICE9PSAtMSB8fCB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignVHJpZGVudC8nKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0lFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcblxuICAgICAgaWYgKG1zaWUgPiAwKSB7XG4gICAgICAgIC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKG1zaWUgKyA1LCB1YS5pbmRleE9mKCcuJywgbXNpZSkpLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmlkZW50ID0gdWEuaW5kZXhPZignVHJpZGVudC8nKTtcblxuICAgICAgaWYgKHRyaWRlbnQgPiAwKSB7XG4gICAgICAgIC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICB2YXIgcnYgPSB1YS5pbmRleE9mKCdydjonKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhydiArIDMsIHVhLmluZGV4T2YoJy4nLCBydikpLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlID0gdWEuaW5kZXhPZignRWRnZS8nKTtcblxuICAgICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcbiAgICAgIH0gLy8gb3RoZXIgYnJvd3NlclxuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXRpbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBGaWx0ZXJzIENsYXNzIGZvciBzZXR0aW5nIGhvdmVyL2FjdGl2ZSBzdGF0ZXMgb24gdGhlIHBhdGhzLlxuICpcbiAqIEBtb2R1bGUgRm9ybWF0dGVyc1xuICoqL1xuXG52YXIgRmlsdGVycyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbHRlcnMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlcnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH0gLy8gY3JlYXRlIGEgcmUtdXNhYmxlIGZpbHRlciB3aGljaCBjYW4gYmUgYXBwZW5kZWQgb3RoZXIgZmlsdGVyIGVmZmVjdHMgYW5kIGFwcGxpZWQgdG8gbXVsdGlwbGUgZWxlbWVudHNcblxuXG4gIF9jcmVhdGVDbGFzcyhGaWx0ZXJzLCBbe1xuICAgIGtleTogXCJnZXREZWZhdWx0RmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRGaWx0ZXIoZWwpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICBmaWx0ZXIuc2l6ZSgnMTIwJScsICcxODAlJywgJy01JScsICctNDAlJyk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoZWwsIHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnR5cGUsIHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmRyb3BTaGFkb3coZWwsIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE5vcm1hbEZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb3JtYWxGaWx0ZXIoZWwpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZHJvcFNoYWRvdyhlbCwgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERlc2F0dXJhdGVGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGVzYXR1cmF0ZUZpbHRlcihlbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBlbC51bmZpbHRlcih0cnVlKTtcbiAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgIGZpbHRlci5zaXplKCcxMjAlJywgJzE4MCUnLCAnLTUlJywgJy00MCUnKTtcbiAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIHZhciBzaGFkb3dBdHRyID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcblxuICAgICAgICBpZiAoc2hhZG93QXR0ci5lbmFibGVkKSB7XG4gICAgICAgICAgZmlsdGVyID0gX3RoaXMuYWRkU2hhZG93KGFkZCwgc2hhZG93QXR0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gYWRkO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyLmNvbG9yTWF0cml4KCdtYXRyaXgnLCBbMCwgMCwgMCwgMCwgMC41LCAwLCAwLCAwLCAwLCAwLjUsIDAsIDAsIDAsIDAsIDAuNSwgMCwgMCwgMCwgMS4wLCAwXSkuY29sb3JNYXRyaXgoJ3NhdHVyYXRlJywgMCk7XG4gICAgICB9KTtcbiAgICAgIGVsLmZpbHRlcmVyLm5vZGUuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xuICAgIH0gLy8gYXBwZW5kcyBkcm9wU2hhZG93IHRvIHRoZSBmaWx0ZXIgb2JqZWN0IHdoaWNoIGNhbiBiZSBjaGFpbmVkIHdpdGggb3RoZXIgZmlsdGVyIGVmZmVjdHNcblxuICB9LCB7XG4gICAga2V5OiBcImFkZExpZ2h0ZW5GaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTGlnaHRlbkZpbHRlcihlbCwgYXR0cnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBpbnRlbnNpdHkgPSBhdHRycy5pbnRlbnNpdHk7XG5cbiAgICAgIGlmIChVdGlscy5pc0ZpcmVmb3goKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyB3aW5kb3cuU1ZHLkZpbHRlcigpO1xuICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuICAgICAgZWwuZmlsdGVyKGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgdmFyIHNoYWRvd0F0dHIgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuXG4gICAgICAgIGlmIChzaGFkb3dBdHRyLmVuYWJsZWQpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBfdGhpczIuYWRkU2hhZG93KGFkZCwgc2hhZG93QXR0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gYWRkO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyLmNvbXBvbmVudFRyYW5zZmVyKHtcbiAgICAgICAgICByZ2I6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgc2xvcGU6IDEuNSxcbiAgICAgICAgICAgIGludGVyY2VwdDogaW50ZW5zaXR5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgfSAvLyBhcHBlbmRzIGRyb3BTaGFkb3cgdG8gdGhlIGZpbHRlciBvYmplY3Qgd2hpY2ggY2FuIGJlIGNoYWluZWQgd2l0aCBvdGhlciBmaWx0ZXIgZWZmZWN0c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRGFya2VuRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERhcmtlbkZpbHRlcihlbCwgYXR0cnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBpbnRlbnNpdHkgPSBhdHRycy5pbnRlbnNpdHk7XG5cbiAgICAgIGlmIChVdGlscy5pc0ZpcmVmb3goKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyB3aW5kb3cuU1ZHLkZpbHRlcigpO1xuICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuICAgICAgZWwuZmlsdGVyKGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgdmFyIHNoYWRvd0F0dHIgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuXG4gICAgICAgIGlmIChzaGFkb3dBdHRyLmVuYWJsZWQpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBfdGhpczMuYWRkU2hhZG93KGFkZCwgc2hhZG93QXR0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gYWRkO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyLmNvbXBvbmVudFRyYW5zZmVyKHtcbiAgICAgICAgICByZ2I6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgc2xvcGU6IGludGVuc2l0eVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGVsLmZpbHRlcmVyLm5vZGUuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUZpbHRlcihlbCwgZmlsdGVyKSB7XG4gICAgICB2YXIgaW50ZW5zaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwLjU7XG5cbiAgICAgIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTm9ybWFsRmlsdGVyKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZExpZ2h0ZW5GaWx0ZXIoZWwsIHtcbiAgICAgICAgICAgICAgaW50ZW5zaXR5OiBpbnRlbnNpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Rhcmtlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGREYXJrZW5GaWx0ZXIoZWwsIHtcbiAgICAgICAgICAgICAgaW50ZW5zaXR5OiBpbnRlbnNpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Rlc2F0dXJhdGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVzYXR1cmF0ZUZpbHRlcihlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBhcHBlbmRzIGRyb3BTaGFkb3cgdG8gdGhlIGZpbHRlciBvYmplY3Qgd2hpY2ggY2FuIGJlIGNoYWluZWQgd2l0aCBvdGhlciBmaWx0ZXIgZWZmZWN0c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNoYWRvdyhhZGQsIGF0dHJzKSB7XG4gICAgICB2YXIgYmx1ciA9IGF0dHJzLmJsdXIsXG4gICAgICAgICAgdG9wID0gYXR0cnMudG9wLFxuICAgICAgICAgIGxlZnQgPSBhdHRycy5sZWZ0LFxuICAgICAgICAgIGNvbG9yID0gYXR0cnMuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSA9IGF0dHJzLm9wYWNpdHk7XG4gICAgICB2YXIgc2hhZG93Qmx1ciA9IGFkZC5mbG9vZChjb2xvciwgb3BhY2l0eSkuY29tcG9zaXRlKGFkZC5zb3VyY2VBbHBoYSwgJ2luJykub2Zmc2V0KGxlZnQsIHRvcCkuZ2F1c3NpYW5CbHVyKGJsdXIpLm1lcmdlKGFkZC5zb3VyY2UpO1xuICAgICAgcmV0dXJuIGFkZC5ibGVuZChhZGQuc291cmNlLCBzaGFkb3dCbHVyKTtcbiAgICB9IC8vIGRpcmVjdGx5IGFkZHMgZHJvcFNoYWRvdyB0byB0aGUgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgc2FtZSBlbGVtZW50LlxuICAgIC8vIHRoZSBvbmx5IHdheSBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWRkU2hhZG93KCkgZnVuY3Rpb24gaXMgdGhhdCBhZGRTaGFkb3cgaXMgY2hhaW5hYmxlIHRvIG90aGVyIGZpbHRlcnMsIHdoaWxlIHRoaXMgZnVuY3Rpb24gZGlzY2FyZHMgYWxsIGZpbHRlcnMgYW5kIGFkZCBkcm9wU2hhZG93XG5cbiAgfSwge1xuICAgIGtleTogXCJkcm9wU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3BTaGFkb3coZWwsIGF0dHJzKSB7XG4gICAgICB2YXIgdG9wID0gYXR0cnMudG9wLFxuICAgICAgICAgIGxlZnQgPSBhdHRycy5sZWZ0LFxuICAgICAgICAgIGJsdXIgPSBhdHRycy5ibHVyLFxuICAgICAgICAgIGNvbG9yID0gYXR0cnMuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSA9IGF0dHJzLm9wYWNpdHksXG4gICAgICAgICAgbm9Vc2VyU3BhY2VPblVzZSA9IGF0dHJzLm5vVXNlclNwYWNlT25Vc2U7XG4gICAgICBlbC51bmZpbHRlcih0cnVlKTtcbiAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgIGZpbHRlci5zaXplKCcxMjAlJywgJzE4MCUnLCAnLTUlJywgJy00MCUnKTtcbiAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIHZhciBzaGFkb3dCbHVyID0gbnVsbDtcblxuICAgICAgICBpZiAoVXRpbHMuaXNTYWZhcmkoKSB8fCBVdGlscy5pc0ZpcmVmb3goKSB8fCBVdGlscy5pc0lFKCkpIHtcbiAgICAgICAgICAvLyBzYWZhcmkvZmlyZWZveCBoYXMgc29tZSBhbHRlcm5hdGl2ZSB3YXkgdG8gdXNlIHRoaXMgZmlsdGVyXG4gICAgICAgICAgc2hhZG93Qmx1ciA9IGFkZC5mbG9vZChjb2xvciwgb3BhY2l0eSkuY29tcG9zaXRlKGFkZC5zb3VyY2VBbHBoYSwgJ2luJykub2Zmc2V0KGxlZnQsIHRvcCkuZ2F1c3NpYW5CbHVyKGJsdXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYWRvd0JsdXIgPSBhZGQuZmxvb2QoY29sb3IsIG9wYWNpdHkpLmNvbXBvc2l0ZShhZGQuc291cmNlQWxwaGEsICdpbicpLm9mZnNldChsZWZ0LCB0b3ApLmdhdXNzaWFuQmx1cihibHVyKS5tZXJnZShhZGQuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZC5ibGVuZChhZGQuc291cmNlLCBzaGFkb3dCbHVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW5vVXNlclNwYWNlT25Vc2UpIHtcbiAgICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbkZpbHRlcihlbCwgcmVhbEluZGV4LCBkYXRhUG9pbnRJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tyZWFsSW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tyZWFsSW5kZXhdLmluZGV4T2YoZGF0YVBvaW50SW5kZXgpID4gLTEpIHtcbiAgICAgICAgICBlbC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgYWN0aXZlRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXI7XG5cbiAgICAgICAgICBpZiAoYWN0aXZlRmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoZWwsIGFjdGl2ZUZpbHRlci50eXBlLCBhY3RpdmVGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWx0ZXJzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQW5pbWF0aW9uIENsYXNzLlxuICpcbiAqIEBtb2R1bGUgQW5pbWF0aW9uc1xuICoqL1xuXG52YXIgQW5pbWF0aW9ucyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbnMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdGlvbnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5zZXRFYXNpbmdGdW5jdGlvbnMoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbmltYXRpb25zLCBbe1xuICAgIGtleTogXCJzZXRFYXNpbmdGdW5jdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RWFzaW5nRnVuY3Rpb25zKCkge1xuICAgICAgdmFyIGVhc2luZztcbiAgICAgIHZhciB1c2VyRGVmaW5lZEVhc2luZyA9IHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lYXNpbmc7XG5cbiAgICAgIHN3aXRjaCAodXNlckRlZmluZWRFYXNpbmcpIHtcbiAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZWFzZWluJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSAnPCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZWFzZW91dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gJz4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Vhc2Vpbm91dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gJzw+JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzd2luZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gZnVuY3Rpb24gZWFzaW5nKHBvcykge1xuICAgICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICAgIHJldHVybiAocG9zIC09IDEpICogcG9zICogKChzICsgMSkgKiBwb3MgKyBzKSArIDE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYm91bmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSBmdW5jdGlvbiBlYXNpbmcocG9zKSB7XG4gICAgICAgICAgICAgIGlmIChwb3MgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBwb3MgKiBwb3M7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKHBvcyAtPSAxLjUgLyAyLjc1KSAqIHBvcyArIDAuNzU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMi41IC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAocG9zIC09IDIuMjUgLyAyLjc1KSAqIHBvcyArIDAuOTM3NTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKHBvcyAtPSAyLjYyNSAvIDIuNzUpICogcG9zICsgMC45ODQzNzU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlbGFzdGljJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSBmdW5jdGlvbiBlYXNpbmcocG9zKSB7XG4gICAgICAgICAgICAgIGlmIChwb3MgPT09ICEhcG9zKSByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogcG9zKSAqIE1hdGguc2luKChwb3MgLSAwLjA3NSkgKiAoMiAqIE1hdGguUEkpIC8gMC4zKSArIDE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSAnPD4nO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53Lmdsb2JhbHMuZWFzaW5nID0gZWFzaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlTGluZShlbCwgZnJvbSwgdG8sIHNwZWVkKSB7XG4gICAgICBlbC5hdHRyKGZyb20pLmFuaW1hdGUoc3BlZWQpLmF0dHIodG8pO1xuICAgIH1cbiAgICAvKlxuICAgICAqKiBBbmltYXRlIHJhZGl1cyBvZiBhIGNpcmNsZSBlbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlQ2lyY2xlUmFkaXVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVDaXJjbGVSYWRpdXMoZWwsIGZyb20sIHRvLCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICBpZiAoIWZyb20pIGZyb20gPSAwO1xuICAgICAgZWwuYXR0cih7XG4gICAgICAgIHI6IGZyb21cbiAgICAgIH0pLmFuaW1hdGUoc3BlZWQsIGVhc2luZykuYXR0cih7XG4gICAgICAgIHI6IHRvXG4gICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiogQW5pbWF0ZSByYWRpdXMgYW5kIHBvc2l0aW9uIG9mIGEgY2lyY2xlIGVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUNpcmNsZShlbCwgZnJvbSwgdG8sIHNwZWVkLCBlYXNpbmcpIHtcbiAgICAgIGVsLmF0dHIoe1xuICAgICAgICByOiBmcm9tLnIsXG4gICAgICAgIGN4OiBmcm9tLmN4LFxuICAgICAgICBjeTogZnJvbS5jeVxuICAgICAgfSkuYW5pbWF0ZShzcGVlZCwgZWFzaW5nKS5hdHRyKHtcbiAgICAgICAgcjogdG8ucixcbiAgICAgICAgY3g6IHRvLmN4LFxuICAgICAgICBjeTogdG8uY3lcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqKiBBbmltYXRlIHJlY3QgcHJvcGVydGllc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVJlY3QoZWwsIGZyb20sIHRvLCBzcGVlZCwgZm4pIHtcbiAgICAgIGVsLmF0dHIoZnJvbSkuYW5pbWF0ZShzcGVlZCkuYXR0cih0bykuYWZ0ZXJBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVQYXRoc0dyYWR1YWxseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlUGF0aHNHcmFkdWFsbHkocGFyYW1zKSB7XG4gICAgICB2YXIgZWwgPSBwYXJhbXMuZWwsXG4gICAgICAgICAgaiA9IHBhcmFtcy5qLFxuICAgICAgICAgIHBhdGhGcm9tID0gcGFyYW1zLnBhdGhGcm9tLFxuICAgICAgICAgIHBhdGhUbyA9IHBhcmFtcy5wYXRoVG8sXG4gICAgICAgICAgc3BlZWQgPSBwYXJhbXMuc3BlZWQsXG4gICAgICAgICAgZGVsYXkgPSBwYXJhbXMuZGVsYXksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBwYXJhbXMuc3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZGVsYXlGYWN0b3IgPSAwO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5hbmltYXRlR3JhZHVhbGx5LmVuYWJsZWQpIHtcbiAgICAgICAgZGVsYXlGYWN0b3IgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZGVsYXk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCAmJiB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgZGVsYXlGYWN0b3IgPSAwO1xuICAgICAgfVxuXG4gICAgICBtZS5tb3JwaFNWRyhlbCwgaiwgcGF0aEZyb20sIHBhdGhUbywgc3BlZWQsIHN0cm9rZVdpZHRoLCBkZWxheSAqIGRlbGF5RmFjdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd0RlbGF5ZWRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93RGVsYXllZEVsZW1lbnRzKCkge1xuICAgICAgdGhpcy53Lmdsb2JhbHMuZGVsYXllZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGVsZSA9IGQuZWw7XG4gICAgICAgIGVsZS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gU1ZHLmpzIGFuaW1hdGlvbiBmb3IgbW9ycGhpbmcgb25lIHBhdGggdG8gYW5vdGhlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9ycGhTVkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9ycGhTVkcoZWwsIGosIHBhdGhGcm9tLCBwYXRoVG8sIHNwZWVkLCBzdHJva2VXaWR0aCwgZGVsYXkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoIXBhdGhGcm9tKSB7XG4gICAgICAgIHBhdGhGcm9tID0gZWwuYXR0cigncGF0aEZyb20nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXRoVG8pIHtcbiAgICAgICAgcGF0aFRvID0gZWwuYXR0cigncGF0aFRvJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0aEZyb20gfHwgcGF0aEZyb20uaW5kZXhPZigndW5kZWZpbmVkJykgPiAtMSB8fCBwYXRoRnJvbS5pbmRleE9mKCdOYU4nKSA+IC0xKSB7XG4gICAgICAgIHBhdGhGcm9tID0gXCJNIDAgXCIuY29uY2F0KHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgc3BlZWQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aFRvLmluZGV4T2YoJ3VuZGVmaW5lZCcpID4gLTEgfHwgcGF0aFRvLmluZGV4T2YoJ05hTicpID4gLTEpIHtcbiAgICAgICAgcGF0aFRvID0gXCJNIDAgXCIuY29uY2F0KHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgc3BlZWQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5zaG91bGRBbmltYXRlKSB7XG4gICAgICAgIHNwZWVkID0gMTtcbiAgICAgIH1cblxuICAgICAgZWwucGxvdChwYXRoRnJvbSkuYW5pbWF0ZSgxLCB3Lmdsb2JhbHMuZWFzaW5nLCBkZWxheSkucGxvdChwYXRoRnJvbSkuYW5pbWF0ZShzcGVlZCwgdy5nbG9iYWxzLmVhc2luZywgZGVsYXkpLnBsb3QocGF0aFRvKS5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBvcmlnaW5hbCBtb3VudCBmdW5jdGlvbiBjYW4gcmV0dXJuIHRydWUgbm93IGFzIGFuaW1hdGlvbiBmaW5pc2hlZCBoZXJlXG4gICAgICAgIGlmIChVdGlscy5pc051bWJlcihqKSkge1xuICAgICAgICAgIGlmIChqID09PSB3Lmdsb2JhbHMuc2VyaWVzW3cuZ2xvYmFscy5tYXhWYWxzSW5BcnJheUluZGV4XS5sZW5ndGggLSAyICYmIHcuZ2xvYmFscy5zaG91bGRBbmltYXRlKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5hbmltYXRpb25FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5hbmltYXRpb25FbmQoX3RoaXMuY3R4LCB3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zaG93RGVsYXllZEVsZW1lbnRzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5pbWF0aW9ucztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEdyYXBoaWNzIENsYXNzIGZvciBhbGwgZHJhd2luZyBvcGVyYXRpb25zLlxuICpcbiAqIEBtb2R1bGUgR3JhcGhpY3NcbiAqKi9cblxudmFyIEdyYXBoaWNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhcGhpY3MoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyYXBoaWNzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdyYXBoaWNzLCBbe1xuICAgIGtleTogXCJkcmF3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgdmFyIGxpbmVDb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJyNhOGE4YTgnO1xuICAgICAgdmFyIGRhc2hBcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxpbmUgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmxpbmUoKS5hdHRyKHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICBzdHJva2U6IGxpbmVDb2xvcixcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBkYXNoQXJyYXksXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1JlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1JlY3QoKSB7XG4gICAgICB2YXIgeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgeDIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgeTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICAgICAgdmFyIGNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAnI2ZlZmVmZSc7XG4gICAgICB2YXIgb3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogMTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogbnVsbDtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogbnVsbDtcbiAgICAgIHZhciBzdHJva2VEYXNoQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IDA7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWN0ID0gdy5nbG9iYWxzLmRvbS5QYXBlci5yZWN0KCk7XG4gICAgICByZWN0LmF0dHIoe1xuICAgICAgICB4OiB4MSxcbiAgICAgICAgeTogeTEsXG4gICAgICAgIHdpZHRoOiB4MiA+IDAgPyB4MiA6IDAsXG4gICAgICAgIGhlaWdodDogeTIgPiAwID8geTIgOiAwLFxuICAgICAgICByeDogcmFkaXVzLFxuICAgICAgICByeTogcmFkaXVzLFxuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoICE9PSBudWxsID8gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yICE9PSBudWxsID8gc3Ryb2tlQ29sb3IgOiAnbm9uZScsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogc3Ryb2tlRGFzaEFycmF5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UG9seWdvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9seWdvbihwb2x5Z29uU3RyaW5nKSB7XG4gICAgICB2YXIgc3Ryb2tlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnI2UxZTFlMSc7XG4gICAgICB2YXIgZmlsbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ25vbmUnO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcG9seWdvbiA9IHcuZ2xvYmFscy5kb20uUGFwZXIucG9seWdvbihwb2x5Z29uU3RyaW5nKS5hdHRyKHtcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NpcmNsZShyYWRpdXMpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmNpcmNsZShyYWRpdXMgKiAyKTtcblxuICAgICAgaWYgKGF0dHJzICE9PSBudWxsKSB7XG4gICAgICAgIGMuYXR0cihhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0aChfcmVmKSB7XG4gICAgICB2YXIgX3JlZiRkID0gX3JlZi5kLFxuICAgICAgICAgIGQgPSBfcmVmJGQgPT09IHZvaWQgMCA/ICcnIDogX3JlZiRkLFxuICAgICAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHZvaWQgMCA/ICcjYThhOGE4JyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgICAgICBfcmVmJGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgICAgICBmaWxsT3BhY2l0eSA9IF9yZWYkZmlsbE9wYWNpdHkgPT09IHZvaWQgMCA/IDEgOiBfcmVmJGZpbGxPcGFjaXR5LFxuICAgICAgICAgIF9yZWYkc3Ryb2tlT3BhY2l0eSA9IF9yZWYuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICBzdHJva2VPcGFjaXR5ID0gX3JlZiRzdHJva2VPcGFjaXR5ID09PSB2b2lkIDAgPyAxIDogX3JlZiRzdHJva2VPcGFjaXR5LFxuICAgICAgICAgIGNsYXNzZXMgPSBfcmVmLmNsYXNzZXMsXG4gICAgICAgICAgX3JlZiRzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgICAgIHN0cm9rZUxpbmVjYXAgPSBfcmVmJHN0cm9rZUxpbmVjYXAgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgX3JlZiRzdHJva2VEYXNoQXJyYXkgPSBfcmVmLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSBfcmVmJHN0cm9rZURhc2hBcnJheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmIChzdHJva2VMaW5lY2FwID09PSBudWxsKSB7XG4gICAgICAgIHN0cm9rZUxpbmVjYXAgPSB3LmNvbmZpZy5zdHJva2UubGluZUNhcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGQuaW5kZXhPZigndW5kZWZpbmVkJykgPiAtMSB8fCBkLmluZGV4T2YoJ05hTicpID4gLTEpIHtcbiAgICAgICAgZCA9IFwiTSAwIFwiLmNvbmNhdCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwID0gdy5nbG9iYWxzLmRvbS5QYXBlci5wYXRoKGQpLmF0dHIoe1xuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBzdHJva2VPcGFjaXR5LFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiBzdHJva2VMaW5lY2FwLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGgsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICBjbGFzczogY2xhc3Nlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXAoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnID0gdy5nbG9iYWxzLmRvbS5QYXBlci5ncm91cCgpO1xuXG4gICAgICBpZiAoYXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgZy5hdHRyKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICB2YXIgbW92ZSA9IFsnTScsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBtb3ZlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmUoeCwgeSkge1xuICAgICAgdmFyIGhPUnYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgbGluZSA9IG51bGw7XG5cbiAgICAgIGlmIChoT1J2ID09PSBudWxsKSB7XG4gICAgICAgIGxpbmUgPSBbJ0wnLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2UgaWYgKGhPUnYgPT09ICdIJykge1xuICAgICAgICBsaW5lID0gWydIJywgeF0uam9pbignICcpO1xuICAgICAgfSBlbHNlIGlmIChoT1J2ID09PSAnVicpIHtcbiAgICAgICAgbGluZSA9IFsnVicsIHldLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICB2YXIgY3VydmUgPSBbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0uam9pbignICcpO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFkcmF0aWNDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFkcmF0aWNDdXJ2ZSh4MSwgeTEsIHgsIHkpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IFsnUScsIHgxLCB5MSwgeCwgeV0uam9pbignICcpO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJjKHJ4LCByeSwgYXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgICAgdmFyIHJlbGF0aXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBmYWxzZTtcbiAgICAgIHZhciBjb29yZCA9ICdBJztcbiAgICAgIGlmIChyZWxhdGl2ZSkgY29vcmQgPSAnYSc7XG4gICAgICB2YXIgYXJjID0gW2Nvb3JkLCByeCwgcnksIGF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBHcmFwaGljc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fVxuICAgICAqICBpID0gc2VyaWVzJ3MgaW5kZXhcbiAgICAgKiAgcmVhbEluZGV4ID0gcmVhbEluZGV4IGlzIHNlcmllcydzIGFjdHVhbCBpbmRleCB3aGVuIGl0IHdhcyBkcmF3biB0aW1lLiBBZnRlciBzZXZlcmFsIHJlZHJhd3MsIHRoZSBpdGVyYXRpbmcgXCJpXCIgbWF5IGNoYW5nZSBpbiBsb29wcywgYnV0IHJlYWxJbmRleCBkb2Vzbid0XG4gICAgICogIHBhdGhGcm9tID0gZXhpc3RpbmcgcGF0aEZyb20gdG8gYW5pbWF0ZVRvXG4gICAgICogIHBhdGhUbyA9IG5ldyBQYXRoIHRvIHdoaWNoIGQgYXR0ciB3aWxsIGJlIGFuaW1hdGVkIGZyb20gcGF0aEZyb20gdG8gcGF0aFRvXG4gICAgICogIHN0cm9rZSA9IGxpbmUgQ29sb3JcbiAgICAgKiAgc3Ryb2tlV2lkdGggPSB3aWR0aCBvZiBwYXRoIExpbmVcbiAgICAgKiAgZmlsbCA9IGl0IGNhbiBiZSBncmFkaWVudCwgc2luZ2xlIGNvbG9yLCBwYXR0ZXJuIG9yIGltYWdlXG4gICAgICogIGFuaW1hdGlvbkRlbGF5ID0gaG93IG11Y2ggdG8gZGVsYXkgd2hlbiBzdGFydGluZyBhbmltYXRpb24gKGluIG1pbGxpc2Vjb25kcylcbiAgICAgKiAgZGF0YUNoYW5nZVNwZWVkID0gZm9yIGR5bmFtaWMgYW5pbWF0aW9ucywgd2hlbiBkYXRhIGNoYW5nZXNcbiAgICAgKiAgY2xhc3NOYW1lID0gY2xhc3MgYXR0cmlidXRlIHRvIGFkZFxuICAgICAqIEByZXR1cm4ge29iamVjdH0gc3ZnLmpzIHBhdGggb2JqZWN0XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUGF0aHMoX3JlZjIpIHtcbiAgICAgIHZhciBpID0gX3JlZjIuaSxcbiAgICAgICAgICBqID0gX3JlZjIuaixcbiAgICAgICAgICByZWFsSW5kZXggPSBfcmVmMi5yZWFsSW5kZXgsXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmMi5wYXRoRnJvbSxcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgc3Ryb2tlID0gX3JlZjIuc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlTGluZWNhcCA9IF9yZWYyLnN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgZmlsbCA9IF9yZWYyLmZpbGwsXG4gICAgICAgICAgYW5pbWF0aW9uRGVsYXkgPSBfcmVmMi5hbmltYXRpb25EZWxheSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQgPSBfcmVmMi5pbml0aWFsU3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkID0gX3JlZjIuZGF0YUNoYW5nZVNwZWVkLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgICAgICBpZCA9IF9yZWYyLmlkLFxuICAgICAgICAgIF9yZWYyJHNob3VsZENsaXBUb0dyaSA9IF9yZWYyLnNob3VsZENsaXBUb0dyaWQsXG4gICAgICAgICAgc2hvdWxkQ2xpcFRvR3JpZCA9IF9yZWYyJHNob3VsZENsaXBUb0dyaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJHNob3VsZENsaXBUb0dyaSxcbiAgICAgICAgICBfcmVmMiRiaW5kRXZlbnRzT25QYXQgPSBfcmVmMi5iaW5kRXZlbnRzT25QYXRocyxcbiAgICAgICAgICBiaW5kRXZlbnRzT25QYXRocyA9IF9yZWYyJGJpbmRFdmVudHNPblBhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJGJpbmRFdmVudHNPblBhdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpbml0aWFsQW5pbSA9IHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgICAgdmFyIGR5bmFtaWNBbmltID0gaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDtcbiAgICAgIHZhciBkO1xuICAgICAgdmFyIHNob3VsZEFuaW1hdGUgPSAhIShpbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgfHwgZHluYW1pY0FuaW0gJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkICYmIHcuZ2xvYmFscy5zaG91bGRBbmltYXRlKTtcblxuICAgICAgaWYgKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgZCA9IHBhdGhGcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IHBhdGhUbztcbiAgICAgICAgdGhpcy53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5T3B0ID0gdy5jb25maWcuc3Ryb2tlLmRhc2hBcnJheTtcbiAgICAgIHZhciBzdHJva2VEYXNoQXJyYXkgPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJva2VEYXNoQXJyYXlPcHQpKSB7XG4gICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHN0cm9rZURhc2hBcnJheU9wdFtyZWFsSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gdy5jb25maWcuc3Ryb2tlLmRhc2hBcnJheTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsID0gdGhpcy5kcmF3UGF0aCh7XG4gICAgICAgIGQ6IGQsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICBjbGFzc2VzOiBjbGFzc05hbWUsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgICAgIHN0cm9rZURhc2hBcnJheTogc3Ryb2tlRGFzaEFycmF5XG4gICAgICB9KTtcbiAgICAgIGVsLmF0dHIoJ2lkJywgXCJcIi5jb25jYXQoaWQsIFwiLVwiKS5jb25jYXQoaSkpO1xuICAgICAgZWwuYXR0cignaW5kZXgnLCByZWFsSW5kZXgpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2xpcFRvR3JpZCkge1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAnY2xpcC1wYXRoJzogXCJ1cmwoI2dyaWRSZWN0TWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBjb25zdCBkZWZhdWx0RmlsdGVyID0gZWwuZmlsdGVyZXJcblxuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihlbCwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudHlwZSwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkU2VyaWVzIHx8IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZFNlcmllcyAmJiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWRTZXJpZXMuaW5kZXhPZihyZWFsSW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG4gICAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWwsIHNoYWRvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiaW5kRXZlbnRzT25QYXRocykge1xuICAgICAgICBlbC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgZWwpKTtcbiAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5wYXRoTW91c2VMZWF2ZS5iaW5kKHRoaXMsIGVsKSk7XG4gICAgICAgIGVsLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcywgZWwpKTtcbiAgICAgIH1cblxuICAgICAgZWwuYXR0cih7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21cbiAgICAgIH0pO1xuICAgICAgdmFyIGRlZmF1bHRBbmltYXRlT3B0cyA9IHtcbiAgICAgICAgZWw6IGVsLFxuICAgICAgICBqOiBqLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICBhbmltLmFuaW1hdGVQYXRoc0dyYWR1YWxseShfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5pbWF0ZU9wdHMsIHtcbiAgICAgICAgICBzcGVlZDogaW5pdGlhbFNwZWVkLFxuICAgICAgICAgIGRlbGF5OiBhbmltYXRpb25EZWxheVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5nbG9iYWxzLnJlc2l6ZWQgfHwgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIGFuaW0uc2hvd0RlbGF5ZWRFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgZHluYW1pY0FuaW0gJiYgc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICBhbmltLmFuaW1hdGVQYXRoc0dyYWR1YWxseShfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5pbWF0ZU9wdHMsIHtcbiAgICAgICAgICBzcGVlZDogZGF0YUNoYW5nZVNwZWVkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0dGVybihzdHlsZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIHN0cm9rZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyNhOGE4YTgnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucGF0dGVybih3aWR0aCwgaGVpZ2h0LCBmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIGlmIChzdHlsZSA9PT0gJ2hvcml6b250YWxMaW5lcycpIHtcbiAgICAgICAgICBhZGQubGluZSgwLCAwLCBoZWlnaHQsIDApLnN0cm9rZSh7XG4gICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAndmVydGljYWxMaW5lcycpIHtcbiAgICAgICAgICBhZGQubGluZSgwLCAwLCAwLCB3aWR0aCkuc3Ryb2tlKHtcbiAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGggKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdzbGFudGVkTGluZXMnKSB7XG4gICAgICAgICAgYWRkLmxpbmUoMCwgMCwgd2lkdGgsIGhlaWdodCkuc3Ryb2tlKHtcbiAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ3NxdWFyZXMnKSB7XG4gICAgICAgICAgYWRkLnJlY3Qod2lkdGgsIGhlaWdodCkuZmlsbCgnbm9uZScpLnN0cm9rZSh7XG4gICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdjaXJjbGVzJykge1xuICAgICAgICAgIGFkZC5jaXJjbGUod2lkdGgpLmZpbGwoJ25vbmUnKS5zdHJva2Uoe1xuICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3R3JhZGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0dyYWRpZW50KHN0eWxlLCBnZnJvbSwgZ3RvLCBvcGFjaXR5RnJvbSwgb3BhY2l0eVRvKSB7XG4gICAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAgIHZhciBzdG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogbnVsbDtcbiAgICAgIHZhciBjb2xvclN0b3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBudWxsO1xuICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gOCAmJiBhcmd1bWVudHNbOF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s4XSA6IDA7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnO1xuICAgICAgZ2Zyb20gPSBVdGlscy5oZXhUb1JnYmEoZ2Zyb20sIG9wYWNpdHlGcm9tKTtcbiAgICAgIGd0byA9IFV0aWxzLmhleFRvUmdiYShndG8sIG9wYWNpdHlUbyk7XG4gICAgICB2YXIgc3RvcDEgPSAwO1xuICAgICAgdmFyIHN0b3AyID0gMTtcbiAgICAgIHZhciBzdG9wMyA9IDE7XG4gICAgICB2YXIgc3RvcDQgPSBudWxsO1xuXG4gICAgICBpZiAoc3RvcHMgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcDEgPSB0eXBlb2Ygc3RvcHNbMF0gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbMF0gLyAxMDAgOiAwO1xuICAgICAgICBzdG9wMiA9IHR5cGVvZiBzdG9wc1sxXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdG9wc1sxXSAvIDEwMCA6IDE7XG4gICAgICAgIHN0b3AzID0gdHlwZW9mIHN0b3BzWzJdICE9PSAndW5kZWZpbmVkJyA/IHN0b3BzWzJdIC8gMTAwIDogMTtcbiAgICAgICAgc3RvcDQgPSB0eXBlb2Ygc3RvcHNbM10gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbM10gLyAxMDAgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFkaWFsID0gISEody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2RvbnV0JyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncGllJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJyk7XG5cbiAgICAgIGlmIChjb2xvclN0b3BzID09PSBudWxsIHx8IGNvbG9yU3RvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGcgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmdyYWRpZW50KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgc3RvcC5hdChzdG9wMSwgZ2Zyb20sIG9wYWNpdHlGcm9tKTtcbiAgICAgICAgICBzdG9wLmF0KHN0b3AyLCBndG8sIG9wYWNpdHlUbyk7XG4gICAgICAgICAgc3RvcC5hdChzdG9wMywgZ3RvLCBvcGFjaXR5VG8pO1xuXG4gICAgICAgICAgaWYgKHN0b3A0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wLmF0KHN0b3A0LCBnZnJvbSwgb3BhY2l0eUZyb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnID0gdy5nbG9iYWxzLmRvbS5QYXBlci5ncmFkaWVudChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgIHZhciBzdG9wcyA9IEFycmF5LmlzQXJyYXkoY29sb3JTdG9wc1tpXSkgPyBjb2xvclN0b3BzW2ldIDogY29sb3JTdG9wcztcbiAgICAgICAgICBzdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBzdG9wLmF0KHMub2Zmc2V0IC8gMTAwLCBzLmNvbG9yLCBzLm9wYWNpdHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyYWRpYWwpIHtcbiAgICAgICAgaWYgKHN0eWxlID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgZy5mcm9tKDAsIDApLnRvKDAsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnZGlhZ29uYWwnKSB7XG4gICAgICAgICAgZy5mcm9tKDAsIDApLnRvKDEsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICBnLmZyb20oMCwgMSkudG8oMSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdkaWFnb25hbDInKSB7XG4gICAgICAgICAgZy5mcm9tKDAsIDEpLnRvKDIsIDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2ZmeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgICB2YXIgb2ZmeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gMjtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScpIHtcbiAgICAgICAgICBnLmF0dHIoe1xuICAgICAgICAgICAgZ3JhZGllbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJyxcbiAgICAgICAgICAgIGN4OiBvZmZ4LFxuICAgICAgICAgICAgY3k6IG9mZnksXG4gICAgICAgICAgICByOiBzaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZy5hdHRyKHtcbiAgICAgICAgICAgIGN4OiAwLjUsXG4gICAgICAgICAgICBjeTogMC41LFxuICAgICAgICAgICAgcjogMC44LFxuICAgICAgICAgICAgZng6IDAuMixcbiAgICAgICAgICAgIGZ5OiAwLjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RleHQob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeCA9IG9wdHMueCxcbiAgICAgICAgICB5ID0gb3B0cy55LFxuICAgICAgICAgIHRleHQgPSBvcHRzLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvciA9IG9wdHMudGV4dEFuY2hvcixcbiAgICAgICAgICBmb250U2l6ZSA9IG9wdHMuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseSA9IG9wdHMuZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3IgPSBvcHRzLmZvcmVDb2xvcixcbiAgICAgICAgICBvcGFjaXR5ID0gb3B0cy5vcGFjaXR5O1xuXG4gICAgICBpZiAoIXRleHRBbmNob3IpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICB9XG5cbiAgICAgIGlmICghZm9yZUNvbG9yKSB7XG4gICAgICAgIGZvcmVDb2xvciA9IHcuY29uZmlnLmNoYXJ0LmZvcmVDb2xvcjtcbiAgICAgIH1cblxuICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgIHZhciBlbFRleHQ7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgIGVsVGV4dCA9IHcuZ2xvYmFscy5kb20uUGFwZXIudGV4dChmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhZGQudHNwYW4odGV4dFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsVGV4dCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucGxhaW4odGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGVsVGV4dC5hdHRyKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogdGV4dEFuY2hvcixcbiAgICAgICAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2F1dG8nLFxuICAgICAgICAnZm9udC1zaXplJzogZm9udFNpemUsXG4gICAgICAgICdmb250LWZhbWlseSc6IGZvbnRGYW1pbHksXG4gICAgICAgIGZpbGw6IGZvcmVDb2xvcixcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXRleHQgJyArIG9wdHMuY3NzQ2xhc3MgPyBvcHRzLmNzc0NsYXNzIDogJydcbiAgICAgIH0pO1xuICAgICAgZWxUZXh0Lm5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICBlbFRleHQubm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIHJldHVybiBlbFRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRzcGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRzcGFuKHRleHRFbCwgdGV4dCwgZm9udEZhbWlseSkge1xuICAgICAgdmFyIHRzcGFuID0gdGV4dEVsLnRzcGFuKHRleHQpO1xuXG4gICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgZm9udEZhbWlseSA9IHRoaXMudy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgIH1cblxuICAgICAgdHNwYW4ubm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd01hcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TWFya2VyKHgsIHksIG9wdHMpIHtcbiAgICAgIHggPSB4IHx8IDA7XG4gICAgICB2YXIgc2l6ZSA9IG9wdHMucFNpemUgfHwgMDtcbiAgICAgIHZhciBlbFBvaW50ID0gbnVsbDtcblxuICAgICAgaWYgKG9wdHMuc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBvcHRzLnBSYWRpdXMgPT09IHVuZGVmaW5lZCA/IHNpemUgLyAyIDogb3B0cy5wUmFkaXVzO1xuXG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgICAgcmFkaXVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuU2l6ZSA9IHNpemUgKiAxLjIgKyByYWRpdXM7XG4gICAgICAgIHZhciBwID0gdGhpcy5kcmF3UmVjdChuU2l6ZSwgblNpemUsIG5TaXplLCBuU2l6ZSwgcmFkaXVzKTtcbiAgICAgICAgcC5hdHRyKHtcbiAgICAgICAgICB4OiB4IC0gblNpemUgLyAyLFxuICAgICAgICAgIHk6IHkgLSBuU2l6ZSAvIDIsXG4gICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgY3k6IHksXG4gICAgICAgICAgY2xhc3M6IG9wdHMuY2xhc3MgPyBvcHRzLmNsYXNzIDogJycsXG4gICAgICAgICAgZmlsbDogb3B0cy5wb2ludEZpbGxDb2xvcixcbiAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3B0cy5wb2ludEZpbGxPcGFjaXR5ID8gb3B0cy5wb2ludEZpbGxPcGFjaXR5IDogMSxcbiAgICAgICAgICBzdHJva2U6IG9wdHMucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogb3B0cy5wV2lkdGggPyBvcHRzLnBXaWR0aCA6IDAsXG4gICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogb3B0cy5wb2ludFN0cm9rZU9wYWNpdHkgPyBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUG9pbnQgPSBwO1xuICAgICAgfSBlbHNlIGlmIChvcHRzLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICBpZiAoIVV0aWxzLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gLy8gbGV0IG5TaXplID0gc2l6ZSAtIG9wdHMucFJhZGl1cyAvIDIgPCAwID8gMCA6IHNpemUgLSBvcHRzLnBSYWRpdXMgLyAyXG5cblxuICAgICAgICBlbFBvaW50ID0gdGhpcy5kcmF3Q2lyY2xlKHNpemUsIHtcbiAgICAgICAgICBjeDogeCxcbiAgICAgICAgICBjeTogeSxcbiAgICAgICAgICBjbGFzczogb3B0cy5jbGFzcyA/IG9wdHMuY2xhc3MgOiAnJyxcbiAgICAgICAgICBzdHJva2U6IG9wdHMucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgICBmaWxsOiBvcHRzLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcHRzLnBvaW50RmlsbE9wYWNpdHkgPyBvcHRzLnBvaW50RmlsbE9wYWNpdHkgOiAxLFxuICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBvcHRzLnBXaWR0aCA/IG9wdHMucFdpZHRoIDogMCxcbiAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA/IG9wdHMucG9pbnRTdHJva2VPcGFjaXR5IDogMVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsUG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhNb3VzZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhNb3VzZUVudGVyKHBhdGgsIGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuICAgICAgdmFyIGogPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdqJykpO1xuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRNb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRNb3VzZUVudGVyKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguZmlyZUV2ZW50KCdkYXRhUG9pbnRNb3VzZUVudGVyJywgW2UsIHRoaXMuY3R4LCB7XG4gICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfV0pO1xuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmIChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdzZWxlY3RlZCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScgJiYgIXcuZ2xvYmFscy5pc1RvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgdmFyIGhvdmVyRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmhvdmVyLmZpbHRlcjtcbiAgICAgICAgICBmaWx0ZXJzLmFwcGx5RmlsdGVyKHBhdGgsIGhvdmVyRmlsdGVyLnR5cGUsIGhvdmVyRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTW91c2VMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTW91c2VMZWF2ZShwYXRoLCBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGkgPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdpbmRleCcpKTtcbiAgICAgIHZhciBqID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaicpKTtcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VMZWF2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VMZWF2ZShlLCB0aGlzLmN0eCwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnZGF0YVBvaW50TW91c2VMZWF2ZScsIFtlLCB0aGlzLmN0eCwge1xuICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH1dKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBpZiAocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuaG92ZXIuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhNb3VzZURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aE1vdXNlRG93bihwYXRoLCBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGkgPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdpbmRleCcpKTtcbiAgICAgIHZhciBqID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaicpKTtcbiAgICAgIHZhciBzZWxlY3RlZCA9ICdmYWxzZSc7XG5cbiAgICAgIGlmIChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdzZWxlY3RlZCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgcGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5pbmRleE9mKGopID4gLTEpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldLmluZGV4T2Yoaik7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXcuY29uZmlnLnN0YXRlcy5hY3RpdmUuYWxsb3dNdWx0aXBsZURhdGFQb2ludHNTZWxlY3Rpb24gJiYgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cyA9IFtdO1xuICAgICAgICAgIHZhciBlbFBhdGhzID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoJy5hcGV4Y2hhcnRzLXNlcmllcyBwYXRoJykubWVtYmVycztcbiAgICAgICAgICB2YXIgZWxDaXJjbGVzID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoJy5hcGV4Y2hhcnRzLXNlcmllcyBjaXJjbGUsIC5hcGV4Y2hhcnRzLXNlcmllcyByZWN0JykubWVtYmVycztcbiAgICAgICAgICBlbFBhdGhzLmZvckVhY2goZnVuY3Rpb24gKGVsUGF0aCkge1xuICAgICAgICAgICAgZWxQYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKGVsUGF0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxDaXJjbGVzLmZvckVhY2goZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICAgICAgY2lyY2xlLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKGNpcmNsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgIHNlbGVjdGVkID0gJ3RydWUnO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldLnB1c2goaik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHZhciBhY3RpdmVGaWx0ZXIgPSB3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlcjtcblxuICAgICAgICBpZiAoYWN0aXZlRmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBmaWx0ZXJzLmFwcGx5RmlsdGVyKHBhdGgsIGFjdGl2ZUZpbHRlci50eXBlLCBhY3RpdmVGaWx0ZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludFNlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50U2VsZWN0aW9uKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgc2VsZWN0ZWREYXRhUG9pbnRzOiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnZGF0YVBvaW50U2VsZWN0aW9uJywgW2UsIHRoaXMuY3R4LCB7XG4gICAgICAgIHNlbGVjdGVkRGF0YVBvaW50czogdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cyxcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9XSk7IC8vIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zZWxlY3RlZFBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAgIHRoaXMudy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnNlbGVjdGVkUG9pbnRzKHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMpXG4gICAgICAvLyB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZUFyb3VuZENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVBcm91bmRDZW50ZXIoZWwpIHtcbiAgICAgIHZhciBjb29yZCA9IGVsLmdldEJCb3goKTtcbiAgICAgIHZhciB4ID0gY29vcmQueCArIGNvb3JkLndpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gY29vcmQueSArIGNvb3JkLmhlaWdodCAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0UmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFJlY3RzKHRleHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciB1c2VCQm94ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmlydHVhbFRleHQgPSB0aGlzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogLTIwMCxcbiAgICAgICAgeTogLTIwMCxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmlydHVhbFRleHQuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtKTtcbiAgICAgIH1cblxuICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodmlydHVhbFRleHQpO1xuICAgICAgdmFyIHJlY3QgPSB2aXJ0dWFsVGV4dC5iYm94KCk7XG5cbiAgICAgIGlmICghdXNlQkJveCkge1xuICAgICAgICByZWN0ID0gdmlydHVhbFRleHQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmlydHVhbFRleHQucmVtb3ZlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYXBwZW5kIC4uLiB0byBsb25nIHRleHRcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkyNDEzMTUvdHJpbW1pbmctdGV4dC10by1hLWdpdmVuLXBpeGVsLXdpZHRoLWluLXN2Z1xuICAgICAqIEBtZW1iZXJvZiBHcmFwaGljc1xuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYWNlVGV4dFdpdGhFbGxpcHNpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGFjZVRleHRXaXRoRWxsaXBzaXModGV4dE9iaiwgdGV4dFN0cmluZywgd2lkdGgpIHtcbiAgICAgIHRleHRPYmoudGV4dENvbnRlbnQgPSB0ZXh0U3RyaW5nO1xuXG4gICAgICBpZiAodGV4dFN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGVsbGlwc2lzIGlzIG5lZWRlZFxuICAgICAgICBpZiAodGV4dE9iai5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgdGV4dFN0cmluZy5sZW5ndGgpID49IHdpZHRoKSB7XG4gICAgICAgICAgZm9yICh2YXIgeCA9IHRleHRTdHJpbmcubGVuZ3RoIC0gMzsgeCA+IDA7IHggLT0gMykge1xuICAgICAgICAgICAgaWYgKHRleHRPYmouZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIHgpIDw9IHdpZHRoKSB7XG4gICAgICAgICAgICAgIHRleHRPYmoudGV4dENvbnRlbnQgPSB0ZXh0U3RyaW5nLnN1YnN0cmluZygwLCB4KSArICcuLi4nO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudCA9ICcuLi4nOyAvLyBjYW4ndCBwbGFjZSBhdCBhbGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInNldEF0dHJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJzKGVsLCBhdHRycykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JhcGhpY3M7XG59KCk7XG5cbmNvbnN0IG5hbWUgPSBcImVuXCI7XG5jb25zdCBvcHRpb25zID0ge1xuXHRtb250aHM6IFtcblx0XHRcIkphbnVhcnlcIixcblx0XHRcIkZlYnJ1YXJ5XCIsXG5cdFx0XCJNYXJjaFwiLFxuXHRcdFwiQXByaWxcIixcblx0XHRcIk1heVwiLFxuXHRcdFwiSnVuZVwiLFxuXHRcdFwiSnVseVwiLFxuXHRcdFwiQXVndXN0XCIsXG5cdFx0XCJTZXB0ZW1iZXJcIixcblx0XHRcIk9jdG9iZXJcIixcblx0XHRcIk5vdmVtYmVyXCIsXG5cdFx0XCJEZWNlbWJlclwiXG5cdF0sXG5cdHNob3J0TW9udGhzOiBbXG5cdFx0XCJKYW5cIixcblx0XHRcIkZlYlwiLFxuXHRcdFwiTWFyXCIsXG5cdFx0XCJBcHJcIixcblx0XHRcIk1heVwiLFxuXHRcdFwiSnVuXCIsXG5cdFx0XCJKdWxcIixcblx0XHRcIkF1Z1wiLFxuXHRcdFwiU2VwXCIsXG5cdFx0XCJPY3RcIixcblx0XHRcIk5vdlwiLFxuXHRcdFwiRGVjXCJcblx0XSxcblx0ZGF5czogW1xuXHRcdFwiU3VuZGF5XCIsXG5cdFx0XCJNb25kYXlcIixcblx0XHRcIlR1ZXNkYXlcIixcblx0XHRcIldlZG5lc2RheVwiLFxuXHRcdFwiVGh1cnNkYXlcIixcblx0XHRcIkZyaWRheVwiLFxuXHRcdFwiU2F0dXJkYXlcIlxuXHRdLFxuXHRzaG9ydERheXM6IFtcblx0XHRcIlN1blwiLFxuXHRcdFwiTW9uXCIsXG5cdFx0XCJUdWVcIixcblx0XHRcIldlZFwiLFxuXHRcdFwiVGh1XCIsXG5cdFx0XCJGcmlcIixcblx0XHRcIlNhdFwiXG5cdF0sXG5cdHRvb2xiYXI6IHtcblx0XHRleHBvcnRUb1NWRzogXCJEb3dubG9hZCBTVkdcIixcblx0XHRleHBvcnRUb1BORzogXCJEb3dubG9hZCBQTkdcIixcblx0XHRtZW51OiBcIk1lbnVcIixcblx0XHRzZWxlY3Rpb246IFwiU2VsZWN0aW9uXCIsXG5cdFx0c2VsZWN0aW9uWm9vbTogXCJTZWxlY3Rpb24gWm9vbVwiLFxuXHRcdHpvb21JbjogXCJab29tIEluXCIsXG5cdFx0em9vbU91dDogXCJab29tIE91dFwiLFxuXHRcdHBhbjogXCJQYW5uaW5nXCIsXG5cdFx0cmVzZXQ6IFwiUmVzZXQgWm9vbVwiXG5cdH1cbn07XG52YXIgZW4gPSB7XG5cdG5hbWU6IG5hbWUsXG5cdG9wdGlvbnM6IG9wdGlvbnNcbn07XG5cbnZhciBPcHRpb25zID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3B0aW9ucygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9ucyk7XG5cbiAgICB0aGlzLnlBeGlzID0ge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHNob3dBbHdheXM6IGZhbHNlLFxuICAgICAgc2VyaWVzTmFtZTogdW5kZWZpbmVkLFxuICAgICAgb3Bwb3NpdGU6IGZhbHNlLFxuICAgICAgcmV2ZXJzZWQ6IGZhbHNlLFxuICAgICAgbG9nYXJpdGhtaWM6IGZhbHNlLFxuICAgICAgdGlja0Ftb3VudDogdW5kZWZpbmVkLFxuICAgICAgZm9yY2VOaWNlU2NhbGU6IGZhbHNlLFxuICAgICAgbWF4OiB1bmRlZmluZWQsXG4gICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgIGRlY2ltYWxzSW5GbG9hdDogMixcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgbWF4V2lkdGg6IDE2MCxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgYWxpZ246IHVuZGVmaW5lZCxcbiAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICBwYWRkaW5nOiAyMCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAnIzc4OTA5QycsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDBcbiAgICAgIH0sXG4gICAgICBheGlzVGlja3M6IHtcbiAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAnIzc4OTA5QycsXG4gICAgICAgIHdpZHRoOiA2LFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICByb3RhdGU6IDkwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXRYOiAwXG4gICAgICB9LFxuICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ2Zyb250JyxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgY29sb3I6ICcjYjZiNmI2JyxcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBkYXNoQXJyYXk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy54QXhpc0Fubm90YXRpb24gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeDI6IG51bGwsXG4gICAgICBzdHJva2VEYXNoQXJyYXk6IDEsXG4gICAgICBmaWxsQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICBvcGFjaXR5OiAwLjMsXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgICBib3R0b206IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMueUF4aXNBbm5vdGF0aW9uID0ge1xuICAgICAgeTogMCxcbiAgICAgIHkyOiBudWxsLFxuICAgICAgc3Ryb2tlRGFzaEFycmF5OiAxLFxuICAgICAgZmlsbENvbG9yOiAnI2MyYzJjMicsXG4gICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgb3BhY2l0eTogMC4zLFxuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDAsXG4gICAgICB5QXhpc0luZGV4OiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAtMyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogJycsXG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnBvaW50QW5ub3RhdGlvbiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiBudWxsLFxuICAgICAgeUF4aXNJbmRleDogMCxcbiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMzMzJyxcbiAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAtMTUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgY3NzQ2xhc3M6ICcnLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgICByaWdodDogNSxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNWRzoge1xuICAgICAgICBTVkc6IHVuZGVmaW5lZCxcbiAgICAgICAgY3NzQ2xhc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT3B0aW9ucywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5ub3RhdGlvbnM6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Zyb250JyxcbiAgICAgICAgICB5YXhpczogW3RoaXMueUF4aXNBbm5vdGF0aW9uXSxcbiAgICAgICAgICB4YXhpczogW3RoaXMueEF4aXNBbm5vdGF0aW9uXSxcbiAgICAgICAgICBwb2ludHM6IFt0aGlzLnBvaW50QW5ub3RhdGlvbl1cbiAgICAgICAgfSxcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZWlub3V0JyxcbiAgICAgICAgICAgIC8vIGxpbmVhciwgZWFzZW91dCwgZWFzZWluLCBlYXNlaW5vdXQsIHN3aW5nLCBib3VuY2UsIGVsYXN0aWNcbiAgICAgICAgICAgIHNwZWVkOiA4MDAsXG4gICAgICAgICAgICBhbmltYXRlR3JhZHVhbGx5OiB7XG4gICAgICAgICAgICAgIGRlbGF5OiAxNTAsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkeW5hbWljQW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHNwZWVkOiAzNTBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbG9jYWxlczogW2VuXSxcbiAgICAgICAgICBkZWZhdWx0TG9jYWxlOiAnZW4nLFxuICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZW5hYmxlZFNlcmllczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgICAgbGVmdDogMixcbiAgICAgICAgICAgIGJsdXI6IDQsXG4gICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4zNVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBhbmltYXRpb25FbmQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJlZm9yZU1vdW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtb3VudGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cGRhdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGVnZW5kQ2xpY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1hcmtlckNsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFQb2ludFNlbGVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YVBvaW50TW91c2VFbnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YVBvaW50TW91c2VMZWF2ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmVmb3JlWm9vbTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgem9vbWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzY3JvbGxlZDogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JlQ29sb3I6ICcjMzczZDNmJyxcbiAgICAgICAgICBmb250RmFtaWx5OiAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgcGFyZW50SGVpZ2h0T2Zmc2V0OiAxNSxcbiAgICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgICAvLyBzZWxlY3RlZFBvaW50czogdW5kZWZpbmVkLCAvLyBkZWZhdWx0IGRhdGFwb2ludHMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICBjb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIGNvbG9yOiAnIzI0MjkyZScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgZGFzaEFycmF5OiAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzcGFya2xpbmU6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBicnVzaDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvU2NhbGVZYXhpczogZmFsc2UsXG4gICAgICAgICAgICB0YXJnZXQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhY2tlZDogZmFsc2UsXG4gICAgICAgICAgc3RhY2tUeXBlOiAnbm9ybWFsJyxcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgdG9vbHM6IHtcbiAgICAgICAgICAgICAgZG93bmxvYWQ6IHRydWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgem9vbTogdHJ1ZSxcbiAgICAgICAgICAgICAgem9vbWluOiB0cnVlLFxuICAgICAgICAgICAgICB6b29tb3V0OiB0cnVlLFxuICAgICAgICAgICAgICBwYW46IHRydWUsXG4gICAgICAgICAgICAgIHJlc2V0OiB0cnVlLFxuICAgICAgICAgICAgICBjdXN0b21JY29uczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWQ6ICd6b29tJyAvLyBhY2NlcHRzIC0+IHpvb20sIHBhbiwgc2VsZWN0aW9uXG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgICAvLyBhdXRvU2NhbGVZYXhpczogZmFsc2UsIC8vIFRPRE86IHJld3JpdGUgdGhlIGF1dG9TY2FsZVkgZnVuY3Rpb25cbiAgICAgICAgICAgIHpvb21lZEFyZWE6IHtcbiAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkwQ0FGOScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzBENDdBMScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbHVtbldpZHRoOiAnNzAlJyxcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbiBwZXJjZW50IDAgLSAxMDBcbiAgICAgICAgICAgIGJhckhlaWdodDogJzcwJScsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW4gcGVyY2VudCAwIC0gMTAwXG4gICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICBlbmRpbmdTaGFwZTogJ2ZsYXQnLFxuICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgIHJhbmdlczogW10sXG4gICAgICAgICAgICAgIGJhY2tncm91bmRCYXJDb2xvcnM6IFtdLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQmFyT3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgbWF4SXRlbXM6IDEwMCxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3AnIC8vIHRvcCwgY2VudGVyLCBib3R0b21cbiAgICAgICAgICAgICAgLy8gVE9ETzogcHJvdmlkZSBzdGFja2VkTGFiZWxzIGZvciBzdGFja2VkIGNoYXJ0cyB3aGljaCBnaXZlcyBhZGRpdGlvbnMgb2YgdmFsdWVzXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmRsZXN0aWNrOiB7XG4gICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgdXB3YXJkOiAnIzAwQjc0NicsXG4gICAgICAgICAgICAgIGRvd253YXJkOiAnI0VGNDAzQydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aWNrOiB7XG4gICAgICAgICAgICAgIHVzZUZpbGxDb2xvcjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGVhdG1hcDoge1xuICAgICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgICAgZW5hYmxlU2hhZGVzOiB0cnVlLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNSxcbiAgICAgICAgICAgIGRpc3RyaWJ1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yU2NhbGU6IHtcbiAgICAgICAgICAgICAgaW52ZXJzZTogZmFsc2UsXG4gICAgICAgICAgICAgIHJhbmdlczogW10sXG4gICAgICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBtYXg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmFkaWFsQmFyOiB7XG4gICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnZlcnNlT3JkZXI6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiAzNjAsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGhvbGxvdzoge1xuICAgICAgICAgICAgICBtYXJnaW46IDUsXG4gICAgICAgICAgICAgIHNpemU6ICc1MCUnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICBpbWFnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpbWFnZVdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgIGltYWdlSGVpZ2h0OiAxNTAsXG4gICAgICAgICAgICAgIGltYWdlT2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgaW1hZ2VPZmZzZXRZOiAwLFxuICAgICAgICAgICAgICBpbWFnZUNsaXBwZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnZnJvbnQnLFxuICAgICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgYmx1cjogMyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2YyZjJmMicsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAnOTclJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgbWFyZ2luOiA1LFxuICAgICAgICAgICAgICAvLyBtYXJnaW4gaXMgaW4gcGl4ZWxzXG4gICAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICBibHVyOiAzLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiAxNixcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgKyAnJSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnVG90YWwnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgICAgICAgICAgIH0sIDApIC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggKyAnJSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByYW5nZUJhcjoge30sXG4gICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXN0b21TY2FsZTogMSxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgZXhwYW5kT25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50YWdlIHZhbHVlcyB3aGljaCBhcmUgZGlzcGxheWVkIG9uIHNsaWNlXG4gICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgLy8gb2Zmc2V0IGJ5IHdoaWNoIGxhYmVscyB3aWxsIG1vdmUgb3V0c2lkZVxuICAgICAgICAgICAgICBtaW5BbmdsZVRvU2hvd0xhYmVsOiAxNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbnV0OiB7XG4gICAgICAgICAgICAgIHNpemU6ICc2NSUnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGlubmVyIGxhYmVscyBhcHBlYXJpbmcgaW5zaWRlIGRvbnV0XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogLTEwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogMTAsXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGxhYmVsOiAnVG90YWwnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJhZGFyOiB7XG4gICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIHBvbHlnb25zOiB7XG4gICAgICAgICAgICAgIC8vIHN0cm9rZUNvbG9yOiAnI2U4ZThlOCcsIC8vIHNob3VsZCBiZSBkZXByZWNhdGVkIGluIHRoZSBtaW5vciB2ZXJzaW9uIGkuZSAzLjJcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3JzOiAnI2U4ZThlOCcsXG4gICAgICAgICAgICAgIGNvbm5lY3RvckNvbG9yczogJyNlOGU4ZTgnLFxuICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZWRPblNlcmllczogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogMSxcbiAgICAgICAgICAgIGxlZnQ6IDEsXG4gICAgICAgICAgICBibHVyOiAxLFxuICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIGFycmF5IG9mIGNvbG9yc1xuICAgICAgICAgIG9wYWNpdHk6IDAuODUsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnZGFyaycsXG4gICAgICAgICAgICB0eXBlOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC41LFxuICAgICAgICAgICAgZ3JhZGllbnRUb0NvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogdHJ1ZSxcbiAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAxLFxuICAgICAgICAgICAgb3BhY2l0eVRvOiAxLFxuICAgICAgICAgICAgc3RvcHM6IFswLCA1MCwgMTAwXSxcbiAgICAgICAgICAgIGNvbG9yU3RvcHM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgc3JjOiBbXSxcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWQgLy8gb3B0aW9uYWxcblxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgc3R5bGU6ICdzcWF1cmVzJyxcbiAgICAgICAgICAgIC8vIFN0cmluZyB8IEFycmF5IG9mIFN0cmluZ3NcbiAgICAgICAgICAgIHdpZHRoOiA2LFxuICAgICAgICAgICAgaGVpZ2h0OiA2LFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2UwZTBlMCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAwLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYmFjaycsXG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICBhbmltYXRlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIGFuaW1hdGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJvdzoge1xuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyB0YWtlcyBhcyBhcnJheSB3aGljaCB3aWxsIGJlIHJlcGVhdGVkIG9uIHJvd3NcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29sdW1uOiB7XG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIHRha2VzIGFuIGFycmF5IHdoaWNoIHdpbGwgYmUgcmVwZWF0ZWQgb24gY29sdW1uc1xuICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICByaWdodDogMTAsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiAxMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICBzaG93Rm9yU2luZ2xlU2VyaWVzOiBmYWxzZSxcbiAgICAgICAgICBzaG93Rm9yTnVsbFNlcmllczogdHJ1ZSxcbiAgICAgICAgICBzaG93Rm9yWmVyb1NlcmllczogdHJ1ZSxcbiAgICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgIC8vIHdoZXRoZXIgdG8gcG9zaXRpb24gbGVnZW5kcyBpbiAxIG9mIDRcbiAgICAgICAgICAvLyBkaXJlY3Rpb24gLSB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHRcbiAgICAgICAgICBob3Jpem9udGFsQWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIC8vIHdoZW4gcG9zaXRpb24gdG9wL2JvdHRvbSwgeW91IGNhbiBzcGVjaWZ5IHdoZXRoZXIgdG8gYWxpZ24gbGVnZW5kcyBsZWZ0LCByaWdodCBvciBjZW50ZXJcbiAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIG9mZnNldFg6IC0yMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2VTZXJpZXNDb2xvcnM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgICB3aWR0aDogMTIsXG4gICAgICAgICAgICBoZWlnaHQ6IDEyLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgcmFkaXVzOiAxMixcbiAgICAgICAgICAgIGN1c3RvbUhUTUw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgb25DbGljazogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtTWFyZ2luOiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiAwLFxuICAgICAgICAgICAgdmVydGljYWw6IDVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uSXRlbUNsaWNrOiB7XG4gICAgICAgICAgICB0b2dnbGVEYXRhU2VyaWVzOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkl0ZW1Ib3Zlcjoge1xuICAgICAgICAgICAgaGlnaGxpZ2h0RGF0YVNlcmllczogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgIGRpc2NyZXRlOiBbXSxcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vc3Ryb2tlQ29sb3I6ICcjZmZmJywgLy8gVE9ETzogZGVwcmVjYXRlIGluIG1ham9yIHZlcnNpb24gNC4wXG4gICAgICAgICAgc3Ryb2tlQ29sb3JzOiAnI2ZmZicsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC45LFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplT2Zmc2V0OiAzXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub0RhdGE6IHtcbiAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNpdmU6IFtdLFxuICAgICAgICAvLyBicmVha3BvaW50cyBzaG91bGQgZm9sbG93IGFzY2VuZGluZyBvcmRlciA0MDAsIHRoZW4gNzAwLCB0aGVuIDEwMDBcbiAgICAgICAgc2VyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlczoge1xuICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdub25lJyxcbiAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2xpZ2h0ZW4nLFxuICAgICAgICAgICAgICB2YWx1ZTogMC4xNVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICBhbGxvd011bHRpcGxlRGF0YVBvaW50c1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2RhcmtlbicsXG4gICAgICAgICAgICAgIHZhbHVlOiAwLjY1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgIG1hcmdpbjogMTAsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnRpdGxlOiB7XG4gICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgbWFyZ2luOiAxMCxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDMwLFxuICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgY3VydmU6ICdzbW9vdGgnLFxuICAgICAgICAgIC8vIFwic21vb3RoXCIgLyBcInN0cmFpZ2h0XCIgLyBcInN0ZXBsaW5lXCJcbiAgICAgICAgICBsaW5lQ2FwOiAnYnV0dCcsXG4gICAgICAgICAgLy8gcm91bmQsIGJ1dHQgLCBzcXVhcmVcbiAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAvLyBhcnJheSBvZiBjb2xvcnNcbiAgICAgICAgICBkYXNoQXJyYXk6IDAgLy8gc2luZ2xlIHZhbHVlIG9yIGFycmF5IG9mIHZhbHVlc1xuXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICAgICAgICAgIC8vIHdoZW4gZGlzYWJsZWQsIHRoZSB0b29sdGlwIHdpbGwgc2hvdyBvbiB0b3Agb2YgdGhlIHNlcmllcyBpbnN0ZWFkIG9mIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAgaW50ZXJzZWN0OiBmYWxzZSxcbiAgICAgICAgICAvLyB3aGVuIGVuYWJsZWQsIHRvb2x0aXAgd2lsbCBvbmx5IHNob3cgd2hlbiB1c2VyIGRpcmVjdGx5IGhvdmVycyBvdmVyIHBvaW50XG4gICAgICAgICAgaW52ZXJzZU9yZGVyOiBmYWxzZSxcbiAgICAgICAgICBjdXN0b206IHVuZGVmaW5lZCxcbiAgICAgICAgICBmaWxsU2VyaWVzQ29sb3I6IGZhbHNlLFxuICAgICAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkRhdGFzZXRIb3Zlcjoge1xuICAgICAgICAgICAgaGlnaGxpZ2h0RGF0YVNlcmllczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgIC8vIHggdmFsdWVcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBmb3JtYXQ6ICdkZCBNTU0nLFxuICAgICAgICAgICAgLy8gZGQvTU0sIGRkIE1NTSB5eSwgZGQgTU1NIHl5eXlcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkIC8vIGEgY3VzdG9tIHVzZXIgc3VwcGxpZWQgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIoc2VyaWVzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXNOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB6OiB7XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpdGxlOiAnU2l6ZTogJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaXhlZDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3RvcFJpZ2h0JyxcbiAgICAgICAgICAgIC8vIHRvcFJpZ2h0LCB0b3BMZWZ0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgcm90YXRlOiAtNDUsXG4gICAgICAgICAgICByb3RhdGVBbHdheXM6IGZhbHNlLFxuICAgICAgICAgICAgaGlkZU92ZXJsYXBwaW5nTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgICAgICAgIG1pbkhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiAxMjAsXG4gICAgICAgICAgICBzaG93RHVwbGljYXRlczogdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmdW5jdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIGZvcm1hdFxuICAgICAgICAgICAgZGF0ZXRpbWVGb3JtYXR0ZXI6IHtcbiAgICAgICAgICAgICAgeWVhcjogJ3l5eXknLFxuICAgICAgICAgICAgICBtb250aDogXCJNTU0gJ3l5XCIsXG4gICAgICAgICAgICAgIGRheTogJ2RkIE1NTScsXG4gICAgICAgICAgICAgIGhvdXI6ICdISDptbScsXG4gICAgICAgICAgICAgIG1pbnV0ZTogJ0hIOm1tOnNzJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzc4OTA5QycsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzc4OTA5QycsXG4gICAgICAgICAgICBoZWlnaHQ6IDYsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja0Ftb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRpY2tQbGFjZW1lbnQ6ICdvbicsXG4gICAgICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWF4OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmFuZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAvLyB0aWNrV2lkdGgvYmFyV2lkdGggb3IgYW4gaW50ZWdlclxuICAgICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICBjb2xvcjogJyNiNmI2YjYnLFxuICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgZGFzaEFycmF5OiAzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgICAgICAgICAvLyBzb2xpZCwgZ3JhZGllbnRcbiAgICAgICAgICAgICAgY29sb3I6ICcjQjFCOUM0JyxcbiAgICAgICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvckZyb206ICcjRDhFM0YwJyxcbiAgICAgICAgICAgICAgICBjb2xvclRvOiAnI0JFRDFFNicsXG4gICAgICAgICAgICAgICAgc3RvcHM6IFswLCAxMDBdLFxuICAgICAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjQsXG4gICAgICAgICAgICAgICAgb3BhY2l0eVRvOiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgYmx1cjogMSxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5YXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICBtb2RlOiAnbGlnaHQnLFxuICAgICAgICAgIHBhbGV0dGU6ICdwYWxldHRlMScsXG4gICAgICAgICAgLy8gSWYgZGVmaW5lZCwgaXQgd2lsbCBvdmVyd3JpdGUgZ2xvYmFscy5jb2xvcnMgdmFyaWFibGVcbiAgICAgICAgICBtb25vY2hyb21lOiB7XG4gICAgICAgICAgICAvLyBtb25vY2hyb21lIGFsbG93cyB5b3UgdG8gc2VsZWN0IGp1c3QgMSBjb2xvciBhbmQgZmlsbCBvdXQgdGhlIHJlc3Qgd2l0aCBsaWdodC9kYXJrIHNoYWRlIChpbnRlbnNpdHkgY2FuIGJlIHNlbGVjdGVkKVxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcjogJyMwMDhGRkInLFxuICAgICAgICAgICAgc2hhZGVUbzogJ2xpZ2h0JyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjY1XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcHRpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQW5ub3RhdGlvbnMgQ2xhc3MgZm9yIGRyYXdpbmcgbGluZXMvcmVjdHMgb24gYm90aCB4YXhpcyBhbmQgeWF4aXMuXG4gKlxuICogQG1vZHVsZSBBbm5vdGF0aW9uc1xuICoqL1xuXG52YXIgQW5ub3RhdGlvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbm5vdGF0aW9ucyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG5cbiAgICBpZiAodGhpcy53Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLmludmVydEF4aXMgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMueERpdmlzaW9uID0gdGhpcy53Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGhpcy53Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbm5vdGF0aW9ucywgW3tcbiAgICBrZXk6IFwiZHJhd0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdmFyIHlBbm5vdGF0aW9ucyA9IHRoaXMuZHJhd1lBeGlzQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgdmFyIHhBbm5vdGF0aW9ucyA9IHRoaXMuZHJhd1hBeGlzQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgdmFyIHBvaW50QW5ub3RhdGlvbnMgPSB0aGlzLmRyYXdQb2ludEFubm90YXRpb25zKCk7XG4gICAgICAgIHZhciBpbml0aWFsQW5pbSA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgdmFyIGFubm9BcnJheSA9IFt5QW5ub3RhdGlvbnMsIHhBbm5vdGF0aW9ucywgcG9pbnRBbm5vdGF0aW9uc107XG4gICAgICAgIHZhciBhbm5vRWxBcnJheSA9IFt4QW5ub3RhdGlvbnMubm9kZSwgeUFubm90YXRpb25zLm5vZGUsIHBvaW50QW5ub3RhdGlvbnMubm9kZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChhbm5vQXJyYXlbaV0pO1xuXG4gICAgICAgICAgaWYgKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICBhbm5vRWxBcnJheVtpXS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuZGVsYXllZEVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZWw6IGFubm9FbEFycmF5W2ldLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhZnRlciBwbGFjaW5nIHRoZSBhbm5vdGF0aW9ucyBvbiBzdmcsIHNldCBhbnkgdmVydGljYWxseSBwbGFjZWQgYW5ub3RhdGlvbnNcblxuXG4gICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb25zKHcuY29uZmlnLmFubm90YXRpb25zLnhheGlzKTsgLy8gYmFja2dyb3VuZCBzaXplcyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIGFmdGVyIHRleHQgaXMgZHJhd24sIHNvIGNhbGxpbmcgdGhlbSBsYXN0XG5cbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uc0JhY2tncm91bmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWGF4aXNBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtaW4gPSB0aGlzLmludmVydEF4aXMgPyB3Lmdsb2JhbHMubWluWSA6IHcuZ2xvYmFscy5taW5YO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5pbnZlcnRBeGlzID8gdy5nbG9iYWxzLnlSYW5nZVswXSA6IHcuZ2xvYmFscy54UmFuZ2U7XG4gICAgICB2YXIgeDEgPSAoYW5uby54IC0gbWluKSAvIChyYW5nZSAvIHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgdmFyIGNhdEluZGV4ID0gdy5nbG9iYWxzLmxhYmVscy5pbmRleE9mKGFubm8ueCk7XG4gICAgICAgIHZhciB4TGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nIHRleHQ6bnRoLWNoaWxkKCcgKyAoY2F0SW5kZXggKyAxKSArICcpJyk7XG5cbiAgICAgICAgaWYgKHhMYWJlbCkge1xuICAgICAgICAgIHgxID0gcGFyc2VGbG9hdCh4TGFiZWwuZ2V0QXR0cmlidXRlKCd4JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VEYXNoQXJyYXkgPSBhbm5vLnN0cm9rZURhc2hBcnJheTtcbiAgICAgIGlmICh4MSA8IDAgfHwgeDEgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSByZXR1cm47XG5cbiAgICAgIGlmIChhbm5vLngyID09PSBudWxsKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5ncmFwaGljcy5kcmF3TGluZSh4MSArIGFubm8ub2Zmc2V0WCwgLy8geDFcbiAgICAgICAgMCArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgeDEgKyBhbm5vLm9mZnNldFgsIC8vIHgyXG4gICAgICAgIHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgYW5uby5vZmZzZXRZLCAvLyB5MlxuICAgICAgICBhbm5vLmJvcmRlckNvbG9yLCAvLyBsaW5lQ29sb3JcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5IC8vZGFzaEFycmF5XG4gICAgICAgICk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChsaW5lLm5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHgyID0gKGFubm8ueDIgLSBtaW4pIC8gKHJhbmdlIC8gdy5nbG9iYWxzLmdyaWRXaWR0aCk7XG5cbiAgICAgICAgaWYgKHgyIDwgeDEpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IHgxO1xuICAgICAgICAgIHgxID0geDI7XG4gICAgICAgICAgeDIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KHgxICsgYW5uby5vZmZzZXRYLCAvLyB4MVxuICAgICAgICAwICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB4MiAtIHgxLCAvLyB4MlxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgMCwgLy8gcmFkaXVzXG4gICAgICAgIGFubm8uZmlsbENvbG9yLCAvLyBjb2xvclxuICAgICAgICBhbm5vLm9wYWNpdHksIC8vIG9wYWNpdHksXG4gICAgICAgIDEsIC8vIHN0cm9rZVdpZHRoXG4gICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIHN0cm9rZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvLyBzdG9rZURhc2hBcnJheVxuICAgICAgICApO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVjdC5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRleHRZID0gYW5uby5sYWJlbC5wb3NpdGlvbiA9PT0gJ3RvcCcgPyAtMyA6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcbiAgICAgIHZhciBlbFRleHQgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogeDEgKyBhbm5vLmxhYmVsLm9mZnNldFgsXG4gICAgICAgIHk6IHRleHRZICsgYW5uby5sYWJlbC5vZmZzZXRZLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiBhbm5vLmxhYmVsLnRleHRBbmNob3IsXG4gICAgICAgIGZvbnRTaXplOiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogYW5uby5sYWJlbC5zdHlsZS5jb2xvcixcbiAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb24tbGFiZWwgJyArIGFubm8ubGFiZWwuc3R5bGUuY3NzQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZWxUZXh0LmF0dHIoe1xuICAgICAgICByZWw6IGluZGV4XG4gICAgICB9KTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbFRleHQubm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdYQXhpc0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQXhpc0Fubm90YXRpb25zKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxnID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9ucydcbiAgICAgIH0pO1xuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMueGF4aXMubWFwKGZ1bmN0aW9uIChhbm5vLCBpbmRleCkge1xuICAgICAgICBfdGhpcy5hZGRYYXhpc0Fubm90YXRpb24oYW5ubywgZWxnLm5vZGUsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWWF4aXNBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFlheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBzdHJva2VEYXNoQXJyYXkgPSBhbm5vLnN0cm9rZURhc2hBcnJheTtcbiAgICAgIHZhciB5MTtcbiAgICAgIHZhciB5MjtcblxuICAgICAgaWYgKHRoaXMuaW52ZXJ0QXhpcykge1xuICAgICAgICB2YXIgY2F0SW5kZXggPSB3Lmdsb2JhbHMubGFiZWxzLmluZGV4T2YoYW5uby55KTtcbiAgICAgICAgdmFyIHhMYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXlheGlzLXRleHRzLWcgdGV4dDpudGgtY2hpbGQoJyArIChjYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICBpZiAoeExhYmVsKSB7XG4gICAgICAgICAgeTEgPSBwYXJzZUZsb2F0KHhMYWJlbC5nZXRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAoYW5uby55IC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1thbm5vLnlBeGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICB5MSA9IChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcblxuICAgICAgaWYgKGFubm8ueTIgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyYXBoaWNzLmRyYXdMaW5lKDAgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIHkxICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgYW5uby5vZmZzZXRYLCAvLyB4MlxuICAgICAgICB5MSArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gbGluZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvLyBkYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgICAgdmFyIF9jYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLnkyKTtcblxuICAgICAgICAgIHZhciBfeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKF9jYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICAgIGlmIChfeExhYmVsKSB7XG4gICAgICAgICAgICB5MiA9IHBhcnNlRmxvYXQoX3hMYWJlbC5nZXRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAoYW5uby55MiAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1thbm5vLnlBeGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIHkyID0gKGFubm8ueTIgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkyID4geTEpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IHkxO1xuICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgeTIgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KDAgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIHkyICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgYW5uby5vZmZzZXRYLCAvLyB4MlxuICAgICAgICB5MSAtIHkyLCAvLyB5MlxuICAgICAgICAwLCAvLyByYWRpdXNcbiAgICAgICAgYW5uby5maWxsQ29sb3IsIC8vIGNvbG9yXG4gICAgICAgIGFubm8ub3BhY2l0eSwgLy8gb3BhY2l0eSxcbiAgICAgICAgMSwgLy8gc3Ryb2tlV2lkdGhcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gc3Ryb2tlQ29sb3JcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5IC8vIHN0b2tlRGFzaEFycmF5XG4gICAgICAgICk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0Lm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dFggPSBhbm5vLmxhYmVsLnBvc2l0aW9uID09PSAncmlnaHQnID8gdy5nbG9iYWxzLmdyaWRXaWR0aCA6IDA7XG4gICAgICB2YXIgZWxUZXh0ID0gdGhpcy5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgIHg6IHRleHRYICsgYW5uby5sYWJlbC5vZmZzZXRYLFxuICAgICAgICB5OiAoeTIgfHwgeTEpICsgYW5uby5sYWJlbC5vZmZzZXRZIC0gMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGV4dEFuY2hvcjogYW5uby5sYWJlbC50ZXh0QW5jaG9yLFxuICAgICAgICBmb250U2l6ZTogYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogYW5uby5sYWJlbC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IGFubm8ubGFiZWwuc3R5bGUuY29sb3IsXG4gICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy1hbm5vdGF0aW9uLWxhYmVsICcgKyBhbm5vLmxhYmVsLnN0eWxlLmNzc0NsYXNzXG4gICAgICB9KTtcbiAgICAgIGVsVGV4dC5hdHRyKHtcbiAgICAgICAgcmVsOiBpbmRleFxuICAgICAgfSk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WUF4aXNBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WUF4aXNBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbGcgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLWFubm90YXRpb25zJ1xuICAgICAgfSk7XG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy55YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgIF90aGlzMi5hZGRZYXhpc0Fubm90YXRpb24oYW5ubywgZWxnLm5vZGUsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckFubm90YXRpb25zKGN0eCkge1xuICAgICAgdmFyIHcgPSBjdHgudztcbiAgICAgIHZhciBhbm5vcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzLWFubm90YXRpb25zLCAuYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9ucywgLmFwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbnMnKTtcbiAgICAgIGFubm9zID0gVXRpbHMubGlzdFRvQXJyYXkoYW5ub3MpO1xuICAgICAgYW5ub3MuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICB3aGlsZSAoYS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciBwb2ludFkgPSAwO1xuXG4gICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9pbnQgYW5ub3RhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGhvcml6b250YWwgYmFyIGNoYXJ0cy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhbm5vLnggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLngpO1xuICAgICAgICB2YXIgeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKGNhdEluZGV4ICsgMSkgKyAnKScpO1xuICAgICAgICB2YXIgeFBvcyA9IHBhcnNlRmxvYXQoeExhYmVsLmdldEF0dHJpYnV0ZSgneCcpKTtcbiAgICAgICAgeCA9IHhQb3M7XG4gICAgICAgIHZhciBhbm5vWSA9IGFubm8ueTtcblxuICAgICAgICBpZiAoYW5uby55ID09PSBudWxsKSB7XG4gICAgICAgICAgYW5ub1kgPSB3Lmdsb2JhbHMuc2VyaWVzW2Fubm8uc2VyaWVzSW5kZXhdW2NhdEluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vWSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSAtIHBhcnNlSW50KGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUpIC0gYW5uby5tYXJrZXIuc2l6ZTtcbiAgICAgICAgcG9pbnRZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAoYW5ub1kgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0gJiYgdy5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICAgIHkgPSAoYW5ub1kgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkgKyBwYXJzZUludChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSArIGFubm8ubWFya2VyLnNpemU7XG4gICAgICAgICAgcG9pbnRZID0gKGFubm9ZIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gKGFubm8ueCAtIHcuZ2xvYmFscy5taW5YKSAvICh3Lmdsb2JhbHMueFJhbmdlIC8gdy5nbG9iYWxzLmdyaWRXaWR0aCk7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChwYXJzZUZsb2F0KGFubm8ueSkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkgLSBwYXJzZUludChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSAtIGFubm8ubWFya2VyLnNpemU7XG4gICAgICAgIHBvaW50WSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gKGFubm8ueSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1thbm5vLnlBeGlzSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgICAgeSA9IChwYXJzZUZsb2F0KGFubm8ueSkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkgLSBwYXJzZUludChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSAtIGFubm8ubWFya2VyLnNpemU7XG4gICAgICAgICAgcG9pbnRZID0gKGFubm8ueSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDAgfHwgeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHJldHVybjtcbiAgICAgIHZhciBvcHRzUG9pbnRzID0ge1xuICAgICAgICBwU2l6ZTogYW5uby5tYXJrZXIuc2l6ZSxcbiAgICAgICAgcFdpZHRoOiBhbm5vLm1hcmtlci5zdHJva2VXaWR0aCxcbiAgICAgICAgcG9pbnRGaWxsQ29sb3I6IGFubm8ubWFya2VyLmZpbGxDb2xvcixcbiAgICAgICAgcG9pbnRTdHJva2VDb2xvcjogYW5uby5tYXJrZXIuc3Ryb2tlQ29sb3IsXG4gICAgICAgIHNoYXBlOiBhbm5vLm1hcmtlci5zaGFwZSxcbiAgICAgICAgcmFkaXVzOiBhbm5vLm1hcmtlci5yYWRpdXMsXG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9uLW1hcmtlciAnICsgYW5uby5tYXJrZXIuY3NzQ2xhc3NcbiAgICAgIH07XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmdyYXBoaWNzLmRyYXdNYXJrZXIoeCArIGFubm8ubWFya2VyLm9mZnNldFgsIHBvaW50WSArIGFubm8ubWFya2VyLm9mZnNldFksIG9wdHNQb2ludHMpO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHBvaW50Lm5vZGUpO1xuICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcbiAgICAgIHZhciBlbFRleHQgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogeCArIGFubm8ubGFiZWwub2Zmc2V0WCxcbiAgICAgICAgeTogeSArIGFubm8ubGFiZWwub2Zmc2V0WSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGV4dEFuY2hvcjogYW5uby5sYWJlbC50ZXh0QW5jaG9yLFxuICAgICAgICBmb250U2l6ZTogYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogYW5uby5sYWJlbC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IGFubm8ubGFiZWwuc3R5bGUuY29sb3IsXG4gICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9uLWxhYmVsICcgKyBhbm5vLmxhYmVsLnN0eWxlLmNzc0NsYXNzXG4gICAgICB9KTtcbiAgICAgIGVsVGV4dC5hdHRyKHtcbiAgICAgICAgcmVsOiBpbmRleFxuICAgICAgfSk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpO1xuXG4gICAgICBpZiAoYW5uby5jdXN0b21TVkcuU1ZHKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXBvaW50LWFubm90YXRpb25zLWN1c3RvbS1zdmcgJyArIGFubm8uY3VzdG9tU1ZHLmNzc0NsYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBnLmF0dHIoe1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHggKyBhbm5vLmN1c3RvbVNWRy5vZmZzZXRYLCBcIiwgXCIpLmNvbmNhdCh5ICsgYW5uby5jdXN0b21TVkcub2Zmc2V0WSwgXCIpXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBnLm5vZGUuaW5uZXJIVE1MID0gYW5uby5jdXN0b21TVkcuU1ZHO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZy5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BvaW50QW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BvaW50QW5ub3RhdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxnID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucydcbiAgICAgIH0pO1xuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMucG9pbnRzLm1hcChmdW5jdGlvbiAoYW5ubywgaW5kZXgpIHtcbiAgICAgICAgX3RoaXMzLmFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBlbGcubm9kZSwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcmllbnRhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZW50YXRpb25zKGFubm9zKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGFubm9JbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgYW5ub3MubWFwKGZ1bmN0aW9uIChhbm5vLCBpbmRleCkge1xuICAgICAgICBpZiAoYW5uby5sYWJlbC5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHZhciBpID0gYW5ub0luZGV4ICE9PSBudWxsID8gYW5ub0luZGV4IDogaW5kZXg7XG4gICAgICAgICAgdmFyIHhBbm5vID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb25zIC5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb24tbGFiZWxbcmVsPSdcIi5jb25jYXQoaSwgXCInXVwiKSk7XG5cbiAgICAgICAgICBpZiAoeEFubm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB4QW5ub0Nvb3JkID0geEFubm8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3gnLCBwYXJzZUZsb2F0KHhBbm5vLmdldEF0dHJpYnV0ZSgneCcpKSAtIHhBbm5vQ29vcmQuaGVpZ2h0ICsgNCk7XG5cbiAgICAgICAgICAgIGlmIChhbm5vLmxhYmVsLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3knLCBwYXJzZUZsb2F0KHhBbm5vLmdldEF0dHJpYnV0ZSgneScpKSArIHhBbm5vQ29vcmQud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeEFubm8uc2V0QXR0cmlidXRlKCd5JywgcGFyc2VGbG9hdCh4QW5uby5nZXRBdHRyaWJ1dGUoJ3knKSkgLSB4QW5ub0Nvb3JkLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFubm9Sb3RhdGluZ0NlbnRlciA9IF90aGlzNC5ncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoeEFubm8pO1xuXG4gICAgICAgICAgICB2YXIgeCA9IGFubm9Sb3RhdGluZ0NlbnRlci54O1xuICAgICAgICAgICAgdmFyIHkgPSBhbm5vUm90YXRpbmdDZW50ZXIueTtcbiAgICAgICAgICAgIHhBbm5vLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoLTkwIFwiLmNvbmNhdCh4LCBcIiBcIikuY29uY2F0KHksIFwiKVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQmFja2dyb3VuZFRvQW5ub1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCYWNrZ3JvdW5kVG9Bbm5vKGFubm9FbCwgYW5ubykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxHcmlkUmVjdCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjb29yZHMgPSBhbm5vRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgcGxlZnQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcubGVmdDtcbiAgICAgIHZhciBwcmlnaHQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcucmlnaHQ7XG4gICAgICB2YXIgcHRvcCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy50b3A7XG4gICAgICB2YXIgcGJvdHRvbSA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5ib3R0b207XG5cbiAgICAgIGlmIChhbm5vLmxhYmVsLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHB0b3AgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcubGVmdDtcbiAgICAgICAgcGJvdHRvbSA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5yaWdodDtcbiAgICAgICAgcGxlZnQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcudG9wO1xuICAgICAgICBwcmlnaHQgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcuYm90dG9tO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDEgPSBjb29yZHMubGVmdCAtIGVsR3JpZFJlY3QubGVmdCAtIHBsZWZ0O1xuICAgICAgdmFyIHkxID0gY29vcmRzLnRvcCAtIGVsR3JpZFJlY3QudG9wIC0gcHRvcDtcbiAgICAgIHZhciBlbFJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KHgxLCB5MSwgY29vcmRzLndpZHRoICsgcGxlZnQgKyBwcmlnaHQsIGNvb3Jkcy5oZWlnaHQgKyBwdG9wICsgcGJvdHRvbSwgMCwgYW5uby5sYWJlbC5zdHlsZS5iYWNrZ3JvdW5kLCAxLCBhbm5vLmxhYmVsLmJvcmRlcldpZHRoLCBhbm5vLmxhYmVsLmJvcmRlckNvbG9yLCAwKTtcbiAgICAgIHJldHVybiBlbFJlY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFubm90YXRpb25zQmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbm5vdGF0aW9uc0JhY2tncm91bmQoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoYW5ubywgaSwgdHlwZSkge1xuICAgICAgICB2YXIgYW5ub0xhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9ucyAuYXBleGNoYXJ0cy1cIikuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb24tbGFiZWxbcmVsPSdcIikuY29uY2F0KGksIFwiJ11cIikpO1xuXG4gICAgICAgIGlmIChhbm5vTGFiZWwpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gYW5ub0xhYmVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICB2YXIgZWxSZWN0ID0gX3RoaXM1LmFkZEJhY2tncm91bmRUb0Fubm8oYW5ub0xhYmVsLCBhbm5vKTtcblxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxSZWN0Lm5vZGUsIGFubm9MYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnhheGlzLm1hcChmdW5jdGlvbiAoYW5ubywgaSkge1xuICAgICAgICBhZGQoYW5ubywgaSwgJ3hheGlzJyk7XG4gICAgICB9KTtcbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnlheGlzLm1hcChmdW5jdGlvbiAoYW5ubywgaSkge1xuICAgICAgICBhZGQoYW5ubywgaSwgJ3lheGlzJyk7XG4gICAgICB9KTtcbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnBvaW50cy5tYXAoZnVuY3Rpb24gKGFubm8sIGkpIHtcbiAgICAgICAgYWRkKGFubm8sIGksICdwb2ludCcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGV4dChwYXJhbXMsIHB1c2hUb01lbW9yeSwgY29udGV4dCkge1xuICAgICAgdmFyIHggPSBwYXJhbXMueCxcbiAgICAgICAgICB5ID0gcGFyYW1zLnksXG4gICAgICAgICAgdGV4dCA9IHBhcmFtcy50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3IgPSBwYXJhbXMudGV4dEFuY2hvcixcbiAgICAgICAgICBfcGFyYW1zJGFwcGVuZFRvID0gcGFyYW1zLmFwcGVuZFRvLFxuICAgICAgICAgIGFwcGVuZFRvID0gX3BhcmFtcyRhcHBlbmRUbyA9PT0gdm9pZCAwID8gJy5hcGV4Y2hhcnRzLWlubmVyJyA6IF9wYXJhbXMkYXBwZW5kVG8sXG4gICAgICAgICAgZm9yZUNvbG9yID0gcGFyYW1zLmZvcmVDb2xvcixcbiAgICAgICAgICBmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gcGFyYW1zLmZvbnRGYW1pbHksXG4gICAgICAgICAgY3NzQ2xhc3MgPSBwYXJhbXMuY3NzQ2xhc3MsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aCA9IHBhcmFtcy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSBwYXJhbXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgIHJhZGl1cyA9IHBhcmFtcy5yYWRpdXMsXG4gICAgICAgICAgYm9yZGVyQ29sb3IgPSBwYXJhbXMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgX3BhcmFtcyRwYWRkaW5nTGVmdCA9IHBhcmFtcy5wYWRkaW5nTGVmdCxcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IF9wYXJhbXMkcGFkZGluZ0xlZnQgPT09IHZvaWQgMCA/IDQgOiBfcGFyYW1zJHBhZGRpbmdMZWZ0LFxuICAgICAgICAgIF9wYXJhbXMkcGFkZGluZ1JpZ2h0ID0gcGFyYW1zLnBhZGRpbmdSaWdodCxcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBfcGFyYW1zJHBhZGRpbmdSaWdodCA9PT0gdm9pZCAwID8gNCA6IF9wYXJhbXMkcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgIF9wYXJhbXMkcGFkZGluZ0JvdHRvbSA9IHBhcmFtcy5wYWRkaW5nQm90dG9tLFxuICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBfcGFyYW1zJHBhZGRpbmdCb3R0b20gPT09IHZvaWQgMCA/IDIgOiBfcGFyYW1zJHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgX3BhcmFtcyRwYWRkaW5nVG9wID0gcGFyYW1zLnBhZGRpbmdUb3AsXG4gICAgICAgICAgcGFkZGluZ1RvcCA9IF9wYXJhbXMkcGFkZGluZ1RvcCA9PT0gdm9pZCAwID8gMiA6IF9wYXJhbXMkcGFkZGluZ1RvcDtcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgdyA9IG1lLnc7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xuICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIHx8ICdzdGFydCcsXG4gICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSB8fCAnMTJweCcsXG4gICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseSxcbiAgICAgICAgZm9yZUNvbG9yOiBmb3JlQ29sb3IgfHwgdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yLFxuICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMtdGV4dCAnICsgY3NzQ2xhc3MgPyBjc3NDbGFzcyA6ICcnXG4gICAgICB9KTtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpO1xuICAgICAgdmFyIHRleHRSZWN0ID0gZWxUZXh0LmJib3goKTtcbiAgICAgIHZhciBlbFJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KHRleHRSZWN0LnggLSBwYWRkaW5nTGVmdCwgdGV4dFJlY3QueSAtIHBhZGRpbmdUb3AsIHRleHRSZWN0LndpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQsIHRleHRSZWN0LmhlaWdodCArIHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nVG9wLCByYWRpdXMsIGJhY2tncm91bmRDb2xvciwgMSwgYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZWxUZXh0LmJlZm9yZShlbFJlY3QpO1xuXG4gICAgICBpZiAocHVzaFRvTWVtb3J5KSB7XG4gICAgICAgIHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5wdXNoKHtcbiAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICBtZXRob2Q6IG1lLmFkZFRleHQsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgICAgYXBwZW5kVG86IGFwcGVuZFRvLFxuICAgICAgICAgICAgZm9yZUNvbG9yOiBmb3JlQ29sb3IsXG4gICAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICBjc3NDbGFzczogY3NzQ2xhc3MsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiBib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogcGFkZGluZ0xlZnQsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHBhZGRpbmdSaWdodCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiBwYWRkaW5nVG9wXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFBvaW50QW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50QW5ub3RhdGlvbkV4dGVybmFsKHBhcmFtcywgcHVzaFRvTWVtb3J5LCBjb250ZXh0KSB7XG4gICAgICB0aGlzLmFkZEFubm90YXRpb25FeHRlcm5hbCh7XG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBwdXNoVG9NZW1vcnk6IHB1c2hUb01lbW9yeSxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHlwZTogJ3BvaW50JyxcbiAgICAgICAgY29udGV4dE1ldGhvZDogY29udGV4dC5hZGRQb2ludEFubm90YXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFlheGlzQW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFlheGlzQW5ub3RhdGlvbkV4dGVybmFsKHBhcmFtcywgcHVzaFRvTWVtb3J5LCBjb250ZXh0KSB7XG4gICAgICB0aGlzLmFkZEFubm90YXRpb25FeHRlcm5hbCh7XG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBwdXNoVG9NZW1vcnk6IHB1c2hUb01lbW9yeSxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHlwZTogJ3lheGlzJyxcbiAgICAgICAgY29udGV4dE1ldGhvZDogY29udGV4dC5hZGRZYXhpc0Fubm90YXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSAvLyBUaGUgYWRkWGF4aXNBbm5vdGF0aW9uIG1ldGhvZCByZXF1aXJlcyBhIHBhcmVudCBjbGFzcywgYW5kIHVzZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBleHRlcm5hbGx5IG9uIHRoZSBjaGFydCBpbnN0YW5jZSBtYXkgbm90IHNwZWNpZnkgcGFyZW50LCBoZW5jZSBhIGRpZmZlcmVudCBtZXRob2RcblxuICB9LCB7XG4gICAga2V5OiBcImFkZFhheGlzQW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFhheGlzQW5ub3RhdGlvbkV4dGVybmFsKHBhcmFtcywgcHVzaFRvTWVtb3J5LCBjb250ZXh0KSB7XG4gICAgICB0aGlzLmFkZEFubm90YXRpb25FeHRlcm5hbCh7XG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBwdXNoVG9NZW1vcnk6IHB1c2hUb01lbW9yeSxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHlwZTogJ3hheGlzJyxcbiAgICAgICAgY29udGV4dE1ldGhvZDogY29udGV4dC5hZGRYYXhpc0Fubm90YXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFubm90YXRpb25FeHRlcm5hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBbm5vdGF0aW9uRXh0ZXJuYWwoX3JlZikge1xuICAgICAgdmFyIHBhcmFtcyA9IF9yZWYucGFyYW1zLFxuICAgICAgICAgIHB1c2hUb01lbW9yeSA9IF9yZWYucHVzaFRvTWVtb3J5LFxuICAgICAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgICBjb250ZXh0TWV0aG9kID0gX3JlZi5jb250ZXh0TWV0aG9kO1xuICAgICAgdmFyIG1lID0gY29udGV4dDtcbiAgICAgIHZhciB3ID0gbWUudztcbiAgICAgIHZhciBwYXJlbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb25zXCIpKTtcbiAgICAgIHZhciBpbmRleCA9IHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCArIDE7XG4gICAgICB2YXIgb3B0ID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIHZhciBheGVzQW5ubyA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUgPT09ICd4YXhpcycgPyBvcHQueEF4aXNBbm5vdGF0aW9uIDogdHlwZSA9PT0gJ3lheGlzJyA/IG9wdC55QXhpc0Fubm90YXRpb24gOiBvcHQucG9pbnRBbm5vdGF0aW9uKTtcbiAgICAgIHZhciBhbm5vID0gVXRpbHMuZXh0ZW5kKGF4ZXNBbm5vLCBwYXJhbXMpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAneGF4aXMnOlxuICAgICAgICAgIHRoaXMuYWRkWGF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3lheGlzJzpcbiAgICAgICAgICB0aGlzLmFkZFlheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgICAgdGhpcy5hZGRQb2ludEFubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGFkZCBiYWNrZ3JvdW5kXG5cblxuICAgICAgdmFyIGF4ZXNBbm5vTGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb25zIC5hcGV4Y2hhcnRzLVwiKS5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbi1sYWJlbFtyZWw9J1wiKS5jb25jYXQoaW5kZXgsIFwiJ11cIikpO1xuICAgICAgdmFyIGVsUmVjdCA9IHRoaXMuYWRkQmFja2dyb3VuZFRvQW5ubyhheGVzQW5ub0xhYmVsLCBhbm5vKTtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxSZWN0Lm5vZGUsIGF4ZXNBbm5vTGFiZWwpO1xuXG4gICAgICBpZiAocHVzaFRvTWVtb3J5KSB7XG4gICAgICAgIHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5wdXNoKHtcbiAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICBtZXRob2Q6IGNvbnRleHRNZXRob2QsXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9ucztcbn0oKTtcblxuLyoqXG4gKiBEYXRlVGltZSBDbGFzcyB0byBtYW5pcHVsYXRlIGRhdGV0aW1lIHZhbHVlcy5cbiAqXG4gKiBAbW9kdWxlIERhdGVUaW1lXG4gKiovXG5cbnZhciBEYXRlVGltZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGltZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm1vbnRoczMxID0gWzEsIDMsIDUsIDcsIDgsIDEwLCAxMl07XG4gICAgdGhpcy5tb250aHMzMCA9IFsyLCA0LCA2LCA5LCAxMV07XG4gICAgdGhpcy5kYXlzQ250T2ZZZWFyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRlVGltZSwgW3tcbiAgICBrZXk6IFwiaXNWYWxpZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZSkge1xuICAgICAgcmV0dXJuICFpc05hTih0aGlzLnBhcnNlRGF0ZShkYXRlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVUQ1RpbWVTdGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVVENUaW1lU3RhbXAoZGF0ZVN0cikge1xuICAgICAgaWYgKCFEYXRlLnBhcnNlKGRhdGVTdHIpKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoZGF0ZVN0cikudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMjUpKS5nZXRUaW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cikge1xuICAgICAgdmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cik7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENUaW1lU3RhbXAoZGF0ZVN0cik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSBEYXRlLnBhcnNlKGRhdGVTdHIucmVwbGFjZSgvLS9nLCAnLycpLnJlcGxhY2UoL1thLXpdKy9naSwgJyAnKSk7XG4gICAgICBvdXRwdXQgPSB0aGlzLmdldFVUQ1RpbWVTdGFtcChvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTI1MjE2Ny82NDk1MDQzXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmVhdEFzVXRjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyZWF0QXNVdGMoZGF0ZVN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgcmVzdWx0LnNldE1pbnV0ZXMocmVzdWx0LmdldE1pbnV0ZXMoKSAtIHJlc3VsdC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NjM4MDE4L2N1cnJlbnQtdGltZS1mb3JtYXR0aW5nLXdpdGgtamF2YXNjcmlwdCNhbnN3ZXItMTQ2MzgxOTFcblxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgIHZhciB1dGMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgY29udmVydFRvVVRDID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgdmFyIGxvY2FsZSA9IHRoaXMudy5nbG9iYWxzLmxvY2FsZTtcbiAgICAgIHZhciBNTU1NID0gWydcXHgwMCddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG9jYWxlLm1vbnRocykpO1xuICAgICAgdmFyIE1NTSA9IFsnXFx4MDEnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydE1vbnRocykpO1xuICAgICAgdmFyIGRkZGQgPSBbJ1xceDAyJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NhbGUuZGF5cykpO1xuICAgICAgdmFyIGRkZCA9IFsnXFx4MDMnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydERheXMpKTtcblxuICAgICAgZnVuY3Rpb24gaWkoaSwgbGVuKSB7XG4gICAgICAgIHZhciBzID0gaSArICcnO1xuICAgICAgICBsZW4gPSBsZW4gfHwgMjtcblxuICAgICAgICB3aGlsZSAocy5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICBzID0gJzAnICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udmVydFRvVVRDKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLnRyZWF0QXNVdGMoZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ID0gdXRjID8gZGF0ZS5nZXRVVENGdWxsWWVhcigpIDogZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXl5eSsvZywgJyQxJyArIHkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXkvZywgJyQxJyArIHkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMikpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peS9nLCAnJDEnICsgeSk7XG4gICAgICB2YXIgTSA9ICh1dGMgPyBkYXRlLmdldFVUQ01vbnRoKCkgOiBkYXRlLmdldE1vbnRoKCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTU0rL2csICckMScgKyBNTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTS9nLCAnJDEnICsgTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NL2csICckMScgKyBpaShNKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlNL2csICckMScgKyBNKTtcbiAgICAgIHZhciBkID0gdXRjID8gZGF0ZS5nZXRVVENEYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZGQrL2csICckMScgKyBkZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZC9nLCAnJDEnICsgZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkL2csICckMScgKyBpaShkKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlkL2csICckMScgKyBkKTtcbiAgICAgIHZhciBIID0gdXRjID8gZGF0ZS5nZXRVVENIb3VycygpIDogZGF0ZS5nZXRIb3VycygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pSEgrL2csICckMScgKyBpaShIKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlIL2csICckMScgKyBIKTtcbiAgICAgIHZhciBoID0gSCA+IDEyID8gSCAtIDEyIDogSCA9PT0gMCA/IDEyIDogSDtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWhoKy9nLCAnJDEnICsgaWkoaCkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0paC9nLCAnJDEnICsgaCk7XG4gICAgICB2YXIgbSA9IHV0YyA/IGRhdGUuZ2V0VVRDTWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSltbSsvZywgJyQxJyArIGlpKG0pKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKW0vZywgJyQxJyArIG0pO1xuICAgICAgdmFyIHMgPSB1dGMgPyBkYXRlLmdldFVUQ1NlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pc3MrL2csICckMScgKyBpaShzKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlzL2csICckMScgKyBzKTtcbiAgICAgIHZhciBmID0gdXRjID8gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmZmYrL2csICckMScgKyBpaShmLCAzKSk7XG4gICAgICBmID0gTWF0aC5yb3VuZChmIC8gMTApO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZmYvZywgJyQxJyArIGlpKGYpKTtcbiAgICAgIGYgPSBNYXRoLnJvdW5kKGYgLyAxMCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmL2csICckMScgKyBmKTtcbiAgICAgIHZhciBUID0gSCA8IDEyID8gJ0FNJyA6ICdQTSc7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlUVCsvZywgJyQxJyArIFQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pVC9nLCAnJDEnICsgVC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHQgPSBULnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSl0dCsvZywgJyQxJyArIHQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pdC9nLCAnJDEnICsgdC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHR6ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBLID0gdXRjIHx8ICF0eiA/ICdaJyA6IHR6ID4gMCA/ICcrJyA6ICctJztcblxuICAgICAgaWYgKCF1dGMpIHtcbiAgICAgICAgdHogPSBNYXRoLmFicyh0eik7XG4gICAgICAgIHZhciB0ekhycyA9IE1hdGguZmxvb3IodHogLyA2MCk7XG4gICAgICAgIHZhciB0ek1pbiA9IHR6ICUgNjA7XG4gICAgICAgIEsgKz0gaWkodHpIcnMpICsgJzonICsgaWkodHpNaW4pO1xuICAgICAgfVxuXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlLL2csICckMScgKyBLKTtcbiAgICAgIHZhciBkYXkgPSAodXRjID8gZGF0ZS5nZXRVVENEYXkoKSA6IGRhdGUuZ2V0RGF5KCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkZFswXSwgJ2cnKSwgZGRkZFtkYXldKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkWzBdLCAnZycpLCBkZGRbZGF5XSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKE1NTU1bMF0sICdnJyksIE1NTU1bTV0pO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobmV3IFJlZ0V4cChNTU1bMF0sICdnJyksIE1NTVtNXSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKTtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGltZVVuaXRzZnJvbVRpbWVzdGFtcChtaW5YLCBtYXhYKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pblggPSB3LmNvbmZpZy54YXhpcy5taW47XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXhYID0gdy5jb25maWcueGF4aXMubWF4O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWWVhciA9IG5ldyBEYXRlKG1pblgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWF4WWVhciA9IG5ldyBEYXRlKG1heFgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWluTW9udGggPSBuZXcgRGF0ZShtaW5YKS5nZXRNb250aCgpO1xuICAgICAgdmFyIG1heE1vbnRoID0gbmV3IERhdGUobWF4WCkuZ2V0TW9udGgoKTtcbiAgICAgIHZhciBtaW5EYXRlID0gbmV3IERhdGUobWluWCkuZ2V0RGF0ZSgpO1xuICAgICAgdmFyIG1heERhdGUgPSBuZXcgRGF0ZShtYXhYKS5nZXREYXRlKCk7XG4gICAgICB2YXIgbWluSG91ciA9IG5ldyBEYXRlKG1pblgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWF4SG91ciA9IG5ldyBEYXRlKG1heFgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWluTWludXRlID0gbmV3IERhdGUobWluWCkuZ2V0TWludXRlcygpO1xuICAgICAgdmFyIG1heE1pbnV0ZSA9IG5ldyBEYXRlKG1heFgpLmdldE1pbnV0ZXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbk1pbnV0ZTogbWluTWludXRlLFxuICAgICAgICBtYXhNaW51dGU6IG1heE1pbnV0ZSxcbiAgICAgICAgbWluSG91cjogbWluSG91cixcbiAgICAgICAgbWF4SG91cjogbWF4SG91cixcbiAgICAgICAgbWluRGF0ZTogbWluRGF0ZSxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZSxcbiAgICAgICAgbWluTW9udGg6IG1pbk1vbnRoLFxuICAgICAgICBtYXhNb250aDogbWF4TW9udGgsXG4gICAgICAgIG1pblllYXI6IG1pblllYXIsXG4gICAgICAgIG1heFllYXI6IG1heFllYXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxjYXRlTGFzdERheXNPZk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGNhdGVMYXN0RGF5c09mTW9udGgobW9udGgsIHllYXIsIHN1YnRyYWN0KSB7XG4gICAgICB2YXIgZGF5cyA9IHRoaXMuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKTsgLy8gd2hhdGV2ZXIgZGF5cyB3ZSBnZXQsIHN1YnRyYWN0IHRoZSBudW1iZXIgb2YgZGF5cyBhc2tlZFxuXG4gICAgICByZXR1cm4gZGF5cyAtIHN1YnRyYWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURheXNPZlllYXIoeWVhcikge1xuICAgICAgdmFyIGRheXMgPSAzNjU7XG5cbiAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgZGF5cyA9IDM2NjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZVJlbWFpbmluZ0RheXNPZlllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcih5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgdmFyIGRheU9mWWVhciA9IHRoaXMuZGF5c0NudE9mWWVhclttb250aF0gKyBkYXRlO1xuICAgICAgaWYgKG1vbnRoID4gMSAmJiB0aGlzLmlzTGVhcFllYXIoKSkgZGF5T2ZZZWFyKys7XG4gICAgICByZXR1cm4gZGF5T2ZZZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZNb250aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKSB7XG4gICAgICB2YXIgZGF5cyA9IDMwO1xuICAgICAgbW9udGggPSBVdGlscy5tb250aE1vZChtb250aCk7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHRoaXMubW9udGhzMzAuaW5kZXhPZihtb250aCkgPiAtMTpcbiAgICAgICAgICBpZiAobW9udGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5tb250aHMzMS5pbmRleE9mKG1vbnRoKSA+IC0xOlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGVUaW1lO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRGVmYXVsdCBDbGFzcyBmb3Igc2V0dGluZyBkZWZhdWx0IG9wdGlvbnMgZm9yIGFsbCBjaGFydCB0eXBlcy5cbiAqXG4gKiBAbW9kdWxlIERlZmF1bHRzXG4gKiovXG5cbnZhciBEZWZhdWx0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlZmF1bHRzKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdHMpO1xuXG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZWZhdWx0cywgW3tcbiAgICBrZXk6IFwibGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBlYXNpbmc6ICdzd2luZydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogNSxcbiAgICAgICAgICBjdXJ2ZTogJ3N0cmFpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgc2l6ZU9mZnNldDogNlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BhcmtsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwYXJrbGluZShkZWZhdWx0cykge1xuICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5zaG93ID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdHMueWF4aXNbMF0uZmxvYXRpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHJldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGVhc2luZzogJ3N3aW5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdjZW50ZXInXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjg1XG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNoYXBlOiAnc3F1YXJlJyxcbiAgICAgICAgICAgIHJhZGl1czogMixcbiAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnYmFyV2lkdGgnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyYWRpZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmRsZXN0aWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmRsZXN0aWNrKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgY29sb3JzOiBbJyMzMzMnXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShfcmVmKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBfcmVmLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4ID0gX3JlZi5kYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICB3ID0gX3JlZi53O1xuICAgICAgICAgICAgdmFyIG8gPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlT1tzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGggPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlSFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGwgPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlTFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGMgPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlQ1tzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiYXBleGNoYXJ0cy10b29sdGlwLWNhbmRsZXN0aWNrXCI+JyArICc8ZGl2Pk9wZW46IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgbyArICc8L3NwYW4+PC9kaXY+JyArICc8ZGl2PkhpZ2g6IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgaCArICc8L3NwYW4+PC9kaXY+JyArICc8ZGl2PkxvdzogPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPicgKyBsICsgJzwvc3Bhbj48L2Rpdj4nICsgJzxkaXY+Q2xvc2U6IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgYyArICc8L3NwYW4+PC9kaXY+JyArICc8L2Rpdj4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZUJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZUJhcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShfcmVmMikge1xuICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWYyLmN0eCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleCA9IF9yZWYyLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4ID0gX3JlZjIuZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgdyA9IF9yZWYyLnc7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB3Lmdsb2JhbHMuc2VyaWVzUmFuZ2VTdGFydFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsID0gJyc7XG4gICAgICAgICAgICB2YXIgZW5kVmFsID0gJyc7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3Nlcmllc0luZGV4XTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgZGF0ZXRpbWVPYmogPSBuZXcgRGF0ZVRpbWUoY3R4KTtcbiAgICAgICAgICAgICAgc3RhcnRWYWwgPSBkYXRldGltZU9iai5mb3JtYXREYXRlKG5ldyBEYXRlKHN0YXJ0KSwgdy5jb25maWcudG9vbHRpcC54LmZvcm1hdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGVuZFZhbCA9IGRhdGV0aW1lT2JqLmZvcm1hdERhdGUobmV3IERhdGUoZW5kKSwgdy5jb25maWcudG9vbHRpcC54LmZvcm1hdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIoc3RhcnQpO1xuICAgICAgICAgICAgICBlbmRWYWwgPSB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyKGVuZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5bGFiZWwgPSB3Lmdsb2JhbHMubGFiZWxzW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImFwZXhjaGFydHMtdG9vbHRpcC1yYW5nZWJhclwiPicgKyAnPGRpdj4gPHNwYW4gY2xhc3M9XCJzZXJpZXMtbmFtZVwiIHN0eWxlPVwiY29sb3I6ICcgKyBjb2xvciArICdcIj4nICsgKHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0ubmFtZSA/IHcuY29uZmlnLnNlcmllc1tzZXJpZXNJbmRleF0ubmFtZSA6ICcnKSArICc8L3NwYW4+PC9kaXY+JyArICc8ZGl2PiA8c3BhbiBjbGFzcz1cImNhdGVnb3J5XCI+JyArIHlsYWJlbCArICc6IDwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJ2YWx1ZSBzdGFydC12YWx1ZVwiPicgKyBzdGFydFZhbCArICc8L3NwYW4+IDxzcGFuIGNsYXNzPVwic2VwYXJhdG9yXCI+LTwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJ2YWx1ZSBlbmQtdmFsdWVcIj4nICsgZW5kVmFsICsgJzwvc3Bhbj48L2Rpdj4nICsgJzwvZGl2Pic7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiA0XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICB0eXBlOiAnZ3JhZGllbnQnLFxuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIHNoYWRlOiAnbGlnaHQnLFxuICAgICAgICAgICAgdHlwZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjY1LFxuICAgICAgICAgICAgb3BhY2l0eVRvOiAwLjUsXG4gICAgICAgICAgICBzdG9wczogWzAsIDEwMCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHNpemVPZmZzZXQ6IDZcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBmb2xsb3dDdXJzb3I6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJydXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJydXNoKGRlZmF1bHRzKSB7XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgICAgIGF1dG9TZWxlY3RlZDogJ3NlbGVjdGlvbicsXG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogMVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHJldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YWNrZWQxMDBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhY2tlZDEwMCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMub3B0cy5kYXRhTGFiZWxzID0gdGhpcy5vcHRzLmRhdGFMYWJlbHMgfHwge307XG4gICAgICB0aGlzLm9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgPSB0aGlzLm9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgfHwgdW5kZWZpbmVkO1xuICAgICAgdmFyIGV4aXN0aW5nRGF0YUxhYmVsRm9ybWF0dGVyID0gdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgdGhpcy5vcHRzLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIF90aGlzLm9wdHMueWF4aXNbaW5kZXhdLm1pbiA9IDA7XG4gICAgICAgIF90aGlzLm9wdHMueWF4aXNbaW5kZXhdLm1heCA9IDEwMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzQmFyID0gdGhpcy5vcHRzLmNoYXJ0LnR5cGUgPT09ICdiYXInO1xuXG4gICAgICBpZiAoaXNCYXIpIHtcbiAgICAgICAgdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyID0gZXhpc3RpbmdEYXRhTGFiZWxGb3JtYXR0ZXIgfHwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA/IHZhbC50b0ZpeGVkKDApICsgJyUnIDogdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIGxlZnQgYW5kIHJpZ2h0IHNwYWNpbmcgaW4gY2hhcnQgZm9yIGxpbmUvYXJlYS9zY2F0dGVyIGlmIHhheGlzIHR5cGUgPSBjYXRlZ29yeSBmb3IgdGhvc2UgY2hhcnRzIGJ5IGNvbnZlcnRpbmcgeGF4aXMgPSBudW1lcmljLiBOdW1lcmljL0RhdGV0aW1lIHhheGlzIHByZXZlbnRzIHRoZSB1bm5lY2Vzc2FyeSBzcGFjaW5nIGluIHRoZSBsZWZ0L3JpZ2h0IG9mIHRoZSBjaGFydCBhcmVhXG5cbiAgfSwge1xuICAgIGtleTogXCJidWJibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnbGlnaHQnLFxuICAgICAgICAgICAgaW52ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjU1LFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDAuNCxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMC44XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY2F0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYXR0ZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgaW50ZXJzZWN0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiA2LFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBzaXplT2Zmc2V0OiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWF0bWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlYXRtYXAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4OiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNoYXBlOiAnc3F1YXJlJyxcbiAgICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHJpZ2h0OiAyMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGllXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICBkb251dDoge1xuICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSkgKyAnJSc7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgc2hhZGU6ICdkYXJrJyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjM1LFxuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICBzdG9wczogWzAsIDEwMCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbnV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbnV0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDEpICsgJyUnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnZGFyaycsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC40LFxuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICB0eXBlOiAndmVydGljYWwnLFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDEsXG4gICAgICAgICAgICBvcGFjaXR5VG86IDEsXG4gICAgICAgICAgICBzdG9wczogWzcwLCA5OCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGFyKCkge1xuICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5zdHlsZS5mb250U2l6ZSA9ICcxM3B4JztcbiAgICAgIHRoaXMub3B0cy55YXhpc1swXS5sYWJlbHMub2Zmc2V0WSA9IDY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNhOGE4YTgnXSxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTFweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICAgICAgZm9sbG93Q3Vyc29yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFkaWFsQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGlhbEJhcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgZHluYW1pY0FuaW1hdGlvbjoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzcGVlZDogODAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNCxcbiAgICAgICAgICAgIGludmVyc2VDb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogJ2RpYWdvbmFsMicsXG4gICAgICAgICAgICBvcGFjaXR5RnJvbTogMSxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMSxcbiAgICAgICAgICAgIHN0b3BzOiBbNzAsIDk4LCAxMDBdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29udmVydENhdFRvTnVtZXJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0Q2F0VG9OdW1lcmljKG9wdHMpIHtcbiAgICAgIG9wdHMueGF4aXMudHlwZSA9ICdudW1lcmljJztcbiAgICAgIG9wdHMueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljID0gdHJ1ZTtcbiAgICAgIG9wdHMueGF4aXMubGFiZWxzID0gb3B0cy54YXhpcy5sYWJlbHMgfHwge307XG5cbiAgICAgIG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciA9IG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICBvcHRzLmNoYXJ0ID0gb3B0cy5jaGFydCB8fCB7fTtcbiAgICAgIG9wdHMuY2hhcnQuem9vbSA9IG9wdHMuY2hhcnQuem9vbSB8fCB3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC56b29tIHx8IHt9O1xuICAgICAgdmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSBvcHRzLnhheGlzLmxhYmVscy5mb3JtYXR0ZXI7XG4gICAgICB2YXIgbGFiZWxzID0gb3B0cy54YXhpcy5jYXRlZ29yaWVzICYmIG9wdHMueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggPyBvcHRzLnhheGlzLmNhdGVnb3JpZXMgOiBvcHRzLmxhYmVscztcblxuICAgICAgaWYgKGxhYmVscyAmJiBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcihsYWJlbHNbdmFsIC0gMV0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcHRzLnhheGlzLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgIG9wdHMubGFiZWxzID0gW107XG4gICAgICBvcHRzLmNoYXJ0Lnpvb20uZW5hYmxlZCA9IG9wdHMuY2hhcnQuem9vbS5lbmFibGVkIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlZmF1bHRzO1xufSgpO1xuXG4vKlxuICoqIFV0aWwgZnVuY3Rpb25zIHdoaWNoIGFyZSBkZXBlbmRlbnQgb24gQXBleENoYXJ0cyBpbnN0YW5jZVxuICovXG52YXIgQ29yZVV0aWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29yZVV0aWxzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3JlVXRpbHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29yZVV0aWxzLCBbe1xuICAgIGtleTogXCJnZXRTdGFja2VkU2VyaWVzVG90YWxzXCIsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVV0aWxzXG4gICAgICogcmV0dXJucyB0aGUgc3VtIG9mIGFsbCBpbmRpdmlkdWFsIHZhbHVlcyBpbiBhIG11bHRpcGxlIHN0YWNrZWQgc2VyaWVzXG4gICAgICogRWcuIHcuZ2xvYmFscy5zZXJpZXMgPSBbWzMyLDMzLDQzLDEyXSwgWzIsMyw1LDFdXVxuICAgICAqICBAcmV0dXJuIFszNCwzNiw0OCwxM11cbiAgICAgKiovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YWNrZWRTZXJpZXNUb3RhbHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0b3RhbCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcuZ2xvYmFscy5zZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ICs9IHcuZ2xvYmFscy5zZXJpZXNbal1baV07XG4gICAgICAgIH1cblxuICAgICAgICB0b3RhbC5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMuc3RhY2tlZFNlcmllc1RvdGFscyA9IHRvdGFsO1xuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0gLy8gZ2V0IHRvdGFsIG9mIHRoZSBhbGwgdmFsdWVzIGluc2lkZSBhbGwgc2VyaWVzXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbEJ5SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxCeUluZGV4KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnQgdHlwZXMgLSBwaWUgLyBkb251dCAvIGNpcmNsZVxuICAgICAgICByZXR1cm4gdGhpcy53LmNvbmZpZy5zZXJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXhpcyBjaGFydHMgLSBzdXBwb3J0aW5nIG11bHRpcGxlIHNlcmllc1xuICAgICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYyArIGN1cjtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU2VyaWVzTnVsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nlcmllc051bGwoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgciA9IFtdO1xuXG4gICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnQgdHlwZXMgLSBwaWUgLyBkb251dCAvIGNpcmNsZVxuICAgICAgICByID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXhpcyBjaGFydHMgLSBzdXBwb3J0aW5nIG11bHRpcGxlIHNlcmllc1xuICAgICAgICByID0gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZCAhPT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWVzSGF2ZVNhbWVWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5zZXJpZXNbaW5kZXhdLmV2ZXJ5KGZ1bmN0aW9uICh2YWwsIGksIGFycikge1xuICAgICAgICByZXR1cm4gdmFsID09PSBhcnJbMF07XG4gICAgICB9KTtcbiAgICB9IC8vIG1heFZhbHNJbkFycmF5SW5kZXggaXMgdGhlIGluZGV4IG9mIHNlcmllc1tdIHdoaWNoIGhhcyB0aGUgbGFyZ2VzdCBudW1iZXIgb2YgaXRlbXNcblxuICB9LCB7XG4gICAga2V5OiBcImdldExhcmdlc3RTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFyZ2VzdFNlcmllcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXggPSB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB9KS5pbmRleE9mKE1hdGgubWF4LmFwcGx5KE1hdGgsIHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aDtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhcmdlc3RNYXJrZXJTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RNYXJrZXJTaXplKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIG0pO1xuICAgICAgfSk7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA9IHNpemU7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiByZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiBhIHNlcmllc1xuICAgICAqIEVnLiB3Lmdsb2JhbHMuc2VyaWVzID0gW1szMiwzMyw0MywxMl0sIFsyLDMsNSwxXV1cbiAgICAgKiAgQHJldHVybiBbMTIwLCAxMV1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMuc2VyaWVzVG90YWxzID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHNlcltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9yIHBpZS9kb251dHMvZ2F1Z2VzXG4gICAgICAgICAgdG90YWwgKz0gc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc1RvdGFsc1hSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbHNYUmFuZ2UobWluWCwgbWF4WCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2VyaWVzVG90YWxzWFJhbmdlID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzWFtpbmRleF1bal0gPiBtaW5YICYmIHcuZ2xvYmFscy5zZXJpZXNYW2luZGV4XVtqXSA8IG1heFgpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHNlcltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXJpZXNUb3RhbHNYUmFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlVXRpbHNcbiAgICAgKiByZXR1cm5zIHRoZSBwZXJjZW50YWdlIHZhbHVlIG9mIGFsbCBpbmRpdmlkdWFsIHZhbHVlcyB3aGljaCBjYW4gYmUgdXNlZCBpbiBhIDEwMCUgc3RhY2tlZCBzZXJpZXNcbiAgICAgKiBFZy4gdy5nbG9iYWxzLnNlcmllcyA9IFtbMzIsIDMzLCA0MywgMTJdLCBbMiwgMywgNSwgMV1dXG4gICAgICogIEByZXR1cm4gW1s5NC4xMSwgOTEuNjYsIDg5LjU4LCA5Mi4zMF0sIFs1Ljg4LCA4LjMzLCAxMC40MSwgNy43XV1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQZXJjZW50U2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcmNlbnRTZXJpZXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5zZXJpZXNQZXJjZW50ID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlcmllc1BlcmNlbnQgPSBbXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHcuZ2xvYmFscy5zdGFja2VkU2VyaWVzVG90YWxzW2pdO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAxMDAgKiBzZXJbal0gLyB0b3RhbDtcbiAgICAgICAgICAgIHNlcmllc1BlcmNlbnQucHVzaChwZXJjZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90b3RhbCA9IHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgIHZhciBfcGVyY2VudCA9IDEwMCAqIHNlciAvIF90b3RhbDtcblxuICAgICAgICAgIHNlcmllc1BlcmNlbnQucHVzaChfcGVyY2VudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzUGVyY2VudDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxjdWxhdGVkUmF0aW9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWRSYXRpb3MoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciB5UmF0aW8gPSBbXTtcbiAgICAgIHZhciBpbnZlcnRlZFlSYXRpbyA9IDA7XG4gICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgIHZhciBpbml0aWFsWFJhdGlvID0gMDtcbiAgICAgIHZhciBpbnZlcnRlZFhSYXRpbyA9IDA7XG4gICAgICB2YXIgelJhdGlvID0gMDtcbiAgICAgIHZhciBiYXNlTGluZVkgPSBbXTtcbiAgICAgIHZhciBiYXNlTGluZUludmVydGVkWSA9IDAuMTtcbiAgICAgIHZhciBiYXNlTGluZVggPSAwO1xuICAgICAgZ2wueVJhbmdlID0gW107XG5cbiAgICAgIGlmIChnbC5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5taW5ZQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ2wueVJhbmdlLnB1c2goTWF0aC5hYnMoZ2wubWluWUFycltpXSAtIGdsLm1heFlBcnJbaV0pKTtcbiAgICAgICAgICBiYXNlTGluZVkucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wueVJhbmdlLnB1c2goTWF0aC5hYnMoZ2wubWluWSAtIGdsLm1heFkpKTtcbiAgICAgIH1cblxuICAgICAgZ2wueFJhbmdlID0gTWF0aC5hYnMoZ2wubWF4WCAtIGdsLm1pblgpO1xuICAgICAgZ2wuelJhbmdlID0gTWF0aC5hYnMoZ2wubWF4WiAtIGdsLm1pblopOyAvLyBtdWx0aXBsZSB5IGF4aXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGdsLnlSYW5nZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgeVJhdGlvLnB1c2goZ2wueVJhbmdlW19pXSAvIGdsLmdyaWRIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB4UmF0aW8gPSBnbC54UmFuZ2UgLyBnbC5ncmlkV2lkdGg7XG4gICAgICBpbml0aWFsWFJhdGlvID0gTWF0aC5hYnMoZ2wuaW5pdGlhbG1heFggLSBnbC5pbml0aWFsbWluWCkgLyBnbC5ncmlkV2lkdGg7XG4gICAgICBpbnZlcnRlZFlSYXRpbyA9IGdsLnlSYW5nZSAvIGdsLmdyaWRXaWR0aDtcbiAgICAgIGludmVydGVkWFJhdGlvID0gZ2wueFJhbmdlIC8gZ2wuZ3JpZEhlaWdodDtcbiAgICAgIHpSYXRpbyA9IGdsLnpSYW5nZSAvIGdsLmdyaWRIZWlnaHQgKiAxNjtcblxuICAgICAgaWYgKGdsLm1pblkgIT09IE51bWJlci5NSU5fVkFMVUUgJiYgTWF0aC5hYnMoZ2wubWluWSkgIT09IDApIHtcbiAgICAgICAgLy8gTmVnYXRpdmUgbnVtYmVycyBwcmVzZW50IGluIHNlcmllc1xuICAgICAgICBnbC5oYXNOZWdzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICBiYXNlTGluZVkgPSBbXTsgLy8gYmFzZWxpbmUgdmFyaWFibGVzIGlzIHRoZSAwIG9mIHRoZSB5YXhpcyB3aGljaCB3aWxsIGJlIG5lZWRlZCB3aGVuIHRoZXJlIGFyZSBuZWdhdGl2ZXNcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB5UmF0aW8ubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZQXJyW19pMl0gLyB5UmF0aW9bX2kyXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZIC8geVJhdGlvWzBdKTtcblxuICAgICAgICBpZiAoZ2wubWluWSAhPT0gTnVtYmVyLk1JTl9WQUxVRSAmJiBNYXRoLmFicyhnbC5taW5ZKSAhPT0gMCkge1xuICAgICAgICAgIGJhc2VMaW5lSW52ZXJ0ZWRZID0gLWdsLm1pblkgLyBpbnZlcnRlZFlSYXRpbzsgLy8gdGhpcyBpcyBmb3IgYmFyIGNoYXJ0XG5cbiAgICAgICAgICBiYXNlTGluZVggPSBnbC5taW5YIC8geFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHlSYXRpbzogeVJhdGlvLFxuICAgICAgICBpbnZlcnRlZFlSYXRpbzogaW52ZXJ0ZWRZUmF0aW8sXG4gICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICB4UmF0aW86IHhSYXRpbyxcbiAgICAgICAgaW5pdGlhbFhSYXRpbzogaW5pdGlhbFhSYXRpbyxcbiAgICAgICAgaW52ZXJ0ZWRYUmF0aW86IGludmVydGVkWFJhdGlvLFxuICAgICAgICBiYXNlTGluZUludmVydGVkWTogYmFzZUxpbmVJbnZlcnRlZFksXG4gICAgICAgIGJhc2VMaW5lWTogYmFzZUxpbmVZLFxuICAgICAgICBiYXNlTGluZVg6IGJhc2VMaW5lWFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvZ1NlcmllcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnNlcmllc0xvZyA9IHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2ldICYmIHcuY29uZmlnLnlheGlzW2ldLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgcmV0dXJuIHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbG9nVmFsID0gKE1hdGgubG9nKGQpIC0gTWF0aC5sb2cody5nbG9iYWxzLm1pbllBcnJbaV0pKSAvIChNYXRoLmxvZyh3Lmdsb2JhbHMubWF4WUFycltpXSkgLSBNYXRoLmxvZyh3Lmdsb2JhbHMubWluWUFycltpXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ1ZhbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc0xvZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nWVJhdGlvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dZUmF0aW9zKHlSYXRpbykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIGdsLnlMb2dSYXRpbyA9IHlSYXRpby5zbGljZSgpO1xuICAgICAgZ2wubG9nWVJhbmdlID0gZ2wueVJhbmdlLm1hcChmdW5jdGlvbiAoeVJhbmdlLCBpKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tpXSAmJiBfdGhpcy53LmNvbmZpZy55YXhpc1tpXS5sb2dhcml0aG1pYykge1xuICAgICAgICAgIHZhciBtYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgIHZhciByYW5nZSA9IDE7XG4gICAgICAgICAgZ2wuc2VyaWVzTG9nLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3NpXSAmJiB3LmNvbmZpZy55YXhpc1tzaV0ubG9nYXJpdGhtaWMpIHtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgodiwgbWF4WSk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKHYsIG1pblkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByYW5nZSA9IE1hdGgucG93KGdsLnlSYW5nZVtpXSwgTWF0aC5hYnMobWluWSAtIG1heFkpIC8gZ2wueVJhbmdlW2ldKTtcbiAgICAgICAgICBnbC55TG9nUmF0aW9baV0gPSByYW5nZSAvIGdsLmdyaWRIZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnbC55TG9nUmF0aW87XG4gICAgfSAvLyBTb21lIGNvbmZpZyBvYmplY3RzIGNhbiBiZSBhcnJheSAtIGFuZCB3ZSBuZWVkIHRvIGV4dGVuZCB0aGVtIGNvcnJlY3RseVxuXG4gIH1dLCBbe1xuICAgIGtleTogXCJjaGVja0NvbWJvU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29tYm9TZXJpZXMoc2VyaWVzKSB7XG4gICAgICB2YXIgY29tYm9DaGFydHMgPSBmYWxzZTtcbiAgICAgIHZhciBjb21ib0NoYXJ0c0hhc0JhcnMgPSBmYWxzZTsgLy8gaWYgdXNlciBzcGVjaWZpZWQgYSB0eXBlIGluIHNlcmllcyB0b28sIHR1cm4gb24gY29tYm9DaGFydHMgZmxhZ1xuXG4gICAgICBpZiAoc2VyaWVzLmxlbmd0aCAmJiB0eXBlb2Ygc2VyaWVzWzBdLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbWJvQ2hhcnRzID0gdHJ1ZTtcbiAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBpZiAocy50eXBlID09PSAnYmFyJyB8fCBzLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBjb21ib0NoYXJ0c0hhc0JhcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbWJvQ2hhcnRzOiBjb21ib0NoYXJ0cyxcbiAgICAgICAgY29tYm9DaGFydHNIYXNCYXJzOiBjb21ib0NoYXJ0c0hhc0JhcnNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZEFycmF5UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQXJyYXlQcm9wcyhjb25maWdJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMueWF4aXMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ0luc3RhbmNlLmV4dGVuZFlBeGlzKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucy55YXhpcykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5ub3RhdGlvbnMueGF4aXMpIHtcbiAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb25zLnBvaW50cykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRQb2ludEFubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlVXRpbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDb25maWcgQ2xhc3MgZm9yIGV4dGVuZGluZyB1c2VyIG9wdGlvbnMgd2l0aCBwcmUtZGVmaW5lZCBBcGV4Q2hhcnRzIGNvbmZpZy5cbiAqXG4gKiBAbW9kdWxlIENvbmZpZ1xuICoqL1xuXG52YXIgQ29uZmlnID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZmlnKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlnKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29uZmlnLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyhvcHRzKTtcbiAgICAgIHRoaXMuY2hhcnRUeXBlID0gb3B0cy5jaGFydC50eXBlO1xuXG4gICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdoaXN0b2dyYW0nKSB7XG4gICAgICAgIC8vIHRlY2huaWNhbGx5LCBhIGhpc3RvZ3JhbSBjYW4gYmUgZHJhd24gYnkgYSBjb2x1bW4gY2hhcnQgd2l0aCBubyBzcGFjZXMgaW4gYmV0d2VlblxuICAgICAgICBvcHRzLmNoYXJ0LnR5cGUgPSAnYmFyJztcbiAgICAgICAgb3B0cyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICBjb2x1bW5XaWR0aDogJzk5Ljk5JSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBvcHRzLnNlcmllcyA9IHRoaXMuY2hlY2tFbXB0eVNlcmllcyhvcHRzLnNlcmllcyk7XG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpcyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZEFubm90YXRpb25zKG9wdHMpO1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdGlvbnMuaW5pdCgpO1xuICAgICAgdmFyIG5ld0RlZmF1bHRzID0ge307XG5cbiAgICAgIGlmIChvcHRzICYmIF90eXBlb2Yob3B0cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBjaGFydERlZmF1bHRzID0ge307XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJ0VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmxpbmUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYXJlYSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmJhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjYW5kbGVzdGljayc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuY2FuZGxlc3RpY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFuZ2VCYXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLnJhbmdlQmFyKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hpc3RvZ3JhbSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYmFyKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2J1YmJsZSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYnViYmxlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NjYXR0ZXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLnNjYXR0ZXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaGVhdG1hcCc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuaGVhdG1hcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwaWUnOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLnBpZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkb251dCc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuZG9udXQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkYXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLnJhZGFyKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JhZGlhbEJhcic6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMucmFkaWFsQmFyKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMubGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuY2hhcnQuYnJ1c2ggJiYgb3B0cy5jaGFydC5icnVzaC5lbmFibGVkKSB7XG4gICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmJydXNoKGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuY2hhcnQuc3RhY2tlZCAmJiBvcHRzLmNoYXJ0LnN0YWNrVHlwZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgZGVmYXVsdHMuc3RhY2tlZDEwMCgpO1xuICAgICAgICB9IC8vIElmIHVzZXIgaGFzIHNwZWNpZmllZCBhIGRhcmsgdGhlbWUsIG1ha2UgdGhlIHRvb2x0aXAgZGFyayB0b29cblxuXG4gICAgICAgIHRoaXMuY2hlY2tGb3JEYXJrVGhlbWUod2luZG93LkFwZXgpOyAvLyBjaGVjayBnbG9iYWwgd2luZG93IEFwZXggb3B0aW9uc1xuXG4gICAgICAgIHRoaXMuY2hlY2tGb3JEYXJrVGhlbWUob3B0cyk7IC8vIGNoZWNrIGxvY2FsbHkgcGFzc2VkIG9wdGlvbnNcblxuICAgICAgICBvcHRzLnhheGlzID0gb3B0cy54YXhpcyB8fCB3aW5kb3cuQXBleC54YXhpcyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbWJvID0gQ29yZVV0aWxzLmNoZWNrQ29tYm9TZXJpZXMob3B0cy5zZXJpZXMpO1xuXG4gICAgICAgIGlmICgob3B0cy5jaGFydC50eXBlID09PSAnbGluZScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnYXJlYScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnc2NhdHRlcicpICYmICFjb21iby5jb21ib0NoYXJ0c0hhc0JhcnMgJiYgb3B0cy54YXhpcy50eXBlICE9PSAnZGF0ZXRpbWUnICYmIG9wdHMueGF4aXMudHlwZSAhPT0gJ251bWVyaWMnICYmIG9wdHMueGF4aXMudGlja1BsYWNlbWVudCAhPT0gJ2JldHdlZW4nKSB7XG4gICAgICAgICAgb3B0cyA9IERlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWMob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5zcGFya2xpbmUgJiYgb3B0cy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZCB8fCB3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC5zcGFya2xpbmUgJiYgd2luZG93LkFwZXguY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQpIHtcbiAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuc3BhcmtsaW5lKGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGVmYXVsdHMgPSBVdGlscy5leHRlbmQoY29uZmlnLCBjaGFydERlZmF1bHRzKTtcbiAgICAgIH0gLy8gY29uZmlnIHNob3VsZCBjYXNjYWRlIGluIHRoaXMgZmFzaGlvblxuICAgICAgLy8gZGVmYXVsdC1jb25maWcgPCBnbG9iYWwtYXBleC12YXJpYWJsZS1jb25maWcgPCB1c2VyLWRlZmluZWQtY29uZmlnXG4gICAgICAvLyBnZXQgR0xPQkFMTFkgZGVmaW5lZCBvcHRpb25zIGFuZCBtZXJnZSB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ1xuXG5cbiAgICAgIHZhciBtZXJnZWRXaXRoRGVmYXVsdENvbmZpZyA9IFV0aWxzLmV4dGVuZChuZXdEZWZhdWx0cywgd2luZG93LkFwZXgpOyAvLyBnZXQgdGhlIG1lcmdlZCBjb25maWcgYW5kIGV4dGVuZCB3aXRoIHVzZXIgZGVmaW5lZCBjb25maWdcblxuICAgICAgY29uZmlnID0gVXRpbHMuZXh0ZW5kKG1lcmdlZFdpdGhEZWZhdWx0Q29uZmlnLCBvcHRzKTsgLy8gc29tZSBmZWF0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC4gdGhvc2UgbWlzbWF0Y2hlcyBzaG91bGQgYmUgaGFuZGxlZFxuXG4gICAgICBjb25maWcgPSB0aGlzLmhhbmRsZVVzZXJJbnB1dEVycm9ycyhjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kWUF4aXMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdHMueWF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdHMueWF4aXMgPSB7fTtcbiAgICAgIH0gLy8gZXh0ZW5kIGdsb2JhbCB5YXhpcyBjb25maWcgKG9ubHkgaWYgb2JqZWN0IGlzIHByb3ZpZGVkIC8gbm90IGFuIGFycmF5KVxuXG5cbiAgICAgIGlmIChvcHRzLnlheGlzLmNvbnN0cnVjdG9yICE9PSBBcnJheSAmJiB3aW5kb3cuQXBleC55YXhpcyAmJiB3aW5kb3cuQXBleC55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZChvcHRzLnlheGlzLCB3aW5kb3cuQXBleC55YXhpcyk7XG4gICAgICB9IC8vIGFzIHdlIGNhbid0IGV4dGVuZCBuZXN0ZWQgb2JqZWN0J3MgYXJyYXkgd2l0aCBleHRlbmQsIHdlIG5lZWQgdG8gZG8gaXQgZmlyc3RcbiAgICAgIC8vIHVzZXIgY2FuIHByb3ZpZGUgZWl0aGVyIGFuIGFycmF5IG9yIG9iamVjdCBpbiB5YXhpcyBjb25maWdcblxuXG4gICAgICBpZiAob3B0cy55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgeWF4aXMgdG8gYXJyYXkgaWYgdXNlciBzdXBwbGllZCBvYmplY3RcbiAgICAgICAgb3B0cy55YXhpcyA9IFtVdGlscy5leHRlbmQob3B0aW9ucy55QXhpcywgb3B0cy55YXhpcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KG9wdHMueWF4aXMsIG9wdGlvbnMueUF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9IC8vIGFubm90YXRpb25zIGFsc28gYWNjZXB0cyBhcnJheSwgc28gd2UgbmVlZCB0byBleHRlbmQgdGhlbSBtYW51YWxseVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmFubm90YXRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRzLmFubm90YXRpb25zID0ge307XG4gICAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBbXTtcbiAgICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFtdO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpO1xuICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZFBvaW50QW5ub3RhdGlvbnMob3B0cyk7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBVdGlscy5leHRlbmRBcnJheSh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucy55YXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnlheGlzIDogW10sIG9wdGlvbnMueUF4aXNBbm5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRYQXhpc0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFhBeGlzQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnhheGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuYW5ub3RhdGlvbnMueGF4aXMgOiBbXSwgb3B0aW9ucy54QXhpc0Fubm90YXRpb24pO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZFBvaW50QW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kUG9pbnRBbm5vdGF0aW9ucyhvcHRzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnBvaW50cyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnBvaW50cyA6IFtdLCBvcHRpb25zLnBvaW50QW5ub3RhdGlvbik7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tGb3JEYXJrVGhlbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGb3JEYXJrVGhlbWUob3B0cykge1xuICAgICAgaWYgKG9wdHMudGhlbWUgJiYgb3B0cy50aGVtZS5tb2RlID09PSAnZGFyaycpIHtcbiAgICAgICAgaWYgKCFvcHRzLnRvb2x0aXApIHtcbiAgICAgICAgICBvcHRzLnRvb2x0aXAgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLnRvb2x0aXAudGhlbWUgIT09ICdsaWdodCcpIHtcbiAgICAgICAgICBvcHRzLnRvb2x0aXAudGhlbWUgPSAnZGFyayc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdHMuY2hhcnQuZm9yZUNvbG9yKSB7XG4gICAgICAgICAgb3B0cy5jaGFydC5mb3JlQ29sb3IgPSAnI2Y2ZjdmOCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdHMudGhlbWUucGFsZXR0ZSkge1xuICAgICAgICAgIG9wdHMudGhlbWUucGFsZXR0ZSA9ICdwYWxldHRlNCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tFbXB0eVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VtcHR5U2VyaWVzKHNlcikge1xuICAgICAgaWYgKHNlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVVzZXJJbnB1dEVycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVc2VySW5wdXRFcnJvcnMob3B0cykge1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdHM7IC8vIGNvbmZsaWN0aW5nIHRvb2x0aXAgb3B0aW9uLiBpbnRlcnNlY3QgbWFrZXMgc3VyZSB0byBmb2N1cyBvbiAxIHBvaW50IGF0IGEgdGltZS4gU2hhcmVkIGNhbm5vdCBiZSB1c2VkIGFsb25nIHdpdGggaXRcblxuICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCAmJiBjb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sdGlwLnNoYXJlZCBjYW5ub3QgYmUgZW5hYmxlZCB3aGVuIHRvb2x0aXAuaW50ZXJzZWN0IGlzIHRydWUuIFR1cm4gb2ZmIGFueSBvdGhlciBvcHRpb24gYnkgc2V0dGluZyBpdCB0byBmYWxzZS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5jaGFydC5zY3JvbGxlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjIuMC4wLiBQbGVhc2UgcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uIGZvciBjaGFydC5zY3JvbGxlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyB8fCBjb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJykgJiYgY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKSB7XG4gICAgICAgIC8vIE5vIG11bHRpcGxlIHlheGlzIGZvciBiYXJzXG4gICAgICAgIGlmIChjb25maWcueWF4aXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgWSBBeGlzIGZvciBiYXJzIGFyZSBub3Qgc3VwcG9ydGVkLiBTd2l0Y2ggdG8gY29sdW1uIGNoYXJ0IGJ5IHNldHRpbmcgcGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw9ZmFsc2UnKTtcbiAgICAgICAgfSAvLyBpZiB5YXhpcyBpcyByZXZlcnNlZCBpbiBob3Jpem9udGFsIGJhciBjaGFydCwgeW91IHNob3VsZCBkcmF3IHRoZSB5LWF4aXMgb24gcmlnaHQgc2lkZVxuXG5cbiAgICAgICAgaWYgKGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS5vcHBvc2l0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcueGF4aXMudG9vbHRpcC5lbmFibGVkID0gZmFsc2U7IC8vIG5vIHhheGlzIHRvb2x0aXAgZm9yIGhvcml6b250YWwgYmFyXG5cbiAgICAgICAgY29uZmlnLnlheGlzWzBdLnRvb2x0aXAuZW5hYmxlZCA9IGZhbHNlOyAvLyBubyB4YXhpcyB0b29sdGlwIGZvciBob3Jpem9udGFsIGJhclxuXG4gICAgICAgIGNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8gem9vbWluZyBmb3IgaG9yeiBiYXJzXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgfHwgY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicpIHtcbiAgICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIGlmIChjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJyAmJiBjb25maWcuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY3Jvc3NoYWlycy53aWR0aCA9IFwiYmFyV2lkdGhcIiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzaW5nbGUgc2VyaWVzLCBub3QgaW4gYSBtdWx0aS1zZXJpZXMgYmFyQ2hhcnQuJyk7XG4gICAgICAgICAgICBjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9ICd0aWNrV2lkdGgnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zdGF0ZXMuaG92ZXIudHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIGNvbmZpZy50b29sdGlwLnNoYXJlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZvbGxvd0N1cnNvciBvcHRpb24gaW4gc2hhcmVkIGNvbHVtbnMgY2Fubm90IGJlIHR1cm5lZCBvZmYuIFBsZWFzZSBzZXQgJWN0b29sdGlwLmZvbGxvd0N1cnNvcjogdHJ1ZScsICdjb2xvcjogYmx1ZTsnKTtcbiAgICAgICAgICAgIGNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICBpZiAoY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXZlcnNlZCB5LWF4aXMgaW4gY2FuZGxlc3RpY2sgY2hhcnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICBjb25maWcueWF4aXNbMF0ucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNoYXJ0Lmdyb3VwICYmIGNvbmZpZy55YXhpc1swXS5sYWJlbHMubWluV2lkdGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJdCBsb29rcyBsaWtlIHlvdSBoYXZlIG11bHRpcGxlIGNoYXJ0cyBpbiBzeW5jaHJvbml6YXRpb24uIFlvdSBtdXN0IHByb3ZpZGUgeWF4aXMubGFiZWxzLm1pbldpZHRoIHdoaWNoIG11c3QgYmUgRVFVQUwgZm9yIGFsbCBncm91cGVkIGNoYXJ0cyB0byBwcmV2ZW50IGluY29ycmVjdCBiZWhhdmlvdXIuJyk7XG4gICAgICB9IC8vIGlmIHVzZXIgc3VwcGxpZWQgYXJyYXkgZm9yIHN0cm9rZSB3aWR0aCwgaXQgd2lsbCBvbmx5IGJlIGFwcGxpY2FibGUgdG8gbGluZS9hcmVhIGNoYXJ0cywgZm9yIGFueSBvdGhlciBjaGFydHMsIHJldmVydCBiYWNrIHRvIE51bWJlclxuXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5zdHJva2Uud2lkdGgpKSB7XG4gICAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSAhPT0gJ2xpbmUnICYmIGNvbmZpZy5jaGFydC50eXBlICE9PSAnYXJlYScpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3N0cm9rZS53aWR0aCBvcHRpb24gYWNjZXB0cyBhcnJheSBvbmx5IGZvciBsaW5lIGFuZCBhcmVhIGNoYXJ0cy4gUmV2ZXJ0ZWQgYmFjayB0byBOdW1iZXInKTtcbiAgICAgICAgICBjb25maWcuc3Ryb2tlLndpZHRoID0gY29uZmlnLnN0cm9rZS53aWR0aFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25maWc7XG59KCk7XG5cbnZhciBHbG9iYWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFscyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2xvYmFscywgW3tcbiAgICBrZXk6IFwiZ2xvYmFsVmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnbG9iYWxWYXJzKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnRJRDogbnVsbCxcbiAgICAgICAgLy8gY2hhcnQgSUQgLSBhcGV4Y2hhcnRzLWN1aWRcbiAgICAgICAgY3VpZDogbnVsbCxcbiAgICAgICAgLy8gY2hhcnQgSUQgLSByYW5kb20gbnVtYmVycyBleGNsdWRpbmcgXCJhcGV4Y2hhcnRzXCIgcGFydFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBiZWZvcmVNb3VudDogW10sXG4gICAgICAgICAgbW91bnRlZDogW10sXG4gICAgICAgICAgdXBkYXRlZDogW10sXG4gICAgICAgICAgY2xpY2tlZDogW10sXG4gICAgICAgICAgc2VsZWN0aW9uOiBbXSxcbiAgICAgICAgICBkYXRhUG9pbnRTZWxlY3Rpb246IFtdLFxuICAgICAgICAgIHpvb21lZDogW10sXG4gICAgICAgICAgc2Nyb2xsZWQ6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yczogW10sXG4gICAgICAgIGNsaWVudFg6IG51bGwsXG4gICAgICAgIGNsaWVudFk6IG51bGwsXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBjb2xvcnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFtdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByYWRhclBvbHlnb25zOiB7XG4gICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgY29sb3JzOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgc2l6ZTogY29uZmlnLm1hcmtlcnMuc2l6ZSxcbiAgICAgICAgICBsYXJnZXN0U2l6ZTogMFxuICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb25FbmRlZDogZmFsc2UsXG4gICAgICAgIGlzVG91Y2hEZXZpY2U6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIC8vIGNoYXJ0IGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIGRhdGFDaGFuZ2VkIHByb3BlcnR5LiBpc0RpcnR5IG1lYW5zIHVzZXIgbWFudWFsbHkgY2FsbGVkIHNvbWUgbWV0aG9kIHRvIHVwZGF0ZVxuICAgICAgICBpbml0aWFsQ29uZmlnOiBudWxsLFxuICAgICAgICAvLyB3ZSB3aWxsIHN0b3JlIHRoZSBmaXJzdCBjb25maWcgdXNlciBoYXMgc2V0IHRvIGdvIGJhY2sgd2hlbiB1c2VyIGZpbmlzaGVzIGludGVyYWN0aW9ucyBsaWtlIHpvb21pbmcgYW5kIGNvbWUgb3V0IG9mIGl0XG4gICAgICAgIGxhc3RYQXhpczogW10sXG4gICAgICAgIGxhc3RZQXhpczogW10sXG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIC8vIHRoZSBNQUlOIHNlcmllcyBhcnJheSAoeSB2YWx1ZXMpXG4gICAgICAgIHNlcmllc1JhbmdlU3RhcnQ6IFtdLFxuICAgICAgICAvLyB0aGUgY2xvbmUgb2Ygc2VyaWVzIGJlY29tZXMgdGhlIHN0YXJ0IGluIHJhbmdlXG4gICAgICAgIHNlcmllc1JhbmdlRW5kOiBbXSxcbiAgICAgICAgLy8gdGhlIGVuZCB2YWx1ZXMgaW4gcmFuZ2UgY2hhcnRcbiAgICAgICAgc2VyaWVzUGVyY2VudDogW10sXG4gICAgICAgIC8vIHRoZSBwZXJjZW50YWdlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc2VyaWVzXG4gICAgICAgIHNlcmllc1RvdGFsczogW10sXG4gICAgICAgIHN0YWNrZWRTZXJpZXNUb3RhbHM6IFtdLFxuICAgICAgICBzZXJpZXNYOiBbXSxcbiAgICAgICAgLy8gc3RvcmUgdGhlIG51bWVyaWMgeCB2YWx1ZXMgaW4gdGhpcyBhcnJheSAoeCB2YWx1ZXMpXG4gICAgICAgIHNlcmllc1o6IFtdLFxuICAgICAgICAvLyBUaGUgM3JkIFwiWlwiIGRpbWVuc2lvbiBmb3IgYnViYmxlcyBjaGFydCAoeiB2YWx1ZXMpXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSB0ZXh0IHRvIGRyYXcgb24geCBheGlzXG4gICAgICAgIC8vIERvbid0IG11dGF0ZSB0aGUgbGFiZWxzLCBtYW55IHRoaW5ncyBpbmNsdWRpbmcgdG9vbHRpcHMgZGVwZW5kcyBvbiBpdCFcbiAgICAgICAgdGltZWxpbmVMYWJlbHM6IFtdLFxuICAgICAgICAvLyBzdG9yZSB0aGUgdGltZWxpbmUgTGFiZWxzIGluIGFub3RoZXIgdmFyaWFibGVcbiAgICAgICAgaW52ZXJ0ZWRUaW1lbGluZUxhYmVsczogW10sXG4gICAgICAgIC8vIGZvciByYW5nZWJhciB0aW1lbGluZVxuICAgICAgICBzZXJpZXNOYW1lczogW10sXG4gICAgICAgIC8vIHNhbWUgYXMgbGFiZWxzLCB1c2VkIGluIG5vbiBheGlzIGNoYXJ0c1xuICAgICAgICBub0xhYmVsc1Byb3ZpZGVkOiBmYWxzZSxcbiAgICAgICAgLy8gaWYgdXNlciBkaWRuJ3QgcHJvdmlkZSBhbnkgY2F0ZWdvcmllcy9sYWJlbHMgb3IgeCB2YWx1ZXMsIGZhbGxiYWNrIHRvIDEsMiwzLDQuLi5cbiAgICAgICAgYWxsU2VyaWVzQ29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgY29sbGFwc2VkU2VyaWVzOiBbXSxcbiAgICAgICAgLy8gd2hlbiB1c2VyIGNvbGxhcHNlcyBhIHNlcmllcywgaXQgZ29lcyBpbnRvIHRoaXMgYXJyYXlcbiAgICAgICAgY29sbGFwc2VkU2VyaWVzSW5kaWNlczogW10sXG4gICAgICAgIC8vIHRoaXMgc3RvcmVzIHRoZSBpbmRleCBvZiB0aGUgY29sbGFwc2VkU2VyaWVzIGluc3RlYWQgb2Ygd2hvbGUgb2JqZWN0IGZvciBxdWljayBhY2Nlc3NcbiAgICAgICAgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzOiBbXSxcbiAgICAgICAgLy8gd2hlbiB1c2VyIGNvbGxhcHNlcyBhbiBcImFsd2F5c1Zpc2libGVcIiBzZXJpZXMsIGl0IGdvZXMgaW50byB0aGlzIGFycmF5XG4gICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXM6IFtdLFxuICAgICAgICAvLyB0aGlzIHN0b3JlcyB0aGUgaW5kZXggb2YgdGhlIGNvbGxhcHNlZFNlcmllcyB3aG9zZSB5LWF4aXMgaXMgYWx3YXlzIHZpc2libGVcbiAgICAgICAgcmlzaW5nU2VyaWVzOiBbXSxcbiAgICAgICAgLy8gd2hlbiB1c2VyIHJlLW9wZW5zIGEgY29sbGFwc2VkIHNlcmllcywgaXQgZ29lcyBoZXJlXG4gICAgICAgIGRhdGFGb3JtYXRYTnVtZXJpYzogZmFsc2UsXG4gICAgICAgIC8vIGJvb2xlYW4gdmFsdWUgdG8gaW5kaWNhdGUgdXNlciBoYXMgcGFzc2VkIG51bWVyaWMgeCB2YWx1ZXNcbiAgICAgICAgc2VsZWN0ZWREYXRhUG9pbnRzOiBbXSxcbiAgICAgICAgaWdub3JlWUF4aXNJbmRleGVzOiBbXSxcbiAgICAgICAgLy8gd2hlbiBzZXJpZXMgYXJlIGJlaW5nIGNvbGxhcHNlZCBpbiBtdWx0aXBsZSB5IGF4ZXMsIGlnbm9yZSBjZXJ0YWluIGluZGV4XG4gICAgICAgIHBhZEhvcml6b250YWw6IDAsXG4gICAgICAgIG1heFZhbHNJbkFycmF5SW5kZXg6IDAsXG4gICAgICAgIHpvb21FbmFibGVkOiBjb25maWcuY2hhcnQudG9vbGJhci5hdXRvU2VsZWN0ZWQgPT09ICd6b29tJyAmJiBjb25maWcuY2hhcnQudG9vbGJhci50b29scy56b29tICYmIGNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQsXG4gICAgICAgIHBhbkVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3BhbicgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMucGFuLFxuICAgICAgICBzZWxlY3Rpb25FbmFibGVkOiBjb25maWcuY2hhcnQudG9vbGJhci5hdXRvU2VsZWN0ZWQgPT09ICdzZWxlY3Rpb24nICYmIGNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzLnNlbGVjdGlvbixcbiAgICAgICAgeWF4aXM6IG51bGwsXG4gICAgICAgIG1pblk6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIC8vICBpcyA1ZS0zMjQsIGkuZS4gdGhlIHNtYWxsZXN0IHBvc2l0aXZlIG51bWJlclxuICAgICAgICAvLyBOT1RFOiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgeSBheGlzLCB0aGUgZmlyc3QgeWF4aXMgYXJyYXkgZWxlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgZm9yIGFsbCB5IHZhbHVlcyBjYWxjdWxhdGlvbnMuIFJlc3QgYWxsIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGF0XG4gICAgICAgIG1heFk6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAvLyBpcyAtMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgICAgLy8gTk9URTogVGhlIGFib3ZlIG5vdGUgZm9yIG1pblkgYXBwbGllcyBoZXJlIGFzIHdlbGxcbiAgICAgICAgbWluWUFycjogW10sXG4gICAgICAgIG1heFlBcnI6IFtdLFxuICAgICAgICBtYXhYOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgLy8gaXMgLTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICAgIGluaXRpYWxtYXhYOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbWluWDogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgLy8gIGlzIDVlLTMyNCwgaS5lLiB0aGUgc21hbGxlc3QgcG9zaXRpdmUgbnVtYmVyXG4gICAgICAgIGluaXRpYWxtaW5YOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICBtaW5aOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAvLyBNYXggWiB2YWx1ZSBpbiBjaGFydHMgd2l0aCBaIGF4aXNcbiAgICAgICAgbWF4WjogLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIC8vIE1heCBaIHZhbHVlIGluIGNoYXJ0cyB3aXRoIFogYXhpc1xuICAgICAgICBtaW5YRGlmZjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbW91c2Vkb3duOiBmYWxzZSxcbiAgICAgICAgbGFzdENsaWVudFBvc2l0aW9uOiB7fSxcbiAgICAgICAgLy8gZG9uJ3QgcmVzZXQgdGhpcyB2YXJpYWJsZSB0aGlzIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQuIEl0IGlzIHVzZWQgdG8gZGV0ZWN0IHJpZ2h0IG9yIGxlZnQgbW91c2Vtb3ZlIGluIHBhbm5pbmdcbiAgICAgICAgdmlzaWJsZVhSYW5nZTogdW5kZWZpbmVkLFxuICAgICAgICB5UmFuZ2U6IFtdLFxuICAgICAgICAvLyB0aGlzIHByb3BlcnR5IGlzIHRoZSBhYnNvbHV0ZSBzdW0gb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBbZWcgKC0xMDAgKyAyMDAgPSAzMDApXSAtIHlBeGlzXG4gICAgICAgIHpSYW5nZTogMCxcbiAgICAgICAgLy8gekF4aXMgUmFuZ2UgKGZvciBidWJibGUgY2hhcnRzKVxuICAgICAgICB4UmFuZ2U6IDAsXG4gICAgICAgIC8vIHhBeGlzIHJhbmdlXG4gICAgICAgIHlWYWx1ZURlY2ltYWw6IDAsXG4gICAgICAgIC8vIGFyZSB0aGVyZSBmbG9hdGluZyBudW1iZXJzIGluIHRoZSBzZXJpZXMuIElmIHllcywgdGhpcyByZXByZXNlbnQgdGhlIGxlbiBvZiB0aGUgZGVjaW1hbHNcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIFNWR05TOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAvLyBzdmcgbmFtZXNwYWNlXG4gICAgICAgIHN2Z1dpZHRoOiAwLFxuICAgICAgICAvLyB0aGUgd2hvbGUgc3ZnIHdpZHRoXG4gICAgICAgIHN2Z0hlaWdodDogMCxcbiAgICAgICAgLy8gdGhlIHdob2xlIHN2ZyBoZWlnaHRcbiAgICAgICAgbm9EYXRhOiBmYWxzZSxcbiAgICAgICAgLy8gd2hldGhlciB0aGVyZSBpcyBhbnkgZGF0YSB0byBkaXNwbGF5IG9yIG5vdFxuICAgICAgICBsb2NhbGU6IHt9LFxuICAgICAgICAvLyB0aGUgY3VycmVudCBsb2NhbGUgdmFsdWVzIHdpbGwgYmUgcHJlc2VydmVkIGhlcmUgZm9yIGdsb2JhbCBhY2Nlc3NcbiAgICAgICAgZG9tOiB7fSxcbiAgICAgICAgLy8gZm9yIHN0b3JpbmcgYWxsIGRvbSBub2RlcyBpbiB0aGlzIHBhcnRpY3VsYXIgcHJvcGVydHlcbiAgICAgICAgLy8gZWxXcmFwOiBudWxsLCAvLyB0aGUgZWxlbWVudCB0aGF0IHdyYXBzIGV2ZXJ5dGhpbmdcbiAgICAgICAgLy8gZWxHcmFwaGljYWw6IG51bGwsIC8vIHRoaXMgY29udGFpbnMgbGluZXMvYXJlYXMvYmFycy9waWVzXG4gICAgICAgIC8vIGVsR3JpZFJlY3Q6IG51bGwsIC8vIHBhdGhzIGdvaW5nIG91dHNpZGUgdGhpcyBhcmVhIHdpbGwgYmUgY2xpcHBlZFxuICAgICAgICAvLyBlbEdyaWRSZWN0TWFzazogbnVsbCwgLy8gY2xpcHBpbmcgd2lsbCBoYXBwZW4gd2l0aCB0aGlzIG1hc2tcbiAgICAgICAgLy8gZWxHcmlkUmVjdE1hcmtlck1hc2s6IG51bGwsIC8vIGNsaXBwaW5nIHdpbGwgaGFwcGVuIHdpdGggdGhpcyBtYXNrXG4gICAgICAgIC8vIGVsTGVnZW5kV3JhcDogbnVsbCwgLy8gdGhlIHdob2xlIGxlZ2VuZCBhcmVhXG4gICAgICAgIC8vIGVsRGVmczogbnVsbCwgLy8gW2RlZnNdIGVsZW1lbnRcbiAgICAgICAgbWVtb3J5OiB7XG4gICAgICAgICAgbWV0aG9kc1RvRXhlYzogW11cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgZGVsYXllZEVsZW1lbnRzOiBbXSxcbiAgICAgICAgLy8gZWxlbWVudCB3aGljaCBhcHBlYXIgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZFxuICAgICAgICBheGlzQ2hhcnRzOiB0cnVlLFxuICAgICAgICAvLyBjaGFydCB0eXBlID0gbGluZSBvciBhcmVhIG9yIGJhclxuICAgICAgICAvLyAocmVmZXIgdGhlbSBhbHNvIGFzIHBsb3QgY2hhcnRzIGluIHRoZSBjb2RlKVxuICAgICAgICBpc1hOdW1lcmljOiBmYWxzZSxcbiAgICAgICAgLy8gYm9vbDogZGF0YSB3YXMgcHJvdmlkZWQgaW4gYSB7W3gseV0sIFt4LHldfSBwYXR0ZXJuXG4gICAgICAgIGlzRGF0YVhZWjogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IGRhdGEgd2FzIHByb3ZpZGVkIGluIGEge1t4LHksel19IHBhdHRlcm5cbiAgICAgICAgcmVzaXplZDogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHVzZXIgaGFzIHJlc2l6ZWRcbiAgICAgICAgcmVzaXplVGltZXI6IG51bGwsXG4gICAgICAgIC8vIHRpbWVvdXQgZnVuY3Rpb24gdG8gbWFrZSBhIHNtYWxsIGRlbGF5IGJlZm9yZVxuICAgICAgICAvLyBkcmF3aW5nIHdoZW4gdXNlciByZXNpemVkXG4gICAgICAgIGNvbWJvQ2hhcnRzOiBmYWxzZSxcbiAgICAgICAgLy8gYm9vbDogd2hldGhlciBpdCdzIGEgY29tYmluYXRpb24gb2YgbGluZS9jb2x1bW5cbiAgICAgICAgY29tYm9DaGFydHNIYXNCYXJzOiBmYWxzZSxcbiAgICAgICAgLy8gYm9vbDogd2hldGhlciBpdCdzIGEgY29tYmluYXRpb24gb2YgbGluZS9jb2x1bW5cbiAgICAgICAgZGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiBoYXMgZGF0YSBjaGFuZ2VkIGR5bmFtaWNhbGx5XG4gICAgICAgIHByZXZpb3VzUGF0aHM6IFtdLFxuICAgICAgICAvLyBhcnJheTogd2hlbiBkYXRhIGlzIGNoYW5nZWQsIGl0IHdpbGwgYW5pbWF0ZSBmcm9tXG4gICAgICAgIC8vIHByZXZpb3VzIHBhdGhzXG4gICAgICAgIHNlcmllc1h2YWx1ZXM6IFtdLFxuICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdGhpcyBpbiB0b29sdGlwIChpdCdzIHggcG9zaXRpb24pXG4gICAgICAgIC8vIHdoZW4gd2Ugd2lsbCBoYXZlIHVuZXF1YWwgeCB2YWx1ZXMsIHdlIHdpbGwgbmVlZFxuICAgICAgICAvLyBzb21lIHdheSB0byBnZXQgeCB2YWx1ZSBkZXBlbmRpbmcgb24gbW91c2UgcG9pbnRlclxuICAgICAgICBzZXJpZXNZdmFsdWVzOiBbXSxcbiAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRoaXMgd2hlbiBkZWNpZGluZyB3aGljaCBzZXJpZXNcbiAgICAgICAgLy8gdXNlciBob3ZlcmVkIG9uXG4gICAgICAgIHNlcmllc0NhbmRsZU86IFtdLFxuICAgICAgICAvLyBjYW5kbGUgc3RpY2sgb3BlbiB2YWx1ZXNcbiAgICAgICAgc2VyaWVzQ2FuZGxlSDogW10sXG4gICAgICAgIC8vIGNhbmRsZSBzdGljayBoaWdoIHZhbHVlc1xuICAgICAgICBzZXJpZXNDYW5kbGVMOiBbXSxcbiAgICAgICAgLy8gY2FuZGxlIHN0aWNrIGxvdyB2YWx1ZXNcbiAgICAgICAgc2VyaWVzQ2FuZGxlQzogW10sXG4gICAgICAgIC8vIGNhbmRsZSBzdGljayBjbG9zZSB2YWx1ZXNcbiAgICAgICAgYWxsU2VyaWVzSGFzRXF1YWxYOiB0cnVlLFxuICAgICAgICBkYXRhUG9pbnRzOiAwLFxuICAgICAgICAvLyB0aGUgbG9uZ2VzdCBzZXJpZXMgbGVuZ3RoXG4gICAgICAgIHBvaW50c0FycmF5OiBbXSxcbiAgICAgICAgLy8gc3RvcmUgdGhlIHBvaW50cyBwb3NpdGlvbnMgaGVyZSB0byBkcmF3IGxhdGVyIG9uIGhvdmVyXG4gICAgICAgIC8vIGZvcm1hdCBpcyAtIFtbeCx5XSxbeCx5XS4uLiBbeCx5XV1cbiAgICAgICAgZGF0YUxhYmVsc1JlY3RzOiBbXSxcbiAgICAgICAgLy8gc3RvcmUgdGhlIHBvc2l0aW9ucyBvZiBkYXRhbGFiZWxzIHRvIHByZXZlbnQgY29sbGlzaW9uXG4gICAgICAgIGxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzOiBbXSxcbiAgICAgICAgaGFzTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHdoZXRoZXIgc2VyaWVzIGNvbnRhaW5zIG51bGwgdmFsdWVzXG4gICAgICAgIGVhc2luZzogbnVsbCxcbiAgICAgICAgLy8gZnVuY3Rpb246IGFuaW1hdGlvbiBlZmZlY3QgdG8gYXBwbHlcbiAgICAgICAgem9vbWVkOiBmYWxzZSxcbiAgICAgICAgLy8gd2hldGhlciB1c2VyIGhhcyB6b29tZWQgb3Igbm90XG4gICAgICAgIGdyaWRXaWR0aDogMCxcbiAgICAgICAgLy8gZHJhd2FibGUgd2lkdGggb2YgYWN0dWFsIGdyYXBocyAoc2VyaWVzIHBhdGhzKVxuICAgICAgICBncmlkSGVpZ2h0OiAwLFxuICAgICAgICAvLyBkcmF3YWJsZSBoZWlnaHQgb2YgYWN0dWFsIGdyYXBocyAoc2VyaWVzIHBhdGhzKVxuICAgICAgICB5QXhpc1NjYWxlOiBbXSxcbiAgICAgICAgeEF4aXNTY2FsZTogbnVsbCxcbiAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9uczogW10sXG4gICAgICAgIHRpbWVzY2FsZVRpY2tzOiBbXSxcbiAgICAgICAgcm90YXRlWExhYmVsczogZmFsc2UsXG4gICAgICAgIGRlZmF1bHRMYWJlbHM6IGZhbHNlLFxuICAgICAgICB4TGFiZWxGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gZm9ybWF0dGVyIGZvciB4IGF4aXMgbGFiZWxzXG4gICAgICAgIHlMYWJlbEZvcm1hdHRlcnM6IFtdLFxuICAgICAgICB4YXhpc1Rvb2x0aXBGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gZm9ybWF0dGVyIGZvciB4IGF4aXMgdG9vbHRpcFxuICAgICAgICB0dEtleUZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICB0dFZhbDogdW5kZWZpbmVkLFxuICAgICAgICB0dFpGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgTElORV9IRUlHSFRfUkFUSU86IDEuNjE4LFxuICAgICAgICB4QXhpc0xhYmVsc0hlaWdodDogMCxcbiAgICAgICAgeUF4aXNMYWJlbHNXaWR0aDogMCxcbiAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVlBeGlzWDogW10sXG4gICAgICAgIHlMYWJlbHNDb29yZHM6IFtdLFxuICAgICAgICB5VGl0bGVDb29yZHM6IFtdLFxuICAgICAgICB5QXhpc1dpZHRoczogW10sXG4gICAgICAgIHRyYW5zbGF0ZVhBeGlzWTogMCxcbiAgICAgICAgdHJhbnNsYXRlWEF4aXNYOiAwLFxuICAgICAgICB0b29sdGlwOiBudWxsLFxuICAgICAgICB0b29sdGlwT3B0czogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGNvbmZpZykge1xuICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbFZhcnMoY29uZmlnKTtcbiAgICAgIGdsb2JhbHMuaW5pdGlhbENvbmZpZyA9IFV0aWxzLmV4dGVuZCh7fSwgY29uZmlnKTtcbiAgICAgIGdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ2xvYmFscy5pbml0aWFsQ29uZmlnLnNlcmllcykpO1xuICAgICAgZ2xvYmFscy5sYXN0WEF4aXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdsb2JhbHMuaW5pdGlhbENvbmZpZy54YXhpcykpO1xuICAgICAgZ2xvYmFscy5sYXN0WUF4aXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdsb2JhbHMuaW5pdGlhbENvbmZpZy55YXhpcykpO1xuICAgICAgcmV0dXJuIGdsb2JhbHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsb2JhbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBCYXNlIENsYXNzIGZvciBleHRlbmRpbmcgdXNlciBvcHRpb25zIHdpdGggcHJlLWRlZmluZWQgQXBleENoYXJ0cyBjb25maWcuXG4gKlxuICogQG1vZHVsZSBCYXNlXG4gKiovXG5cbnZhciBCYXNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZShvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29uZmlnID0gbmV3IENvbmZpZyh0aGlzLm9wdHMpLmluaXQoKTtcbiAgICAgIHZhciBnbG9iYWxzID0gbmV3IEdsb2JhbHMoKS5pbml0KGNvbmZpZyk7XG4gICAgICB2YXIgdyA9IHtcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIGdsb2JhbHM6IGdsb2JhbHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZTtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEZpbGwgQ2xhc3MgZm9yIHNldHRpbmcgZmlsbCBvcHRpb25zIG9mIHRoZSBwYXRocy5cbiAqXG4gKiBAbW9kdWxlIEZpbGxcbiAqKi9cblxudmFyIEZpbGwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWxsKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxsKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMub3B0cyA9IG51bGw7XG4gICAgdGhpcy5zZXJpZXNJbmRleCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsbCwgW3tcbiAgICBrZXk6IFwiY2xpcHBlZEltZ0FyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpcHBlZEltZ0FyZWEocGFyYW1zKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgIHZhciBzdmdXID0gcGFyc2VJbnQody5nbG9iYWxzLmdyaWRXaWR0aCk7XG4gICAgICB2YXIgc3ZnSCA9IHBhcnNlSW50KHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgIHZhciBzaXplID0gc3ZnVyA+IHN2Z0ggPyBzdmdXIDogc3ZnSDtcbiAgICAgIHZhciBmaWxsSW1nID0gcGFyYW1zLmltYWdlO1xuICAgICAgdmFyIGltZ1dpZHRoID0gMDtcbiAgICAgIHZhciBpbWdIZWlnaHQgPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy53aWR0aCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBhcmFtcy5oZWlnaHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChjbmYuZmlsbC5pbWFnZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNuZi5maWxsLmltYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW1nV2lkdGggPSBjbmYuZmlsbC5pbWFnZS53aWR0aCArIDE7XG4gICAgICAgICAgaW1nSGVpZ2h0ID0gY25mLmZpbGwuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltZ1dpZHRoID0gc2l6ZSArIDE7XG4gICAgICAgICAgaW1nSGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1nV2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGltZ0hlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbFBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAncGF0dGVybicpO1xuICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXR0ZXJuLCB7XG4gICAgICAgIGlkOiBwYXJhbXMucGF0dGVybklELFxuICAgICAgICBwYXR0ZXJuVW5pdHM6IHBhcmFtcy5wYXR0ZXJuVW5pdHMgPyBwYXJhbXMucGF0dGVyblVuaXRzIDogJ3VzZXJTcGFjZU9uVXNlJyxcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBpbWdIZWlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbEltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ2ltYWdlJyk7XG4gICAgICBlbFBhdHRlcm4uYXBwZW5kQ2hpbGQoZWxJbWFnZSk7XG4gICAgICBlbEltYWdlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBmaWxsSW1nKTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsSW1hZ2UsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ25vbmUnLFxuICAgICAgICB3aWR0aDogaW1nV2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodCArICdweCdcbiAgICAgIH0pO1xuICAgICAgZWxJbWFnZS5zdHlsZS5vcGFjaXR5ID0gcGFyYW1zLm9wYWNpdHk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsRGVmcy5ub2RlLmFwcGVuZENoaWxkKGVsUGF0dGVybik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc0luZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc0luZGV4KG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmRpc3RyaWJ1dGVkIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICB0aGlzLnNlcmllc0luZGV4ID0gb3B0cy5zZXJpZXNOdW1iZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlcmllc0luZGV4ID0gb3B0cy5zZXJpZXNOdW1iZXIgJSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbGxQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxQYXRoKG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIHBhdGhGaWxsO1xuICAgICAgdmFyIHBhdHRlcm5GaWxsLCBncmFkaWVudEZpbGw7XG4gICAgICB0aGlzLnNlcmllc0luZGV4ID0gdGhpcy5nZXRTZXJpZXNJbmRleChvcHRzKTtcbiAgICAgIHZhciBmaWxsQ29sb3JzID0gdGhpcy5nZXRGaWxsQ29sb3JzKCk7XG4gICAgICB2YXIgZmlsbENvbG9yID0gZmlsbENvbG9yc1t0aGlzLnNlcmllc0luZGV4XTtcbiAgICAgIHZhciBmaWxsVHlwZSA9IHRoaXMuZ2V0RmlsbFR5cGUodGhpcy5zZXJpZXNJbmRleCk7XG4gICAgICB2YXIgZmlsbE9wYWNpdHkgPSBBcnJheS5pc0FycmF5KGNuZi5maWxsLm9wYWNpdHkpID8gY25mLmZpbGwub3BhY2l0eVt0aGlzLnNlcmllc0luZGV4XSA6IGNuZi5maWxsLm9wYWNpdHk7XG4gICAgICB2YXIgZGVmYXVsdENvbG9yID0gZmlsbENvbG9yO1xuXG4gICAgICBpZiAob3B0cy5jb2xvcikge1xuICAgICAgICBmaWxsQ29sb3IgPSBvcHRzLmNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbENvbG9yLmluZGV4T2YoJ3JnYicpID09PSAtMSkge1xuICAgICAgICBkZWZhdWx0Q29sb3IgPSBVdGlscy5oZXhUb1JnYmEoZmlsbENvbG9yLCBmaWxsT3BhY2l0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsbENvbG9yLmluZGV4T2YoJ3JnYmEnKSA+IC0xKSB7XG4gICAgICAgICAgZmlsbE9wYWNpdHkgPSAwICsgJy4nICsgVXRpbHMuZ2V0T3BhY2l0eUZyb21SR0JBKGZpbGxDb2xvcnNbdGhpcy5zZXJpZXNJbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsVHlwZSA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgIHBhdHRlcm5GaWxsID0gdGhpcy5oYW5kbGVQYXR0ZXJuRmlsbChwYXR0ZXJuRmlsbCwgZmlsbENvbG9yLCBmaWxsT3BhY2l0eSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgIGdyYWRpZW50RmlsbCA9IHRoaXMuaGFuZGxlR3JhZGllbnRGaWxsKGdyYWRpZW50RmlsbCwgZmlsbENvbG9yLCBmaWxsT3BhY2l0eSwgdGhpcy5zZXJpZXNJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbmYuZmlsbC5pbWFnZS5zcmMubGVuZ3RoID4gMCAmJiBmaWxsVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICBpZiAob3B0cy5zZXJpZXNOdW1iZXIgPCBjbmYuZmlsbC5pbWFnZS5zcmMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5jbGlwcGVkSW1nQXJlYSh7XG4gICAgICAgICAgICBvcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICAgICAgICAgIGltYWdlOiBjbmYuZmlsbC5pbWFnZS5zcmNbb3B0cy5zZXJpZXNOdW1iZXJdLFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBvcHRzLnBhdHRlcm5Vbml0cyxcbiAgICAgICAgICAgIHBhdHRlcm5JRDogXCJwYXR0ZXJuXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkKS5jb25jYXQob3B0cy5zZXJpZXNOdW1iZXIgKyAxKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhdGhGaWxsID0gXCJ1cmwoI3BhdHRlcm5cIi5jb25jYXQody5nbG9iYWxzLmN1aWQpLmNvbmNhdChvcHRzLnNlcmllc051bWJlciArIDEsIFwiKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoRmlsbCA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWxsVHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICBwYXRoRmlsbCA9IGdyYWRpZW50RmlsbDtcbiAgICAgIH0gZWxzZSBpZiAoZmlsbFR5cGUgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICBwYXRoRmlsbCA9IHBhdHRlcm5GaWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICB9IC8vIG92ZXJyaWRlIHBhdHRlcm4vZ3JhZGllbnQgaWYgb3B0cy5zb2xpZCBpcyB0cnVlXG5cblxuICAgICAgaWYgKG9wdHMuc29saWQpIHtcbiAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoRmlsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsbFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbFR5cGUoc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5maWxsLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiB3LmNvbmZpZy5maWxsLnR5cGVbc2VyaWVzSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHcuY29uZmlnLmZpbGwudHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsbENvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxsQ29sb3JzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBmaWxsQ29sb3JzID0gW107XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnNlcmllc1t0aGlzLnNlcmllc0luZGV4XS50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZmlsbENvbG9ycyA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmZpbGwuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuZmlsbC5jb2xvcnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZmlsbENvbG9ycyA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmZpbGwuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuZmlsbC5jb2xvcnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMucHVzaCh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBjb2xvcnMgcGFzc2VkIGluIGFyZ3VtZW50c1xuXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5maWxsQ29sb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmaWxsQ29sb3JzID0gW107XG5cbiAgICAgICAgaWYgKG9wdHMuZmlsbENvbG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgZmlsbENvbG9ycyA9IG9wdHMuZmlsbENvbG9ycy5zbGljZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGxDb2xvcnMucHVzaChvcHRzLmZpbGxDb2xvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxsQ29sb3JzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVQYXR0ZXJuRmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQYXR0ZXJuRmlsbChwYXR0ZXJuRmlsbCwgZmlsbENvbG9yLCBmaWxsT3BhY2l0eSwgZGVmYXVsdENvbG9yKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBwYXR0ZXJuU3Ryb2tlV2lkdGggPSBjbmYuZmlsbC5wYXR0ZXJuLnN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyBBcnJheS5pc0FycmF5KGNuZi5zdHJva2Uud2lkdGgpID8gY25mLnN0cm9rZS53aWR0aFt0aGlzLnNlcmllc0luZGV4XSA6IGNuZi5zdHJva2Uud2lkdGggOiBBcnJheS5pc0FycmF5KGNuZi5maWxsLnBhdHRlcm4uc3Ryb2tlV2lkdGgpID8gY25mLmZpbGwucGF0dGVybi5zdHJva2VXaWR0aFt0aGlzLnNlcmllc0luZGV4XSA6IGNuZi5maWxsLnBhdHRlcm4uc3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgcGF0dGVybkxpbmVDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgICAgaWYgKGNuZi5maWxsLnBhdHRlcm4uc3R5bGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAodHlwZW9mIGNuZi5maWxsLnBhdHRlcm4uc3R5bGVbb3B0cy5zZXJpZXNOdW1iZXJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBwZiA9IGdyYXBoaWNzLmRyYXdQYXR0ZXJuKGNuZi5maWxsLnBhdHRlcm4uc3R5bGVbb3B0cy5zZXJpZXNOdW1iZXJdLCBjbmYuZmlsbC5wYXR0ZXJuLndpZHRoLCBjbmYuZmlsbC5wYXR0ZXJuLmhlaWdodCwgcGF0dGVybkxpbmVDb2xvciwgcGF0dGVyblN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSk7XG4gICAgICAgICAgcGF0dGVybkZpbGwgPSBwZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuRmlsbCA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybkZpbGwgPSBncmFwaGljcy5kcmF3UGF0dGVybihjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlLCBjbmYuZmlsbC5wYXR0ZXJuLndpZHRoLCBjbmYuZmlsbC5wYXR0ZXJuLmhlaWdodCwgcGF0dGVybkxpbmVDb2xvciwgcGF0dGVyblN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXR0ZXJuRmlsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlR3JhZGllbnRGaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUdyYWRpZW50RmlsbChncmFkaWVudEZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIGkpIHtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxzKCk7XG4gICAgICB2YXIgdHlwZSA9IGNuZi5maWxsLmdyYWRpZW50LnR5cGU7XG4gICAgICB2YXIgZ3JhZGllbnRGcm9tLCBncmFkaWVudFRvO1xuICAgICAgdmFyIG9wYWNpdHlGcm9tID0gY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eUZyb20gPT09IHVuZGVmaW5lZCA/IGZpbGxPcGFjaXR5IDogQXJyYXkuaXNBcnJheShjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5RnJvbSkgPyBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5RnJvbVtpXSA6IGNuZi5maWxsLmdyYWRpZW50Lm9wYWNpdHlGcm9tO1xuICAgICAgdmFyIG9wYWNpdHlUbyA9IGNuZi5maWxsLmdyYWRpZW50Lm9wYWNpdHlUbyA9PT0gdW5kZWZpbmVkID8gZmlsbE9wYWNpdHkgOiBBcnJheS5pc0FycmF5KGNuZi5maWxsLmdyYWRpZW50Lm9wYWNpdHlUbykgPyBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG9baV0gOiBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG87XG4gICAgICBncmFkaWVudEZyb20gPSBmaWxsQ29sb3I7XG5cbiAgICAgIGlmIChjbmYuZmlsbC5ncmFkaWVudC5ncmFkaWVudFRvQ29sb3JzID09PSB1bmRlZmluZWQgfHwgY25mLmZpbGwuZ3JhZGllbnQuZ3JhZGllbnRUb0NvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGNuZi5maWxsLmdyYWRpZW50LnNoYWRlID09PSAnZGFyaycpIHtcbiAgICAgICAgICBncmFkaWVudFRvID0gdXRpbHMuc2hhZGVDb2xvcihwYXJzZUZsb2F0KGNuZi5maWxsLmdyYWRpZW50LnNoYWRlSW50ZW5zaXR5KSAqIC0xLCBmaWxsQ29sb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50VG8gPSB1dGlscy5zaGFkZUNvbG9yKHBhcnNlRmxvYXQoY25mLmZpbGwuZ3JhZGllbnQuc2hhZGVJbnRlbnNpdHkpLCBmaWxsQ29sb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmFkaWVudFRvID0gY25mLmZpbGwuZ3JhZGllbnQuZ3JhZGllbnRUb0NvbG9yc1tvcHRzLnNlcmllc051bWJlcl07XG4gICAgICB9XG5cbiAgICAgIGlmIChjbmYuZmlsbC5ncmFkaWVudC5pbnZlcnNlQ29sb3JzKSB7XG4gICAgICAgIHZhciB0ID0gZ3JhZGllbnRGcm9tO1xuICAgICAgICBncmFkaWVudEZyb20gPSBncmFkaWVudFRvO1xuICAgICAgICBncmFkaWVudFRvID0gdDtcbiAgICAgIH1cblxuICAgICAgZ3JhZGllbnRGaWxsID0gZ3JhcGhpY3MuZHJhd0dyYWRpZW50KHR5cGUsIGdyYWRpZW50RnJvbSwgZ3JhZGllbnRUbywgb3BhY2l0eUZyb20sIG9wYWNpdHlUbywgb3B0cy5zaXplLCBjbmYuZmlsbC5ncmFkaWVudC5zdG9wcywgY25mLmZpbGwuZ3JhZGllbnQuY29sb3JTdG9wcywgaSk7XG4gICAgICByZXR1cm4gZ3JhZGllbnRGaWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxsO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgTWFya2VycyBDbGFzcyBmb3IgZHJhd2luZyBwb2ludHMgb24geSB2YWx1ZXMgaW4gYXhlcyBjaGFydHMuXG4gKlxuICogQG1vZHVsZSBNYXJrZXJzXG4gKiovXG5cbnZhciBNYXJrZXJzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFya2VycyhjdHgsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFya2Vycyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXJrZXJzLCBbe1xuICAgIGtleTogXCJzZXRHbG9iYWxNYXJrZXJTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdsb2JhbE1hcmtlclNpemUoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLnNpemUgPSBBcnJheS5pc0FycmF5KHcuY29uZmlnLm1hcmtlcnMuc2l6ZSkgPyB3LmNvbmZpZy5tYXJrZXJzLnNpemUgOiBbdy5jb25maWcubWFya2Vycy5zaXplXTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAody5nbG9iYWxzLm1hcmtlcnMuc2l6ZS5sZW5ndGggPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLnNpemUucHVzaCh3Lmdsb2JhbHMubWFya2Vycy5zaXplWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLnNpemUgPSB3LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHcuY29uZmlnLm1hcmtlcnMuc2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsb3RDaGFydE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdENoYXJ0TWFya2Vycyhwb2ludHNQb3MsIHNlcmllc0luZGV4LCBqKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBpID0gc2VyaWVzSW5kZXg7XG4gICAgICB2YXIgcCA9IHBvaW50c1BvcztcbiAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBudWxsO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBwb2ludDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCkge1xuICAgICAgICBlbFBvaW50c1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxQb2ludHNXcmFwLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLnggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChxKSB7XG4gICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajsgLy8gYSBzbWFsbCBoYWNrIGFzIHdlIGhhdmUgMiBwb2ludHMgZm9yIHRoZSBmaXJzdCB2YWwgdG8gY29ubmVjdCBpdFxuXG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMCkgZGF0YVBvaW50SW5kZXggPSAwO1xuICAgICAgICAgIGlmIChqID09PSAxICYmIHEgPT09IDEpIGRhdGFQb2ludEluZGV4ID0gMTtcbiAgICAgICAgICB2YXIgUG9pbnRDbGFzc2VzID0gJ2FwZXhjaGFydHMtbWFya2VyJztcblxuICAgICAgICAgIGlmICgody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdhcmVhJykgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSAnIG5vLXBvaW50ZXItZXZlbnRzJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2hvdWxkTWFya2VyRHJhdyA9IEFycmF5LmlzQXJyYXkody5jb25maWcubWFya2Vycy5zaXplKSA/IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCA6IHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA+IDA7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTWFya2VyRHJhdykge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHAueVtxXSkpIHtcbiAgICAgICAgICAgICAgUG9pbnRDbGFzc2VzICs9IFwiIHdcIi5jb25jYXQoKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFBvaW50Q2xhc3NlcyA9ICdhcGV4Y2hhcnRzLW51bGxwb2ludCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuZ2V0TWFya2VyQ29uZmlnKFBvaW50Q2xhc3Nlcywgc2VyaWVzSW5kZXgpOyAvLyBkaXNjcmV0ZSBtYXJrZXJzIGlzIGFuIG9wdGlvbiB3aGVyZSB1c2VyIGNhbiBzcGVjaWZ5IGEgcGFydGljdWxhciBtYXJrZXIgd2l0aCBkaWZmZXJlbnQgc2l6ZSBhbmQgY29sb3JcblxuXG4gICAgICAgICAgICB3LmNvbmZpZy5tYXJrZXJzLmRpc2NyZXRlLm1hcChmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXJrZXIuc2VyaWVzSW5kZXggPT09IHNlcmllc0luZGV4ICYmIG1hcmtlci5kYXRhUG9pbnRJbmRleCA9PT0gZGF0YVBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvaW50U3Ryb2tlQ29sb3IgPSBtYXJrZXIuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wb2ludEZpbGxDb2xvciA9IG1hcmtlci5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wU2l6ZSA9IG1hcmtlci5zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdKSB7XG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS5maWxsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvaW50RmlsbENvbG9yID0gdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uZmlsbENvbG9yO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wb2ludFN0cm9rZUNvbG9yID0gdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9pbnQgPSBncmFwaGljcy5kcmF3TWFya2VyKHAueFtxXSwgcC55W3FdLCBvcHRzKTtcbiAgICAgICAgICAgIHBvaW50LmF0dHIoJ3JlbCcsIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgIHBvaW50LmF0dHIoJ2onLCBkYXRhUG9pbnRJbmRleCk7XG4gICAgICAgICAgICBwb2ludC5hdHRyKCdpbmRleCcsIHNlcmllc0luZGV4KTtcbiAgICAgICAgICAgIHBvaW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJywgb3B0cy5wU2l6ZSk7XG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKF90aGlzLmN0eCk7XG4gICAgICAgICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihwb2ludCwgc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4KTtcblxuICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnRzKHBvaW50KTtcblxuICAgICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCkge1xuICAgICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBhcnJheSBjcmVhdGlvbiAtIG11bHRpZGltZW5zaW9uYWxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnBvaW50c0FycmF5W3Nlcmllc0luZGV4XSA9PT0gJ3VuZGVmaW5lZCcpIHcuZ2xvYmFscy5wb2ludHNBcnJheVtzZXJpZXNJbmRleF0gPSBbXTtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5wb2ludHNBcnJheVtzZXJpZXNJbmRleF0ucHVzaChbcC54W3FdLCBwLnlbcV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBwLngubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICBfbG9vcChxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxQb2ludHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VyQ29uZmlnKGNzc0NsYXNzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcFN0eWxlID0gdGhpcy5nZXRNYXJrZXJTdHlsZShzZXJpZXNJbmRleCk7XG4gICAgICB2YXIgcFNpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW3Nlcmllc0luZGV4XTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBTaXplOiBwU2l6ZSxcbiAgICAgICAgcFJhZGl1czogdy5jb25maWcubWFya2Vycy5yYWRpdXMsXG4gICAgICAgIHBXaWR0aDogdy5jb25maWcubWFya2Vycy5zdHJva2VXaWR0aCxcbiAgICAgICAgcG9pbnRTdHJva2VDb2xvcjogcFN0eWxlLnBvaW50U3Ryb2tlQ29sb3IsXG4gICAgICAgIHBvaW50RmlsbENvbG9yOiBwU3R5bGUucG9pbnRGaWxsQ29sb3IsXG4gICAgICAgIHNoYXBlOiB3LmNvbmZpZy5tYXJrZXJzLnNoYXBlIGluc3RhbmNlb2YgQXJyYXkgPyB3LmNvbmZpZy5tYXJrZXJzLnNoYXBlW3Nlcmllc0luZGV4XSA6IHcuY29uZmlnLm1hcmtlcnMuc2hhcGUsXG4gICAgICAgIGNsYXNzOiBjc3NDbGFzcyxcbiAgICAgICAgcG9pbnRTdHJva2VPcGFjaXR5OiB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgIHBvaW50RmlsbE9wYWNpdHk6IHcuY29uZmlnLm1hcmtlcnMuZmlsbE9wYWNpdHksXG4gICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50cyhjaXJjbGUpIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICBjaXJjbGUubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZ3JhcGhpY3MucGF0aE1vdXNlRW50ZXIuYmluZCh0aGlzLmN0eCwgY2lyY2xlKSk7XG4gICAgICBjaXJjbGUubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLmN0eCwgY2lyY2xlKSk7XG4gICAgICBjaXJjbGUubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcy5jdHgsIGNpcmNsZSkpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGdyYXBoaWNzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLmN0eCwgY2lyY2xlKSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2VyU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VyU3R5bGUoc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNvbG9ycyA9IHcuZ2xvYmFscy5tYXJrZXJzLmNvbG9ycztcbiAgICAgIHZhciBzdHJva2VDb2xvcnMgPSB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZUNvbG9yIHx8IHcuY29uZmlnLm1hcmtlcnMuc3Ryb2tlQ29sb3JzO1xuICAgICAgdmFyIHBvaW50U3Ryb2tlQ29sb3IgPSBzdHJva2VDb2xvcnMgaW5zdGFuY2VvZiBBcnJheSA/IHN0cm9rZUNvbG9yc1tzZXJpZXNJbmRleF0gOiBzdHJva2VDb2xvcnM7XG4gICAgICB2YXIgcG9pbnRGaWxsQ29sb3IgPSBjb2xvcnMgaW5zdGFuY2VvZiBBcnJheSA/IGNvbG9yc1tzZXJpZXNJbmRleF0gOiBjb2xvcnM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludFN0cm9rZUNvbG9yOiBwb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICBwb2ludEZpbGxDb2xvcjogcG9pbnRGaWxsQ29sb3JcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmtlcnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBTY2F0dGVyIENsYXNzLlxuICogVGhpcyBDbGFzcyBhbHNvIGhhbmRsZXMgYnViYmxlcyBjaGFydCBhcyBjdXJyZW50bHkgdGhlcmUgaXMgbm8gbWFqb3IgZGlmZmVyZW5jZSBpbiBkcmF3aW5nIHRoZW0sXG4gKiBAbW9kdWxlIFNjYXR0ZXJcbiAqKi9cblxudmFyIFNjYXR0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2F0dGVyKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2F0dGVyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICB0aGlzLmR5bmFtaWNBbmltID0gdGhpcy5pbml0aWFsQW5pbSAmJiB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkOyAvLyB0aGlzIGFycmF5IHdpbGwgaGVscCBpbiBjZW50ZXJpbmcgdGhlIGxhYmVsIGluIGJ1YmJsZXNcblxuICAgIHRoaXMucmFkaXVzU2l6ZXMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2F0dGVyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoZWxTZXJpZXMsIGosIG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciByZWFsSW5kZXggPSBvcHRzLnJlYWxJbmRleDtcbiAgICAgIHZhciBwb2ludHNQb3MgPSBvcHRzLnBvaW50c1BvcztcbiAgICAgIHZhciB6UmF0aW8gPSBvcHRzLnpSYXRpbztcbiAgICAgIHZhciBlbFBvaW50c01haW4gPSBvcHRzLmVsUGFyZW50O1xuICAgICAgdmFyIGVsUG9pbnRzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyBhcGV4Y2hhcnRzLXNlcmllcy1cIi5jb25jYXQody5jb25maWcuY2hhcnQudHlwZSlcbiAgICAgIH0pO1xuICAgICAgZWxQb2ludHNXcmFwLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG5cbiAgICAgIGlmIChwb2ludHNQb3MueCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcG9pbnRzUG9zLngubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICB2YXIgZGF0YVBvaW50SW5kZXggPSBqICsgMTtcbiAgICAgICAgICB2YXIgc2hvdWxkRHJhdyA9IHRydWU7IC8vIGEgc21hbGwgaGFjayBhcyB3ZSBoYXZlIDIgcG9pbnRzIGZvciB0aGUgZmlyc3QgdmFsIHRvIGNvbm5lY3QgaXRcblxuICAgICAgICAgIGlmIChqID09PSAwICYmIHEgPT09IDApIGRhdGFQb2ludEluZGV4ID0gMDtcbiAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBxID09PSAxKSBkYXRhUG9pbnRJbmRleCA9IDE7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IDA7XG4gICAgICAgICAgdmFyIGZpbmlzaFJhZGl1cyA9IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbcmVhbEluZGV4XTtcblxuICAgICAgICAgIGlmICh6UmF0aW8gIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvLyBtZWFucyB3ZSBoYXZlIGEgYnViYmxlXG4gICAgICAgICAgICBmaW5pc2hSYWRpdXMgPSB3Lmdsb2JhbHMuc2VyaWVzWltyZWFsSW5kZXhdW2RhdGFQb2ludEluZGV4XSAvIHpSYXRpbztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJhZGl1c1NpemVzW3JlYWxJbmRleF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFkaXVzU2l6ZXMucHVzaChbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmFkaXVzU2l6ZXNbcmVhbEluZGV4XS5wdXNoKGZpbmlzaFJhZGl1cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IGZpbmlzaFJhZGl1cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeCA9IHBvaW50c1Bvcy54W3FdO1xuICAgICAgICAgIHZhciB5ID0gcG9pbnRzUG9zLnlbcV07XG4gICAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IDA7XG5cbiAgICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwIHx8IHkgPT09IG51bGwgfHwgdHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNbcmVhbEluZGV4XVtkYXRhUG9pbnRJbmRleF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaG91bGREcmF3ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZERyYXcpIHtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmRyYXdQb2ludCh4LCB5LCByYWRpdXMsIGZpbmlzaFJhZGl1cywgcmVhbEluZGV4LCBkYXRhUG9pbnRJbmRleCwgaik7XG4gICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKGNpcmNsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9pbnQoeCwgeSwgcmFkaXVzLCBmaW5pc2hSYWRpdXMsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgsIGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGkgPSByZWFsSW5kZXg7XG4gICAgICB2YXIgYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgbWFya2VyQ29uZmlnID0gbWFya2Vycy5nZXRNYXJrZXJDb25maWcoJ2FwZXhjaGFydHMtbWFya2VyJywgaSk7XG4gICAgICB2YXIgcGF0aEZpbGxDaXJjbGUgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ29iamVjdEJvdW5kaW5nQm94J1xuICAgICAgfSk7XG4gICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShyYWRpdXMpO1xuXG4gICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbZGF0YVBvaW50SW5kZXhdKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0uZmlsbENvbG9yKSB7XG4gICAgICAgICAgcGF0aEZpbGxDaXJjbGUgPSB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtkYXRhUG9pbnRJbmRleF0uZmlsbENvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNpcmNsZS5hdHRyKHtcbiAgICAgICAgY3g6IHgsXG4gICAgICAgIGN5OiB5LFxuICAgICAgICBmaWxsOiBwYXRoRmlsbENpcmNsZSxcbiAgICAgICAgc3Ryb2tlOiBtYXJrZXJDb25maWcucG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlckNvbmZpZy5wV2lkdGhcbiAgICAgIH0pO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhjaXJjbGUsIHtcbiAgICAgICAgICB0b3A6IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cudG9wLFxuICAgICAgICAgIGxlZnQ6IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cubGVmdCxcbiAgICAgICAgICBibHVyOiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmJsdXIsXG4gICAgICAgICAgY29sb3I6IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5vcGFjaXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMucmVzaXplZCkge1xuICAgICAgICAgIHNwZWVkID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW0uYW5pbWF0ZUNpcmNsZVJhZGl1cyhjaXJjbGUsIDAsIGZpbmlzaFJhZGl1cywgc3BlZWQsIHcuZ2xvYmFscy5lYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNBbmltKSB7XG4gICAgICAgICAgdmFyIF9zcGVlZCA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZDtcbiAgICAgICAgICB2YXIgcHJldlgsIHByZXZZLCBwcmV2UjtcbiAgICAgICAgICB2YXIgcHJldlBhdGhKID0gbnVsbDtcbiAgICAgICAgICBwcmV2UGF0aEogPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tyZWFsSW5kZXhdICYmIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3JlYWxJbmRleF1bal07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHByZXZQYXRoSiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJldlBhdGhKICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzZXJpZXMgY29udGFpbmluZyBsZXNzIGVsZW1lbnRzIHdpbGwgaWdub3JlIHRoZXNlIHZhbHVlcyBhbmQgcmV2ZXJ0IHRvIDBcbiAgICAgICAgICAgIHByZXZYID0gcHJldlBhdGhKLng7XG4gICAgICAgICAgICBwcmV2WSA9IHByZXZQYXRoSi55O1xuICAgICAgICAgICAgcHJldlIgPSB0eXBlb2YgcHJldlBhdGhKLnIgIT09ICd1bmRlZmluZWQnID8gcHJldlBhdGhKLnIgOiBmaW5pc2hSYWRpdXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgY3MgPSAwOyBjcyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjcysrKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc1tjc10uaW5kZXggPT09IHJlYWxJbmRleCkge1xuICAgICAgICAgICAgICBfc3BlZWQgPSAxO1xuICAgICAgICAgICAgICBmaW5pc2hSYWRpdXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIGZpbmlzaFJhZGl1cyA9IDA7XG4gICAgICAgICAgYW5pbS5hbmltYXRlQ2lyY2xlKGNpcmNsZSwge1xuICAgICAgICAgICAgY3g6IHByZXZYLFxuICAgICAgICAgICAgY3k6IHByZXZZLFxuICAgICAgICAgICAgcjogcHJldlJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjeDogeCxcbiAgICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgICAgcjogZmluaXNoUmFkaXVzXG4gICAgICAgICAgfSwgX3NwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaXJjbGUuYXR0cih7XG4gICAgICAgICAgICByOiBmaW5pc2hSYWRpdXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaXJjbGUuYXR0cih7XG4gICAgICAgIHJlbDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgIGo6IGRhdGFQb2ludEluZGV4LFxuICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAnZGVmYXVsdC1tYXJrZXItc2l6ZSc6IGZpbmlzaFJhZGl1c1xuICAgICAgfSk7XG4gICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihjaXJjbGUsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgbWFya2Vycy5hZGRFdmVudHMoY2lyY2xlKTtcbiAgICAgIGNpcmNsZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZW50ZXJUZXh0SW5CdWJibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VudGVyVGV4dEluQnViYmxlKHkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgeSA9IHkgKyBwYXJzZUludCh3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2F0dGVyO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRGF0YUxhYmVscyBDbGFzcyBmb3IgZHJhd2luZyBkYXRhTGFiZWxzIG9uIEF4ZXMgYmFzZWQgQ2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgRGF0YUxhYmVsc1xuICoqL1xuXG52YXIgRGF0YUxhYmVscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFMYWJlbHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFMYWJlbHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH0gLy8gV2hlbiB0aGVyZSBhcmUgbWFueSBkYXRhbGFiZWxzIHRvIGJlIHByaW50ZWQsIGFuZCBzb21lIG9mIHRoZW0gb3ZlcmxhcHMgZWFjaCBvdGhlciBpbiB0aGUgc2FtZSBzZXJpZXMsIHRoaXMgbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcbiAgLy8gQWxzbywgd2hlbiBkYXRhbGFiZWxzIGV4Y2VlZHMgdGhlIGRyYXdhYmxlIGFyZWEgYW5kIGdldCBjbGlwcGVkIG9mZiwgd2UgbmVlZCB0byBhZGp1c3QgYW5kIG1vdmUgc29tZSBwaXhlbHMgdG8gbWFrZSB0aGVtIHZpc2libGUgYWdhaW5cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhTGFiZWxzLCBbe1xuICAgIGtleTogXCJkYXRhTGFiZWxzQ29ycmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB2YWwsIGksIGRhdGFQb2ludEluZGV4LCBhbHdheXNEcmF3RGF0YUxhYmVsLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGRyYXduZXh0TGFiZWwgPSBmYWxzZTsgLy9cblxuICAgICAgdmFyIHRleHRSZWN0cyA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIGZvbnRTaXplKTtcbiAgICAgIHZhciB3aWR0aCA9IHRleHRSZWN0cy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0ZXh0UmVjdHMuaGVpZ2h0OyAvLyBmaXJzdCB2YWx1ZSBpbiBzZXJpZXMsIHNvIHB1c2ggYW4gZW1wdHkgYXJyYXlcblxuICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldID09PSAndW5kZWZpbmVkJykgdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXSA9IFtdOyAvLyB0aGVuIHN0YXJ0IHB1c2hpbmcgYWN0dWFsIHJlY3RzIGluIHRoYXQgc3ViLWFycmF5XG5cbiAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ubGVuZ3RoIC0gMjtcbiAgICAgIHZhciBsYXN0RHJhd25JbmRleCA9IHR5cGVvZiB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldW3cuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXS5sZW5ndGggLSAxXSA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXVtsZW5dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbGFzdERhdGFMYWJlbFJlY3QgPSB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldW2xhc3REcmF3bkluZGV4XTtcblxuICAgICAgICBpZiAoIC8vIG5leHQgbGFiZWwgZm9yd2FyZCBhbmQgeCBub3QgaW50ZXJzZWN0aW5nXG4gICAgICAgIHggPiBsYXN0RGF0YUxhYmVsUmVjdC54ICsgbGFzdERhdGFMYWJlbFJlY3Qud2lkdGggKyAyIHx8IHkgPiBsYXN0RGF0YUxhYmVsUmVjdC55ICsgbGFzdERhdGFMYWJlbFJlY3QuaGVpZ2h0ICsgMiB8fCB4ICsgd2lkdGggPCBsYXN0RGF0YUxhYmVsUmVjdC54IC8vIG5leHQgbGFiZWwgaXMgZ29pbmcgdG8gYmUgZHJhd24gYmFja3dhcmRzXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gdGhlIDIgaW5kZXhlcyBkb24ndCBvdmVycmlkZSwgc28gT0sgdG8gZHJhdyBuZXh0IGxhYmVsXG4gICAgICAgICAgICBkcmF3bmV4dExhYmVsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhUG9pbnRJbmRleCA9PT0gMCB8fCBhbHdheXNEcmF3RGF0YUxhYmVsKSB7XG4gICAgICAgIGRyYXduZXh0TGFiZWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBkcmF3bmV4dExhYmVsOiBkcmF3bmV4dExhYmVsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RGF0YUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdEYXRhTGFiZWwocG9zLCBpLCBqKSB7XG4gICAgICB2YXIgYWxpZ24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICd0b3AnO1xuICAgICAgLy8gdGhpcyBtZXRob2QgaGFuZGxlcyBsaW5lLCBhcmVhLCBidWJibGUsIHNjYXR0ZXIgY2hhcnRzIGFzIHRob3NlIGNoYXJ0cyBjb250YWlucyBtYXJrZXJzL3BvaW50cyB3aGljaCBoYXZlIHByZS1kZWZpbmVkIHgveSBwb3NpdGlvbnNcbiAgICAgIC8vIGFsbCBvdGhlciBjaGFydHMgbGlrZSBiYXJzIC8gaGVhdG1hcHMgd2lsbCBkZWZpbmUgdGhlaXIgb3duIGRyYXdEYXRhTGFiZWwgcm91dGluZVxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajtcbiAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gbnVsbDtcblxuICAgICAgaWYgKCFkYXRhTGFiZWxzQ29uZmlnLmVuYWJsZWQgfHwgcG9zLnggaW5zdGFuY2VvZiBBcnJheSAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICAgIH1cblxuICAgICAgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJ1xuICAgICAgfSk7XG4gICAgICBlbERhdGFMYWJlbHNXcmFwLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG5cbiAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcG9zLngubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgeCA9IHBvcy54W3FdICsgZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRYO1xuICAgICAgICB5ID0gcG9zLnlbcV0gKyBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFkgLSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldIC0gNTtcblxuICAgICAgICBpZiAoYWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgeSA9IHkgKyB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldICogMiArIHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpICogMS40O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgICAgIC8vIGEgc21hbGwgaGFjayBhcyB3ZSBoYXZlIDIgcG9pbnRzIGZvciB0aGUgZmlyc3QgdmFsIHRvIGNvbm5lY3QgaXRcbiAgICAgICAgICBpZiAoaiA9PT0gMSAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMSkgZGF0YVBvaW50SW5kZXggPSAxO1xuICAgICAgICAgIHZhciB2YWwgPSB3Lmdsb2JhbHMuc2VyaWVzW2ldW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgICB2YXIgdGV4dCA9ICcnO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdidWJibGUnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdy5nbG9iYWxzLnNlcmllc1pbaV1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgeSA9IHBvcy55W3FdICsgdy5jb25maWcuZGF0YUxhYmVscy5vZmZzZXRZO1xuICAgICAgICAgICAgdmFyIHNjYXR0ZXIgPSBuZXcgU2NhdHRlcih0aGlzLmN0eCk7XG4gICAgICAgICAgICB2YXIgY2VudGVyVGV4dEluQnViYmxlQ29vcmRzID0gc2NhdHRlci5jZW50ZXJUZXh0SW5CdWJibGUoeSwgaSwgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgeSA9IGNlbnRlclRleHRJbkJ1YmJsZUNvb3Jkcy55O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IHcuY29uZmlnLmRhdGFMYWJlbHMuZm9ybWF0dGVyKHZhbCwge1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0ZXh0ID09PSBudWxsKSB0ZXh0ID0gJyc7XG4gICAgICAgICAgdGhpcy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGRhdGFQb2ludEluZGV4LFxuICAgICAgICAgICAgcGFyZW50OiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IHcuY29uZmlnLmRhdGFMYWJlbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxvdERhdGFMYWJlbHNUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3REYXRhTGFiZWxzVGV4dChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeCA9IG9wdHMueCxcbiAgICAgICAgICB5ID0gb3B0cy55LFxuICAgICAgICAgIGkgPSBvcHRzLmksXG4gICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICB0ZXh0ID0gb3B0cy50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3IgPSBvcHRzLnRleHRBbmNob3IsXG4gICAgICAgICAgcGFyZW50ID0gb3B0cy5wYXJlbnQsXG4gICAgICAgICAgZGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuZGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICBhbHdheXNEcmF3RGF0YUxhYmVsID0gb3B0cy5hbHdheXNEcmF3RGF0YUxhYmVsLFxuICAgICAgICAgIG9mZnNldENvcnJlY3Rpb24gPSBvcHRzLm9mZnNldENvcnJlY3Rpb247XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZE9uU2VyaWVzKSkge1xuICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkT25TZXJpZXMuaW5kZXhPZihpKSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3JyZWN0ZWRMYWJlbHMgPSB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGRyYXduZXh0TGFiZWw6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGlmIChvZmZzZXRDb3JyZWN0aW9uKSB7XG4gICAgICAgIGNvcnJlY3RlZExhYmVscyA9IHRoaXMuZGF0YUxhYmVsc0NvcnJlY3Rpb24oeCwgeSwgdGV4dCwgaSwgaiwgYWx3YXlzRHJhd0RhdGFMYWJlbCwgcGFyc2VJbnQoZGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSkpO1xuICAgICAgfSAvLyB3aGVuIHpvb21lZCwgd2UgZG9uJ3QgbmVlZCB0byBjb3JyZWN0IGxhYmVscyBvZmZzZXRzLFxuICAgICAgLy8gYnV0IGlmIG5vcm1hbGx5LCBsYWJlbHMgZ2V0IGNyb3BwZWQsIGNvcnJlY3QgdGhlbVxuXG5cbiAgICAgIGlmICghdy5nbG9iYWxzLnpvb21lZCkge1xuICAgICAgICB4ID0gY29ycmVjdGVkTGFiZWxzLng7XG4gICAgICAgIHkgPSBjb3JyZWN0ZWRMYWJlbHMueTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcnJlY3RlZExhYmVscy5kcmF3bmV4dExhYmVsKSB7XG4gICAgICAgIHZhciBkYXRhTGFiZWxUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgZm9yZUNvbG9yOiB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnNbaV0sXG4gICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvciB8fCBkYXRhTGFiZWxzQ29uZmlnLnRleHRBbmNob3IsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBmb250U2l6ZTogZGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRGYW1pbHlcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFMYWJlbFRleHQuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbCcsXG4gICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgY3k6IHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHRleHRTaGFkb3cgPSBkYXRhTGFiZWxzQ29uZmlnLmRyb3BTaGFkb3c7XG4gICAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGRhdGFMYWJlbFRleHQsIHRleHRTaGFkb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmFkZChkYXRhTGFiZWxUZXh0KTtcblxuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXS5wdXNoKGopO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhTGFiZWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQmFyIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGJvdGggQ29sdW1ucyBhbmQgQmFycy5cbiAqXG4gKiBAbW9kdWxlIEJhclxuICoqL1xuXG52YXIgQmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKGN0eCwgeHlSYXRpb3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMuYmFyT3B0aW9ucyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhcjtcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IHRoaXMuYmFyT3B0aW9ucy5ob3Jpem9udGFsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB3LmNvbmZpZy5zdHJva2Uud2lkdGg7XG4gICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcblxuICAgIGlmICh0aGlzLnh5UmF0aW9zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnhSYXRpbyA9IHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFhSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWFJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFlSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWVJhdGlvO1xuICAgICAgdGhpcy5iYXNlTGluZVkgPSB4eVJhdGlvcy5iYXNlTGluZVk7XG4gICAgICB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZID0geHlSYXRpb3MuYmFzZUxpbmVJbnZlcnRlZFk7XG4gICAgfVxuXG4gICAgdGhpcy55YXhpc0luZGV4ID0gMDtcbiAgICB0aGlzLnNlcmllc0xlbiA9IDA7XG4gIH1cbiAgLyoqIHByaW1hcnkgZHJhdyBtZXRob2Qgd2hpY2ggaXMgY2FsbGVkIG9uIGJhciBvYmplY3RcbiAgICogQG1lbWJlcm9mIEJhclxuICAgKiBAcGFyYW0ge2FycmF5fSBzZXJpZXMgLSB1c2VyIHN1cHBsaWVkIHNlcmllcyB2YWx1ZXNcbiAgICogQHBhcmFtIHtpbnR9IHNlcmllc0luZGV4IC0gdGhlIGluZGV4IGJ5IHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduIG9uIHRoZSBzdmdcbiAgICogQHJldHVybiB7bm9kZX0gZWxlbWVudCB3aGljaCBpcyBzdXBwbGllZCB0byBwYXJlbnQgY2hhcnQgZHJhdyBtZXRob2QgZm9yIGFwcGVuZGluZ1xuICAgKiovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgsIHcpO1xuICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTtcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWJhci1zZXJpZXMgYXBleGNoYXJ0cy1wbG90LXNlcmllcydcbiAgICAgIH0pO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsSXRlbXMgPiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGF0YUxhYmVscy5tYXhJdGVtcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogRGF0YUxhYmVscyBhcmUgZW5hYmxlZCBidXQgdGhlcmUgYXJlIHRvbyBtYW55IHRvIGRpc3BsYXkuIFRoaXMgbWF5IGNhdXNlIHBlcmZvcm1hbmNlIGlzc3VlIHdoZW4gcmVuZGVyaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgdmFyIHBhdGhUbyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdm9pZCAwO1xuICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICB4RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB4RGl2aXNpb24gaXMgdGhlIEdSSURXSURUSCBkaXZpZGVkIGJ5IG51bWJlciBvZiBkYXRhcG9pbnRzIChjb2x1bW5zKVxuICAgICAgICB5RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB5RGl2aXNpb24gaXMgdGhlIEdSSURIRUlHSFQgZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoYmFycylcbiAgICAgICAgemVyb0ggPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcbiAgICAgICAgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgIHZhciB5QXJyaiA9IFtdOyAvLyBob2xkIHkgdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgIHZhciB4QXJyaiA9IFtdOyAvLyBob2xkIHggdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlSSA9IHRoaXMudmlzaWJsZUkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3RoaXMueWF4aXNJbmRleF0ucmV2ZXJzZWQ7XG4gICAgICAgIHZhciBpbml0UG9zaXRpb25zID0gdGhpcy5pbml0aWFsUG9zaXRpb25zKCk7XG4gICAgICAgIHkgPSBpbml0UG9zaXRpb25zLnk7XG4gICAgICAgIGJhckhlaWdodCA9IGluaXRQb3NpdGlvbnMuYmFySGVpZ2h0O1xuICAgICAgICB5RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnlEaXZpc2lvbjtcbiAgICAgICAgemVyb1cgPSBpbml0UG9zaXRpb25zLnplcm9XO1xuICAgICAgICB4ID0gaW5pdFBvc2l0aW9ucy54O1xuICAgICAgICBiYXJXaWR0aCA9IGluaXRQb3NpdGlvbnMuYmFyV2lkdGg7XG4gICAgICAgIHhEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueERpdmlzaW9uO1xuICAgICAgICB6ZXJvSCA9IGluaXRQb3NpdGlvbnMuemVyb0g7XG5cbiAgICAgICAgaWYgKCF0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICB9IC8vIGVsZGF0YWxhYmVsc1xuXG5cbiAgICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCB0aiA9IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqIDwgdy5nbG9iYWxzLmRhdGFQb2ludHM7IGorKywgdGotLSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJpZXNbaV1bal0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pc051bGxWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNOdWxsVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuc3Ryb2tlLnNob3cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh0aGlzLnN0cm9rZVdpZHRoKSA/IHRoaXMuc3Ryb2tlV2lkdGhbcmVhbEluZGV4XSA6IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhzID0gbnVsbDtcblxuICAgICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcGF0aHMgPSB0aGlzLmRyYXdCYXJQYXRocyh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIHplcm9XOiB6ZXJvVyxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeURpdmlzaW9uOiB5RGl2aXNpb24sXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhzID0gdGhpcy5kcmF3Q29sdW1uUGF0aHMoe1xuICAgICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGJjOiBiY1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICB6ZXJvSDogemVyb0gsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoVG8gPSBwYXRocy5wYXRoVG87XG4gICAgICAgICAgcGF0aEZyb20gPSBwYXRocy5wYXRoRnJvbTtcbiAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICB4ID0gcGF0aHMueDsgLy8gcHVzaCBjdXJyZW50IFhcblxuICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgeEFycmoucHVzaCh4ICsgYmFyV2lkdGggLyAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5QXJyai5wdXNoKHkpO1xuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IHRoaXMuZ2V0UGF0aEZpbGxDb2xvcihzZXJpZXMsIGksIGosIHJlYWxJbmRleCk7XG4gICAgICAgICAgZWxTZXJpZXMgPSB0aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdmlzaWJsZVNlcmllczogdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdiYXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gcHVzaCBhbGwgeCB2YWwgYXJyYXlzIGludG8gbWFpbiB4QXJyXG5cblxuICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tyZWFsSW5kZXhdID0geEFycmo7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyajtcbiAgICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhdGhGaWxsQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZpbGxDb2xvcihzZXJpZXMsIGksIGosIHJlYWxJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSBudWxsO1xuICAgICAgdmFyIHNlcmllc051bWJlciA9IHRoaXMuYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IGogOiBpO1xuXG4gICAgICBpZiAodGhpcy5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY29sb3JSYW5nZSA9IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMucmFuZ2VzO1xuICAgICAgICBjb2xvclJhbmdlLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoc2VyaWVzW2ldW2pdID49IHJhbmdlLmZyb20gJiYgc2VyaWVzW2ldW2pdIDw9IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBmaWxsQ29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0gJiYgdy5jb25maWcuc2VyaWVzW2ldLmRhdGFbal0uZmlsbENvbG9yKSB7XG4gICAgICAgIGZpbGxDb2xvciA9IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdLmZpbGxDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgIHNlcmllc051bWJlcjogdGhpcy5iYXJPcHRpb25zLmRpc3RyaWJ1dGVkID8gc2VyaWVzTnVtYmVyIDogcmVhbEluZGV4LFxuICAgICAgICBjb2xvcjogZmlsbENvbG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXRoRmlsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclNlcmllcyhfcmVmKSB7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gX3JlZi5yZWFsSW5kZXgsXG4gICAgICAgICAgcGF0aEZpbGwgPSBfcmVmLnBhdGhGaWxsLFxuICAgICAgICAgIGxpbmVGaWxsID0gX3JlZi5saW5lRmlsbCxcbiAgICAgICAgICBqID0gX3JlZi5qLFxuICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmLnBhdGhGcm9tLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYuZWxTZXJpZXMsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHNlcmllcyA9IF9yZWYuc2VyaWVzLFxuICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYuYmFySGVpZ2h0LFxuICAgICAgICAgIGJhcldpZHRoID0gX3JlZi5iYXJXaWR0aCxcbiAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwID0gX3JlZi5lbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgIHZpc2libGVTZXJpZXMgPSBfcmVmLnZpc2libGVTZXJpZXMsXG4gICAgICAgICAgdHlwZSA9IF9yZWYudHlwZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcblxuICAgICAgaWYgKCFsaW5lRmlsbCkge1xuICAgICAgICAvKiBmaXggYXBleGNoYXJ0cyMzNDEgKi9cbiAgICAgICAgbGluZUZpbGwgPSB0aGlzLmJhck9wdGlvbnMuZGlzdHJpYnV0ZWQgPyB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9yc1tqXSA6IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW3JlYWxJbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVtqXS5zdHJva2VDb2xvcikge1xuICAgICAgICBsaW5lRmlsbCA9IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhW2pdLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc051bGxWYWx1ZSkge1xuICAgICAgICBwYXRoRmlsbCA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbGF5ID0gaiAvIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuYW5pbWF0ZUdyYWR1YWxseS5kZWxheSAqICh3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkIC8gdy5nbG9iYWxzLmRhdGFQb2ludHMpIC8gMi40O1xuICAgICAgdmFyIHJlbmRlcmVkUGF0aCA9IGdyYXBoaWNzLnJlbmRlclBhdGhzKHtcbiAgICAgICAgaTogaSxcbiAgICAgICAgajogaixcbiAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHN0cm9rZTogbGluZUZpbGwsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdy5jb25maWcuc3Ryb2tlLmxpbmVDYXAsXG4gICAgICAgIGZpbGw6IHBhdGhGaWxsLFxuICAgICAgICBhbmltYXRpb25EZWxheTogZGVsYXksXG4gICAgICAgIGluaXRpYWxTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCxcbiAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgIGNsYXNzTmFtZTogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1hcmVhXCIpLFxuICAgICAgICBpZDogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1hcmVhXCIpXG4gICAgICB9KTtcbiAgICAgIHJlbmRlcmVkUGF0aC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihyZW5kZXJlZFBhdGgsIHJlYWxJbmRleCwgaik7XG4gICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRQYXRoKTtcbiAgICAgIHZhciBkYXRhTGFiZWxzID0gdGhpcy5jYWxjdWxhdGVEYXRhTGFiZWxzUG9zKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgaTogaSxcbiAgICAgICAgajogaixcbiAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICByZW5kZXJlZFBhdGg6IHJlbmRlcmVkUGF0aCxcbiAgICAgICAgdmlzaWJsZVNlcmllczogdmlzaWJsZVNlcmllc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgIGVsRGF0YUxhYmVsc1dyYXAuYWRkKGRhdGFMYWJlbHMpO1xuICAgICAgfVxuXG4gICAgICBlbFNlcmllcy5hZGQoZWxEYXRhTGFiZWxzV3JhcCk7XG4gICAgICByZXR1cm4gZWxTZXJpZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRWYXJpYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFZhcmlhYmxlcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgICB0aGlzLnRvdGFsSXRlbXMgPSAwO1xuICAgICAgdGhpcy5zZXJpZXNMZW4gPSAwO1xuICAgICAgdGhpcy52aXNpYmxlSSA9IC0xO1xuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSAxOyAvLyBudW1iZXIgb2YgdmlzaWJsZSBiYXJzIGFmdGVyIHVzZXIgem9vbWVkIGluL291dFxuXG4gICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NsXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXJpZXNMZW4gPSB0aGlzLnNlcmllc0xlbiArIDE7XG4gICAgICAgICAgdGhpcy50b3RhbEl0ZW1zICs9IHNlcmllc1tzbF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgLy8gZ2V0IG1heCB2aXNpYmxlIGl0ZW1zXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJpZXNbc2xdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllc1hbc2xdW2pdID4gdy5nbG9iYWxzLm1pblggJiYgdy5nbG9iYWxzLnNlcmllc1hbc2xdW2pdIDwgdy5nbG9iYWxzLm1heFgpIHtcbiAgICAgICAgICAgICAgdGhpcy52aXNpYmxlSXRlbXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXJpZXNMZW4gPT09IDApIHtcbiAgICAgICAgLy8gQSBzbWFsbCBhZGp1c3RtZW50IHdoZW4gY29tYm8gY2hhcnRzIGFyZSB1c2VkXG4gICAgICAgIHRoaXMuc2VyaWVzTGVuID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsUG9zaXRpb25zKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeCwgeSwgeURpdmlzaW9uLCB4RGl2aXNpb24sIGJhckhlaWdodCwgYmFyV2lkdGgsIHplcm9ILCB6ZXJvVztcblxuICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIGhlaWdodCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgeURpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgYmFySGVpZ2h0ID0geURpdmlzaW9uIC8gdGhpcy5zZXJpZXNMZW47XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeURpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aGlzLnRvdGFsSXRlbXM7XG4gICAgICAgICAgYmFySGVpZ2h0ID0geURpdmlzaW9uIC8gdGhpcy5zZXJpZXNMZW47XG4gICAgICAgIH1cblxuICAgICAgICBiYXJIZWlnaHQgPSBiYXJIZWlnaHQgKiBwYXJzZUludCh0aGlzLmJhck9wdGlvbnMuYmFySGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgemVyb1cgPSB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICsgdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRXaWR0aCA6IDApIC0gKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuYmFzZUxpbmVJbnZlcnRlZFkgKiAyIDogMCk7XG4gICAgICAgIHkgPSAoeURpdmlzaW9uIC0gYmFySGVpZ2h0ICogdGhpcy5zZXJpZXNMZW4pIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuICAgICAgICB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGhpcy52aXNpYmxlSXRlbXM7XG4gICAgICAgIGJhcldpZHRoID0geERpdmlzaW9uIC8gdGhpcy5zZXJpZXNMZW4gKiBwYXJzZUludCh0aGlzLmJhck9wdGlvbnMuY29sdW1uV2lkdGgpIC8gMTAwO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIC8vIG1heCBiYXJ3aWR0aCBzaG91bGQgYmUgZXF1YWwgdG8gbWluWERpZmYgdG8gYXZvaWQgb3ZlcmxhcFxuICAgICAgICAgIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5taW5YRGlmZiAvIHRoaXMueFJhdGlvO1xuICAgICAgICAgIGJhcldpZHRoID0geERpdmlzaW9uIC8gdGhpcy5zZXJpZXNMZW4gKiBwYXJzZUludCh0aGlzLmJhck9wdGlvbnMuY29sdW1uV2lkdGgpIC8gMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgemVyb0ggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gLSAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgOiAwKSArICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApO1xuICAgICAgICB4ID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyAoeERpdmlzaW9uIC0gYmFyV2lkdGggKiB0aGlzLnNlcmllc0xlbikgLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIHplcm9IOiB6ZXJvSCxcbiAgICAgICAgemVyb1c6IHplcm9XXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFyUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhclBhdGhzKF9yZWYyKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IF9yZWYyLmluZGV4ZXMsXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZjIuYmFySGVpZ2h0LFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgcGF0aFRvID0gX3JlZjIucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZjIucGF0aEZyb20sXG4gICAgICAgICAgemVyb1cgPSBfcmVmMi56ZXJvVyxcbiAgICAgICAgICB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmMi55RGl2aXNpb24sXG4gICAgICAgICAgZWxTZXJpZXMgPSBfcmVmMi5lbFNlcmllcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICB2YXIgYmMgPSBpbmRleGVzLmJjO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeSA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMuaW52ZXJ0ZWRYUmF0aW8gLSBiYXJIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXJZUG9zaXRpb24gPSB5ICsgYmFySGVpZ2h0ICogdGhpcy52aXNpYmxlSTtcbiAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoemVyb1csIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IGdyYXBoaWNzLm1vdmUoemVyb1csIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhGcm9tID0gdGhpcy5nZXRQYXRoRnJvbShyZWFsSW5kZXgsIGopO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gemVyb1c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gemVyb1cgKyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gLSAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLmludmVydGVkWVJhdGlvIDogMCkgKiAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kaW5nU2hhcGVPcHRzID0ge1xuICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvbixcbiAgICAgICAgeDogeCxcbiAgICAgICAgemVyb1c6IHplcm9XXG4gICAgICB9O1xuICAgICAgdmFyIGVuZGluZ1NoYXBlID0gdGhpcy5iYXJFbmRpbmdTaGFwZSh3LCBlbmRpbmdTaGFwZU9wdHMsIHRoaXMuc2VyaWVzLCBpLCBqKTtcbiAgICAgIHBhdGhUbyA9IHBhdGhUbyArIGdyYXBoaWNzLmxpbmUoZW5kaW5nU2hhcGUubmV3WCwgYmFyWVBvc2l0aW9uKSArIGVuZGluZ1NoYXBlLnBhdGggKyBncmFwaGljcy5saW5lKHplcm9XLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLSBzdHJva2VXaWR0aCkgKyBncmFwaGljcy5saW5lKHplcm9XLCBiYXJZUG9zaXRpb24pO1xuICAgICAgcGF0aEZyb20gPSBwYXRoRnJvbSArIGdyYXBoaWNzLmxpbmUoemVyb1csIGJhcllQb3NpdGlvbikgKyBlbmRpbmdTaGFwZS5lbmRpbmdfcF9mcm9tICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB5ID0geSArIHlEaXZpc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGggPiAwICYmIGkgPT09IDApIHtcbiAgICAgICAgaWYgKGJjID49IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBiYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmNvbG9yID0gdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzW2JjXTtcbiAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCgwLCBiYXJZUG9zaXRpb24gLSBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCBiYXJIZWlnaHQgKiB0aGlzLnNlcmllc0xlbiwgMCwgYmNvbG9yLCB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29sdW1uUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NvbHVtblBhdGhzKF9yZWYzKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IF9yZWYzLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnksXG4gICAgICAgICAgeERpdmlzaW9uID0gX3JlZjMueERpdmlzaW9uLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYzLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYzLnBhdGhGcm9tLFxuICAgICAgICAgIGJhcldpZHRoID0gX3JlZjMuYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0ggPSBfcmVmMy56ZXJvSCxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZjMuZWxTZXJpZXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeSA9IHplcm9IO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHplcm9IIC0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZGluZ1NoYXBlT3B0cyA9IHtcbiAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICB5OiB5LFxuICAgICAgICB6ZXJvSDogemVyb0hcbiAgICAgIH07XG4gICAgICB2YXIgZW5kaW5nU2hhcGUgPSB0aGlzLmJhckVuZGluZ1NoYXBlKHcsIGVuZGluZ1NoYXBlT3B0cywgdGhpcy5zZXJpZXMsIGksIGopO1xuICAgICAgcGF0aFRvID0gcGF0aFRvICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGVuZGluZ1NoYXBlLm5ld1kpICsgZW5kaW5nU2hhcGUucGF0aCArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gLSBzdHJva2VXaWR0aCAvIDIsIHplcm9IKTtcbiAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgemVyb0gpICsgZW5kaW5nU2hhcGUuZW5kaW5nX3BfZnJvbSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCB6ZXJvSCkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiAtIHN0cm9rZVdpZHRoIC8gMiwgemVyb0gpO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzLmxlbmd0aCA+IDAgJiYgaSA9PT0gMCkge1xuICAgICAgICBpZiAoYmMgPj0gdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgIGJjID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiY29sb3IgPSB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnNbYmNdO1xuICAgICAgICB2YXIgcmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KGJhclhQb3NpdGlvbiAtIGJhcldpZHRoICogdGhpcy52aXNpYmxlSSwgMCwgYmFyV2lkdGggKiB0aGlzLnNlcmllc0xlbiwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsIDAsIGJjb2xvciwgdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyT3BhY2l0eSk7XG4gICAgICAgIGVsU2VyaWVzLmFkZChyZWN0KTtcbiAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtYmFja2dyb3VuZEJhcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBiYXJYUG9zaXRpb246IGJhclhQb3NpdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIGdldFBhdGhGcm9tIGlzIGEgY29tbW9uIGZ1bmN0aW9uIGZvciBiYXJzL2NvbHVtbnMgd2hpY2ggaXMgdXNlZCB0byBnZXQgcHJldmlvdXMgcGF0aHMgd2hlbiBkYXRhIGNoYW5nZXMuXG4gICAgICogQG1lbWJlcm9mIEJhclxuICAgICAqIEBwYXJhbSB7aW50fSByZWFsSW5kZXggLSBjdXJyZW50IGl0ZXJhdGluZyBpXG4gICAgICogQHBhcmFtIHtpbnR9IGogLSBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXMncyBqIGluZGV4XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoRnJvbSBpcyB0aGUgc3RyaW5nIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgaW4gYW5pbWF0aW9uc1xuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBhdGhGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhdGhGcm9tKHJlYWxJbmRleCwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcGF0aEZyb207XG5cbiAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICBpZiAoZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1tqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzW2pdLmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoRnJvbTtcbiAgICB9XG4gICAgLyoqIGNhbGN1bGF0ZUJhckRhdGFMYWJlbHMgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIGRhdGEtbGFiZWxzXG4gICAgICogSXQgYWxzbyBzZXRzIHRoZSBlbGVtZW50J3MgZGF0YSBhdHRyIGZvciBiYXJzIGFuZCBjYWxscyBkcmF3Q2FsY3VsYXRlZEJhckRhdGFMYWJlbHMoKVxuICAgICAqIEBtZW1iZXJvZiBCYXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ge2JhclByb3BzfSBtb3N0IG9mIHRoZSBiYXIgcHJvcGVydGllcyB1c2VkIHRocm91Z2hvdXQgdGhlIGJhclxuICAgICAqIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGRhdGFMYWJlbHMgbm9kZS1lbGVtZW50IHdoaWNoIHlvdSBjYW4gYXBwZW5kIGxhdGVyXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlRGF0YUxhYmVsc1Bvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVEYXRhTGFiZWxzUG9zKF9yZWY0KSB7XG4gICAgICB2YXIgeCA9IF9yZWY0LngsXG4gICAgICAgICAgeSA9IF9yZWY0LnksXG4gICAgICAgICAgaSA9IF9yZWY0LmksXG4gICAgICAgICAgaiA9IF9yZWY0LmosXG4gICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjQucmVhbEluZGV4LFxuICAgICAgICAgIHNlcmllcyA9IF9yZWY0LnNlcmllcyxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBfcmVmNC5iYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmNC5iYXJXaWR0aCxcbiAgICAgICAgICB2aXNpYmxlU2VyaWVzID0gX3JlZjQudmlzaWJsZVNlcmllcyxcbiAgICAgICAgICByZW5kZXJlZFBhdGggPSBfcmVmNC5yZW5kZXJlZFBhdGg7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBBcnJheS5pc0FycmF5KHRoaXMuc3Ryb2tlV2lkdGgpID8gdGhpcy5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIHZhciBiY3ggPSB4ICsgcGFyc2VGbG9hdChiYXJXaWR0aCAqIHZpc2libGVTZXJpZXMpO1xuICAgICAgdmFyIGJjeSA9IHkgKyBwYXJzZUZsb2F0KGJhckhlaWdodCAqIHZpc2libGVTZXJpZXMpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgYmN4ID0geCArIHBhcnNlRmxvYXQoYmFyV2lkdGggKiAodmlzaWJsZVNlcmllcyArIDEpKSAtIHN0cm9rZVdpZHRoO1xuICAgICAgICBiY3kgPSB5ICsgcGFyc2VGbG9hdChiYXJIZWlnaHQgKiAodmlzaWJsZVNlcmllcyArIDEpKSAtIHN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG51bGw7XG4gICAgICB2YXIgZGF0YUxhYmVsc1ggPSB4O1xuICAgICAgdmFyIGRhdGFMYWJlbHNZID0geTtcbiAgICAgIHZhciBkYXRhTGFiZWxzUG9zID0ge307XG4gICAgICB2YXIgZGF0YUxhYmVsc0NvbmZpZyA9IHcuY29uZmlnLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgYmFyRGF0YUxhYmVsc0NvbmZpZyA9IHRoaXMuYmFyT3B0aW9ucy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIG9mZlggPSBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICB2YXIgb2ZmWSA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WTtcbiAgICAgIHZhciB0ZXh0UmVjdHMgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmVuYWJsZWQpIHtcbiAgICAgICAgdGV4dFJlY3RzID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdKHcuZ2xvYmFscy5tYXhZKSwgcGFyc2VJbnQoZGF0YUxhYmVsc0NvbmZpZy5zdHlsZS5mb250U2l6ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgZGF0YUxhYmVsc1BvcyA9IHRoaXMuY2FsY3VsYXRlQmFyc0RhdGFMYWJlbHNQb3NpdGlvbih7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICByZW5kZXJlZFBhdGg6IHJlbmRlcmVkUGF0aCxcbiAgICAgICAgICBiY3k6IGJjeSxcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICB0ZXh0UmVjdHM6IHRleHRSZWN0cyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZGF0YUxhYmVsc1g6IGRhdGFMYWJlbHNYLFxuICAgICAgICAgIGRhdGFMYWJlbHNZOiBkYXRhTGFiZWxzWSxcbiAgICAgICAgICBiYXJEYXRhTGFiZWxzQ29uZmlnOiBiYXJEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIG9mZlg6IG9mZlgsXG4gICAgICAgICAgb2ZmWTogb2ZmWVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFMYWJlbHNQb3MgPSB0aGlzLmNhbGN1bGF0ZUNvbHVtbnNEYXRhTGFiZWxzUG9zaXRpb24oe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgcmVuZGVyZWRQYXRoOiByZW5kZXJlZFBhdGgsXG4gICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgYmN4OiBiY3gsXG4gICAgICAgICAgYmN5OiBiY3ksXG4gICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICBkYXRhTGFiZWxzWTogZGF0YUxhYmVsc1ksXG4gICAgICAgICAgYmFyRGF0YUxhYmVsc0NvbmZpZzogYmFyRGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICBvZmZYOiBvZmZYLFxuICAgICAgICAgIG9mZlk6IG9mZllcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVkUGF0aC5hdHRyKHtcbiAgICAgICAgY3k6IGRhdGFMYWJlbHNQb3MuYmN5LFxuICAgICAgICBjeDogZGF0YUxhYmVsc1Bvcy5iY3gsXG4gICAgICAgIGo6IGosXG4gICAgICAgIHZhbDogc2VyaWVzW2ldW2pdLFxuICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoXG4gICAgICB9KTtcbiAgICAgIGRhdGFMYWJlbHMgPSB0aGlzLmRyYXdDYWxjdWxhdGVkRGF0YUxhYmVscyh7XG4gICAgICAgIHg6IGRhdGFMYWJlbHNQb3MuZGF0YUxhYmVsc1gsXG4gICAgICAgIHk6IGRhdGFMYWJlbHNQb3MuZGF0YUxhYmVsc1ksXG4gICAgICAgIHZhbDogc2VyaWVzW2ldW2pdLFxuICAgICAgICBpOiByZWFsSW5kZXgsXG4gICAgICAgIGo6IGosXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhTGFiZWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVDb2x1bW5zRGF0YUxhYmVsc1Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbHVtbnNEYXRhTGFiZWxzUG9zaXRpb24ob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaSA9IG9wdHMuaSxcbiAgICAgICAgICBqID0gb3B0cy5qLFxuICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgYmN4ID0gb3B0cy5iY3gsXG4gICAgICAgICAgYmFyV2lkdGggPSBvcHRzLmJhcldpZHRoLFxuICAgICAgICAgIHRleHRSZWN0cyA9IG9wdHMudGV4dFJlY3RzLFxuICAgICAgICAgIGRhdGFMYWJlbHNZID0gb3B0cy5kYXRhTGFiZWxzWSxcbiAgICAgICAgICBiYXJEYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5iYXJEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCxcbiAgICAgICAgICBvZmZYID0gb3B0cy5vZmZYLFxuICAgICAgICAgIG9mZlkgPSBvcHRzLm9mZlk7XG4gICAgICB2YXIgZGF0YUxhYmVsc1g7XG4gICAgICB2YXIgYmFySGVpZ2h0ID0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdO1xuICAgICAgdmFyIGRhdGFQb2ludHNEaXZpZGVkV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICBiY3ggPSBiY3ggLSBzdHJva2VXaWR0aCAvIDI7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBkYXRhTGFiZWxzWCA9IGJjeCAtIGJhcldpZHRoIC8gMiArIG9mZlg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhTGFiZWxzWCA9IGJjeCAtIGRhdGFQb2ludHNEaXZpZGVkV2lkdGggKyBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsSXNOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzW2ldW2pdIDw9IDA7XG5cbiAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZWQpIHtcbiAgICAgICAgeSA9IHkgLSBiYXJIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYmFyRGF0YUxhYmVsc0NvbmZpZy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IHkgKyBiYXJIZWlnaHQgLyAyICsgdGV4dFJlY3RzLmhlaWdodCAvIDIgKyBvZmZZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IHkgKyBiYXJIZWlnaHQgLyAyICsgdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBvZmZZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCArIHRleHRSZWN0cy5oZWlnaHQgKyBzdHJva2VXaWR0aCArIG9mZlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCAtIHRleHRSZWN0cy5oZWlnaHQgLyAyICsgc3Ryb2tlV2lkdGggLSBvZmZZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSAtIHRleHRSZWN0cy5oZWlnaHQgLyAyIC0gb2ZmWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5ICsgdGV4dFJlY3RzLmhlaWdodCArIG9mZlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJjeDogYmN4LFxuICAgICAgICBiY3k6IHksXG4gICAgICAgIGRhdGFMYWJlbHNYOiBkYXRhTGFiZWxzWCxcbiAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVCYXJzRGF0YUxhYmVsc1Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJhcnNEYXRhTGFiZWxzUG9zaXRpb24ob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeCA9IG9wdHMueCxcbiAgICAgICAgICBpID0gb3B0cy5pLFxuICAgICAgICAgIGogPSBvcHRzLmosXG4gICAgICAgICAgYmN5ID0gb3B0cy5iY3ksXG4gICAgICAgICAgYmFySGVpZ2h0ID0gb3B0cy5iYXJIZWlnaHQsXG4gICAgICAgICAgdGV4dFJlY3RzID0gb3B0cy50ZXh0UmVjdHMsXG4gICAgICAgICAgZGF0YUxhYmVsc1ggPSBvcHRzLmRhdGFMYWJlbHNYLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCxcbiAgICAgICAgICBiYXJEYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5iYXJEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIG9mZlggPSBvcHRzLm9mZlgsXG4gICAgICAgICAgb2ZmWSA9IG9wdHMub2ZmWTtcbiAgICAgIHZhciBkYXRhUG9pbnRzRGl2aWRlZEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICB2YXIgZGF0YUxhYmVsc1kgPSBiY3kgLSBkYXRhUG9pbnRzRGl2aWRlZEhlaWdodCArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiArIG9mZlkgLSAzO1xuICAgICAgdmFyIGJhcldpZHRoID0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLmludmVydGVkWVJhdGlvO1xuICAgICAgdmFyIHZhbElzTmVnYXRpdmUgPSB0aGlzLnNlcmllc1tpXVtqXSA8PSAwO1xuXG4gICAgICBpZiAodGhpcy5pc1JldmVyc2VkKSB7XG4gICAgICAgIHggPSB4ICsgYmFyV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYmFyRGF0YUxhYmVsc0NvbmZpZy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgLSBvZmZYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGggLSBNYXRoLnJvdW5kKHRleHRSZWN0cy53aWR0aCAvIDIpIC0gb2ZmWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSB4IC0gYmFyV2lkdGggKyBzdHJva2VXaWR0aCArIE1hdGgucm91bmQodGV4dFJlY3RzLndpZHRoIC8gMikgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSAtIG9mZlg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoIC0gTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSArIG9mZlg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGNvbW1lbnRpbmcgYmVsb3cgbGluZXMgYXMgdGhpcyBjYXVzZXMgb3ZlcmxhcHMgb3ZlciBvdGhlciBsYWJlbHNcbiAgICAgIC8vIGlmIChkYXRhTGFiZWxzWCA8IDApIHtcbiAgICAgIC8vICAgZGF0YUxhYmVsc1ggPSB0ZXh0UmVjdHMud2lkdGggKyBzdHJva2VXaWR0aFxuICAgICAgLy8gfSBlbHNlIGlmIChkYXRhTGFiZWxzWCArIHRleHRSZWN0cy53aWR0aCAvIDIgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAvLyAgIGRhdGFMYWJlbHNYID0gZGF0YUxhYmVsc1ggLSB0ZXh0UmVjdHMud2lkdGggLSBzdHJva2VXaWR0aFxuICAgICAgLy8gfVxuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJjeDogeCxcbiAgICAgICAgYmN5OiBiY3ksXG4gICAgICAgIGRhdGFMYWJlbHNYOiBkYXRhTGFiZWxzWCxcbiAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q2FsY3VsYXRlZERhdGFMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKF9yZWY1KSB7XG4gICAgICB2YXIgeCA9IF9yZWY1LngsXG4gICAgICAgICAgeSA9IF9yZWY1LnksXG4gICAgICAgICAgdmFsID0gX3JlZjUudmFsLFxuICAgICAgICAgIGkgPSBfcmVmNS5pLFxuICAgICAgICAgIGogPSBfcmVmNS5qLFxuICAgICAgICAgIHRleHRSZWN0cyA9IF9yZWY1LnRleHRSZWN0cyxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBfcmVmNS5iYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmNS5iYXJXaWR0aCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gX3JlZjUuZGF0YUxhYmVsc0NvbmZpZztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGRhdGFMYWJlbHMgPSBuZXcgRGF0YUxhYmVscyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcuZm9ybWF0dGVyO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuICAgICAgdmFyIGlzU2VyaWVzTm90Q29sbGFwc2VkID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSA+IC0xO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkICYmICFpc1Nlcmllc05vdENvbGxhcHNlZCkge1xuICAgICAgICBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhLWxhYmVscydcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIodmFsLCB7XG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgYmFyV2lkdGggPSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFySGVpZ2h0ID0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRSZWN0cy53aWR0aCAvIDEuNiA+IGJhcldpZHRoIHx8IHRleHRSZWN0cy5oZWlnaHQgPiBiYXJIZWlnaHQpIHtcbiAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHBhcmVudDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGFsd2F5c0RyYXdEYXRhTGFiZWw6IHRydWUsXG4gICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsRGF0YUxhYmVsc1dyYXA7XG4gICAgfVxuICAgIC8qKiBiYXJFbmRpbmdTaGFwZSBkcmF3cyB0aGUgdmFyaW91cyBzaGFwZXMgb24gdG9wIG9mIGJhcnMvY29sdW1uc1xuICAgICAqIEBtZW1iZXJvZiBCYXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdyAtIGNoYXJ0IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIGNvbnNpc3RzIHNldmVyYWwgcHJvcGVydGllcyBsaWtlIGJhckhlaWdodC9iYXJXaWR0aFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHNlcmllcyAtIGdsb2JhbCBwcmltYXJ5IHNlcmllc1xuICAgICAqIEBwYXJhbSB7aW50fSBpIC0gY3VycmVudCBpdGVyYXRpbmcgc2VyaWVzJ3MgaW5kZXhcbiAgICAgKiBAcGFyYW0ge2ludH0gaiAtIHNlcmllcydzIGogb2YgaVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gcGF0aCAtIGVuZGluZyBzaGFwZSB3aGV0aGVyIHJvdW5kL2Fycm93XG4gICAgICogICAgICAgICBlbmRpbmdfcF9mcm9tIC0gc2ltaWxhciB0byBwYXRoRnJvbVxuICAgICAqICAgICAgICAgbmV3WSAtIHdoaWNoIGlzIGNhbGN1bGF0ZWQgZnJvbSBleGlzdGluZyB5IGFuZCBuZXcgc2hhcGUncyB0b3BcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJiYXJFbmRpbmdTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXJFbmRpbmdTaGFwZSh3LCBvcHRzLCBzZXJpZXMsIGksIGopIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgZW5kaW5nU2hhcGUgPSBudWxsO1xuICAgICAgICB2YXIgZW5kaW5nU2hhcGVGcm9tID0gJyc7XG4gICAgICAgIHZhciB4ID0gb3B0cy54O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW2ldW2pdICE9PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1bal0gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW52ZXJzZSA9IHNlcmllc1tpXVtqXSA8IDA7XG4gICAgICAgICAgdmFyIGVYID0gb3B0cy5iYXJIZWlnaHQgLyAyIC0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgICAgICBpZiAoaW52ZXJzZSkgZVggPSAtb3B0cy5iYXJIZWlnaHQgLyAyIC0gb3B0cy5zdHJva2VXaWR0aDtcblxuICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFyT3B0aW9ucy5lbmRpbmdTaGFwZSA9PT0gJ3JvdW5kZWQnKSB7XG4gICAgICAgICAgICAgIHggPSBvcHRzLnggLSBlWCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoICh0aGlzLmJhck9wdGlvbnMuZW5kaW5nU2hhcGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICBlbmRpbmdTaGFwZSA9IGdyYXBoaWNzLmxpbmUoeCwgb3B0cy5iYXJZUG9zaXRpb24gKyBvcHRzLmJhckhlaWdodCAtIG9wdHMuc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncm91bmRlZCc6XG4gICAgICAgICAgICAgIGVuZGluZ1NoYXBlID0gZ3JhcGhpY3MucXVhZHJhdGljQ3VydmUoeCArIGVYLCBvcHRzLmJhcllQb3NpdGlvbiArIChvcHRzLmJhckhlaWdodCAtIG9wdHMuc3Ryb2tlV2lkdGgpIC8gMiwgeCwgb3B0cy5iYXJZUG9zaXRpb24gKyBvcHRzLmJhckhlaWdodCAtIG9wdHMuc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IGVuZGluZ1NoYXBlLFxuICAgICAgICAgIGVuZGluZ19wX2Zyb206IGVuZGluZ1NoYXBlRnJvbSxcbiAgICAgICAgICBuZXdYOiB4XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2VuZGluZ1NoYXBlID0gbnVsbDtcbiAgICAgICAgdmFyIF9lbmRpbmdTaGFwZUZyb20gPSAnJztcbiAgICAgICAgdmFyIHkgPSBvcHRzLnk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbaV1bal0gIT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW52ZXJzZSA9IHNlcmllc1tpXVtqXSA8IDA7XG5cbiAgICAgICAgICB2YXIgZVkgPSBvcHRzLmJhcldpZHRoIC8gMiAtIG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgaWYgKF9pbnZlcnNlKSBlWSA9IC1vcHRzLmJhcldpZHRoIC8gMiAtIG9wdHMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzaGFwZSBleGNlZWRzIHRoZSBjaGFydCBoZWlnaHQsIGhlbmNlIHJlZHVjZSB5XG4gICAgICAgICAgICBpZiAodGhpcy5iYXJPcHRpb25zLmVuZGluZ1NoYXBlID09PSAncm91bmRlZCcpIHtcbiAgICAgICAgICAgICAgeSA9IHkgKyBlWSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoICh0aGlzLmJhck9wdGlvbnMuZW5kaW5nU2hhcGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICBfZW5kaW5nU2hhcGUgPSBncmFwaGljcy5saW5lKG9wdHMuYmFyWFBvc2l0aW9uICsgb3B0cy5iYXJXaWR0aCAtIG9wdHMuc3Ryb2tlV2lkdGgsIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncm91bmRlZCc6XG4gICAgICAgICAgICAgIF9lbmRpbmdTaGFwZSA9IGdyYXBoaWNzLnF1YWRyYXRpY0N1cnZlKG9wdHMuYmFyWFBvc2l0aW9uICsgKG9wdHMuYmFyV2lkdGggLSBvcHRzLnN0cm9rZVdpZHRoKSAvIDIsIHkgLSBlWSwgb3B0cy5iYXJYUG9zaXRpb24gKyBvcHRzLmJhcldpZHRoIC0gb3B0cy5zdHJva2VXaWR0aCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogX2VuZGluZ1NoYXBlLFxuICAgICAgICAgIGVuZGluZ19wX2Zyb206IF9lbmRpbmdTaGFwZUZyb20sXG4gICAgICAgICAgbmV3WTogeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBCYXJTdGFja2VkIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGJvdGggU3RhY2tlZCBDb2x1bW5zIGFuZCBCYXJzLlxuICpcbiAqIEBtb2R1bGUgQmFyU3RhY2tlZFxuICogVGhlIHdob2xlIGNhbGN1bGF0aW9uIGZvciBzdGFja2VkIGJhci9jb2x1bW4gaXMgZGlmZmVyZW50IGZyb20gbm9ybWFsIGJhci9jb2x1bW4sXG4gKiBoZW5jZSBpdCBtYWtlcyBzZW5zZSB0byBkZXJpdmUgYSBuZXcgY2xhc3MgZm9yIGl0IGV4dGVuZGluZyBtb3N0IG9mIHRoZSBwcm9wcyBvZiBQYXJlbnQgQmFyXG4gKiovXG5cbnZhciBCYXJTdGFja2VkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFyKSB7XG4gIF9pbmhlcml0cyhCYXJTdGFja2VkLCBfQmFyKTtcblxuICBmdW5jdGlvbiBCYXJTdGFja2VkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJTdGFja2VkKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQmFyU3RhY2tlZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFyU3RhY2tlZCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcywgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmJhciA9IG5ldyBCYXIodGhpcy5jdHgsIHRoaXMueHlSYXRpb3MpO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgsIHcpO1xuICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICB0aGlzLmluaXRWYXJpYWJsZXMoc2VyaWVzKTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrVHlwZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgIHNlcmllcyA9IHcuZ2xvYmFscy5zZXJpZXNQZXJjZW50LnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VyaWVzID0gc2VyaWVzO1xuICAgICAgdGhpcy50b3RhbEl0ZW1zID0gMDtcbiAgICAgIHRoaXMucHJldlkgPSBbXTsgLy8geSBwb3NpdGlvbiBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZYID0gW107IC8vIHggcG9zaXRpb24gb24gY2hhcnRcblxuICAgICAgdGhpcy5wcmV2WUYgPSBbXTsgLy8geSBwb3NpdGlvbiBpbmNsdWRpbmcgc2hhcGVzIG9uIGNoYXJ0XG5cbiAgICAgIHRoaXMucHJldlhGID0gW107IC8vIHggcG9zaXRpb24gaW5jbHVkaW5nIHNoYXBlcyBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZZVmFsID0gW107IC8vIHkgdmFsdWVzIChzZXJpZXNbaV1bal0pIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy5wcmV2WFZhbCA9IFtdOyAvLyB4IHZhbHVlcyAoc2VyaWVzW2ldW2pdKSBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmogPSBbXTsgLy8geGogaW5kaWNhdGVzIHggcG9zaXRpb24gb24gZ3JhcGggaW4gYmFyc1xuXG4gICAgICB0aGlzLnhBcnJqRiA9IFtdOyAvLyB4akYgaW5kaWNhdGVzIGJhcidzIHggcG9zaXRpb24gKyBlbmRpbmdzaGFwZSdzIHBvc2l0aW9ucyBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmpWYWwgPSBbXTsgLy8geCB2YWwgbWVhbnMgdGhlIGFjdHVhbCBzZXJpZXMncyB5IHZhbHVlcyBpbiBob3Jpem9udGFsL2JhcnNcblxuICAgICAgdGhpcy55QXJyaiA9IFtdOyAvLyB5aiBpbmRpY2F0ZXMgeSBwb3NpdGlvbiBvbiBncmFwaCBpbiBjb2x1bW5zXG5cbiAgICAgIHRoaXMueUFycmpGID0gW107IC8vIHlqRiBpbmRpY2F0ZXMgYmFyJ3MgeSBwb3NpdGlvbiArIGVuZGluZ3NoYXBlJ3MgcG9zaXRpb25zIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy55QXJyalZhbCA9IFtdOyAvLyB5IHZhbCBtZWFucyB0aGUgYWN0dWFsIHNlcmllcydzIHkgdmFsdWVzIGluIGNvbHVtbnNcblxuICAgICAgZm9yICh2YXIgc2wgPSAwOyBzbCA8IHNlcmllcy5sZW5ndGg7IHNsKyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzbF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudG90YWxJdGVtcyArPSBzZXJpZXNbc2xdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICB9KTtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGJjID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKywgYmMrKykge1xuICAgICAgICB2YXIgcGF0aFRvID0gdm9pZCAwLFxuICAgICAgICAgICAgcGF0aEZyb20gPSB2b2lkIDA7XG4gICAgICAgIHZhciB4RGl2aXNpb24gPSB2b2lkIDA7IC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG5cbiAgICAgICAgdmFyIHlEaXZpc2lvbiA9IHZvaWQgMDsgLy8geURpdmlzaW9uIGlzIHRoZSBHUklESEVJR0hUIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGJhcnMpXG5cbiAgICAgICAgdmFyIHplcm9IID0gdm9pZCAwOyAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcblxuICAgICAgICB2YXIgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgIHZhciB4QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciB5QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7XG5cbiAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3RoaXMueWF4aXNJbmRleF0ucmV2ZXJzZWQ7IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSkpLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG4gICAgICAgIHZhciBpbml0UG9zaXRpb25zID0gdGhpcy5pbml0aWFsUG9zaXRpb25zKHgsIHksIHhEaXZpc2lvbiwgeURpdmlzaW9uLCB6ZXJvSCwgemVyb1cpO1xuICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgIHplcm9XID0gaW5pdFBvc2l0aW9ucy56ZXJvVztcbiAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IO1xuICAgICAgICB0aGlzLnlBcnJqID0gW107XG4gICAgICAgIHRoaXMueUFycmpGID0gW107XG4gICAgICAgIHRoaXMueUFycmpWYWwgPSBbXTtcbiAgICAgICAgdGhpcy54QXJyaiA9IFtdO1xuICAgICAgICB0aGlzLnhBcnJqRiA9IFtdO1xuICAgICAgICB0aGlzLnhBcnJqVmFsID0gW107IC8vIGlmICghdGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIC8vIHRoaXMueEFycmoucHVzaCh4ICsgYmFyV2lkdGggLyAyKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnN0cm9rZS5zaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc051bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkodGhpcy5zdHJva2VXaWR0aCkgPyB0aGlzLnN0cm9rZVdpZHRoW3JlYWxJbmRleF0gOiB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHBhdGhzID0gdGhpcy5kcmF3QmFyUGF0aHMoe1xuICAgICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGJjOiBiY1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgICB6ZXJvVzogemVyb1csXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRocyA9IHRoaXMuZHJhd0NvbHVtblBhdGhzKHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aFRvID0gcGF0aHMucGF0aFRvO1xuICAgICAgICAgIHBhdGhGcm9tID0gcGF0aHMucGF0aEZyb207XG4gICAgICAgICAgeSA9IHBhdGhzLnk7XG4gICAgICAgICAgeCA9IHBhdGhzLng7XG4gICAgICAgICAgeEFyclZhbHVlcy5wdXNoKHgpO1xuICAgICAgICAgIHlBcnJWYWx1ZXMucHVzaCh5KTtcbiAgICAgICAgICB2YXIgcGF0aEZpbGwgPSB0aGlzLmJhci5nZXRQYXRoRmlsbENvbG9yKHNlcmllcywgaSwgaiwgcmVhbEluZGV4KTtcbiAgICAgICAgICBlbFNlcmllcyA9IHRoaXMucmVuZGVyU2VyaWVzKHtcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgcGF0aEZpbGw6IHBhdGhGaWxsLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllcyxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXA6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgIHZpc2libGVTZXJpZXM6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyVmFsdWVzO1xuICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWXZhbHVlc1tyZWFsSW5kZXhdID0geUFyclZhbHVlczsgLy8gcHVzaCBhbGwgY3VycmVudCB5IHZhbHVlcyBhcnJheSB0byBtYWluIFByZXZZIEFycmF5XG5cbiAgICAgICAgdGhpcy5wcmV2WS5wdXNoKHRoaXMueUFycmopO1xuICAgICAgICB0aGlzLnByZXZZRi5wdXNoKHRoaXMueUFycmpGKTtcbiAgICAgICAgdGhpcy5wcmV2WVZhbC5wdXNoKHRoaXMueUFycmpWYWwpO1xuICAgICAgICB0aGlzLnByZXZYLnB1c2godGhpcy54QXJyaik7XG4gICAgICAgIHRoaXMucHJldlhGLnB1c2godGhpcy54QXJyakYpO1xuICAgICAgICB0aGlzLnByZXZYVmFsLnB1c2godGhpcy54QXJyalZhbCk7XG4gICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxQb3NpdGlvbnMoeCwgeSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHplcm9ILCB6ZXJvVykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYmFySGVpZ2h0LCBiYXJXaWR0aDtcblxuICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIGhlaWdodCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgeURpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgYmFySGVpZ2h0ID0geURpdmlzaW9uO1xuICAgICAgICBiYXJIZWlnaHQgPSBiYXJIZWlnaHQgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuYmFySGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgemVyb1cgPSB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICsgdy5nbG9iYWxzLnBhZEhvcml6b250YWwgKyAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRXaWR0aCA6IDApIC0gKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuYmFzZUxpbmVJbnZlcnRlZFkgKiAyIDogMCk7IC8vIGluaXRpYWwgeSBwb3NpdGlvbiBpcyBoYWxmIG9mIGJhckhlaWdodCAqIGhhbGYgb2YgbnVtYmVyIG9mIEJhcnNcblxuICAgICAgICB5ID0gKHlEaXZpc2lvbiAtIGJhckhlaWdodCkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2lkdGggZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb247XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeERpdmlzaW9uID0gdy5nbG9iYWxzLm1pblhEaWZmIC8gdGhpcy54UmF0aW87XG4gICAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb24gKiBwYXJzZUludCh0aGlzLmJhck9wdGlvbnMuY29sdW1uV2lkdGgpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhcldpZHRoID0gYmFyV2lkdGggKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sdW1uV2lkdGgpIC8gMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgemVyb0ggPSB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IDogMCkgLSAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5iYXNlTGluZVlbdGhpcy55YXhpc0luZGV4XSAqIDIgOiAwKTsgLy8gaW5pdGlhbCB4IHBvc2l0aW9uIGlzIG9uZSB0aGlyZCBvZiBiYXJXaWR0aFxuXG4gICAgICAgIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArICh4RGl2aXNpb24gLSBiYXJXaWR0aCkgLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIHplcm9IOiB6ZXJvSCxcbiAgICAgICAgemVyb1c6IHplcm9XXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFyUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhclBhdGhzKF9yZWYpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZi5pbmRleGVzLFxuICAgICAgICAgIGJhckhlaWdodCA9IF9yZWYuYmFySGVpZ2h0LFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYucGF0aEZyb20sXG4gICAgICAgICAgemVyb1cgPSBfcmVmLnplcm9XLFxuICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmLnlEaXZpc2lvbixcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYuZWxTZXJpZXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBiYXJZUG9zaXRpb24gPSB5O1xuICAgICAgdmFyIGJhclhQb3NpdGlvbjtcbiAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICB2YXIgYmMgPSBpbmRleGVzLmJjO1xuICAgICAgdmFyIHByZXZCYXJXID0gMDtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLnByZXZYRi5sZW5ndGg7IGsrKykge1xuICAgICAgICBwcmV2QmFyVyA9IHByZXZCYXJXICsgdGhpcy5wcmV2WEZba11bal07XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB2YXIgYlhQID0gemVyb1c7XG5cbiAgICAgICAgaWYgKHRoaXMucHJldlhWYWxbaSAtIDFdW2pdIDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnByZXZYW2kgLSAxXVtqXSArIHByZXZCYXJXIC0gKHRoaXMuaXNSZXZlcnNlZCA/IHByZXZCYXJXIDogMCkgKiAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnByZXZYW2kgLSAxXVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2WFZhbFtpIC0gMV1bal0gPj0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnByZXZYW2kgLSAxXVtqXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYlhQID0gdGhpcy5wcmV2WFtpIC0gMV1bal0gLSBwcmV2QmFyVyArICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFyVyA6IDApICogMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBiYXJYUG9zaXRpb24gPSBiWFA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlggdmFsdWVzXG4gICAgICAgIGJhclhQb3NpdGlvbiA9IHplcm9XO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeCA9IGJhclhQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBiYXJYUG9zaXRpb24gKyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gLSAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLmludmVydGVkWVJhdGlvIDogMCkgKiAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kaW5nU2hhcGVPcHRzID0ge1xuICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBpbnZlcnRlZFlSYXRpbzogdGhpcy5pbnZlcnRlZFlSYXRpbyxcbiAgICAgICAgYmFyWVBvc2l0aW9uOiBiYXJZUG9zaXRpb24sXG4gICAgICAgIHg6IHhcbiAgICAgIH07XG4gICAgICB2YXIgZW5kaW5nU2hhcGUgPSB0aGlzLmJhci5iYXJFbmRpbmdTaGFwZSh3LCBlbmRpbmdTaGFwZU9wdHMsIHRoaXMuc2VyaWVzLCBpLCBqKTtcblxuICAgICAgaWYgKHRoaXMuc2VyaWVzLmxlbmd0aCA+IDEgJiYgaSAhPT0gdGhpcy5lbmRpbmdTaGFwZU9uU2VyaWVzTnVtYmVyKSB7XG4gICAgICAgIC8vIHJldmVydCBiYWNrIHRvIGZsYXQgc2hhcGUgaWYgbm90IGxhc3Qgc2VyaWVzXG4gICAgICAgIGVuZGluZ1NoYXBlLnBhdGggPSB0aGlzLmdyYXBoaWNzLmxpbmUoZW5kaW5nU2hhcGUubmV3WCwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnhBcnJqLnB1c2goZW5kaW5nU2hhcGUubmV3WCk7XG4gICAgICB0aGlzLnhBcnJqRi5wdXNoKE1hdGguYWJzKGJhclhQb3NpdGlvbiAtIGVuZGluZ1NoYXBlLm5ld1gpKTtcbiAgICAgIHRoaXMueEFycmpWYWwucHVzaCh0aGlzLnNlcmllc1tpXVtqXSk7XG4gICAgICBwYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuICAgICAgcGF0aEZyb20gPSB0aGlzLmdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuYmFyLmdldFBhdGhGcm9tKHJlYWxJbmRleCwgaiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBwYXRoVG8gPSBwYXRoVG8gKyB0aGlzLmdyYXBoaWNzLmxpbmUoZW5kaW5nU2hhcGUubmV3WCwgYmFyWVBvc2l0aW9uKSArIGVuZGluZ1NoYXBlLnBhdGggKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLSBzdHJva2VXaWR0aCkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuICAgICAgcGF0aEZyb20gPSBwYXRoRnJvbSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbikgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLSBzdHJva2VXaWR0aCkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLSBzdHJva2VXaWR0aCkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQgLSBzdHJva2VXaWR0aCkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzLmxlbmd0aCA+IDAgJiYgaSA9PT0gMCkge1xuICAgICAgICBpZiAoYmMgPj0gdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgIGJjID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiY29sb3IgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnNbYmNdO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCwgYmFyWVBvc2l0aW9uLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCBiYXJIZWlnaHQsIDAsIGJjb2xvciwgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmNvbG9ycy5iYWNrZ3JvdW5kQmFyT3BhY2l0eSk7XG4gICAgICAgIGVsU2VyaWVzLmFkZChyZWN0KTtcbiAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtYmFja2dyb3VuZEJhcicpO1xuICAgICAgfVxuXG4gICAgICB5ID0geSArIHlEaXZpc2lvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdDb2x1bW5QYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q29sdW1uUGF0aHMoX3JlZjIpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICB4RGl2aXNpb24gPSBfcmVmMi54RGl2aXNpb24sXG4gICAgICAgICAgcGF0aFRvID0gX3JlZjIucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZjIucGF0aEZyb20sXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmMi5iYXJXaWR0aCxcbiAgICAgICAgICB6ZXJvSCA9IF9yZWYyLnplcm9ILFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjIuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZWxTZXJpZXMgPSBfcmVmMi5lbFNlcmllcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciBiYyA9IGluZGV4ZXMuYmM7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB2YXIgc2VyaWVzVmFsID0gdy5nbG9iYWxzLnNlcmllc1hbaV1bal07XG4gICAgICAgIGlmICghc2VyaWVzVmFsKSBzZXJpZXNWYWwgPSAwO1xuICAgICAgICB4ID0gKHNlcmllc1ZhbCAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFyWFBvc2l0aW9uID0geDtcbiAgICAgIHZhciBiYXJZUG9zaXRpb247XG4gICAgICB2YXIgcHJldkJhckggPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMucHJldllGLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHByZXZCYXJIID0gcHJldkJhckggKyB0aGlzLnByZXZZRltrXVtqXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwICYmICF3Lmdsb2JhbHMuaXNYTnVtZXJpYyB8fCBpID4gMCAmJiB3Lmdsb2JhbHMuaXNYTnVtZXJpYyAmJiB3Lmdsb2JhbHMuc2VyaWVzWFtpIC0gMV1bal0gPT09IHcuZ2xvYmFscy5zZXJpZXNYW2ldW2pdKSB7XG4gICAgICAgIHZhciBiWVA7XG4gICAgICAgIHZhciBwcmV2WVZhbHVlID0gdGhpcy5wcmV2WVtpIC0gMV1bal07XG5cbiAgICAgICAgaWYgKHRoaXMucHJldllWYWxbaSAtIDFdW2pdIDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICBiWVAgPSBwcmV2WVZhbHVlIC0gcHJldkJhckggKyAodGhpcy5pc1JldmVyc2VkID8gcHJldkJhckggOiAwKSAqIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA+PSAwKSB7XG4gICAgICAgICAgICBiWVAgPSBwcmV2WVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiWVAgPSBwcmV2WVZhbHVlICsgcHJldkJhckggLSAodGhpcy5pc1JldmVyc2VkID8gcHJldkJhckggOiAwKSAqIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmFyWVBvc2l0aW9uID0gYllQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IHNlcmllcyB3aWxsIG5vdCBoYXZlIHByZXZZIHZhbHVlcywgYWxzbyBpZiB0aGUgcHJldiBpbmRleCdzIHNlcmllcyBYIGRvZXNuJ3QgbWF0Y2hlcyB0aGUgY3VycmVudCBpbmRleCdzIHNlcmllcyBYLCB0aGVuIHN0YXJ0IGZyb20gemVyb1xuICAgICAgICBiYXJZUG9zaXRpb24gPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHplcm9IO1xuICAgICAgfVxuXG4gICAgICB5ID0gYmFyWVBvc2l0aW9uIC0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgIHZhciBlbmRpbmdTaGFwZU9wdHMgPSB7XG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICB5UmF0aW86IHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF0sXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgICAgdmFyIGVuZGluZ1NoYXBlID0gdGhpcy5iYXIuYmFyRW5kaW5nU2hhcGUodywgZW5kaW5nU2hhcGVPcHRzLCB0aGlzLnNlcmllcywgaSwgaik7XG4gICAgICB0aGlzLnlBcnJqLnB1c2goZW5kaW5nU2hhcGUubmV3WSk7XG4gICAgICB0aGlzLnlBcnJqRi5wdXNoKE1hdGguYWJzKGJhcllQb3NpdGlvbiAtIGVuZGluZ1NoYXBlLm5ld1kpKTtcbiAgICAgIHRoaXMueUFycmpWYWwucHVzaCh0aGlzLnNlcmllc1tpXVtqXSk7XG4gICAgICBwYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuICAgICAgcGF0aEZyb20gPSB0aGlzLmdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCBiYXJZUG9zaXRpb24pO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuYmFyLmdldFBhdGhGcm9tKHJlYWxJbmRleCwgaiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBwYXRoVG8gPSBwYXRoVG8gKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCBlbmRpbmdTaGFwZS5uZXdZKSArIGVuZGluZ1NoYXBlLnBhdGggKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gLSBzdHJva2VXaWR0aCAvIDIsIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHBhdGhGcm9tICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCBiYXJZUG9zaXRpb24pICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGgsIGJhcllQb3NpdGlvbikgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gLSBzdHJva2VXaWR0aCAvIDIsIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdChiYXJYUG9zaXRpb24sIDAsIGJhcldpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCwgYmNvbG9yLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogdy5nbG9iYWxzLmlzWE51bWVyaWMgPyB4IC0geERpdmlzaW9uIDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBXaGVuIHVzZXIgY2xpY2tzIG9uIGxlZ2VuZHMsIHRoZSBjb2xsYXBzZWQgc2VyaWVzIHdpbGwgYmUgZmlsbGVkIHdpdGggWzAsMCwwLC4uLiwwXVxuICAgICAqIFdlIG5lZWQgdG8gbWFrZSBzdXJlLCB0aGF0IHRoZSBsYXN0IHNlcmllcyBpcyBub3QgWzAsMCwwLC4uLiwwXVxuICAgICAqIGFzIHdlIG5lZWQgdG8gZHJhdyBzaGFwZXMgb24gdGhlIGxhc3Qgc2VyaWVzIChmb3Igc3RhY2tlZCBiYXJzL2NvbHVtbnMgb25seSlcbiAgICAgKiBIZW5jZSwgd2UgYXJlIGNvbGxlY3RpbmcgYWxsIGlubmVyIGFycmF5cyBpbiBzZXJpZXMgd2hpY2ggaGFzIFswLDAsMC4uLiwwXVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrWmVyb1Nlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1plcm9TZXJpZXMoX3JlZjMpIHtcbiAgICAgIHZhciBzZXJpZXMgPSBfcmVmMy5zZXJpZXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgZm9yICh2YXIgenMgPSAwOyB6cyA8IHNlcmllcy5sZW5ndGg7IHpzKyspIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKHZhciB6c2ogPSAwOyB6c2ogPCBzZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgenNqKyspIHtcbiAgICAgICAgICB0b3RhbCArPSBzZXJpZXNbenNdW3pzal07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90YWwgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnplcm9TZXJpZXNlcy5wdXNoKHpzKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBZnRlciBnZXR0aW5nIGFsbCB6ZXJvc2VyaWVzZXMsIHdlIG5lZWQgdG8gZW5zdXJlIHdoZXRoZXIgZW5kaW5nc2hhcGVvblNlcmllcyBpcyBub3QgaW4gdGhhdCB6ZXJvc2VyaWVzIGFycmF5XG5cblxuICAgICAgZm9yICh2YXIgcyA9IHNlcmllcy5sZW5ndGggLSAxOyBzID49IDA7IHMtLSkge1xuICAgICAgICBpZiAodGhpcy56ZXJvU2VyaWVzZXMuaW5kZXhPZihzKSA+IC0xICYmIHMgPT09IHRoaXMuZW5kaW5nU2hhcGVPblNlcmllc051bWJlcikge1xuICAgICAgICAgIHRoaXMuZW5kaW5nU2hhcGVPblNlcmllc051bWJlciAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhclN0YWNrZWQ7XG59KEJhcik7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDYW5kbGVTdGljayBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBib3RoIFN0YWNrZWQgQ29sdW1ucyBhbmQgQmFycy5cbiAqXG4gKiBAbW9kdWxlIENhbmRsZVN0aWNrXG4gKiovXG5cbnZhciBDYW5kbGVTdGljayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhcikge1xuICBfaW5oZXJpdHMoQ2FuZGxlU3RpY2ssIF9CYXIpO1xuXG4gIGZ1bmN0aW9uIENhbmRsZVN0aWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW5kbGVTdGljayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKENhbmRsZVN0aWNrKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYW5kbGVTdGljaywgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcywgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgdGhpcy5jYW5kbGVzdGlja09wdGlvbnMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmNhbmRsZXN0aWNrO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgsIHcpO1xuICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTtcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgdmFyIHBhdGhUbyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdm9pZCAwO1xuICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICB4RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB4RGl2aXNpb24gaXMgdGhlIEdSSURXSURUSCBkaXZpZGVkIGJ5IG51bWJlciBvZiBkYXRhcG9pbnRzIChjb2x1bW5zKVxuICAgICAgICB6ZXJvSCA9IHZvaWQgMDsgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG5cbiAgICAgICAgdmFyIHlBcnJqID0gW107IC8vIGhvbGQgeSB2YWx1ZXMgb2YgY3VycmVudCBpdGVyYXRpbmcgc2VyaWVzXG5cbiAgICAgICAgdmFyIHhBcnJqID0gW107IC8vIGhvbGQgeCB2YWx1ZXMgb2YgY3VycmVudCBpdGVyYXRpbmcgc2VyaWVzXG5cbiAgICAgICAgdmFyIHJlYWxJbmRleCA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHNlcmllc0luZGV4W2ldIDogaTsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSkpLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZXJpZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudmlzaWJsZUkgPSB0aGlzLnZpc2libGVJICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgIHZhciBiYXJIZWlnaHQgPSAwO1xuICAgICAgICB2YXIgYmFyV2lkdGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy55YXhpc0luZGV4ID0gcmVhbEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRQb3NpdGlvbnMgPSB0aGlzLmluaXRpYWxQb3NpdGlvbnMoKTtcbiAgICAgICAgeSA9IGluaXRQb3NpdGlvbnMueTtcbiAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgIHggPSBpbml0UG9zaXRpb25zLng7XG4gICAgICAgIGJhcldpZHRoID0gaW5pdFBvc2l0aW9ucy5iYXJXaWR0aDtcbiAgICAgICAgeERpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy54RGl2aXNpb247XG4gICAgICAgIHplcm9IID0gaW5pdFBvc2l0aW9ucy56ZXJvSDtcbiAgICAgICAgeEFycmoucHVzaCh4ICsgYmFyV2lkdGggLyAyKTsgLy8gZWxkYXRhbGFiZWxzXG5cbiAgICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCB0aiA9IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqIDwgdy5nbG9iYWxzLmRhdGFQb2ludHM7IGorKywgdGotLSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJpZXNbaV1bal0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pc051bGxWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNOdWxsVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuc3Ryb2tlLnNob3cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh0aGlzLnN0cm9rZVdpZHRoKSA/IHRoaXMuc3Ryb2tlV2lkdGhbcmVhbEluZGV4XSA6IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbG9yID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBwYXRocyA9IHRoaXMuZHJhd0NhbmRsZVN0aWNrUGF0aHMoe1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF0aFRvID0gcGF0aHMucGF0aFRvO1xuICAgICAgICAgIHBhdGhGcm9tID0gcGF0aHMucGF0aEZyb207XG4gICAgICAgICAgeSA9IHBhdGhzLnk7XG4gICAgICAgICAgeCA9IHBhdGhzLng7XG4gICAgICAgICAgY29sb3IgPSBwYXRocy5jb2xvcjsgLy8gcHVzaCBjdXJyZW50IFhcblxuICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgeEFycmoucHVzaCh4ICsgYmFyV2lkdGggLyAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5QXJyai5wdXNoKHkpO1xuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbGluZUZpbGwgPSB0aGlzLmNhbmRsZXN0aWNrT3B0aW9ucy53aWNrLnVzZUZpbGxDb2xvciA/IGNvbG9yIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVsU2VyaWVzID0gdGhpcy5yZW5kZXJTZXJpZXMoe1xuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICBwYXRoRmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgICBsaW5lRmlsbDogbGluZUZpbGwsXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgZWxEYXRhTGFiZWxzV3JhcDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICAgIHZpc2libGVTZXJpZXM6IHRoaXMudmlzaWJsZUksXG4gICAgICAgICAgICB0eXBlOiAnY2FuZGxlc3RpY2snXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gcHVzaCBhbGwgeCB2YWwgYXJyYXlzIGludG8gbWFpbiB4QXJyXG5cblxuICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tyZWFsSW5kZXhdID0geEFycmo7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyajtcbiAgICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdDYW5kbGVTdGlja1BhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDYW5kbGVTdGlja1BhdGhzKF9yZWYpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZi5pbmRleGVzLFxuICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICB4RGl2aXNpb24gPSBfcmVmLnhEaXZpc2lvbixcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYucGF0aEZyb20sXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgIHplcm9IID0gX3JlZi56ZXJvSCxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIGlzUG9zaXRpdmUgPSB0cnVlO1xuICAgICAgdmFyIGNvbG9yUG9zID0gdy5jb25maWcucGxvdE9wdGlvbnMuY2FuZGxlc3RpY2suY29sb3JzLnVwd2FyZDtcbiAgICAgIHZhciBjb2xvck5lZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmNhbmRsZXN0aWNrLmNvbG9ycy5kb3dud2FyZDtcbiAgICAgIHZhciB5UmF0aW8gPSB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIG9obGMgPSB0aGlzLmdldE9ITENWYWx1ZShyZWFsSW5kZXgsIGopO1xuICAgICAgdmFyIGwxID0gemVyb0g7XG4gICAgICB2YXIgbDIgPSB6ZXJvSDtcblxuICAgICAgaWYgKG9obGMubyA+IG9obGMuYykge1xuICAgICAgICBpc1Bvc2l0aXZlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB5MSA9IE1hdGgubWluKG9obGMubywgb2hsYy5jKTtcbiAgICAgIHZhciB5MiA9IE1hdGgubWF4KG9obGMubywgb2hsYy5jKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeTEgPSB6ZXJvSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gemVyb0ggLSB5MSAvIHlSYXRpbztcbiAgICAgICAgeTIgPSB6ZXJvSCAtIHkyIC8geVJhdGlvO1xuICAgICAgICBsMSA9IHplcm9IIC0gb2hsYy5oIC8geVJhdGlvO1xuICAgICAgICBsMiA9IHplcm9IIC0gb2hsYy5sIC8geVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIHkyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCBsMSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCBsMikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCB5MiAtIHN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHkyLFxuICAgICAgICBiYXJYUG9zaXRpb246IGJhclhQb3NpdGlvbixcbiAgICAgICAgY29sb3I6IGlzUG9zaXRpdmUgPyBjb2xvclBvcyA6IGNvbG9yTmVnXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPSExDVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T0hMQ1ZhbHVlKGksIGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbzogdy5nbG9iYWxzLnNlcmllc0NhbmRsZU9baV1bal0sXG4gICAgICAgIGg6IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVIW2ldW2pdLFxuICAgICAgICBsOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlTFtpXVtqXSxcbiAgICAgICAgYzogdy5nbG9iYWxzLnNlcmllc0NhbmRsZUNbaV1bal1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbmRsZVN0aWNrO1xufShCYXIpO1xuXG52YXIgQ3Jvc3NoYWlycyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENyb3NzaGFpcnMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3NzaGFpcnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3Jvc3NoYWlycywgW3tcbiAgICBrZXk6IFwiZHJhd1hDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYQ3Jvc3NoYWlycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGNyb3NzaGFpckdyYWRpZW50ID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5maWxsLmdyYWRpZW50O1xuICAgICAgdmFyIGNyb3NzaGFpclNoYWRvdyA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZHJvcFNoYWRvdztcbiAgICAgIHZhciBmaWxsVHlwZSA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZmlsbC50eXBlO1xuICAgICAgdmFyIGdyYWRpZW50RnJvbSA9IGNyb3NzaGFpckdyYWRpZW50LmNvbG9yRnJvbTtcbiAgICAgIHZhciBncmFkaWVudFRvID0gY3Jvc3NoYWlyR3JhZGllbnQuY29sb3JUbztcbiAgICAgIHZhciBvcGFjaXR5RnJvbSA9IGNyb3NzaGFpckdyYWRpZW50Lm9wYWNpdHlGcm9tO1xuICAgICAgdmFyIG9wYWNpdHlUbyA9IGNyb3NzaGFpckdyYWRpZW50Lm9wYWNpdHlUbztcbiAgICAgIHZhciBzdG9wcyA9IGNyb3NzaGFpckdyYWRpZW50LnN0b3BzO1xuICAgICAgdmFyIHNoYWRvdyA9ICdub25lJztcbiAgICAgIHZhciBkcm9wU2hhZG93ID0gY3Jvc3NoYWlyU2hhZG93LmVuYWJsZWQ7XG4gICAgICB2YXIgc2hhZG93TGVmdCA9IGNyb3NzaGFpclNoYWRvdy5sZWZ0O1xuICAgICAgdmFyIHNoYWRvd1RvcCA9IGNyb3NzaGFpclNoYWRvdy50b3A7XG4gICAgICB2YXIgc2hhZG93Qmx1ciA9IGNyb3NzaGFpclNoYWRvdy5ibHVyO1xuICAgICAgdmFyIHNoYWRvd0NvbG9yID0gY3Jvc3NoYWlyU2hhZG93LmNvbG9yO1xuICAgICAgdmFyIHNoYWRvd09wYWNpdHkgPSBjcm9zc2hhaXJTaGFkb3cub3BhY2l0eTtcbiAgICAgIHZhciB4Y3Jvc3NoYWlyc0ZpbGwgPSB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLmZpbGwuY29sb3I7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnNob3cpIHtcbiAgICAgICAgaWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG4gICAgICAgICAgeGNyb3NzaGFpcnNGaWxsID0gZ3JhcGhpY3MuZHJhd0dyYWRpZW50KCd2ZXJ0aWNhbCcsIGdyYWRpZW50RnJvbSwgZ3JhZGllbnRUbywgb3BhY2l0eUZyb20sIG9wYWNpdHlUbywgbnVsbCwgc3RvcHMsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhjcm9zc2hhaXJzID0gZ3JhcGhpY3MuZHJhd1JlY3QoKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIHRvIHByZXZlbnQgZHJhd2luZyAyIGxpbmVzLCBjb252ZXJ0IHJlY3QgdG8gbGluZVxuICAgICAgICAgIHhjcm9zc2hhaXJzID0gZ3JhcGhpY3MuZHJhd0xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhjcm9zc2hhaXJzLmF0dHIoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14Y3Jvc3NoYWlycycsXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHkyOiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogVXRpbHMuaXNOdW1iZXIody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCkgPyB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoIDogMCxcbiAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0LFxuICAgICAgICAgIGZpbGw6IHhjcm9zc2hhaXJzRmlsbCxcbiAgICAgICAgICBmaWx0ZXI6IHNoYWRvdyxcbiAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5vcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZTogdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5zdHJva2UuY29sb3IsXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5zdHJva2UuZGFzaEFycmF5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkcm9wU2hhZG93KSB7XG4gICAgICAgICAgeGNyb3NzaGFpcnMgPSBmaWx0ZXJzLmRyb3BTaGFkb3coeGNyb3NzaGFpcnMsIHtcbiAgICAgICAgICAgIGxlZnQ6IHNoYWRvd0xlZnQsXG4gICAgICAgICAgICB0b3A6IHNoYWRvd1RvcCxcbiAgICAgICAgICAgIGJsdXI6IHNoYWRvd0JsdXIsXG4gICAgICAgICAgICBjb2xvcjogc2hhZG93Q29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5OiBzaGFkb3dPcGFjaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh4Y3Jvc3NoYWlycyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZQ3Jvc3NoYWlyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WUNyb3NzaGFpcnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY3Jvc3NoYWlyID0gdy5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycztcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLmNyb3NzaGFpcnMuc2hvdykge1xuICAgICAgICB2YXIgeWNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3TGluZSgwLCAwLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCAwLCBjcm9zc2hhaXIuc3Ryb2tlLmNvbG9yLCBjcm9zc2hhaXIuc3Ryb2tlLmRhc2hBcnJheSwgY3Jvc3NoYWlyLnN0cm9rZS53aWR0aCk7XG4gICAgICAgIHljcm9zc2hhaXJzLmF0dHIoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15Y3Jvc3NoYWlycydcbiAgICAgICAgfSk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHljcm9zc2hhaXJzKTtcbiAgICAgIH0gLy8gZHJhdyBhbiBpbnZpc2libGUgY3Jvc3NoYWlyIHRvIGhlbHAgaW4gcG9zaXRpb25pbmcgdGhlIHlheGlzIHRvb2x0aXBcblxuXG4gICAgICB2YXIgeWNyb3NzaGFpcnNIaWRkZW4gPSBncmFwaGljcy5kcmF3TGluZSgwLCAwLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCAwLCBjcm9zc2hhaXIuc3Ryb2tlLmNvbG9yLCAwLCAwKTtcbiAgICAgIHljcm9zc2hhaXJzSGlkZGVuLmF0dHIoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWNyb3NzaGFpcnMtaGlkZGVuJ1xuICAgICAgfSk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh5Y3Jvc3NoYWlyc0hpZGRlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENyb3NzaGFpcnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBIZWF0TWFwIENsYXNzLlxuICogQG1vZHVsZSBIZWF0TWFwXG4gKiovXG5cbnZhciBIZWF0TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGVhdE1hcChjdHgsIHh5UmF0aW9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYXRNYXApO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy54UmF0aW8gPSB4eVJhdGlvcy54UmF0aW87XG4gICAgdGhpcy55UmF0aW8gPSB4eVJhdGlvcy55UmF0aW87XG4gICAgdGhpcy5uZWdSYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbjtcbiAgICB0aGlzLnJlY3RSYWRpdXMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAucmFkaXVzO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB0aGlzLncuY29uZmlnLnN0cm9rZS53aWR0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIZWF0TWFwLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmV0ID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtaGVhdG1hcCdcbiAgICAgIH0pO1xuICAgICAgcmV0LmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7IC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuXG4gICAgICB2YXIgeERpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgdmFyIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICB2YXIgeTEgPSAwO1xuICAgICAgdmFyIHJldiA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGVja0NvbG9yUmFuZ2UoKTtcbiAgICAgIHZhciBoZWF0U2VyaWVzID0gc2VyaWVzLnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICByZXYgPSB0cnVlO1xuICAgICAgICBoZWF0U2VyaWVzLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHJldiA/IDAgOiBoZWF0U2VyaWVzLmxlbmd0aCAtIDE7IHJldiA/IGkgPCBoZWF0U2VyaWVzLmxlbmd0aCA6IGkgPj0gMDsgcmV2ID8gaSsrIDogaS0tKSB7XG4gICAgICAgIC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBhcGV4Y2hhcnRzLWhlYXRtYXAtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW2ldKSksXG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiBpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWxTZXJpZXMsIHNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDEgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGVhdFNlcmllc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBjb2xvclNoYWRlUGVyY2VudCA9IDE7XG4gICAgICAgICAgdmFyIGhlYXRDb2xvclByb3BzID0gdGhpcy5kZXRlcm1pbmVIZWF0Q29sb3IoaSwgaik7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmhhc05lZ3MgfHwgdGhpcy5uZWdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHNoYWRlSW50ZW5zaXR5ID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5zaGFkZUludGVuc2l0eTtcblxuICAgICAgICAgICAgaWYgKGhlYXRDb2xvclByb3BzLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gMSAtICgxICsgaGVhdENvbG9yUHJvcHMucGVyY2VudCAvIDEwMCkgKiBzaGFkZUludGVuc2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gKDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSAqIHNoYWRlSW50ZW5zaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9IDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb2xvciA9IGhlYXRDb2xvclByb3BzLmNvbG9yO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuZW5hYmxlU2hhZGVzKSB7XG4gICAgICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMoKTtcbiAgICAgICAgICAgIGNvbG9yID0gVXRpbHMuaGV4VG9SZ2JhKHV0aWxzLnNoYWRlQ29sb3IoY29sb3JTaGFkZVBlcmNlbnQsIGhlYXRDb2xvclByb3BzLmNvbG9yKSwgdy5jb25maWcuZmlsbC5vcGFjaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yZWN0UmFkaXVzO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgcmFkaXVzKTtcbiAgICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgICAgY3g6IHgxLFxuICAgICAgICAgICAgY3k6IHkxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaGVhdG1hcC1yZWN0Jyk7XG4gICAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB2YWw6IGhlYXRTZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbMF0sXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWN0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgcmVjdCkpO1xuICAgICAgICAgIHJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCByZWN0KSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGdyYXBoaWNzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCByZWN0KSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgICAgIGlmICghdy5nbG9iYWxzLnJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgc3BlZWQgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVIZWF0TWFwKHJlY3QsIHgxLCB5MSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHNwZWVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgX3NwZWVkID0gMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0uZW5hYmxlZCAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgICBfc3BlZWQgPSB0aGlzLmR5bmFtaWNBbmltLnNwZWVkO1xuICAgICAgICAgICAgICB2YXIgY29sb3JGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0uY29sb3I7XG4gICAgICAgICAgICAgIGlmICghY29sb3JGcm9tKSBjb2xvckZyb20gPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUhlYXRDb2xvcihyZWN0LCBVdGlscy5pc0NvbG9ySGV4KGNvbG9yRnJvbSkgPyBjb2xvckZyb20gOiBVdGlscy5yZ2IyaGV4KGNvbG9yRnJvbSksIFV0aWxzLmlzQ29sb3JIZXgoY29sb3IpID8gY29sb3IgOiBVdGlscy5yZ2IyaGV4KGNvbG9yKSwgX3NwZWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuY2FsY3VsYXRlSGVhdG1hcERhdGFMYWJlbHMoe1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiB5MSxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgc2VyaWVzOiBoZWF0U2VyaWVzLFxuICAgICAgICAgICAgcmVjdEhlaWdodDogeURpdmlzaW9uLFxuICAgICAgICAgICAgcmVjdFdpZHRoOiB4RGl2aXNpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkYXRhTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbFNlcmllcy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSB4MSArIHhEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHkxID0geTEgKyB5RGl2aXNpb247XG4gICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgfSAvLyBhZGp1c3QgeWF4aXMgbGFiZWxzIGZvciBoZWF0bWFwXG5cblxuICAgICAgdmFyIHlBeGlzU2NhbGUgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgIHlBeGlzU2NhbGUudW5zaGlmdCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5QXhpc1NjYWxlLnB1c2goJycpO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQgPSB5QXhpc1NjYWxlO1xuICAgICAgdmFyIGRpdmlzb3IgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm9mZnNldFkgPSAtKGRpdmlzb3IgLyAyKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQ29sb3JSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0NvbG9yUmFuZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBoZWF0bWFwID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcDtcblxuICAgICAgaWYgKGhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBoZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCAwKSB7XG4gICAgICAgICAgICBfdGhpcy5uZWdSYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lSGVhdENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUhlYXRDb2xvcihpLCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB2YWwgPSB3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdO1xuICAgICAgdmFyIGhlYXRtYXAgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5oZWF0bWFwO1xuICAgICAgdmFyIHNlcmllc051bWJlciA9IGhlYXRtYXAuY29sb3JTY2FsZS5pbnZlcnNlID8gaiA6IGk7XG4gICAgICB2YXIgY29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3Nlcmllc051bWJlcl07XG4gICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHcuZ2xvYmFscy5zZXJpZXNbaV0pKTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkody5nbG9iYWxzLnNlcmllc1tpXSkpO1xuXG4gICAgICBpZiAoIWhlYXRtYXAuZGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgbWluID0gdy5nbG9iYWxzLm1pblk7XG4gICAgICAgIG1heCA9IHcuZ2xvYmFscy5tYXhZO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhlYXRtYXAuY29sb3JTY2FsZS5taW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1pbiA9IGhlYXRtYXAuY29sb3JTY2FsZS5taW4gPCB3Lmdsb2JhbHMubWluWSA/IGhlYXRtYXAuY29sb3JTY2FsZS5taW4gOiB3Lmdsb2JhbHMubWluWTtcbiAgICAgICAgbWF4ID0gaGVhdG1hcC5jb2xvclNjYWxlLm1heCA+IHcuZ2xvYmFscy5tYXhZID8gaGVhdG1hcC5jb2xvclNjYWxlLm1heCA6IHcuZ2xvYmFscy5tYXhZO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWwgPSBNYXRoLmFicyhtYXgpICsgTWF0aC5hYnMobWluKTtcbiAgICAgIHZhciBwZXJjZW50ID0gMTAwICogdmFsIC8gKHRvdGFsID09PSAwID8gdG90YWwgLSAwLjAwMDAwMSA6IHRvdGFsKTtcblxuICAgICAgaWYgKGhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY29sb3JSYW5nZSA9IGhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXM7XG4gICAgICAgIGNvbG9yUmFuZ2UubWFwKGZ1bmN0aW9uIChyYW5nZSwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAodmFsID49IHJhbmdlLmZyb20gJiYgdmFsIDw9IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBjb2xvciA9IHJhbmdlLmNvbG9yO1xuICAgICAgICAgICAgbWluID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIG1heCA9IHJhbmdlLnRvO1xuXG4gICAgICAgICAgICB2YXIgX3RvdGFsID0gTWF0aC5hYnMobWF4KSArIE1hdGguYWJzKG1pbik7XG5cbiAgICAgICAgICAgIHBlcmNlbnQgPSAxMDAgKiB2YWwgLyAoX3RvdGFsID09PSAwID8gX3RvdGFsIC0gMC4wMDAwMDEgOiBfdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgcGVyY2VudDogcGVyY2VudFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlSGVhdG1hcERhdGFMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSGVhdG1hcERhdGFMYWJlbHMoX3JlZikge1xuICAgICAgdmFyIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgc2VyaWVzID0gX3JlZi5zZXJpZXMsXG4gICAgICAgICAgcmVjdEhlaWdodCA9IF9yZWYucmVjdEhlaWdodCxcbiAgICAgICAgICByZWN0V2lkdGggPSBfcmVmLnJlY3RXaWR0aDtcbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBsZXQgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpXG5cbiAgICAgIHZhciBkYXRhTGFiZWxzQ29uZmlnID0gdy5jb25maWcuZGF0YUxhYmVscztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBkYXRhTGFiZWxzQ29uZmlnLmZvcm1hdHRlcjtcbiAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gbnVsbDtcblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcuZW5hYmxlZCkge1xuICAgICAgICBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhLWxhYmVscydcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvZmZYID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRYO1xuICAgICAgICB2YXIgb2ZmWSA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WTtcbiAgICAgICAgdmFyIGRhdGFMYWJlbHNYID0geCArIHJlY3RXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICB2YXIgZGF0YUxhYmVsc1kgPSB5ICsgcmVjdEhlaWdodCAvIDIgKyBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSAvIDMgKyBvZmZZO1xuICAgICAgICB2YXIgdGV4dCA9IGZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdLCB7XG4gICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YUxhYmVscy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgIHg6IGRhdGFMYWJlbHNYLFxuICAgICAgICAgIHk6IGRhdGFMYWJlbHNZLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHBhcmVudDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUhlYXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRNYXAoZWwsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHNwZWVkKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmN0eCk7XG4gICAgICBhbmltYXRpb25zLmFuaW1hdGVSZWN0KGVsLCB7XG4gICAgICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0sIHNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVIZWF0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRDb2xvcihlbCwgY29sb3JGcm9tLCBjb2xvclRvLCBzcGVlZCkge1xuICAgICAgZWwuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yRnJvbVxuICAgICAgfSkuYW5pbWF0ZShzcGVlZCkuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yVG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWF0TWFwO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgUGllIENsYXNzIGZvciBkcmF3aW5nIFBpZSAvIERvbnV0IENoYXJ0cy5cbiAqIEBtb2R1bGUgUGllXG4gKiovXG5cbnZhciBQaWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWUoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmNoYXJ0VHlwZSA9IHRoaXMudy5jb25maWcuY2hhcnQudHlwZTtcbiAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMuaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDtcbiAgICB0aGlzLmFuaW1CZWdpbkFyciA9IFswXTtcbiAgICB0aGlzLmFuaW1EdXIgPSAwO1xuICAgIHRoaXMuZG9udXREYXRhTGFiZWxzID0gdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQubGFiZWxzO1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMubGluZUNvbG9yQXJyID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgIT09IHVuZGVmaW5lZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIDogdy5nbG9iYWxzLmNvbG9ycztcbiAgICB0aGlzLmRlZmF1bHRTaXplID0gdy5nbG9iYWxzLnN2Z0hlaWdodCA8IHcuZ2xvYmFscy5zdmdXaWR0aCA/IHcuZ2xvYmFscy5zdmdIZWlnaHQgLSAzNSA6IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgdGhpcy5jZW50ZXJZID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDI7XG4gICAgdGhpcy5jZW50ZXJYID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgdGhpcy5mdWxsQW5nbGUgPSAzNjA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmRvbnV0U2l6ZSA9IDA7XG4gICAgdGhpcy5zbGljZUxhYmVscyA9IFtdO1xuICAgIHRoaXMucHJldlNlY3RvckFuZ2xlQXJyID0gW107IC8vIGZvciBkeW5hbWljIGFuaW1hdGlvbnNcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaWUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1waWUnXG4gICAgICB9KTtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VyaWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIENBTENVTEFURSBUSEUgVE9UQUxcbiAgICAgICAgdG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHNlcmllc1trXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWN0b3JBbmdsZUFyciA9IFtdOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCgpOyAvLyBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm8gZXJyb3IgaWYgdGhlcmUgaXMgbm8gZGF0YVxuXG4gICAgICBpZiAodG90YWwgPT09IDApIHtcbiAgICAgICAgdG90YWwgPSAwLjAwMDAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIEFOR0xFU1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmZ1bGxBbmdsZSAqIFV0aWxzLm5lZ1RvWmVybyhzZXJpZXNbaV0pIC8gdG90YWw7XG4gICAgICAgIHNlY3RvckFuZ2xlQXJyLnB1c2goYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBwcmV2VG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIFBSRVYgVE9UQUxcbiAgICAgICAgICBwcmV2VG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW19rXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNBbmdsZTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgLy8gQ0FMQ1VMQVRFIFRIRSBQUkVWSU9VUyBBTkdMRVNcbiAgICAgICAgICBwcmV2aW91c0FuZ2xlID0gdGhpcy5mdWxsQW5nbGUgKiBVdGlscy5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbX2ldKSAvIHByZXZUb3RhbDtcbiAgICAgICAgICB0aGlzLnByZXZTZWN0b3JBbmdsZUFyci5wdXNoKHByZXZpb3VzQW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyLjA1IC0gdy5jb25maWcuc3Ryb2tlLndpZHRoIC0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb251dFNpemUgPSB0aGlzLnNpemUgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuc2l6ZSkgLyAxMDA7XG4gICAgICB2YXIgc2NhbGVTaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucGllLmN1c3RvbVNjYWxlO1xuICAgICAgdmFyIGhhbGZXID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IGhhbGZXIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIgKiBzY2FsZVNpemU7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IGhhbGZIIC0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyICogc2NhbGVTaXplO1xuXG4gICAgICBpZiAodGhpcy5kb251dERhdGFMYWJlbHMuc2hvdykge1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMucmVuZGVySW5uZXJEYXRhTGFiZWxzKHRoaXMuZG9udXREYXRhTGFiZWxzLCB7XG4gICAgICAgICAgaG9sbG93U2l6ZTogdGhpcy5kb251dFNpemUsXG4gICAgICAgICAgY2VudGVyWDogdGhpcy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmRvbnV0RGF0YUxhYmVscy5zaG93LFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXG4gICAgICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0LmFkZChkYXRhTGFiZWxzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW5uZXIgY2lyY2xlIGFuZCBhZGQgc29tZSB0ZXh0IHRvIGl0XG4gICAgICAgIHZhciBjaXJjbGUgPSBncmFwaGljcy5kcmF3Q2lyY2xlKHRoaXMuZG9udXRTaXplKTtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgIGN4OiB0aGlzLmNlbnRlclgsXG4gICAgICAgICAgY3k6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuYmFja2dyb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGNpcmNsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbEcgPSBzZWxmLmRyYXdBcmNzKHNlY3RvckFuZ2xlQXJyLCBzZXJpZXMpOyAvLyBhZGQgc2xpY2UgZGF0YUxhYmVscyBhdCB0aGUgZW5kXG5cbiAgICAgIHRoaXMuc2xpY2VMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICBlbEcuYWRkKHMpO1xuICAgICAgfSk7XG4gICAgICBlbFNlcmllcy5hdHRyKHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSAtIDUsIFwiKSBzY2FsZShcIikuY29uY2F0KHNjYWxlU2l6ZSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKHtcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVYJzogdHJhbnNsYXRlWCxcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVZJzogdHJhbnNsYXRlWSAtIDI1XG4gICAgICB9KTtcbiAgICAgIGVsU2VyaWVzLmFkZChlbEcpO1xuICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gY29yZSBmdW5jdGlvbiBmb3IgZHJhd2luZyBwaWUgYXJjc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0FyY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Moc2VjdG9yQW5nbGVBcnIsIHNlcmllcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gMDtcbiAgICAgIHZhciBwcmV2U3RhcnRBbmdsZSA9IDA7XG4gICAgICB2YXIgZW5kQW5nbGUgPSAwO1xuICAgICAgdmFyIHByZXZFbmRBbmdsZSA9IDA7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gdy5jb25maWcuc3Ryb2tlLnNob3cgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGggOiAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3RvckFuZ2xlQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGlmKHNlY3RvckFuZ2xlQXJyW2ldPjApIHtcbiAgICAgICAgdmFyIGVsUGllQXJjID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcGllLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpLFxuICAgICAgICAgIGlkOiAnYXBleGNoYXJ0cy1zZXJpZXMtJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGQoZWxQaWVBcmMpO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIHByZXZTdGFydEFuZ2xlID0gcHJldkVuZEFuZ2xlO1xuICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgcHJldkVuZEFuZ2xlID0gcHJldlN0YXJ0QW5nbGUgKyB0aGlzLnByZXZTZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgdmFyIGFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgICAgIH0pOyAvLyBhZGRpdGlvbmFseSwgcGFzcyBzaXplIGZvciBncmFkaWVudCBkcmF3aW5nIGluIHRoZSBmaWxsUGF0aCBmdW5jdGlvblxuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRDaGFuZ2VkUGF0aChwcmV2U3RhcnRBbmdsZSwgcHJldkVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVsUGF0aCA9IGdyYXBoaWNzLmRyYXdQYXRoKHtcbiAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5saW5lQ29sb3JBcnIgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMubGluZUNvbG9yQXJyW2ldIDogdGhpcy5saW5lQ29sb3JBcnIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IHcuY29uZmlnLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICBjbGFzc2VzOiAnYXBleGNoYXJ0cy1waWUtYXJlYSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICBpZDogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh3LmNvbmZpZy5jaGFydC50eXBlLCBcIi1zbGljZS1cIikuY29uY2F0KGkpLFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIGo6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIHNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZExpc3RlbmVycyhlbFBhdGgsIHRoaXMuZG9udXREYXRhTGFiZWxzKTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAnZGF0YTphbmdsZSc6IGFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0YXJ0QW5nbGUnOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0cm9rZVdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAnZGF0YTp2YWx1ZSc6IHNlcmllc1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IFV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4odGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMuc2l6ZSAvIDEuMjUgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICBsYWJlbFBvc2l0aW9uID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgKHRoaXMuc2l6ZSArIHRoaXMuZG9udXRTaXplKSAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxQaWVBcmMuYWRkKGVsUGF0aCk7IC8vIEFuaW1hdGlvbiBjb2RlIHN0YXJ0c1xuXG4gICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyB0aGlzLmZ1bGxBbmdsZSAqIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgdGhpcy5hbmltRHVyID0gZHVyICsgdGhpcy5hbmltRHVyO1xuICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0gJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldlN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldkVuZEFuZ2xlOiBwcmV2RW5kQW5nbGUsXG4gICAgICAgICAgICBhbmltYXRlU3RhcnRpbmdQb3M6IHRydWUsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgYW5pbUJlZ2luQXJyOiB0aGlzLmFuaW1CZWdpbkFycixcbiAgICAgICAgICAgIGR1cjogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHRvdGFsSXRlbXM6IHNlY3RvckFuZ2xlQXJyLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgICAgZHVyOiBkdXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhbmltYXRpb24gY29kZSBlbmRzXG5cblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLmV4cGFuZE9uQ2xpY2spIHtcbiAgICAgICAgICBlbFBhdGguY2xpY2sodGhpcy5waWVDbGlja2VkLmJpbmQodGhpcywgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciB4UG9zID0gbGFiZWxQb3NpdGlvbi54O1xuICAgICAgICAgIHZhciB5UG9zID0gbGFiZWxQb3NpdGlvbi55O1xuICAgICAgICAgIHZhciB0ZXh0ID0gMTAwICogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKyAnJSc7XG5cbiAgICAgICAgICBpZiAoYW5nbGUgIT09IDAgJiYgdy5jb25maWcucGxvdE9wdGlvbnMucGllLmRhdGFMYWJlbHMubWluQW5nbGVUb1Nob3dMYWJlbCA8IHNlY3RvckFuZ2xlQXJyW2ldKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdy5jb25maWcuZGF0YUxhYmVscy5mb3JtYXR0ZXI7XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNQZXJjZW50W2ldWzBdLCB7XG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcmVDb2xvciA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9yc1tpXTtcbiAgICAgICAgICAgIHZhciBlbFBpZUxhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgICB5OiB5UG9zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgZm9udFNpemU6IHcuY29uZmlnLmRhdGFMYWJlbHMuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHcuY29uZmlnLmRhdGFMYWJlbHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgZm9yZUNvbG9yOiBmb3JlQ29sb3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHRTaGFkb3cgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmRyb3BTaGFkb3c7XG5cbiAgICAgICAgICAgICAgdmFyIF9maWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuXG4gICAgICAgICAgICAgIF9maWx0ZXJzLmRyb3BTaGFkb3coZWxQaWVMYWJlbCwgdGV4dFNoYWRvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsUGllTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXBpZS1sYWJlbCcpO1xuXG4gICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5hbmltYXRlICYmIHcuZ2xvYmFscy5yZXNpemVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbFBpZUxhYmVsLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1waWUtbGFiZWwtZGVsYXknKTtcbiAgICAgICAgICAgICAgZWxQaWVMYWJlbC5ub2RlLnN0eWxlLmFuaW1hdGlvbkRlbGF5ID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCAvIDk0MCArICdzJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zbGljZUxhYmVscy5wdXNoKGVsUGllTGFiZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoZWxQYXRoLCBkYXRhTGFiZWxzKSB7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpOyAvLyBhcHBlbmQgZmlsdGVycyBvbiBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlXG5cbiAgICAgIGVsUGF0aC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBncmFwaGljcy5wYXRoTW91c2VFbnRlci5iaW5kKHRoaXMsIGVsUGF0aCkpO1xuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMucHJpbnREYXRhTGFiZWxzSW5uZXIuYmluZCh0aGlzLCBlbFBhdGgubm9kZSwgZGF0YUxhYmVscykpO1xuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5yZXZlcnREYXRhTGFiZWxzSW5uZXIuYmluZCh0aGlzLCBlbFBhdGgubm9kZSwgZGF0YUxhYmVscykpO1xuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZ3JhcGhpY3MucGF0aE1vdXNlRG93bi5iaW5kKHRoaXMsIGVsUGF0aCkpO1xuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wcmludERhdGFMYWJlbHNJbm5lci5iaW5kKHRoaXMsIGVsUGF0aC5ub2RlLCBkYXRhTGFiZWxzKSk7XG4gICAgfSAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGZvciBvdGhlciBjaXJjbGUgY2hhcnRzIHRvb1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVQYXRocyhlbCwgb3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGFuZ2xlID0gb3B0cy5lbmRBbmdsZSAtIG9wdHMuc3RhcnRBbmdsZTtcbiAgICAgIHZhciBwcmV2QW5nbGUgPSBhbmdsZTtcbiAgICAgIHZhciBmcm9tU3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcbiAgICAgIHZhciB0b1N0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG5cbiAgICAgIGlmIChvcHRzLnByZXZTdGFydEFuZ2xlICE9PSB1bmRlZmluZWQgJiYgb3B0cy5wcmV2RW5kQW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmcm9tU3RhcnRBbmdsZSA9IG9wdHMucHJldkVuZEFuZ2xlO1xuICAgICAgICBwcmV2QW5nbGUgPSBvcHRzLnByZXZFbmRBbmdsZSAtIG9wdHMucHJldlN0YXJ0QW5nbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmkgPT09IHcuY29uZmlnLnNlcmllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIHNvbWUgYWRqdXN0bWVudHMgZm9yIHRoZSBsYXN0IG92ZXJsYXBwaW5nIHBhdGhzXG4gICAgICAgIGlmIChhbmdsZSArIHRvU3RhcnRBbmdsZSA+IHRoaXMuZnVsbEFuZ2xlKSB7XG4gICAgICAgICAgb3B0cy5lbmRBbmdsZSA9IG9wdHMuZW5kQW5nbGUgLSAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ2xlICsgdG9TdGFydEFuZ2xlIDwgdGhpcy5mdWxsQW5nbGUpIHtcbiAgICAgICAgICBvcHRzLmVuZEFuZ2xlID0gb3B0cy5lbmRBbmdsZSArICh0aGlzLmZ1bGxBbmdsZSAtIChhbmdsZSArIHRvU3RhcnRBbmdsZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA9PT0gdGhpcy5mdWxsQW5nbGUpIGFuZ2xlID0gdGhpcy5mdWxsQW5nbGUgLSAwLjAxO1xuICAgICAgbWUuYW5pbWF0ZUFyYyhlbCwgZnJvbVN0YXJ0QW5nbGUsIHRvU3RhcnRBbmdsZSwgYW5nbGUsIHByZXZBbmdsZSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVBcmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUFyYyhlbCwgZnJvbVN0YXJ0QW5nbGUsIHRvU3RhcnRBbmdsZSwgYW5nbGUsIHByZXZBbmdsZSwgb3B0cykge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNpemUgPSBtZS5zaXplO1xuXG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGg7XG5cbiAgICAgIGlmIChpc05hTihmcm9tU3RhcnRBbmdsZSkgfHwgaXNOYU4ocHJldkFuZ2xlKSkge1xuICAgICAgICBmcm9tU3RhcnRBbmdsZSA9IHRvU3RhcnRBbmdsZTtcbiAgICAgICAgcHJldkFuZ2xlID0gYW5nbGU7XG4gICAgICAgIG9wdHMuZHVyID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJBbmdsZSA9IGFuZ2xlO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0b1N0YXJ0QW5nbGU7XG4gICAgICB2YXIgZnJvbUFuZ2xlID0gZnJvbVN0YXJ0QW5nbGUgLSB0b1N0YXJ0QW5nbGU7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgb3B0cy5zaG91bGRTZXRQcmV2UGF0aHMpIHtcbiAgICAgICAgLy8gdG8gYXZvaWQgZmxpY2tlcmluZywgc2V0IHByZXYgcGF0aCBmaXJzdCBhbmQgdGhlbiB3ZSB3aWxsIGFuaW1hdGUgZnJvbSB0aGVyZVxuICAgICAgICBwYXRoID0gbWUuZ2V0UGllUGF0aCh7XG4gICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGU6IHByZXZBbmdsZSxcbiAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICBkOiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5kdXIgIT09IDApIHtcbiAgICAgICAgZWwuYW5pbWF0ZShvcHRzLmR1ciwgdy5nbG9iYWxzLmVhc2luZywgb3B0cy5hbmltQmVnaW5BcnJbb3B0cy5pXSkuYWZ0ZXJBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncGllJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoMzAwKS5hdHRyKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLnN0cm9rZS53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfSkuZHVyaW5nKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICBjdXJyQW5nbGUgPSBmcm9tQW5nbGUgKyAoYW5nbGUgLSBmcm9tQW5nbGUpICogcG9zO1xuXG4gICAgICAgICAgaWYgKG9wdHMuYW5pbWF0ZVN0YXJ0aW5nUG9zKSB7XG4gICAgICAgICAgICBjdXJyQW5nbGUgPSBwcmV2QW5nbGUgKyAoYW5nbGUgLSBwcmV2QW5nbGUpICogcG9zO1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGZyb21TdGFydEFuZ2xlIC0gcHJldkFuZ2xlICsgKHRvU3RhcnRBbmdsZSAtIChmcm9tU3RhcnRBbmdsZSAtIHByZXZBbmdsZSkpICogcG9zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgICAgIG1lOiBtZSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBhbmdsZTogY3VyckFuZ2xlLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhOnBhdGhPcmlnJywgcGF0aCk7XG4gICAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgICBkOiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICAgIG1lOiBtZSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghb3B0cy5pc1RyYWNrKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhOnBhdGhPcmlnJywgcGF0aCk7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIGQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBpZUNsaWNrZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGllQ2xpY2tlZChpKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIHZhciBzaXplID0gbWUuc2l6ZSArIDQ7XG4gICAgICB2YXIgZWxQYXRoID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoXCIjYXBleGNoYXJ0cy1cIi5jb25jYXQody5jb25maWcuY2hhcnQudHlwZS50b0xvd2VyQ2FzZSgpLCBcIi1zbGljZS1cIikuY29uY2F0KGkpKS5tZW1iZXJzWzBdO1xuICAgICAgdmFyIHBhdGhGcm9tID0gZWxQYXRoLmF0dHIoJ2QnKTtcblxuICAgICAgaWYgKGVsUGF0aC5hdHRyKCdkYXRhOnBpZUNsaWNrZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAnZGF0YTpwaWVDbGlja2VkJzogJ2ZhbHNlJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9yaWdQYXRoID0gZWxQYXRoLmF0dHIoJ2RhdGE6cGF0aE9yaWcnKTtcbiAgICAgICAgZWxQYXRoLmF0dHIoe1xuICAgICAgICAgIGQ6IG9yaWdQYXRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNldCBhbGwgZWxlbXNcbiAgICAgICAgdmFyIGFsbEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXBpZS1hcmVhJyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYWxsRWxzLCBmdW5jdGlvbiAocGllU2xpY2UpIHtcbiAgICAgICAgICBwaWVTbGljZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGllQ2xpY2tlZCcsICdmYWxzZScpO1xuICAgICAgICAgIHZhciBvcmlnUGF0aCA9IHBpZVNsaWNlLmdldEF0dHJpYnV0ZSgnZGF0YTpwYXRoT3JpZycpO1xuICAgICAgICAgIHBpZVNsaWNlLnNldEF0dHJpYnV0ZSgnZCcsIG9yaWdQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUGF0aC5hdHRyKCdkYXRhOnBpZUNsaWNrZWQnLCAndHJ1ZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHBhcnNlSW50KGVsUGF0aC5hdHRyKCdkYXRhOnN0YXJ0QW5nbGUnKSk7XG4gICAgICB2YXIgYW5nbGUgPSBwYXJzZUludChlbFBhdGguYXR0cignZGF0YTphbmdsZScpKTtcbiAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgbWU6IG1lLFxuICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICAgIH0pO1xuICAgICAgaWYgKGFuZ2xlID09PSAzNjApIHJldHVybjtcbiAgICAgIGVsUGF0aC5wbG90KHBhdGgpLmFuaW1hdGUoMSkucGxvdChwYXRoRnJvbSkuYW5pbWF0ZSgxMDApLnBsb3QocGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYW5nZWRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZWRQYXRoKHByZXZTdGFydEFuZ2xlLCBwcmV2RW5kQW5nbGUpIHtcbiAgICAgIHZhciBwYXRoID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLmR5bmFtaWNBbmltICYmIHRoaXMudy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLmdldFBpZVBhdGgoe1xuICAgICAgICAgIG1lOiB0aGlzLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgIGFuZ2xlOiBwcmV2RW5kQW5nbGUgLSBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICBzaXplOiB0aGlzLnNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaWVQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpZVBhdGgoX3JlZikge1xuICAgICAgdmFyIG1lID0gX3JlZi5tZSxcbiAgICAgICAgICBzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgICAgICBzaXplID0gX3JlZi5zaXplO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIHZhciBzdGFydERlZyA9IHN0YXJ0QW5nbGU7XG4gICAgICB2YXIgc3RhcnRSYWRpYW5zID0gTWF0aC5QSSAqIChzdGFydERlZyAtIDkwKSAvIDE4MDtcbiAgICAgIHZhciBlbmREZWcgPSBhbmdsZSArIHN0YXJ0QW5nbGU7XG4gICAgICBpZiAoTWF0aC5jZWlsKGVuZERlZykgPj0gMzYwKSBlbmREZWcgPSAzNTkuOTk7XG4gICAgICB2YXIgZW5kUmFkaWFucyA9IE1hdGguUEkgKiAoZW5kRGVnIC0gOTApIC8gMTgwO1xuICAgICAgdmFyIHgxID0gbWUuY2VudGVyWCArIHNpemUgKiBNYXRoLmNvcyhzdGFydFJhZGlhbnMpO1xuICAgICAgdmFyIHkxID0gbWUuY2VudGVyWSArIHNpemUgKiBNYXRoLnNpbihzdGFydFJhZGlhbnMpO1xuICAgICAgdmFyIHgyID0gbWUuY2VudGVyWCArIHNpemUgKiBNYXRoLmNvcyhlbmRSYWRpYW5zKTtcbiAgICAgIHZhciB5MiA9IG1lLmNlbnRlclkgKyBzaXplICogTWF0aC5zaW4oZW5kUmFkaWFucyk7XG4gICAgICB2YXIgc3RhcnRJbm5lciA9IFV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4obWUuY2VudGVyWCwgbWUuY2VudGVyWSwgbWUuZG9udXRTaXplLCBlbmREZWcpO1xuICAgICAgdmFyIGVuZElubmVyID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbihtZS5jZW50ZXJYLCBtZS5jZW50ZXJZLCBtZS5kb251dFNpemUsIHN0YXJ0RGVnKTtcbiAgICAgIHZhciBsYXJnZUFyYyA9IGFuZ2xlID4gMTgwID8gMSA6IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgIHBhdGggPSBbJ00nLCB4MSwgeTEsICdBJywgc2l6ZSwgc2l6ZSwgMCwgbGFyZ2VBcmMsIDEsIHgyLCB5MiwgJ0wnLCBzdGFydElubmVyLngsIHN0YXJ0SW5uZXIueSwgJ0EnLCBtZS5kb251dFNpemUsIG1lLmRvbnV0U2l6ZSwgMCwgbGFyZ2VBcmMsIDAsIGVuZElubmVyLngsIGVuZElubmVyLnksICdMJywgeDEsIHkxLCAneiddLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScpIHtcbiAgICAgICAgcGF0aCA9IFsnTScsIHgxLCB5MSwgJ0EnLCBzaXplLCBzaXplLCAwLCBsYXJnZUFyYywgMSwgeDIsIHkyLCAnTCcsIG1lLmNlbnRlclgsIG1lLmNlbnRlclksICdMJywgeDEsIHkxXS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gWydNJywgeDEsIHkxLCAnQScsIHNpemUsIHNpemUsIDAsIGxhcmdlQXJjLCAxLCB4MiwgeTJdLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlcklubmVyRGF0YUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbm5lckRhdGFMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgb3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzLWdyb3VwJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQob3B0cy50cmFuc2xhdGVYID8gb3B0cy50cmFuc2xhdGVYIDogMCwgXCIsIFwiKS5jb25jYXQob3B0cy50cmFuc2xhdGVZID8gb3B0cy50cmFuc2xhdGVZIDogMCwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBzaG93VG90YWwgPSBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLnNob3c7XG4gICAgICBnLm5vZGUuc3R5bGUub3BhY2l0eSA9IG9wdHMub3BhY2l0eTtcbiAgICAgIHZhciB4ID0gb3B0cy5jZW50ZXJYO1xuICAgICAgdmFyIHkgPSBvcHRzLmNlbnRlclk7XG4gICAgICB2YXIgbGFiZWxDb2xvciwgdmFsdWVDb2xvcjtcblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcubmFtZS5jb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxDb2xvciA9IGRhdGFMYWJlbHNDb25maWcubmFtZS5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcudmFsdWUuY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZUNvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVDb2xvciA9IGRhdGFMYWJlbHNDb25maWcudmFsdWUuY29sb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9ybWF0dGVyO1xuICAgICAgdmFyIHZhbCA9ICcnO1xuICAgICAgdmFyIG5hbWUgPSAnJztcblxuICAgICAgaWYgKHNob3dUb3RhbCkge1xuICAgICAgICBsYWJlbENvbG9yID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5jb2xvcjtcbiAgICAgICAgbmFtZSA9IGRhdGFMYWJlbHNDb25maWcudG90YWwubGFiZWw7XG4gICAgICAgIHZhbCA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyKHcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1swXSwgdyk7XG4gICAgICAgICAgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLnNob3cpIHtcbiAgICAgICAgdmFyIGVsTGFiZWwgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5ICsgcGFyc2VJbnQoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLm9mZnNldFkpLFxuICAgICAgICAgIHRleHQ6IG5hbWUsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgZm9yZUNvbG9yOiBsYWJlbENvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmZvbnRGYW1pbHlcbiAgICAgICAgfSk7XG4gICAgICAgIGVsTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCcpO1xuICAgICAgICBnLmFkZChlbExhYmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcudmFsdWUuc2hvdykge1xuICAgICAgICB2YXIgdmFsT2Zmc2V0ID0gZGF0YUxhYmVsc0NvbmZpZy5uYW1lLnNob3cgPyBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLm9mZnNldFkpICsgMTYgOiBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLm9mZnNldFk7XG4gICAgICAgIHZhciBlbFZhbHVlID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSArIHZhbE9mZnNldCxcbiAgICAgICAgICB0ZXh0OiB2YWwsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgZm9yZUNvbG9yOiB2YWx1ZUNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9udEZhbWlseVxuICAgICAgICB9KTtcbiAgICAgICAgZWxWYWx1ZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlJyk7XG4gICAgICAgIGcuYWRkKGVsVmFsdWUpO1xuICAgICAgfSAvLyBmb3IgYSBtdWx0aS1zZXJpZXMgY2lyY2xlIGNoYXJ0LCB3ZSBuZWVkIHRvIHNob3cgdG90YWwgdmFsdWUgaW5zdGVhZCBvZiBmaXJzdCBzZXJpZXMgbGFiZWxzXG5cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSB2YWx1ZSBvZiB0aGF0IHNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCAtIE9wdGlvbmFsIGVsIChpbmRpY2F0ZXMgd2hpY2ggc2VyaWVzIHdhcyBob3ZlcmVkL2NsaWNrZWQpLiBJZiB0aGlzIHBhcmFtIGlzIG5vdCBwcmVzZW50LCBtZWFucyB3ZSBuZWVkIHRvIHNob3cgdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50SW5uZXJMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRJbm5lckxhYmVscyhsYWJlbHNDb25maWcsIG5hbWUsIHZhbCwgZWwpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxhYmVsQ29sb3I7XG5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICBpZiAobGFiZWxzQ29uZmlnLm5hbWUuY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3BhcnNlSW50KGVsLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gbGFiZWxzQ29uZmlnLm5hbWUuY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEgJiYgbGFiZWxzQ29uZmlnLnRvdGFsLnNob3cpIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gbGFiZWxzQ29uZmlnLnRvdGFsLmNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVsLWxhYmVsJyk7XG4gICAgICB2YXIgZWxWYWx1ZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWRhdGFsYWJlbC12YWx1ZScpO1xuICAgICAgdmFyIGxiRm9ybWF0dGVyID0gbGFiZWxzQ29uZmlnLnZhbHVlLmZvcm1hdHRlcjtcbiAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgdyk7IC8vIHdlIG5lZWQgdG8gc2hvdyBUb3RhbCBWYWwgLSBzbyBnZXQgdGhlIGZvcm1hdHRlciBvZiBpdFxuXG4gICAgICBpZiAoIWVsICYmIHR5cGVvZiBsYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IGxhYmVsc0NvbmZpZy50b3RhbC5mb3JtYXR0ZXIodyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbExhYmVsICE9PSBudWxsKSB7XG4gICAgICAgIGVsTGFiZWwudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlbFZhbHVlLnRleHRDb250ZW50ID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMYWJlbCAhPT0gbnVsbCkge1xuICAgICAgICBlbExhYmVsLnN0eWxlLmZpbGwgPSBsYWJlbENvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmludERhdGFMYWJlbHNJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludERhdGFMYWJlbHNJbm5lcihlbCwgZGF0YUxhYmVsc0NvbmZpZykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhOnZhbHVlJyk7XG4gICAgICB2YXIgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1twYXJzZUludChlbC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMV07XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5wcmludElubmVyTGFiZWxzKGRhdGFMYWJlbHNDb25maWcsIG5hbWUsIHZhbCwgZWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YUxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVscy1ncm91cCcpO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0dyb3VwICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGFMYWJlbHNHcm91cC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0RGF0YUxhYmVsc0lubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydERhdGFMYWJlbHNJbm5lcihlbCwgZGF0YUxhYmVsc0NvbmZpZykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZGF0YUxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVscy1ncm91cCcpO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5zaG93ICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICAgIHBpZS5wcmludElubmVyTGFiZWxzKGRhdGFMYWJlbHNDb25maWcsIGRhdGFMYWJlbHNDb25maWcudG90YWwubGFiZWwsIGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyKHcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLmxlbmd0aCAmJiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdO1xuXG4gICAgICAgICAgICB2YXIgX2VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIiNhcGV4Y2hhcnRzLVwiLmNvbmNhdCh3LmNvbmZpZy5jaGFydC50eXBlLnRvTG93ZXJDYXNlKCksIFwiLXNsaWNlLVwiKS5jb25jYXQoaW5kZXgpKTtcblxuICAgICAgICAgICAgdGhpcy5wcmludERhdGFMYWJlbHNJbm5lcihfZWwsIGRhdGFMYWJlbHNDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YUxhYmVsc0dyb3VwICYmIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMubGVuZ3RoICYmIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzR3JvdXAuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkYXRhTGFiZWxzR3JvdXAgJiYgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzR3JvdXAuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBpZTtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFJhZGFyIENsYXNzIGZvciBTcGlkZXIvUmFkYXIgQ2hhcnRzLlxuICogQG1vZHVsZSBSYWRhclxuICoqL1xuXG52YXIgUmFkYXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSYWRhcihjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkYXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5jaGFydFR5cGUgPSB0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgdGhpcy5pbml0aWFsQW5pbSA9IHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLmluaXRpYWxBbmltICYmIHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQ7XG4gICAgdGhpcy5hbmltRHVyID0gMDtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB0aGlzLmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICB0aGlzLmxpbmVDb2xvckFyciA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzICE9PSB1bmRlZmluZWQgPyB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyA6IHcuZ2xvYmFscy5jb2xvcnM7XG4gICAgdGhpcy5kZWZhdWx0U2l6ZSA9IHcuZ2xvYmFscy5zdmdIZWlnaHQgPCB3Lmdsb2JhbHMuc3ZnV2lkdGggPyB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gMzUgOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgIHRoaXMubWF4VmFsdWUgPSB0aGlzLncuZ2xvYmFscy5tYXhZO1xuICAgIHRoaXMucG9seWdvbnMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucztcbiAgICB0aGlzLm1heExhYmVsV2lkdGggPSAyMDtcbiAgICB2YXIgbG9uZ2VzdExhYmVsID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH0pWzBdO1xuICAgIHZhciBsYWJlbFdpZHRoID0gdGhpcy5ncmFwaGljcy5nZXRUZXh0UmVjdHMobG9uZ2VzdExhYmVsLCB3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLmRlZmF1bHRTaXplIC8gMi4xIC0gdy5jb25maWcuc3Ryb2tlLndpZHRoIC0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyIC0gbGFiZWxXaWR0aC53aWR0aCAvIDEuNzU7XG5cbiAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkYXIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5zaXplO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVJhZGl1c09mUGVyY2VudCA9IFtdO1xuICAgIHRoaXMuZGF0YVJhZGl1cyA9IFtdO1xuICAgIHRoaXMuYW5nbGVBcnIgPSBbXTtcbiAgICB0aGlzLnlheGlzTGFiZWxzVGV4dHNQb3MgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYWRhciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBhbGxTZXJpZXMgPSBbXTtcbiAgICAgIHRoaXMuZGF0YVBvaW50c0xlbiA9IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoO1xuICAgICAgdGhpcy5kaXNBbmdsZSA9IE1hdGguUEkgKiAyIC8gdGhpcy5kYXRhUG9pbnRzTGVuO1xuICAgICAgdmFyIGhhbGZXID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IGhhbGZXO1xuICAgICAgdmFyIHRyYW5zbGF0ZVkgPSBoYWxmSDtcbiAgICAgIHZhciByZXQgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGFyLXNlcmllcycsXG4gICAgICAgICdkYXRhOmlubmVyVHJhbnNsYXRlWCc6IHRyYW5zbGF0ZVgsXG4gICAgICAgICdkYXRhOmlubmVyVHJhbnNsYXRlWSc6IHRyYW5zbGF0ZVkgLSAyNSxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCB8fCAwLCBcIiwgXCIpLmNvbmNhdCh0cmFuc2xhdGVZIHx8IDAsIFwiKVwiKVxuICAgICAgfSk7XG4gICAgICB2YXIgZGF0YVBvaW50c1BvcyA9IFtdO1xuICAgICAgdmFyIGVsUG9pbnRzTWFpbiA9IG51bGw7XG4gICAgICB0aGlzLnlheGlzTGFiZWxzID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcydcbiAgICAgIH0pO1xuICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoKS5hdHRyKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogaVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5kYXRhUmFkaXVzT2ZQZXJjZW50W2ldID0gW107XG4gICAgICAgIF90aGlzLmRhdGFSYWRpdXNbaV0gPSBbXTtcbiAgICAgICAgX3RoaXMuYW5nbGVBcnJbaV0gPSBbXTtcbiAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChkdiwgaikge1xuICAgICAgICAgIF90aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnRbaV1bal0gPSBkdiAvIF90aGlzLm1heFZhbHVlO1xuICAgICAgICAgIF90aGlzLmRhdGFSYWRpdXNbaV1bal0gPSBfdGhpcy5kYXRhUmFkaXVzT2ZQZXJjZW50W2ldW2pdICogX3RoaXMuc2l6ZTtcbiAgICAgICAgICBfdGhpcy5hbmdsZUFycltpXVtqXSA9IGogKiBfdGhpcy5kaXNBbmdsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFQb2ludHNQb3MgPSBfdGhpcy5nZXREYXRhUG9pbnRzUG9zKF90aGlzLmRhdGFSYWRpdXNbaV0sIF90aGlzLmFuZ2xlQXJyW2ldKTtcblxuICAgICAgICB2YXIgcGF0aHMgPSBfdGhpcy5jcmVhdGVQYXRocyhkYXRhUG9pbnRzUG9zLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pOyAvLyBwb2ludHNcblxuXG4gICAgICAgIGVsUG9pbnRzTWFpbiA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCBoaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgICB3Lmdsb2JhbHMuZGVsYXllZEVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGVsOiBlbFBvaW50c01haW4ubm9kZSxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlZmF1bHRSZW5kZXJlZFBhdGhPcHRpb25zID0ge1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgcmVhbEluZGV4OiBpLFxuICAgICAgICAgIGFuaW1hdGlvbkRlbGF5OiBpLFxuICAgICAgICAgIGluaXRpYWxTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCxcbiAgICAgICAgICBkYXRhQ2hhbmdlU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZCxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYXBleGNoYXJ0cy1yYWRhclwiLFxuICAgICAgICAgIGlkOiBcImFwZXhjaGFydHMtcmFkYXJcIixcbiAgICAgICAgICBzaG91bGRDbGlwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgICBiaW5kRXZlbnRzT25QYXRoczogZmFsc2UsXG4gICAgICAgICAgc3Ryb2tlOiB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9yc1tpXSxcbiAgICAgICAgICBzdHJva2VMaW5lQ2FwOiB3LmNvbmZpZy5zdHJva2UubGluZUNhcFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGF0aEZyb20gPSBudWxsO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGF0aEZyb20gPSBfdGhpcy5nZXRQYXRoRnJvbShpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGF0aHMubGluZVBhdGhzVG8ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICB2YXIgcmVuZGVyZWRMaW5lUGF0aCA9IF90aGlzLmdyYXBoaWNzLnJlbmRlclBhdGhzKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRSZW5kZXJlZFBhdGhPcHRpb25zLCB7XG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20gPT09IG51bGwgPyBwYXRocy5saW5lUGF0aHNGcm9tW3BdIDogcGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG86IHBhdGhzLmxpbmVQYXRoc1RvW3BdLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSA/IHcuY29uZmlnLnN0cm9rZS53aWR0aFtpXSA6IHcuY29uZmlnLnN0cm9rZS53aWR0aCxcbiAgICAgICAgICAgIGZpbGw6ICdub25lJ1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZExpbmVQYXRoKTtcbiAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgIHNlcmllc051bWJlcjogaVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIHJlbmRlcmVkQXJlYVBhdGggPSBfdGhpcy5ncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tID09PSBudWxsID8gcGF0aHMuYXJlYVBhdGhzRnJvbVtwXSA6IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5hcmVhUGF0aHNUb1twXSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgZmlsbDogcGF0aEZpbGxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKF90aGlzLmN0eCk7XG4gICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhyZW5kZXJlZEFyZWFQYXRoLCBfb2JqZWN0U3ByZWFkKHt9LCBzaGFkb3csIHtcbiAgICAgICAgICAgICAgbm9Vc2VyU3BhY2VPblVzZTogdHJ1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZEFyZWFQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoc2osIGopIHtcbiAgICAgICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKF90aGlzLmN0eCk7XG4gICAgICAgICAgdmFyIG9wdHMgPSBtYXJrZXJzLmdldE1hcmtlckNvbmZpZygnYXBleGNoYXJ0cy1tYXJrZXInLCBpKTtcblxuICAgICAgICAgIHZhciBwb2ludCA9IF90aGlzLmdyYXBoaWNzLmRyYXdNYXJrZXIoZGF0YVBvaW50c1Bvc1tqXS54LCBkYXRhUG9pbnRzUG9zW2pdLnksIG9wdHMpO1xuXG4gICAgICAgICAgcG9pbnQuYXR0cigncmVsJywgaik7XG4gICAgICAgICAgcG9pbnQuYXR0cignaicsIGopO1xuICAgICAgICAgIHBvaW50LmF0dHIoJ2luZGV4JywgaSk7XG4gICAgICAgICAgcG9pbnQubm9kZS5zZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnLCBvcHRzLnBTaXplKTtcblxuICAgICAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZWxQb2ludHNXcmFwKSB7XG4gICAgICAgICAgICBlbFBvaW50c1dyYXAuYWRkKHBvaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbFBvaW50c01haW4uYWRkKGVsUG9pbnRzV3JhcCk7XG4gICAgICAgICAgZWxTZXJpZXMuYWRkKGVsUG9pbnRzTWFpbik7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxTZXJpZXMucHVzaChlbFNlcmllcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHJhd1BvbHlnb25zKHtcbiAgICAgICAgcGFyZW50OiByZXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gdGhpcy5kcmF3TGFiZWxzKCk7XG4gICAgICAgIHJldC5hZGQoZGF0YUxhYmVscyk7XG4gICAgICB9XG5cbiAgICAgIHJldC5hZGQodGhpcy55YXhpc0xhYmVscyk7XG4gICAgICBhbGxTZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxTKSB7XG4gICAgICAgIHJldC5hZGQoZWxTKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BvbHlnb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2x5Z29ucyhvcHRzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gICAgICB2YXIgeWF4aXNUZXh0cyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICB2YXIgbGF5ZXJzID0geWF4aXNUZXh0cy5sZW5ndGg7XG4gICAgICB2YXIgcmFkaXVzU2l6ZXMgPSBbXTtcbiAgICAgIHZhciBsYXllckRpcyA9IHRoaXMuc2l6ZSAvIChsYXllcnMgLSAxKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnM7IGkrKykge1xuICAgICAgICByYWRpdXNTaXplc1tpXSA9IGxheWVyRGlzICogaTtcbiAgICAgIH1cblxuICAgICAgcmFkaXVzU2l6ZXMucmV2ZXJzZSgpO1xuICAgICAgdmFyIHBvbHlnb25TdHJpbmdzID0gW107XG4gICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgIHJhZGl1c1NpemVzLmZvckVhY2goZnVuY3Rpb24gKHJhZGl1c1NpemUsIHIpIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBfdGhpczIuZ2V0UG9seWdvblBvcyhyYWRpdXNTaXplKTtcblxuICAgICAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IF90aGlzMi5ncmFwaGljcy5kcmF3TGluZShwLngsIHAueSwgMCwgMCwgQXJyYXkuaXNBcnJheShfdGhpczIucG9seWdvbnMuY29ubmVjdG9yQ29sb3JzKSA/IF90aGlzMi5wb2x5Z29ucy5jb25uZWN0b3JDb2xvcnNbaV0gOiBfdGhpczIucG9seWdvbnMuY29ubmVjdG9yQ29sb3JzKTtcblxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgX3RoaXMyLnlheGlzTGFiZWxzVGV4dHNQb3MucHVzaCh7XG4gICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgeTogcC55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHJpbmcgKz0gcC54ICsgJywnICsgcC55ICsgJyAnO1xuICAgICAgICB9KTtcbiAgICAgICAgcG9seWdvblN0cmluZ3MucHVzaChzdHJpbmcpO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29uU3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHZhciBzdHJva2VDb2xvcnMgPSBfdGhpczIucG9seWdvbnMuc3Ryb2tlQ29sb3JzO1xuXG4gICAgICAgIHZhciBwb2x5Z29uID0gX3RoaXMyLmdyYXBoaWNzLmRyYXdQb2x5Z29uKHAsIEFycmF5LmlzQXJyYXkoc3Ryb2tlQ29sb3JzKSA/IHN0cm9rZUNvbG9yc1tpXSA6IHN0cm9rZUNvbG9ycywgdy5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnNbaV0pO1xuXG4gICAgICAgIHBhcmVudC5hZGQocG9seWdvbik7XG4gICAgICB9KTtcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcGFyZW50LmFkZChsKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbMF0uc2hvdykge1xuICAgICAgICB0aGlzLnlheGlzTGFiZWxzVGV4dHNQb3MuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIHZhciB5VGV4dCA9IF90aGlzMi5kcmF3WUF4aXNUZXh0KHAueCwgcC55LCBpLCB5YXhpc1RleHRzW2ldKTtcblxuICAgICAgICAgIF90aGlzMi55YXhpc0xhYmVscy5hZGQoeVRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lBeGlzVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WUF4aXNUZXh0KHgsIHksIGksIHRleHQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHlheGlzQ29uZmlnID0gdy5jb25maWcueWF4aXNbMF07XG4gICAgICB2YXIgZm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF07XG4gICAgICB2YXIgeWF4aXNMYWJlbCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICB4OiB4ICsgeWF4aXNDb25maWcubGFiZWxzLm9mZnNldFgsXG4gICAgICAgIHk6IHkgKyB5YXhpc0NvbmZpZy5sYWJlbHMub2Zmc2V0WSxcbiAgICAgICAgdGV4dDogZm9ybWF0dGVyKHRleHQsIGkpLFxuICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgZm9udFNpemU6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogeWF4aXNDb25maWcubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogeWF4aXNDb25maWcubGFiZWxzLnN0eWxlLmNvbG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB5YXhpc0xhYmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGltaXQgPSAxMDtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICB2YXIgZGF0YUxhYmVsc0NvbmZpZyA9IHcuY29uZmlnLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvbHlnb25Qb3MgPSB0aGlzLmdldFBvbHlnb25Qb3ModGhpcy5zaXplKTtcbiAgICAgIHZhciBjdXJyUG9zWCA9IDA7XG4gICAgICB2YXIgY3VyclBvc1kgPSAwO1xuICAgICAgdy5nbG9iYWxzLmxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsYWJlbCwgaSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gZGF0YUxhYmVsc0NvbmZpZy5mb3JtYXR0ZXI7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzID0gbmV3IERhdGFMYWJlbHMoX3RoaXMzLmN0eCk7XG5cbiAgICAgICAgaWYgKHBvbHlnb25Qb3NbaV0pIHtcbiAgICAgICAgICBjdXJyUG9zWCA9IHBvbHlnb25Qb3NbaV0ueDtcbiAgICAgICAgICBjdXJyUG9zWSA9IHBvbHlnb25Qb3NbaV0ueTtcblxuICAgICAgICAgIGlmIChNYXRoLmFicyhwb2x5Z29uUG9zW2ldLngpID49IGxpbWl0KSB7XG4gICAgICAgICAgICBpZiAocG9seWdvblBvc1tpXS54ID4gMCkge1xuICAgICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgICAgY3VyclBvc1ggKz0gMTA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvbHlnb25Qb3NbaV0ueCA8IDApIHtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgICBjdXJyUG9zWCAtPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLmFicyhwb2x5Z29uUG9zW2ldLnkpID49IF90aGlzMy5zaXplIC0gbGltaXQpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uUG9zW2ldLnkgPCAwKSB7XG4gICAgICAgICAgICAgIGN1cnJQb3NZIC09IDEwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2x5Z29uUG9zW2ldLnkgPiAwKSB7XG4gICAgICAgICAgICAgIGN1cnJQb3NZICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0ZXh0ID0gZm9ybWF0dGVyKGxhYmVsLCB7XG4gICAgICAgICAgICBzZXJpZXNJbmRleDogLTEsXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgICB4OiBjdXJyUG9zWCxcbiAgICAgICAgICAgIHk6IGN1cnJQb3NZLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogaSxcbiAgICAgICAgICAgIHBhcmVudDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IGRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgICBvZmZzZXRDb3JyZWN0aW9uOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYXRocyhwb3MsIG9yaWdpbikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBsaW5lUGF0aHNUbyA9IFtdO1xuICAgICAgdmFyIGxpbmVQYXRoc0Zyb20gPSBbXTtcbiAgICAgIHZhciBhcmVhUGF0aHNUbyA9IFtdO1xuICAgICAgdmFyIGFyZWFQYXRoc0Zyb20gPSBbXTtcblxuICAgICAgaWYgKHBvcy5sZW5ndGgpIHtcbiAgICAgICAgbGluZVBhdGhzRnJvbSA9IFt0aGlzLmdyYXBoaWNzLm1vdmUob3JpZ2luLngsIG9yaWdpbi55KV07XG4gICAgICAgIGFyZWFQYXRoc0Zyb20gPSBbdGhpcy5ncmFwaGljcy5tb3ZlKG9yaWdpbi54LCBvcmlnaW4ueSldO1xuICAgICAgICB2YXIgbGluZVBhdGhUbyA9IHRoaXMuZ3JhcGhpY3MubW92ZShwb3NbMF0ueCwgcG9zWzBdLnkpO1xuICAgICAgICB2YXIgYXJlYVBhdGhUbyA9IHRoaXMuZ3JhcGhpY3MubW92ZShwb3NbMF0ueCwgcG9zWzBdLnkpO1xuICAgICAgICBwb3MuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICAgIGxpbmVQYXRoVG8gKz0gX3RoaXM0LmdyYXBoaWNzLmxpbmUocC54LCBwLnkpO1xuICAgICAgICAgIGFyZWFQYXRoVG8gKz0gX3RoaXM0LmdyYXBoaWNzLmxpbmUocC54LCBwLnkpO1xuXG4gICAgICAgICAgaWYgKGkgPT09IHBvcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBsaW5lUGF0aFRvICs9ICdaJztcbiAgICAgICAgICAgIGFyZWFQYXRoVG8gKz0gJ1onO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmVQYXRoc1RvLnB1c2gobGluZVBhdGhUbyk7XG4gICAgICAgIGFyZWFQYXRoc1RvLnB1c2goYXJlYVBhdGhUbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVQYXRoc0Zyb206IGxpbmVQYXRoc0Zyb20sXG4gICAgICAgIGxpbmVQYXRoc1RvOiBsaW5lUGF0aHNUbyxcbiAgICAgICAgYXJlYVBhdGhzRnJvbTogYXJlYVBhdGhzRnJvbSxcbiAgICAgICAgYXJlYVBhdGhzVG86IGFyZWFQYXRoc1RvXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXRoRnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoRnJvbShyZWFsSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBhdGhGcm9tID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgcHAgPSAwOyBwcCA8IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aDsgcHArKykge1xuICAgICAgICB2YXIgZ3BwID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdO1xuXG4gICAgICAgIGlmIChncHAucGF0aHMubGVuZ3RoID4gMCAmJiBwYXJzZUludChncHAucmVhbEluZGV4KSA9PT0gcGFyc2VJbnQocmVhbEluZGV4KSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF0aEZyb20gPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMF0uZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhGcm9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhUG9pbnRzUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFQb2ludHNQb3MoZGF0YVJhZGl1c0FyciwgYW5nbGVBcnIpIHtcbiAgICAgIHZhciBkYXRhUG9pbnRzTGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmRhdGFQb2ludHNMZW47XG4gICAgICBkYXRhUmFkaXVzQXJyID0gZGF0YVJhZGl1c0FyciB8fCBbXTtcbiAgICAgIGFuZ2xlQXJyID0gYW5nbGVBcnIgfHwgW107XG4gICAgICB2YXIgZGF0YVBvaW50c1Bvc0FycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVBvaW50c0xlbjsgaisrKSB7XG4gICAgICAgIHZhciBjdXJQb2ludFBvcyA9IHt9O1xuICAgICAgICBjdXJQb2ludFBvcy54ID0gZGF0YVJhZGl1c0FycltqXSAqIE1hdGguc2luKGFuZ2xlQXJyW2pdKTtcbiAgICAgICAgY3VyUG9pbnRQb3MueSA9IC1kYXRhUmFkaXVzQXJyW2pdICogTWF0aC5jb3MoYW5nbGVBcnJbal0pO1xuICAgICAgICBkYXRhUG9pbnRzUG9zQXJyYXkucHVzaChjdXJQb2ludFBvcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhUG9pbnRzUG9zQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvbHlnb25Qb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9seWdvblBvcyhzaXplKSB7XG4gICAgICB2YXIgZG90c0FycmF5ID0gW107XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAvIHRoaXMuZGF0YVBvaW50c0xlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFQb2ludHNMZW47IGkrKykge1xuICAgICAgICB2YXIgY3VyUG9zID0ge307XG4gICAgICAgIGN1clBvcy54ID0gc2l6ZSAqIE1hdGguc2luKGkgKiBhbmdsZSk7XG4gICAgICAgIGN1clBvcy55ID0gLXNpemUgKiBNYXRoLmNvcyhpICogYW5nbGUpO1xuICAgICAgICBkb3RzQXJyYXkucHVzaChjdXJQb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG90c0FycmF5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYWRhcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFJhZGlhbCBDbGFzcyBmb3IgZHJhd2luZyBDaXJjbGUgLyBTZW1pIENpcmNsZSBDaGFydHMuXG4gKiBAbW9kdWxlIFJhZGlhbFxuICoqL1xuXG52YXIgUmFkaWFsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGllKSB7XG4gIF9pbmhlcml0cyhSYWRpYWwsIF9QaWUpO1xuXG4gIGZ1bmN0aW9uIFJhZGlhbChjdHgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaWFsKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJhZGlhbCkuY2FsbCh0aGlzLCBjdHgpKTtcbiAgICBfdGhpcy5jdHggPSBjdHg7XG4gICAgX3RoaXMudyA9IGN0eC53O1xuICAgIF90aGlzLmFuaW1CZWdpbkFyciA9IFswXTtcbiAgICBfdGhpcy5hbmltRHVyID0gMDtcbiAgICB2YXIgdyA9IF90aGlzLnc7XG4gICAgX3RoaXMuc3RhcnRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zdGFydEFuZ2xlO1xuICAgIF90aGlzLmVuZEFuZ2xlID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmVuZEFuZ2xlO1xuICAgIF90aGlzLnRyYWNrU3RhcnRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjay5zdGFydEFuZ2xlO1xuICAgIF90aGlzLnRyYWNrRW5kQW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suZW5kQW5nbGU7XG4gICAgX3RoaXMucmFkaWFsRGF0YUxhYmVscyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5kYXRhTGFiZWxzO1xuICAgIGlmICghX3RoaXMudHJhY2tTdGFydEFuZ2xlKSBfdGhpcy50cmFja1N0YXJ0QW5nbGUgPSBfdGhpcy5zdGFydEFuZ2xlO1xuICAgIGlmICghX3RoaXMudHJhY2tFbmRBbmdsZSkgX3RoaXMudHJhY2tFbmRBbmdsZSA9IF90aGlzLmVuZEFuZ2xlO1xuICAgIGlmIChfdGhpcy5lbmRBbmdsZSA9PT0gMzYwKSBfdGhpcy5lbmRBbmdsZSA9IDM1OS45OTtcbiAgICBfdGhpcy5mdWxsQW5nbGUgPSAzNjAgLSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuZW5kQW5nbGUgLSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuc3RhcnRBbmdsZTtcbiAgICBfdGhpcy5tYXJnaW4gPSBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2subWFyZ2luKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFkaWFsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmV0ID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmFkaWFsYmFyJ1xuICAgICAgfSk7XG4gICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgdmFyIGNlbnRlclkgPSB0aGlzLmRlZmF1bHRTaXplIC8gMjtcbiAgICAgIHZhciBjZW50ZXJYID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyLjA1IC0gdy5jb25maWcuc3Ryb2tlLndpZHRoIC0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnNpemU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckFyciA9IHcuZ2xvYmFscy5maWxsLmNvbG9ycztcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjay5zaG93KSB7XG4gICAgICAgIHZhciBlbFRyYWNrcyA9IHRoaXMuZHJhd1RyYWNrcyh7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICBjZW50ZXJYOiBjZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IGNlbnRlclksXG4gICAgICAgICAgY29sb3JBcnI6IGNvbG9yQXJyLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICAgIH0pO1xuICAgICAgICBlbFNlcmllcy5hZGQoZWxUcmFja3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxHID0gdGhpcy5kcmF3QXJjcyh7XG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGNlbnRlclg6IGNlbnRlclgsXG4gICAgICAgIGNlbnRlclk6IGNlbnRlclksXG4gICAgICAgIGNvbG9yQXJyOiBjb2xvckFycixcbiAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgIH0pO1xuICAgICAgZWxTZXJpZXMuYWRkKGVsRy5nKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cucG9zaXRpb24gPT09ICdmcm9udCcpIHtcbiAgICAgICAgZWxHLmcuYWRkKGVsRy5lbEhvbGxvdyk7XG5cbiAgICAgICAgaWYgKGVsRy5kYXRhTGFiZWxzKSB7XG4gICAgICAgICAgZWxHLmcuYWRkKGVsRy5kYXRhTGFiZWxzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdUcmFja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RyYWNrcyhvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZyA9IGdyYXBoaWNzLmdyb3VwKCk7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aChvcHRzKTtcbiAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC8gMjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxSYWRpYWxCYXJUcmFjayA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmFkaWFsYmFyLXRyYWNrIGFwZXhjaGFydHMtdHJhY2snXG4gICAgICAgIH0pO1xuICAgICAgICBnLmFkZChlbFJhZGlhbEJhclRyYWNrKTtcbiAgICAgICAgZWxSYWRpYWxCYXJUcmFjay5hdHRyKHtcbiAgICAgICAgICBpZDogJ2FwZXhjaGFydHMtdHJhY2stJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgb3B0cy5zaXplID0gb3B0cy5zaXplIC0gc3Ryb2tlV2lkdGggLSB0aGlzLm1hcmdpbjtcbiAgICAgICAgdmFyIHRyYWNrQ29uZmlnID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IDAsXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICAgIGZpbGxDb2xvcnM6IEFycmF5LmlzQXJyYXkodHJhY2tDb25maWcuYmFja2dyb3VuZCkgPyB0cmFja0NvbmZpZy5iYWNrZ3JvdW5kW2ldIDogdHJhY2tDb25maWcuYmFja2dyb3VuZCxcbiAgICAgICAgICBzb2xpZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLnRyYWNrU3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhpcy50cmFja0VuZEFuZ2xlO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUpICsgTWF0aC5hYnMoc3RhcnRBbmdsZSkgPj0gMzYwKSBlbmRBbmdsZSA9IDM2MCAtIE1hdGguYWJzKHRoaXMuc3RhcnRBbmdsZSkgLSAwLjE7XG4gICAgICAgIHZhciBlbFBhdGggPSBncmFwaGljcy5kcmF3UGF0aCh7XG4gICAgICAgICAgZDogJycsXG4gICAgICAgICAgc3Ryb2tlOiBwYXRoRmlsbCxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggKiBwYXJzZUludCh0cmFja0NvbmZpZy5zdHJva2VXaWR0aCkgLyAxMDAsXG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRyYWNrQ29uZmlnLm9wYWNpdHksXG4gICAgICAgICAgY2xhc3NlczogJ2FwZXhjaGFydHMtcmFkaWFsYmFyLWFyZWEnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0cmFja0NvbmZpZy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgc2hhZG93ID0gdHJhY2tDb25maWcuZHJvcFNoYWRvdztcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWxQYXRoLCBzaGFkb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxSYWRpYWxCYXJUcmFjay5hZGQoZWxQYXRoKTtcbiAgICAgICAgZWxQYXRoLmF0dHIoJ2lkJywgJ2FwZXhjaGFydHMtcmFkaWFsYmFyVHJhY2stJyArIGkpO1xuICAgICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICAgIHBpZS5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBzaXplOiBvcHRzLnNpemUsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB0b3RhbEl0ZW1zOiAyLFxuICAgICAgICAgIGFuaW1CZWdpbkFycjogMCxcbiAgICAgICAgICBkdXI6IDAsXG4gICAgICAgICAgaXNUcmFjazogdHJ1ZSxcbiAgICAgICAgICBlYXNpbmc6IHcuZ2xvYmFscy5lYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXJjc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJjcyhvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudzsgLy8gc2l6ZSwgZG9udXRTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBjb2xvckFyciwgbGluZUNvbG9yQXJyLCBzZWN0b3JBbmdsZUFyciwgc2VyaWVzXG5cbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aChvcHRzKTtcbiAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgIHZhciBob2xsb3dGaWxsSUQgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmJhY2tncm91bmQ7XG4gICAgICB2YXIgaG9sbG93U2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoICogb3B0cy5zZXJpZXMubGVuZ3RoIC0gdGhpcy5tYXJnaW4gKiBvcHRzLnNlcmllcy5sZW5ndGggLSBzdHJva2VXaWR0aCAqIHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjay5zdHJva2VXaWR0aCkgLyAxMDAgLyAyO1xuICAgICAgdmFyIGhvbGxvd1JhZGl1cyA9IGhvbGxvd1NpemUgLSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93Lm1hcmdpbjtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBob2xsb3dGaWxsSUQgPSB0aGlzLmRyYXdIb2xsb3dJbWFnZShvcHRzLCBnLCBob2xsb3dTaXplLCBob2xsb3dGaWxsSUQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxIb2xsb3cgPSB0aGlzLmRyYXdIb2xsb3coe1xuICAgICAgICBzaXplOiBob2xsb3dSYWRpdXMsXG4gICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgY2VudGVyWTogb3B0cy5jZW50ZXJZLFxuICAgICAgICBmaWxsOiBob2xsb3dGaWxsSURcbiAgICAgIH0pO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgdmFyIHNoYWRvdyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuZHJvcFNoYWRvdztcbiAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsSG9sbG93LCBzaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd24gPSAxO1xuXG4gICAgICBpZiAoIXRoaXMucmFkaWFsRGF0YUxhYmVscy50b3RhbC5zaG93ICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBzaG93biA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWUgPSBuZXcgUGllKHRoaXMuY3R4KTtcbiAgICAgIHZhciBkYXRhTGFiZWxzID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMucmFkaWFsRGF0YUxhYmVscy5zaG93KSB7XG4gICAgICAgIGRhdGFMYWJlbHMgPSBwaWUucmVuZGVySW5uZXJEYXRhTGFiZWxzKHRoaXMucmFkaWFsRGF0YUxhYmVscywge1xuICAgICAgICAgIGhvbGxvd1NpemU6IGhvbGxvd1NpemUsXG4gICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICBvcGFjaXR5OiBzaG93blxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICBnLmFkZChlbEhvbGxvdyk7XG5cbiAgICAgICAgaWYgKGRhdGFMYWJlbHMpIHtcbiAgICAgICAgICBnLmFkZChkYXRhTGFiZWxzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV2ZXJzZUxvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5pbnZlcnNlT3JkZXIpIHtcbiAgICAgICAgcmV2ZXJzZUxvb3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gcmV2ZXJzZUxvb3AgPyBvcHRzLnNlcmllcy5sZW5ndGggLSAxIDogMDsgcmV2ZXJzZUxvb3AgPyBpID49IDAgOiBpIDwgb3B0cy5zZXJpZXMubGVuZ3RoOyByZXZlcnNlTG9vcCA/IGktLSA6IGkrKykge1xuICAgICAgICB2YXIgZWxSYWRpYWxCYXJBcmMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgYXBleGNoYXJ0cy1yYWRpYWwtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW2ldKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGcuYWRkKGVsUmFkaWFsQmFyQXJjKTtcbiAgICAgICAgZWxSYWRpYWxCYXJBcmMuYXR0cih7XG4gICAgICAgICAgaWQ6ICdhcGV4Y2hhcnRzLXNlcmllcy0nICsgaSxcbiAgICAgICAgICByZWw6IGkgKyAxXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN0eC5zZXJpZXMuYWRkQ29sbGFwc2VkQ2xhc3NUb1NlcmllcyhlbFJhZGlhbEJhckFyYywgaSk7XG4gICAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC0gdGhpcy5tYXJnaW47XG4gICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgIHNlcmllc051bWJlcjogaSxcbiAgICAgICAgICBzaXplOiBvcHRzLnNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcHJldlN0YXJ0QW5nbGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciB0b3RhbEFuZ2xlID0gTWF0aC5hYnMody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmVuZEFuZ2xlIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnN0YXJ0QW5nbGUpOyAvLyBpZiBkYXRhIGV4Y2VlZHMgMTAwLCBtYWtlIGl0IDEwMFxuXG4gICAgICAgIHZhciBkYXRhVmFsdWUgPSBVdGlscy5uZWdUb1plcm8ob3B0cy5zZXJpZXNbaV0gPiAxMDAgPyAxMDAgOiBvcHRzLnNlcmllc1tpXSkgLyAxMDA7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGgucm91bmQodG90YWxBbmdsZSAqIGRhdGFWYWx1ZSkgKyB0aGlzLnN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBwcmV2RW5kQW5nbGUgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIHByZXZTdGFydEFuZ2xlID0gdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgICAgIHByZXZFbmRBbmdsZSA9IE1hdGgucm91bmQodG90YWxBbmdsZSAqIFV0aWxzLm5lZ1RvWmVybyh3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tpXSkgLyAxMDApICsgcHJldlN0YXJ0QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyckZ1bGxBbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlKSArIE1hdGguYWJzKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgIGlmIChjdXJyRnVsbEFuZ2xlID49IDM2MCkge1xuICAgICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgLSAwLjAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZGdWxsQW5nbGUgPSBNYXRoLmFicyhwcmV2RW5kQW5nbGUpICsgTWF0aC5hYnMocHJldlN0YXJ0QW5nbGUpO1xuXG4gICAgICAgIGlmIChwcmV2RnVsbEFuZ2xlID49IDM2MCkge1xuICAgICAgICAgIHByZXZFbmRBbmdsZSA9IHByZXZFbmRBbmdsZSAtIDAuMDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBkYXNoQXJyYXkgPSBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXkpID8gdy5jb25maWcuc3Ryb2tlLmRhc2hBcnJheVtpXSA6IHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXk7XG4gICAgICAgIHZhciBlbFBhdGggPSBncmFwaGljcy5kcmF3UGF0aCh7XG4gICAgICAgICAgZDogJycsXG4gICAgICAgICAgc3Ryb2tlOiBwYXRoRmlsbCxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiB3LmNvbmZpZy5maWxsLm9wYWNpdHksXG4gICAgICAgICAgY2xhc3NlczogJ2FwZXhjaGFydHMtcmFkaWFsYmFyLWFyZWEnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogZGFzaEFycmF5XG4gICAgICAgIH0pO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbFBhdGgubm9kZSwge1xuICAgICAgICAgICdkYXRhOmFuZ2xlJzogYW5nbGUsXG4gICAgICAgICAgJ2RhdGE6dmFsdWUnOiBvcHRzLnNlcmllc1tpXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIF9zaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIF9zaGFkb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoZWxQYXRoLCB0aGlzLnJhZGlhbERhdGFMYWJlbHMpO1xuXG4gICAgICAgIHZhciBfcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG5cbiAgICAgICAgZWxSYWRpYWxCYXJBcmMuYWRkKGVsUGF0aCk7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICBpZDogJ2FwZXhjaGFydHMtcmFkaWFsYmFyLXNsaWNlLScgKyBpLFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIGo6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgIGlmIChfcGllLmluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkO1xuICAgICAgICAgIHRoaXMuYW5pbUR1ciA9IGR1ciAvIChvcHRzLnNlcmllcy5sZW5ndGggKiAxLjIpICsgdGhpcy5hbmltRHVyO1xuICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICBkdXIgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDM2MCAqIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZDtcbiAgICAgICAgICB0aGlzLmFuaW1EdXIgPSBkdXIgLyAob3B0cy5zZXJpZXMubGVuZ3RoICogMS4yKSArIHRoaXMuYW5pbUR1cjtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKHRoaXMuYW5pbUR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBfcGllLmFuaW1hdGVQYXRocyhlbFBhdGgsIHtcbiAgICAgICAgICBjZW50ZXJYOiBvcHRzLmNlbnRlclgsXG4gICAgICAgICAgY2VudGVyWTogb3B0cy5jZW50ZXJZLFxuICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgIHByZXZFbmRBbmdsZTogcHJldkVuZEFuZ2xlLFxuICAgICAgICAgIHByZXZTdGFydEFuZ2xlOiBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICBzaXplOiBvcHRzLnNpemUsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB0b3RhbEl0ZW1zOiAyLFxuICAgICAgICAgIGFuaW1CZWdpbkFycjogdGhpcy5hbmltQmVnaW5BcnIsXG4gICAgICAgICAgZHVyOiBkdXIsXG4gICAgICAgICAgc2hvdWxkU2V0UHJldlBhdGhzOiB0cnVlLFxuICAgICAgICAgIGVhc2luZzogdy5nbG9iYWxzLmVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZzogZyxcbiAgICAgICAgZWxIb2xsb3c6IGVsSG9sbG93LFxuICAgICAgICBkYXRhTGFiZWxzOiBkYXRhTGFiZWxzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3SG9sbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdIb2xsb3cob3B0cykge1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBjaXJjbGUgPSBncmFwaGljcy5kcmF3Q2lyY2xlKG9wdHMuc2l6ZSAqIDIpO1xuICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmFkaWFsYmFyLWhvbGxvdycsXG4gICAgICAgIGN4OiBvcHRzLmNlbnRlclgsXG4gICAgICAgIGN5OiBvcHRzLmNlbnRlclksXG4gICAgICAgIHI6IG9wdHMuc2l6ZSxcbiAgICAgICAgZmlsbDogb3B0cy5maWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdIb2xsb3dJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SG9sbG93SW1hZ2Uob3B0cywgZywgaG9sbG93U2l6ZSwgaG9sbG93RmlsbElEKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWxsID0gbmV3IEZpbGwodGhpcy5jdHgpO1xuICAgICAgdmFyIHJhbmRJRCA9IChNYXRoLnJhbmRvbSgpICsgMSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg0KTtcbiAgICAgIHZhciBob2xsb3dGaWxsSW1nID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZTtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2VDbGlwcGVkKSB7XG4gICAgICAgIGZpbGwuY2xpcHBlZEltZ0FyZWEoe1xuICAgICAgICAgIHdpZHRoOiBob2xsb3dTaXplLFxuICAgICAgICAgIGhlaWdodDogaG9sbG93U2l6ZSxcbiAgICAgICAgICBpbWFnZTogaG9sbG93RmlsbEltZyxcbiAgICAgICAgICBwYXR0ZXJuSUQ6IFwicGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KHJhbmRJRClcbiAgICAgICAgfSk7XG4gICAgICAgIGhvbGxvd0ZpbGxJRCA9IFwidXJsKCNwYXR0ZXJuXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkKS5jb25jYXQocmFuZElELCBcIilcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW1nV2lkdGggPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlV2lkdGg7XG4gICAgICAgIHZhciBpbWdIZWlnaHQgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChpbWdXaWR0aCA9PT0gdW5kZWZpbmVkICYmIGltZ0hlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGltYWdlID0gdy5nbG9iYWxzLmRvbS5QYXBlci5pbWFnZShob2xsb3dGaWxsSW1nKS5sb2FkZWQoZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKG9wdHMuY2VudGVyWCAtIGxvYWRlci53aWR0aCAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlT2Zmc2V0WCwgb3B0cy5jZW50ZXJZIC0gbG9hZGVyLmhlaWdodCAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlT2Zmc2V0WSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZy5hZGQoaW1hZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaW1hZ2UgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmltYWdlKGhvbGxvd0ZpbGxJbWcpLmxvYWRlZChmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUob3B0cy5jZW50ZXJYIC0gaW1nV2lkdGggLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFgsIG9wdHMuY2VudGVyWSAtIGltZ0hlaWdodCAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlT2Zmc2V0WSk7XG4gICAgICAgICAgICB0aGlzLnNpemUoaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBnLmFkZChfaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBob2xsb3dGaWxsSUQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0cm9rZVdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0cm9rZVdpZHRoKG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIG9wdHMuc2l6ZSAqICgxMDAgLSBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnNpemUpKSAvIDEwMCAvIChvcHRzLnNlcmllcy5sZW5ndGggKyAxKSAtIHRoaXMubWFyZ2luO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYWRpYWw7XG59KFBpZSk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSYW5nZUJhciBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBSYW5nZS9UaW1lbGluZSBCYXJzLlxuICpcbiAqIEBtb2R1bGUgUmFuZ2VCYXJcbiAqKi9cblxudmFyIFJhbmdlQmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFyKSB7XG4gIF9pbmhlcml0cyhSYW5nZUJhciwgX0Jhcik7XG5cbiAgZnVuY3Rpb24gUmFuZ2VCYXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlQmFyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmFuZ2VCYXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJhbmdlQmFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnJhbmdlQmFyT3B0aW9ucyA9IHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMucmFuZ2VCYXI7XG4gICAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICAgIHRoaXMuc2VyaWVzUmFuZ2VTdGFydCA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZVN0YXJ0O1xuICAgICAgdGhpcy5zZXJpZXNSYW5nZUVuZCA9IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZDtcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhbmdlYmFyLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgdmFyIHBhdGhUbyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdm9pZCAwO1xuICAgICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgICB4RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB4RGl2aXNpb24gaXMgdGhlIEdSSURXSURUSCBkaXZpZGVkIGJ5IG51bWJlciBvZiBkYXRhcG9pbnRzIChjb2x1bW5zKVxuICAgICAgICB5RGl2aXNpb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB5RGl2aXNpb24gaXMgdGhlIEdSSURIRUlHSFQgZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoYmFycylcbiAgICAgICAgemVyb0ggPSB2b2lkIDAsXG4gICAgICAgICAgICAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcbiAgICAgICAgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgIHZhciB5QXJyaiA9IFtdOyAvLyBob2xkIHkgdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgIHZhciB4QXJyaiA9IFtdOyAvLyBob2xkIHggdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VyaWVzW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnZpc2libGVJID0gdGhpcy52aXNpYmxlSSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoID0gMDtcblxuICAgICAgICBpZiAodGhpcy55UmF0aW8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbml0UG9zaXRpb25zID0gdGhpcy5pbml0aWFsUG9zaXRpb25zKCk7XG4gICAgICAgIHkgPSBpbml0UG9zaXRpb25zLnk7XG4gICAgICAgIHlEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueURpdmlzaW9uO1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgemVyb1cgPSBpbml0UG9zaXRpb25zLnplcm9XO1xuICAgICAgICB4ID0gaW5pdFBvc2l0aW9ucy54O1xuICAgICAgICBiYXJXaWR0aCA9IGluaXRQb3NpdGlvbnMuYmFyV2lkdGg7XG4gICAgICAgIHhEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueERpdmlzaW9uO1xuICAgICAgICB6ZXJvSCA9IGluaXRQb3NpdGlvbnMuemVyb0g7XG4gICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7IC8vIGVsZGF0YWxhYmVsc1xuXG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgdGogPSB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaiA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzOyBqKyssIHRqLS0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNOdWxsVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzTnVsbFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnN0cm9rZS5zaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc051bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkodGhpcy5zdHJva2VXaWR0aCkgPyB0aGlzLnN0cm9rZVdpZHRoW3JlYWxJbmRleF0gOiB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHBhdGhzID0gdGhpcy5kcmF3UmFuZ2VCYXJQYXRocyh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIHplcm9XOiB6ZXJvVyxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeURpdmlzaW9uOiB5RGl2aXNpb24sXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhzID0gdGhpcy5kcmF3UmFuZ2VDb2x1bW5QYXRocyh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgIHhEaXZpc2lvbjogeERpdmlzaW9uLFxuICAgICAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgIHplcm9IOiB6ZXJvSCxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGhUbyA9IHBhdGhzLnBhdGhUbztcbiAgICAgICAgICBwYXRoRnJvbSA9IHBhdGhzLnBhdGhGcm9tO1xuICAgICAgICAgIHkgPSBwYXRocy55O1xuICAgICAgICAgIHggPSBwYXRocy54OyAvLyBwdXNoIGN1cnJlbnQgWFxuXG4gICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBsaW5lRmlsbCA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW3JlYWxJbmRleF07XG4gICAgICAgICAgZWxTZXJpZXMgPSB0aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGxpbmVGaWxsOiBsaW5lRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdmlzaWJsZVNlcmllczogdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdyYW5nZWJhcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1JhbmdlQ29sdW1uUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1JhbmdlQ29sdW1uUGF0aHMoX3JlZikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgICAgICB4RGl2aXNpb24gPSBfcmVmLnhEaXZpc2lvbixcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYucGF0aEZyb20sXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgIHplcm9IID0gX3JlZi56ZXJvSDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICB2YXIgeVJhdGlvID0gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VWYWx1ZShyZWFsSW5kZXgsIGopO1xuICAgICAgdmFyIHkxID0gTWF0aC5taW4ocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICB2YXIgeTIgPSBNYXRoLm1heChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeTEgPSB6ZXJvSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gemVyb0ggLSB5MSAvIHlSYXRpbztcbiAgICAgICAgeTIgPSB6ZXJvSCAtIHkyIC8geVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCB5MiAtIHN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHkyLFxuICAgICAgICBiYXJYUG9zaXRpb246IGJhclhQb3NpdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1JhbmdlQmFyUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1JhbmdlQmFyUGF0aHMoX3JlZjIpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICB5RGl2aXNpb24gPSBfcmVmMi55RGl2aXNpb24sXG4gICAgICAgICAgcGF0aFRvID0gX3JlZjIucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZjIucGF0aEZyb20sXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZjIuYmFySGVpZ2h0LFxuICAgICAgICAgIHplcm9XID0gX3JlZjIuemVyb1c7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIHgxID0gemVyb1c7XG4gICAgICB2YXIgeDIgPSB6ZXJvVztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHkgPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLmludmVydGVkWFJhdGlvIC0gYmFySGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFyWVBvc2l0aW9uID0geSArIGJhckhlaWdodCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKHplcm9XLCBiYXJZUG9zaXRpb24pO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKHplcm9XLCBiYXJZUG9zaXRpb24pO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5zZXJpZXNbaV1bal0gIT09IG51bGwpIHtcbiAgICAgICAgeDEgPSB6ZXJvVyArIHRoaXMuc2VyaWVzUmFuZ2VTdGFydFtpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICAgIHgyID0gemVyb1cgKyB0aGlzLnNlcmllc1JhbmdlRW5kW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbztcbiAgICAgIH1cblxuICAgICAgcGF0aFRvID0gZ3JhcGhpY3MubW92ZSh4MSwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUoeDIsIGJhcllQb3NpdGlvbikgKyBncmFwaGljcy5saW5lKHgyLCBiYXJZUG9zaXRpb24gKyBiYXJIZWlnaHQpICsgZ3JhcGhpY3MubGluZSh4MSwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0KSArIGdyYXBoaWNzLmxpbmUoeDEsIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeSA9IHkgKyB5RGl2aXNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgyLFxuICAgICAgICB5OiB5LFxuICAgICAgICBiYXJZUG9zaXRpb246IGJhcllQb3NpdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZVZhbHVlKGksIGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHcuZ2xvYmFscy5zZXJpZXNSYW5nZVN0YXJ0W2ldW2pdLFxuICAgICAgICBlbmQ6IHcuZ2xvYmFscy5zZXJpZXNSYW5nZUVuZFtpXVtqXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2VCYXI7XG59KEJhcik7XG5cbi8qKlxuICogQXBleENoYXJ0cyBMaW5lIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIExpbmUgLyBBcmVhIENoYXJ0cy5cbiAqIFRoaXMgY2xhc3MgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB2YWx1ZXMgZm9yIEJ1YmJsZS9TY2F0dGVyIGNoYXJ0cywgc28gbmVlZCB0byByZW5hbWUgaXQgdG8gQXhpcyBDaGFydHMgdG8gYXZvaWQgY29uZnVzaW9uc1xuICogQG1vZHVsZSBMaW5lXG4gKiovXG5cbnZhciBMaW5lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGluZShjdHgsIHh5UmF0aW9zLCBpc1BvaW50c0NoYXJ0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy54eVJhdGlvcyA9IHh5UmF0aW9zO1xuICAgIHRoaXMucG9pbnRzQ2hhcnQgPSAhKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScgJiYgdGhpcy53LmNvbmZpZy5jaGFydC50eXBlICE9PSAnc2NhdHRlcicpIHx8IGlzUG9pbnRzQ2hhcnQ7XG4gICAgdGhpcy5zY2F0dGVyID0gbmV3IFNjYXR0ZXIodGhpcy5jdHgpO1xuICAgIHRoaXMubm9OZWdhdGl2ZXMgPSB0aGlzLncuZ2xvYmFscy5taW5YID09PSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMueWF4aXNJbmRleCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcywgcHR5cGUsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciB0eXBlID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gcHR5cGUgOiB3LmNvbmZpZy5jaGFydC50eXBlO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXNcIilcbiAgICAgIH0pO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgsIHcpO1xuICAgICAgc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgdmFyIHlSYXRpbyA9IHRoaXMueHlSYXRpb3MueVJhdGlvO1xuICAgICAgeVJhdGlvID0gY29yZVV0aWxzLmdldExvZ1lSYXRpb3MoeVJhdGlvKTtcbiAgICAgIHZhciB6UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnpSYXRpbztcbiAgICAgIHZhciB4UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnhSYXRpbztcbiAgICAgIHZhciBiYXNlTGluZVkgPSB0aGlzLnh5UmF0aW9zLmJhc2VMaW5lWTsgLy8gcHVzaCBhbGwgc2VyaWVzIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gZHJhdyBpbiByZXZlcnNlIG9yZGVyIChmb3Igc3RhY2tlZCBjaGFydHMpXG5cbiAgICAgIHZhciBhbGxTZXJpZXMgPSBbXTtcbiAgICAgIHZhciBwcmV2U2VyaWVzWSA9IFtdO1xuICAgICAgdmFyIGNhdGVnb3J5QXhpc0NvcnJlY3Rpb24gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB3aWR0aCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiAody5jb25maWcuZmlsbC50eXBlID09PSAnZ3JhZGllbnQnIHx8IHcuY29uZmlnLmZpbGwudHlwZVtpXSA9PT0gJ2dyYWRpZW50JykpIHtcbiAgICAgICAgICAvLyBhIHNtYWxsIGFkanVzdG1lbnQgdG8gYWxsb3cgZ3JhZGllbnQgbGluZSB0byBkcmF3IGNvcnJlY3RseSBmb3IgYWxsIHNhbWUgdmFsdWVzXG5cbiAgICAgICAgICAvKiAjZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzM1OCAqL1xuICAgICAgICAgIGlmIChjb3JlVXRpbHMuc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoaSkpIHtcbiAgICAgICAgICAgIHZhciBnU2VyaWVzID0gc2VyaWVzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBnU2VyaWVzW2dTZXJpZXMubGVuZ3RoIC0gMV0gPSBnU2VyaWVzW2dTZXJpZXMubGVuZ3RoIC0gMV0gKyAwLjAwMDAwMTtcbiAgICAgICAgICAgIHNlcmllc1tpXSA9IGdTZXJpZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgdmFyIHJlYWxJbmRleCA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHNlcmllc0luZGV4W2ldIDogaTtcblxuICAgICAgICBpZiAoeVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3RoaXMueWF4aXNJbmRleF0ucmV2ZXJzZWQ7XG4gICAgICAgIHZhciB5QXJyaiA9IFtdOyAvLyBob2xkIHkgdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuXG4gICAgICAgIHZhciB4QXJyaiA9IFtdOyAvLyBob2xkIHggdmFsdWVzIG9mIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllc1xuICAgICAgICAvLyB6ZXJvWSBpcyB0aGUgMCB2YWx1ZSBpbiB5IHNlcmllcyB3aGljaCBjYW4gYmUgdXNlZCBpbiBuZWdhdGl2ZSBjaGFydHNcblxuICAgICAgICB2YXIgemVyb1kgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIGJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdIC0gKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IDogMCkgKyAodGhpcy5pc1JldmVyc2VkID8gYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gKiAyIDogMCk7XG4gICAgICAgIHZhciBhcmVhQm90dG9tWSA9IHplcm9ZO1xuXG4gICAgICAgIGlmICh6ZXJvWSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSB7XG4gICAgICAgICAgYXJlYUJvdHRvbVkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhdGVnb3J5QXhpc0NvcnJlY3Rpb24gPSB4RGl2aXNpb24gLyAyO1xuICAgICAgICB2YXIgeCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbjtcbiAgICAgICAgdmFyIHkgPSAxO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYyAmJiB3Lmdsb2JhbHMuc2VyaWVzWC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgeCA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdWzBdIC0gdy5nbG9iYWxzLm1pblgpIC8geFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgeEFycmoucHVzaCh4KTtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gdm9pZCAwLFxuICAgICAgICAgICAgYXJlYVBhdGggPSB2b2lkIDAsXG4gICAgICAgICAgICBwYXRoRnJvbUxpbmUgPSB2b2lkIDAsXG4gICAgICAgICAgICBwYXRoRnJvbUFyZWEgPSB2b2lkIDA7XG4gICAgICAgIHZhciBsaW5lUGF0aHMgPSBbXTtcbiAgICAgICAgdmFyIGFyZWFQYXRocyA9IFtdOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tyZWFsSW5kZXhdKSlcbiAgICAgICAgfSk7IC8vIHBvaW50c1xuXG4gICAgICAgIHZhciBlbFBvaW50c01haW4gPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzLXdyYXAnXG4gICAgICAgIH0pOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3R4LnNlcmllcy5hZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCByZWFsSW5kZXgpO1xuICAgICAgICB2YXIgbG9uZ2VzdFNlcmllcyA9IHNlcmllc1tpXS5sZW5ndGggPT09IHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgICBlbFNlcmllcy5hdHRyKHtcbiAgICAgICAgICAnZGF0YTpsb25nZXN0U2VyaWVzJzogbG9uZ2VzdFNlcmllcyxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IHJlYWxJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRQYXRoRnJvbSA9IHRydWU7XG4gICAgICAgIHZhciBwWCA9IHg7XG4gICAgICAgIHZhciBwWSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHByZXZYID0gcFg7XG4gICAgICAgIHZhciBwcmV2WSA9IHplcm9ZOyAvLyB3Lmdsb2JhbHMuc3ZnSGVpZ2h0O1xuXG4gICAgICAgIHZhciBsaW5lWVBvc2l0aW9uID0gMDsgLy8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBjdXJyZW50IHNlcmllcyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcblxuICAgICAgICB2YXIgZmlyc3RQcmV2WSA9IHRoaXMuZGV0ZXJtaW5lRmlyc3RQcmV2WSh7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICB5UmF0aW86IHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdLFxuICAgICAgICAgIHplcm9ZOiB6ZXJvWSxcbiAgICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgICAgcHJldlNlcmllc1k6IHByZXZTZXJpZXNZLFxuICAgICAgICAgIGxpbmVZUG9zaXRpb246IGxpbmVZUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZZID0gZmlyc3RQcmV2WS5wcmV2WTtcbiAgICAgICAgeUFycmoucHVzaChwcmV2WSk7XG4gICAgICAgIHBZID0gcHJldlk7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXVswXSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IHZhbHVlIGl0c2VsZiBpcyBudWxsLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIHBvaW50ZXIgdG8gYSBsb2NhdGlvbiB3aGVyZSBhIG51bGwgdmFsdWUgaXMgbm90IGZvdW5kXG4gICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZXJpZXNbaV0ubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNbaV1bc10gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldlggPSB4RGl2aXNpb24gKiBzO1xuICAgICAgICAgICAgICBwcmV2WSA9IHplcm9ZIC0gc2VyaWVzW2ldW3NdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF07XG4gICAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgcHJldlkpO1xuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGdyYXBoaWNzLm1vdmUocHJldlgsIGFyZWFCb3R0b21ZKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgcHJldlkpO1xuICAgICAgICAgIGFyZWFQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubGluZShwcmV2WCwgcHJldlkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aEZyb21MaW5lID0gZ3JhcGhpY3MubW92ZSgtMSwgemVyb1kpICsgZ3JhcGhpY3MubGluZSgtMSwgemVyb1kpO1xuICAgICAgICBwYXRoRnJvbUFyZWEgPSBncmFwaGljcy5tb3ZlKC0xLCB6ZXJvWSkgKyBncmFwaGljcy5saW5lKC0xLCB6ZXJvWSk7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcGF0aEZyb20gPSB0aGlzLmNoZWNrUHJldmlvdXNQYXRocyh7XG4gICAgICAgICAgICBwYXRoRnJvbUxpbmU6IHBhdGhGcm9tTGluZSxcbiAgICAgICAgICAgIHBhdGhGcm9tQXJlYTogcGF0aEZyb21BcmVhLFxuICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoRnJvbUxpbmUgPSBwYXRoRnJvbS5wYXRoRnJvbUxpbmU7XG4gICAgICAgICAgcGF0aEZyb21BcmVhID0gcGF0aEZyb20ucGF0aEZyb21BcmVhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSB3Lmdsb2JhbHMuZGF0YVBvaW50cyA+IDEgPyB3Lmdsb2JhbHMuZGF0YVBvaW50cyAtIDEgOiB3Lmdsb2JhbHMuZGF0YVBvaW50cztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgdmFyIHNYID0gdy5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVtqICsgMV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVtqICsgMV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8qIGZpeCAjMzc0ICovXG4gICAgICAgICAgICAgIHNYID0gdy5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVtpdGVyYXRpb25zIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSAoc1ggLSB3Lmdsb2JhbHMubWluWCkgLyB4UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtaW5ZID0gVXRpbHMuaXNOdW1iZXIody5nbG9iYWxzLm1pbllBcnJbcmVhbEluZGV4XSkgPyB3Lmdsb2JhbHMubWluWUFycltyZWFsSW5kZXhdIDogdy5nbG9iYWxzLm1pblk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoIDwgdy5jb25maWcuc2VyaWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHByZXZTZXJpZXNZW2kgLSAxXVtqICsgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzXG4gICAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSB6ZXJvWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbaV1baiArIDFdID09PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1baiArIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHkgPSBsaW5lWVBvc2l0aW9uIC0gbWluWSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IG1pblkgLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHkgPSBsaW5lWVBvc2l0aW9uIC0gc2VyaWVzW2ldW2ogKyAxXSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHNlcmllc1tpXVtqICsgMV0gLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbaV1baiArIDFdID09PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1baiArIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHkgPSB6ZXJvWSAtIG1pblkgLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSArICh0aGlzLmlzUmV2ZXJzZWQgPyBtaW5ZIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gOiAwKSAqIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5ID0gemVyb1kgLSBzZXJpZXNbaV1baiArIDFdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gc2VyaWVzW2ldW2ogKyAxXSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gcHVzaCBjdXJyZW50IFhcblxuXG4gICAgICAgICAgeEFycmoucHVzaCh4KTsgLy8gcHVzaCBjdXJyZW50IFkgdGhhdCB3aWxsIGJlIHVzZWQgYXMgbmV4dCBzZXJpZXMncyBib3R0b20gcG9zaXRpb25cblxuICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYXRocyA9IHRoaXMuY3JlYXRlUGF0aHMoe1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgICAgICBwWDogcFgsXG4gICAgICAgICAgICBwWTogcFksXG4gICAgICAgICAgICBhcmVhQm90dG9tWTogYXJlYUJvdHRvbVksXG4gICAgICAgICAgICBsaW5lUGF0aDogbGluZVBhdGgsXG4gICAgICAgICAgICBhcmVhUGF0aDogYXJlYVBhdGgsXG4gICAgICAgICAgICBsaW5lUGF0aHM6IGxpbmVQYXRocyxcbiAgICAgICAgICAgIGFyZWFQYXRoczogYXJlYVBhdGhzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJlYVBhdGhzID0gY2FsY3VsYXRlZFBhdGhzLmFyZWFQYXRocztcbiAgICAgICAgICBsaW5lUGF0aHMgPSBjYWxjdWxhdGVkUGF0aHMubGluZVBhdGhzO1xuICAgICAgICAgIHBYID0gY2FsY3VsYXRlZFBhdGhzLnBYO1xuICAgICAgICAgIHBZID0gY2FsY3VsYXRlZFBhdGhzLnBZO1xuICAgICAgICAgIGFyZWFQYXRoID0gY2FsY3VsYXRlZFBhdGhzLmFyZWFQYXRoO1xuICAgICAgICAgIGxpbmVQYXRoID0gY2FsY3VsYXRlZFBhdGhzLmxpbmVQYXRoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXBwZW5kUGF0aEZyb20pIHtcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHBhdGhGcm9tTGluZSArIGdyYXBoaWNzLmxpbmUoeCwgemVyb1kpO1xuICAgICAgICAgICAgcGF0aEZyb21BcmVhID0gcGF0aEZyb21BcmVhICsgZ3JhcGhpY3MubGluZSh4LCB6ZXJvWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50c1BvcyA9IHRoaXMuY2FsY3VsYXRlUG9pbnRzKHtcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgcHJldlk6IHByZXZZLFxuICAgICAgICAgICAgY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbjogY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbixcbiAgICAgICAgICAgIHhSYXRpbzogeFJhdGlvXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMucG9pbnRzQ2hhcnQpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJzID0gbmV3IE1hcmtlcnModGhpcy5jdHgpO1xuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFQb2ludHMgPiAxKSB7XG4gICAgICAgICAgICAgIGVsUG9pbnRzTWFpbi5ub2RlLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gbWFya2Vycy5wbG90Q2hhcnRNYXJrZXJzKHBvaW50c1BvcywgcmVhbEluZGV4LCBqICsgMSk7XG5cbiAgICAgICAgICAgIGlmIChlbFBvaW50c1dyYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzY2F0dGVyIC8gYnViYmxlIGNoYXJ0IHBvaW50cyBjcmVhdGlvblxuICAgICAgICAgICAgdGhpcy5zY2F0dGVyLmRyYXcoZWxTZXJpZXMsIGosIHtcbiAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgIHBvaW50c1BvczogcG9pbnRzUG9zLFxuICAgICAgICAgICAgICB6UmF0aW86IHpSYXRpbyxcbiAgICAgICAgICAgICAgZWxQYXJlbnQ6IGVsUG9pbnRzTWFpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRhdGFMYWJlbEFsaWduID0gIXNlcmllc1tpXVtqICsgMV0gfHwgc2VyaWVzW2ldW2ogKyAxXSA+IHNlcmllc1tpXVtqXSA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgdmFyIGRhdGFMYWJlbHMgPSBuZXcgRGF0YUxhYmVscyh0aGlzLmN0eCk7XG4gICAgICAgICAgdmFyIGRyYXduTGFiZWxzID0gZGF0YUxhYmVscy5kcmF3RGF0YUxhYmVsKHBvaW50c1BvcywgcmVhbEluZGV4LCBqICsgMSwgbnVsbCwgZGF0YUxhYmVsQWxpZ24pO1xuXG4gICAgICAgICAgaWYgKGRyYXduTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwLmFkZChkcmF3bkxhYmVscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHB1c2ggYWxsIGN1cnJlbnQgeSB2YWx1ZXMgYXJyYXkgdG8gbWFpbiBQcmV2WSBBcnJheVxuXG5cbiAgICAgICAgcHJldlNlcmllc1kucHVzaCh5QXJyaik7IC8vIHB1c2ggYWxsIHggdmFsIGFycmF5cyBpbnRvIG1haW4geEFyclxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqOyAvLyB0aGVzZSBlbGVtZW50cyB3aWxsIGJlIHNob3duIGFmdGVyIGFyZWEgcGF0aCBhbmltYXRpb24gY29tcGxldGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLnBvaW50c0NoYXJ0KSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGVsOiBlbFBvaW50c01haW4ubm9kZSxcbiAgICAgICAgICAgIGluZGV4OiByZWFsSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgIGFuaW1hdGlvbkRlbGF5OiBpLFxuICAgICAgICAgIGluaXRpYWxTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCxcbiAgICAgICAgICBkYXRhQ2hhbmdlU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5zcGVlZCxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSksXG4gICAgICAgICAgaWQ6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBhcmVhUGF0aHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21BcmVhLFxuICAgICAgICAgICAgICBwYXRoVG86IGFyZWFQYXRoc1twXSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiBudWxsLFxuICAgICAgICAgICAgICBmaWxsOiBwYXRoRmlsbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKHJlbmRlcmVkUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnN0cm9rZS5zaG93ICYmICF0aGlzLnBvaW50c0NoYXJ0KSB7XG4gICAgICAgICAgdmFyIGxpbmVGaWxsID0gbnVsbDtcblxuICAgICAgICAgIGlmICh0eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIC8vIGZpbGxhYmxlIGxpbmVzIG9ubHkgZm9yIGxpbmVDaGFydFxuICAgICAgICAgICAgbGluZUZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lRmlsbCA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW3JlYWxJbmRleF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX3AgPSAwOyBfcCA8IGxpbmVQYXRocy5sZW5ndGg7IF9wKyspIHtcbiAgICAgICAgICAgIHZhciBfcmVuZGVyZWRQYXRoID0gZ3JhcGhpY3MucmVuZGVyUGF0aHMoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tTGluZSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBsaW5lUGF0aHNbX3BdLFxuICAgICAgICAgICAgICBzdHJva2U6IGxpbmVGaWxsLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gdy5jb25maWcuc3Ryb2tlLndpZHRoW3JlYWxJbmRleF0gOiB3LmNvbmZpZy5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAgIHN0cm9rZUxpbmVDYXA6IHcuY29uZmlnLnN0cm9rZS5saW5lQ2FwLFxuICAgICAgICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKF9yZW5kZXJlZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsU2VyaWVzLmFkZChlbFBvaW50c01haW4pO1xuICAgICAgICBlbFNlcmllcy5hZGQoZWxEYXRhTGFiZWxzV3JhcCk7XG4gICAgICAgIGFsbFNlcmllcy5wdXNoKGVsU2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3MgPSBhbGxTZXJpZXMubGVuZ3RoOyBfcyA+IDA7IF9zLS0pIHtcbiAgICAgICAgcmV0LmFkZChhbGxTZXJpZXNbX3MgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhdGhzKF9yZWYpIHtcbiAgICAgIHZhciBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHBYID0gX3JlZi5wWCxcbiAgICAgICAgICBwWSA9IF9yZWYucFksXG4gICAgICAgICAgeERpdmlzaW9uID0gX3JlZi54RGl2aXNpb24sXG4gICAgICAgICAgYXJlYUJvdHRvbVkgPSBfcmVmLmFyZWFCb3R0b21ZLFxuICAgICAgICAgIGxpbmVQYXRoID0gX3JlZi5saW5lUGF0aCxcbiAgICAgICAgICBhcmVhUGF0aCA9IF9yZWYuYXJlYVBhdGgsXG4gICAgICAgICAgbGluZVBhdGhzID0gX3JlZi5saW5lUGF0aHMsXG4gICAgICAgICAgYXJlYVBhdGhzID0gX3JlZi5hcmVhUGF0aHMsXG4gICAgICAgICAgc2VyaWVzSW5kZXggPSBfcmVmLnNlcmllc0luZGV4O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGN1cnZlID0gdy5jb25maWcuc3Ryb2tlLmN1cnZlO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2UuY3VydmUpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcmllc0luZGV4KSkge1xuICAgICAgICAgIGN1cnZlID0gdy5jb25maWcuc3Ryb2tlLmN1cnZlW3Nlcmllc0luZGV4W2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJ2ZSA9IHcuY29uZmlnLnN0cm9rZS5jdXJ2ZVtpXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBsb2dpYyBvZiBzbW9vdGggY3VydmUgZGVyaXZlZCBmcm9tIGNoYXJ0aXN0XG4gICAgICAvLyBDUkVESVRTOiBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9cblxuXG4gICAgICBpZiAoY3VydmUgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSAoeCAtIHBYKSAqIDAuMzU7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5oYXNOdWxsVmFsdWVzKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tpXVtqXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNlcmllc1tpXVtqICsgMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHBYLCBwWSkgKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHggKyAxLCB5KTtcbiAgICAgICAgICAgICAgYXJlYVBhdGggPSBncmFwaGljcy5tb3ZlKHBYICsgMSwgcFkpICsgZ3JhcGhpY3MuY3VydmUocFggKyBsZW5ndGgsIHBZLCB4IC0gbGVuZ3RoLCB5LCB4ICsgMSwgeSkgKyBncmFwaGljcy5saW5lKHgsIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLmxpbmUocFgsIGFyZWFCb3R0b21ZKSArICd6JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwWCwgcFkpO1xuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGdyYXBoaWNzLm1vdmUocFgsIHBZKSArICd6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lUGF0aHMucHVzaChsaW5lUGF0aCk7XG4gICAgICAgICAgYXJlYVBhdGhzLnB1c2goYXJlYVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVQYXRoID0gbGluZVBhdGggKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHgsIHkpO1xuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcFggPSB4O1xuICAgICAgICBwWSA9IHk7XG5cbiAgICAgICAgaWYgKGogPT09IHNlcmllc1tpXS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgLy8gbGFzdCBsb29wLCBjbG9zZSBwYXRoXG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmN1cnZlKHBYLCBwWSwgeCwgeSwgeCwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZSh4LCB5KSArICd6JztcblxuICAgICAgICAgIGlmICghdy5nbG9iYWxzLmhhc051bGxWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxpbmVQYXRocy5wdXNoKGxpbmVQYXRoKTtcbiAgICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZXJpZXNbaV1baiArIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLm1vdmUoeCwgeSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmxpbmUoeCAtIHhEaXZpc2lvbiwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZSh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubW92ZSh4LCB5KTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubW92ZSh4LCBhcmVhQm90dG9tWSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VydmUgPT09ICdzdGVwbGluZScpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubGluZSh4LCBudWxsLCAnSCcpICsgZ3JhcGhpY3MubGluZShudWxsLCB5LCAnVicpO1xuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHgsIG51bGwsICdIJykgKyBncmFwaGljcy5saW5lKG51bGwsIHksICdWJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5KTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqID09PSBzZXJpZXNbaV0ubGVuZ3RoIC0gMikge1xuICAgICAgICAgIC8vIGxhc3QgbG9vcCwgY2xvc2UgcGF0aFxuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHgsIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLm1vdmUoeCwgeSkgKyAneic7XG4gICAgICAgICAgbGluZVBhdGhzLnB1c2gobGluZVBhdGgpO1xuICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lUGF0aHM6IGxpbmVQYXRocyxcbiAgICAgICAgYXJlYVBhdGhzOiBhcmVhUGF0aHMsXG4gICAgICAgIHBYOiBwWCxcbiAgICAgICAgcFk6IHBZLFxuICAgICAgICBsaW5lUGF0aDogbGluZVBhdGgsXG4gICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50cyhfcmVmMikge1xuICAgICAgdmFyIHNlcmllcyA9IF9yZWYyLnNlcmllcyxcbiAgICAgICAgICByZWFsSW5kZXggPSBfcmVmMi5yZWFsSW5kZXgsXG4gICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnksXG4gICAgICAgICAgaSA9IF9yZWYyLmksXG4gICAgICAgICAgaiA9IF9yZWYyLmosXG4gICAgICAgICAgcHJldlkgPSBfcmVmMi5wcmV2WSxcbiAgICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0gX3JlZjIuY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbixcbiAgICAgICAgICB4UmF0aW8gPSBfcmVmMi54UmF0aW87XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwdFggPSBbXTtcbiAgICAgIHZhciBwdFkgPSBbXTtcblxuICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgdmFyIHhQVDFzdCA9IGNhdGVnb3J5QXhpc0NvcnJlY3Rpb24gKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFg7IC8vIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZSBzZXJpZXNcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIGl0J3Mgbm90IGEgdGltZSBzZXJpZXMsIGJlY2F1c2UgYSB0aW1lIHNlcmllcyBtYXlcbiAgICAgICAgLy8gc3RhcnQgZnJvbSB0aGUgbWlkZGxlIG9mIHRoZSB4IGF4aXNcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4UFQxc3QgPSAody5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVswXSAtIHcuZ2xvYmFscy5taW5YKSAvIHhSYXRpbyArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgfSAvLyBwdXNoIDIgcG9pbnRzIGZvciB0aGUgZmlyc3QgZGF0YSB2YWx1ZXNcblxuXG4gICAgICAgIHB0WC5wdXNoKHhQVDFzdCk7XG4gICAgICAgIHB0WS5wdXNoKFV0aWxzLmlzTnVtYmVyKHNlcmllc1tpXVswXSkgPyBwcmV2WSArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WSA6IG51bGwpO1xuICAgICAgICBwdFgucHVzaCh4ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYKTtcbiAgICAgICAgcHRZLnB1c2goVXRpbHMuaXNOdW1iZXIoc2VyaWVzW2ldW2ogKyAxXSkgPyB5ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRZIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdFgucHVzaCh4ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYKTtcbiAgICAgICAgcHRZLnB1c2goVXRpbHMuaXNOdW1iZXIoc2VyaWVzW2ldW2ogKyAxXSkgPyB5ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRZIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludHNQb3MgPSB7XG4gICAgICAgIHg6IHB0WCxcbiAgICAgICAgeTogcHRZXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBvaW50c1BvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tQcmV2aW91c1BhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUHJldmlvdXNQYXRocyhfcmVmMykge1xuICAgICAgdmFyIHBhdGhGcm9tTGluZSA9IF9yZWYzLnBhdGhGcm9tTGluZSxcbiAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBfcmVmMy5wYXRoRnJvbUFyZWEsXG4gICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjMucmVhbEluZGV4O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICBpZiAoKGdwcC50eXBlID09PSAnbGluZScgfHwgZ3BwLnR5cGUgPT09ICdhcmVhJykgJiYgZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCkpIHtcbiAgICAgICAgICBpZiAoZ3BwLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRQYXRoRnJvbSA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChncHAudHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFBhdGhGcm9tID0gZmFsc2U7XG4gICAgICAgICAgICBwYXRoRnJvbUFyZWEgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMF0uZDtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnN0cm9rZS5zaG93KSB7XG4gICAgICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1sxXS5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoRnJvbUxpbmU6IHBhdGhGcm9tTGluZSxcbiAgICAgICAgcGF0aEZyb21BcmVhOiBwYXRoRnJvbUFyZWFcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUZpcnN0UHJldllcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRmlyc3RQcmV2WShfcmVmNCkge1xuICAgICAgdmFyIGkgPSBfcmVmNC5pLFxuICAgICAgICAgIHNlcmllcyA9IF9yZWY0LnNlcmllcyxcbiAgICAgICAgICB5UmF0aW8gPSBfcmVmNC55UmF0aW8sXG4gICAgICAgICAgemVyb1kgPSBfcmVmNC56ZXJvWSxcbiAgICAgICAgICBwcmV2WSA9IF9yZWY0LnByZXZZLFxuICAgICAgICAgIHByZXZTZXJpZXNZID0gX3JlZjQucHJldlNlcmllc1ksXG4gICAgICAgICAgbGluZVlQb3NpdGlvbiA9IF9yZWY0LmxpbmVZUG9zaXRpb247XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbaV1bMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAvLyAxc3QgeSB2YWx1ZSBvZiBwcmV2aW91cyBzZXJpZXNcbiAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBwcmV2U2VyaWVzWVtpIC0gMV1bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WSB2YWx1ZXNcbiAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSB6ZXJvWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2WSA9IGxpbmVZUG9zaXRpb24gLSBzZXJpZXNbaV1bMF0gLyB5UmF0aW8gKyAodGhpcy5pc1JldmVyc2VkID8gc2VyaWVzW2ldWzBdIC8geVJhdGlvIDogMCkgKiAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZZID0gemVyb1kgLSBzZXJpZXNbaV1bMF0gLyB5UmF0aW8gKyAodGhpcy5pc1JldmVyc2VkID8gc2VyaWVzW2ldWzBdIC8geVJhdGlvIDogMCkgKiAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzIGlzIG51bGxcbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQgJiYgaSA+IDAgJiYgdHlwZW9mIHNlcmllc1tpXVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBjaGVjayBmb3IgdW5kZWZpbmVkIHZhbHVlICh1bmRlZmluZWQgdmFsdWUgd2lsbCBvY2N1ciB3aGVuIHdlIGNsZWFyIHRoZSBzZXJpZXMgd2hpbGUgdXNlciBjbGlja3Mgb24gbGVnZW5kIHRvIGhpZGUgc2VyaWVzZXMpXG4gICAgICAgICAgZm9yICh2YXIgcyA9IGkgLSAxOyBzID49IDA7IHMtLSkge1xuICAgICAgICAgICAgLy8gZm9yIGxvb3AgdG8gZ2V0IHRvIDFzdCBwcmV2aW91cyB2YWx1ZSB1bnRpbCB3ZSBnZXQgaXRcbiAgICAgICAgICAgIGlmIChzZXJpZXNbc11bMF0gIT09IG51bGwgJiYgdHlwZW9mIHNlcmllc1tzXVswXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHByZXZTZXJpZXNZW3NdWzBdO1xuICAgICAgICAgICAgICBwcmV2WSA9IGxpbmVZUG9zaXRpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgIGxpbmVZUG9zaXRpb246IGxpbmVZUG9zaXRpb25cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmU7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBGb3JtYXR0ZXIgQ2xhc3MgZm9yIHNldHRpbmcgdmFsdWUgZm9ybWF0dGVycyBmb3IgYXhlcyBhcyB3ZWxsIGFzIHRvb2x0aXBzLlxuICpcbiAqIEBtb2R1bGUgRm9ybWF0dGVyc1xuICoqL1xuXG52YXIgRm9ybWF0dGVycyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvcm1hdHRlcnMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdHRlcnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy50b29sdGlwS2V5Rm9ybWF0ID0gJ2RkIE1NTSc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWF0dGVycywgW3tcbiAgICBrZXk6IFwieExhYmVsRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHhMYWJlbEZvcm1hdChmbiwgdmFsKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgLy8gaWYgdXNlciBoYXMgbm90IHNwZWNpZmllZCBhIGN1c3RvbSBmb3JtYXR0ZXIsIHVzZSB0aGUgZGVmYXVsdCB0b29sdGlwLnguZm9ybWF0XG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGF0ZXRpbWVPYmogPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgICAgIHJldHVybiBkYXRldGltZU9iai5mb3JtYXREYXRlKG5ldyBEYXRlKHZhbCksIHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXQsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbih2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMYWJlbEZvcm1hdHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGFiZWxGb3JtYXR0ZXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICB3Lmdsb2JhbHMueGF4aXNUb29sdGlwRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgdy5nbG9iYWxzLnR0S2V5Rm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgdy5nbG9iYWxzLnR0WkZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy5sZWdlbmRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5nbG9iYWxzLnR0S2V5Rm9ybWF0dGVyID0gdy5jb25maWcudG9vbHRpcC54LmZvcm1hdHRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy54YXhpcy50b29sdGlwLmZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3Lmdsb2JhbHMueGF4aXNUb29sdGlwRm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5mb3JtYXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuY29uZmlnLnRvb2x0aXAueSkpIHtcbiAgICAgICAgdy5nbG9iYWxzLnR0VmFsID0gdy5jb25maWcudG9vbHRpcC55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueS5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHcuZ2xvYmFscy50dFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC56LmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy50dFpGb3JtYXR0ZXIgPSB3LmNvbmZpZy50b29sdGlwLnouZm9ybWF0dGVyO1xuICAgICAgfSAvLyBsZWdlbmQgZm9ybWF0dGVyIC0gaWYgdXNlciB3YW50cyB0byBhcHBlbmQgYW55IGdsb2JhbCB2YWx1ZXMgb2Ygc2VyaWVzIHRvIGxlZ2VuZCB0ZXh0XG5cblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMubGVnZW5kRm9ybWF0dGVyID0gdy5jb25maWcubGVnZW5kLmZvcm1hdHRlcjtcbiAgICAgIH0gLy8gZm9ybWF0dGVyIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIG92ZXJ3cml0ZSBmb3JtYXQgcHJvcGVydHlcblxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgLy8gbnVtZXJpYyB4YXhpcyBtYXkgaGF2ZSBzbWFsbGVyIHJhbmdlLCBzbyBkZWZhdWx0aW5nIHRvIDEgZGVjaW1hbFxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyAmJiB3Lmdsb2JhbHMuZGF0YVBvaW50cyA8IDUwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9IC8vIGZvcm1hdHRlciBmdW5jdGlvbiB3aWxsIGFsd2F5cyBvdmVyd3JpdGUgZm9ybWF0IHByb3BlcnR5XG5cblxuICAgICAgdy5jb25maWcueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaSkge1xuICAgICAgICBpZiAoeWF4ZS5sYWJlbHMuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpXSA9IHlheGUubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMueVZhbHVlRGVjaW1hbCAhPT0gMCB8fCB3Lmdsb2JhbHMubWF4WSAtIHcuZ2xvYmFscy5taW5ZIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCh5YXhlLmRlY2ltYWxzSW5GbG9hdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdy5nbG9iYWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWF0bWFwTGFiZWxGb3JtYXR0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlYXRtYXBMYWJlbEZvcm1hdHRlcnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQgPSB3Lmdsb2JhbHMuc2VyaWVzTmFtZXMuc2xpY2UoKTsgLy8gIGdldCB0aGUgbG9uZ2VzdCBzdHJpbmcgZnJvbSB0aGUgbGFiZWxzIGFycmF5IGFuZCBhbHNvIGFwcGx5IGxhYmVsIGZvcm1hdHRlciB0byBpdFxuXG4gICAgICAgIHZhciBsb25nZXN0ID0gdy5nbG9iYWxzLnNlcmllc05hbWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgIH0sIDApO1xuICAgICAgICB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5uaWNlTWF4ID0gbG9uZ2VzdDtcbiAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1pbiA9IGxvbmdlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm1hdHRlcnM7XG59KCk7XG5cbnZhciBBeGVzVXRpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGVzVXRpbHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF4ZXNVdGlscyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfSAvLyBCYXNlZCBvbiB0aGUgZm9ybWF0dGVyIGZ1bmN0aW9uLCBnZXQgdGhlIGxhYmVsIHRleHQgYW5kIHBvc2l0aW9uXG5cblxuICBfY3JlYXRlQ2xhc3MoQXhlc1V0aWxzLCBbe1xuICAgIGtleTogXCJnZXRMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbChsYWJlbHMsIHRpbWVsaW5lTGFiZWxzLCB4LCBpKSB7XG4gICAgICB2YXIgZHJhd25MYWJlbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmF3TGFiZWwgPSB0eXBlb2YgbGFiZWxzW2ldID09PSAndW5kZWZpbmVkJyA/ICcnIDogbGFiZWxzW2ldO1xuICAgICAgdmFyIGxhYmVsO1xuICAgICAgdmFyIHhsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICB2YXIgY3VzdG9tRm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgbGFiZWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHJhd0xhYmVsKTtcblxuICAgICAgaWYgKGN1c3RvbUZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhYmVsID0gY3VzdG9tRm9ybWF0dGVyKHJhd0xhYmVsLCBsYWJlbHNbaV0sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZWxpbmVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB4ID0gdGltZWxpbmVMYWJlbHNbaV0ucG9zaXRpb247XG4gICAgICAgIGxhYmVsID0gdGltZWxpbmVMYWJlbHNbaV0udmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiBjdXN0b21Gb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhYmVsID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3VuZGVmaW5lZCcpIGxhYmVsID0gJyc7XG4gICAgICBsYWJlbCA9IGxhYmVsLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChsYWJlbC5pbmRleE9mKCdOYU4nKSA9PT0gMCB8fCBsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ludmFsaWQnKSA9PT0gMCB8fCBsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2luZmluaXR5JykgPj0gMCB8fCBkcmF3bkxhYmVscy5pbmRleE9mKGxhYmVsKSA+PSAwICYmICF3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvd0R1cGxpY2F0ZXMpIHtcbiAgICAgICAgbGFiZWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgdGV4dDogbGFiZWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZQXhpc1RpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZQXhpc1RpY2tzKHgsIHRpY2tBbW91bnQsIGF4aXNCb3JkZXIsIGF4aXNUaWNrcywgcmVhbEluZGV4LCBsYWJlbHNEaXZpZGVyLCBlbFlheGlzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7IC8vIGluaXRpYWwgbGFiZWwgcG9zaXRpb24gPSAwO1xuXG4gICAgICB2YXIgdCA9IHcuZ2xvYmFscy50cmFuc2xhdGVZO1xuXG4gICAgICBpZiAoYXhpc1RpY2tzLnNob3cpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgPT09IHRydWUpIHggPSB4ICsgYXhpc1RpY2tzLndpZHRoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aWNrQW1vdW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciB0WSA9IHQgKyB0aWNrQW1vdW50IC8gMTAgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5vZmZzZXRZIC0gMTtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0WSA9IGxhYmVsc0RpdmlkZXIgKiBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFRpY2sgPSBncmFwaGljcy5kcmF3TGluZSh4ICsgYXhpc0JvcmRlci5vZmZzZXRYIC0gYXhpc1RpY2tzLndpZHRoICsgYXhpc1RpY2tzLm9mZnNldFgsIHRZICsgYXhpc1RpY2tzLm9mZnNldFksIHggKyBheGlzQm9yZGVyLm9mZnNldFggKyBheGlzVGlja3Mub2Zmc2V0WCwgdFkgKyBheGlzVGlja3Mub2Zmc2V0WSwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgICAgZWxZYXhpcy5hZGQoZWxUaWNrKTtcbiAgICAgICAgICB0ID0gdCArIGxhYmVsc0RpdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXhlc1V0aWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWEF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWC1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWEF4aXNcbiAqKi9cblxudmFyIFhBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMueGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7XG5cbiAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vICB0aW1lbGluZSBsYWJlbHMgYXJlIHRoZXJlXG4gICAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3bkxhYmVscyA9IFtdO1xuXG4gICAgaWYgKHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgdGhpcy5vZmZZID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmZZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyAxO1xuICAgIH1cblxuICAgIHRoaXMub2ZmWSA9IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WTtcbiAgICB0aGlzLnhheGlzRm9udFNpemUgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemU7XG4gICAgdGhpcy54YXhpc0ZvbnRGYW1pbHkgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udEZhbWlseTtcbiAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgdGhpcy54YXhpc0JvcmRlcldpZHRoID0gdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci53aWR0aDtcblxuICAgIGlmICh0aGlzLnhheGlzQm9yZGVyV2lkdGguaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgIHRoaXMueGF4aXNCb3JkZXJXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKiBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpIC8gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnhheGlzQm9yZGVyV2lkdGggPSBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMueGF4aXNCb3JkZXJIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmhlaWdodDsgLy8gRm9yIGJhcnMsIHdlIHdpbGwgb25seSBjb25zaWRlciBzaW5nbGUgeSB4YWlzLFxuICAgIC8vIGFzIHdlIGFyZSBub3QgcHJvdmlkaW5nIG11bHRpcGxlIHlheGlzIGZvciBiYXIgY2hhcnRzXG5cbiAgICB0aGlzLnlheGlzID0gdy5jb25maWcueWF4aXNbMF07XG4gICAgdGhpcy5heGVzVXRpbHMgPSBuZXcgQXhlc1V0aWxzKGN0eCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWEF4aXMsIFt7XG4gICAga2V5OiBcImRyYXdYYXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGVsWGF4aXMuYWRkKGVsWGF4aXNUZXh0cyk7XG4gICAgICB2YXIgY29sV2lkdGg7IC8vIGluaXRpYWwgeCBQb3NpdGlvbiAoa2VlcCBhZGRpbmcgY29sdW1uIHdpZHRoIGluIHRoZSBsb29wKVxuXG4gICAgICB2YXIgeFBvcyA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFiZWxzLnB1c2godGhpcy54YXhpc0xhYmVsc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBjb2xXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAobGFiZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICB4UG9zID0geFBvcyArIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgeFBvcyA9IHhQb3MgKyBjb2xXaWR0aCArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxzTGVuID0gbGFiZWxzLmxlbmd0aDtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5zaG93KSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPD0gbGFiZWxzTGVuIC0gMTsgX2krKykge1xuICAgICAgICAgIHZhciB4ID0geFBvcyAtIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuYXhlc1V0aWxzLmdldExhYmVsKGxhYmVscywgdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLCB4LCBfaSwgdGhpcy5kcmF3bkxhYmVscyk7XG4gICAgICAgICAgdGhpcy5kcmF3bkxhYmVscy5wdXNoKGxhYmVsLnRleHQpO1xuICAgICAgICAgIHZhciBvZmZzZXRZQ29ycmVjdGlvbiA9IDI4O1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzKSB7XG4gICAgICAgICAgICBvZmZzZXRZQ29ycmVjdGlvbiA9IDIyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFRpY2sgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICB4OiBsYWJlbC54LFxuICAgICAgICAgICAgeTogdGhpcy5vZmZZICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFkgKyBvZmZzZXRZQ29ycmVjdGlvbixcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy54YXhpc0ZvbnRTaXplLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy54YXhpc0ZvbnRGYW1pbHksXG4gICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkodGhpcy54YXhpc0ZvcmVDb2xvcnMpID8gdGhpcy54YXhpc0ZvcmVDb2xvcnNbX2ldIDogdGhpcy54YXhpc0ZvcmVDb2xvcnMsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteGF4aXMtbGFiZWwgJyArIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5jc3NDbGFzc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsWGF4aXNUZXh0cy5hZGQoZWxUaWNrKTtcbiAgICAgICAgICBncmFwaGljcy5hZGRUc3BhbihlbFRpY2ssIGxhYmVsLnRleHQsIHRoaXMueGF4aXNGb250RmFtaWx5KTtcbiAgICAgICAgICB2YXIgZWxUb29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAndGl0bGUnKTtcbiAgICAgICAgICBlbFRvb2x0aXBUaXRsZS50ZXh0Q29udGVudCA9IGxhYmVsLnRleHQ7XG4gICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgIHhQb3MgPSB4UG9zICsgY29sV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWxYYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbFhBeGlzVGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyICsgdy5jb25maWcueGF4aXMudGl0bGUub2Zmc2V0WCxcbiAgICAgICAgICB5OiB0aGlzLm9mZlkgLSBwYXJzZUludCh0aGlzLnhheGlzRm9udFNpemUpICsgdy5nbG9iYWxzLnhBeGlzTGFiZWxzSGVpZ2h0ICsgdy5jb25maWcueGF4aXMudGl0bGUub2Zmc2V0WSxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuY29sb3IsXG4gICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBlbFhheGlzVGl0bGUuYWRkKGVsWEF4aXNUaXRsZVRleHQpO1xuICAgICAgICBlbFhheGlzLmFkZChlbFhheGlzVGl0bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuYXhpc0JvcmRlci5zaG93KSB7XG4gICAgICAgIHZhciBsaW5lQ29ycmVjdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgbGluZUNvcnJlY3Rpb24gPSBsaW5lQ29ycmVjdGlvbiAtIDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsSG9yekxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIGxpbmVDb3JyZWN0aW9uICsgdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci5vZmZzZXRYLCB0aGlzLm9mZlksIHRoaXMueGF4aXNCb3JkZXJXaWR0aCwgdGhpcy5vZmZZLCB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmNvbG9yLCAwLCB0aGlzLnhheGlzQm9yZGVySGVpZ2h0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxIb3J6TGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbFhheGlzO1xuICAgIH0gLy8gdGhpcyBhY3R1YWxseSBiZWNvbWVzIHRoZSB2ZXJ0aWNhbCBheGlzIChmb3IgYmFyIGNoYXJ0cylcblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdYYXhpc0ludmVyc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc0ludmVyc2VkKHJlYWxJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHRyYW5zbGF0ZVlBeGlzWCA9IHcuY29uZmlnLnlheGlzWzBdLm9wcG9zaXRlID8gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdIDogMDtcbiAgICAgIHZhciBlbFlheGlzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMgYXBleGNoYXJ0cy14YXhpcy1pbnZlcnNlZCcsXG4gICAgICAgIHJlbDogcmVhbEluZGV4XG4gICAgICB9KTtcbiAgICAgIHZhciBlbFlheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nIGFwZXhjaGFydHMteGF4aXMtaW52ZXJzZWQtdGV4dHMtZycsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWUF4aXNYICsgJywgMCknXG4gICAgICB9KTtcbiAgICAgIGVsWWF4aXMuYWRkKGVsWWF4aXNUZXh0cyk7XG4gICAgICB2YXIgY29sSGVpZ2h0OyAvLyBpbml0aWFsIHggUG9zaXRpb24gKGtlZXAgYWRkaW5nIGNvbHVtbiB3aWR0aCBpbiB0aGUgbG9vcClcblxuICAgICAgdmFyIHlQb3M7XG4gICAgICB2YXIgbGFiZWxzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYWJlbHMucHVzaCh0aGlzLnhheGlzTGFiZWxzW2ldKTtcbiAgICAgIH1cblxuICAgICAgY29sSGVpZ2h0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyBsYWJlbHMubGVuZ3RoO1xuICAgICAgeVBvcyA9IC0oY29sSGVpZ2h0IC8gMi4yKTtcbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgdmFyIHlsYWJlbHMgPSB3LmNvbmZpZy55YXhpc1swXS5sYWJlbHM7XG5cbiAgICAgIGlmICh5bGFiZWxzLnNob3cpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDw9IGxhYmVscy5sZW5ndGggLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBsYWJlbCA9IHR5cGVvZiBsYWJlbHNbX2kyXSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGxhYmVsc1tfaTJdO1xuICAgICAgICAgIGxhYmVsID0gbGJGb3JtYXR0ZXIobGFiZWwpO1xuICAgICAgICAgIHZhciBlbExhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeWxhYmVscy5vZmZzZXRYIC0gMTUsXG4gICAgICAgICAgICB5OiB5UG9zICsgY29sSGVpZ2h0ICsgeWxhYmVscy5vZmZzZXRZLFxuICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0aGlzLnlheGlzLm9wcG9zaXRlID8gJ3N0YXJ0JyA6ICdlbmQnLFxuICAgICAgICAgICAgZm9yZUNvbG9yOiB5bGFiZWxzLnN0eWxlLmNvbG9yID8geWxhYmVscy5zdHlsZS5jb2xvciA6IHlsYWJlbHMuc3R5bGUuY29sb3JzW19pMl0sXG4gICAgICAgICAgICBmb250U2l6ZTogeWxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHlsYWJlbHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy1sYWJlbCAnICsgeWxhYmVscy5zdHlsZS5jc3NDbGFzc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsWWF4aXNUZXh0cy5hZGQoZWxMYWJlbCk7XG4gICAgICAgICAgeVBvcyA9IHlQb3MgKyBjb2xIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWxYYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10aXRsZSBhcGV4Y2hhcnRzLXhheGlzLXRpdGxlLWludmVyc2VkJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVlBeGlzWCArICcsIDApJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVsWEF4aXNUaXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIsXG4gICAgICAgICAgdGV4dDogdy5jb25maWcueWF4aXNbMF0udGl0bGUudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb3JlQ29sb3I6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10aXRsZS10ZXh0ICcgKyB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxYYXhpc1RpdGxlLmFkZChlbFhBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxYYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIuc2hvdykge1xuICAgICAgICB2YXIgZWxIb3J6TGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci5vZmZzZXRYLCB0aGlzLm9mZlksIHRoaXMueGF4aXNCb3JkZXJXaWR0aCwgdGhpcy5vZmZZLCB0aGlzLnlheGlzLmF4aXNCb3JkZXIuY29sb3IsIDAsIHRoaXMueGF4aXNCb3JkZXJIZWlnaHQpO1xuICAgICAgICBlbFlheGlzLmFkZChlbEhvcnpMaW5lKTtcbiAgICAgICAgdGhpcy5heGVzVXRpbHMuZHJhd1lBeGlzVGlja3MoMCwgbGFiZWxzLmxlbmd0aCwgdy5jb25maWcueWF4aXNbMF0uYXhpc0JvcmRlciwgdy5jb25maWcueWF4aXNbMF0uYXhpc1RpY2tzLCAwLCBjb2xIZWlnaHQsIGVsWWF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxZYXhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1hheGlzVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hheGlzVGlja3MoeDEsIGFwcGVuZFRvRWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeDIgPSB4MTtcbiAgICAgIGlmICh4MSA8IDAgfHwgeDEgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSByZXR1cm47XG4gICAgICB2YXIgeTEgPSB0aGlzLm9mZlkgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Mub2Zmc2V0WTtcbiAgICAgIHZhciB5MiA9IHkxICsgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLmhlaWdodDtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBsaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUoeDEgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Mub2Zmc2V0WCwgeTEgKyB3LmNvbmZpZy54YXhpcy5vZmZzZXRZLCB4MiArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5vZmZzZXRYLCB5MiArIHcuY29uZmlnLnhheGlzLm9mZnNldFksIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5jb2xvcik7IC8vIHdlIGFyZSBub3QgcmV0dXJuaW5nIGFueXRoaW5nLCBidXQgYXBwZW5kaW5nIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHBhc2VkIGluIHBhcmFtXG5cbiAgICAgICAgYXBwZW5kVG9FbGVtZW50LmFkZChsaW5lKTtcbiAgICAgICAgbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMteGF4aXMtdGljaycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRYQXhpc1RpY2tzUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFhBeGlzVGlja3NQb3NpdGlvbnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4QXhpc1RpY2tzUG9zaXRpb25zID0gW107XG4gICAgICB2YXIgeENvdW50ID0gdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7XG4gICAgICB2YXIgeDEgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeENvdW50OyBpKyspIHtcbiAgICAgICAgICB4MSA9IHRoaXMueGF4aXNMYWJlbHNbaV0ucG9zaXRpb247XG4gICAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9ucy5wdXNoKHgxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzID0geENvdW50O1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzOyBfaTMrKykge1xuICAgICAgICAgIHZhciB4MUNvdW50ID0geENvdW50Rm9yQ2F0ZWdvcnlDaGFydHM7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2JhcicpIHtcbiAgICAgICAgICAgIHgxQ291bnQgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHgxQ291bnQ7XG4gICAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9ucy5wdXNoKHgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geEF4aXNUaWNrc1Bvc2l0aW9ucztcbiAgICB9IC8vIHRvIHJvdGF0ZSB4LWF4aXMgbGFiZWxzIG9yIHRvIHB1dCAuLi4gZm9yIGxvbmdlciB0ZXh0IGluIHhheGlzXG5cbiAgfSwge1xuICAgIGtleTogXCJ4QXhpc0xhYmVsQ29ycmVjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geEF4aXNMYWJlbENvcnJlY3Rpb25zKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHhBeGlzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZycpO1xuICAgICAgdmFyIHhBeGlzVGV4dHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nIHRleHQnKTtcbiAgICAgIHZhciB5QXhpc1RleHRzSW52ZXJzZWQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpcy1pbnZlcnNlZCB0ZXh0Jyk7XG4gICAgICB2YXIgeEF4aXNUZXh0c0ludmVyc2VkID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteGF4aXMtaW52ZXJzZWQtdGV4dHMtZyB0ZXh0Jyk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucm90YXRlWExhYmVscyB8fCB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlQWx3YXlzKSB7XG4gICAgICAgIGZvciAodmFyIHhhdCA9IDA7IHhhdCA8IHhBeGlzVGV4dHMubGVuZ3RoOyB4YXQrKykge1xuICAgICAgICAgIHZhciB0ZXh0Um90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoeEF4aXNUZXh0c1t4YXRdKTtcbiAgICAgICAgICB0ZXh0Um90YXRpbmdDZW50ZXIueSA9IHRleHRSb3RhdGluZ0NlbnRlci55IC0gMTsgLy8gKyB0aWNrV2lkdGgvNDtcblxuICAgICAgICAgIHRleHRSb3RhdGluZ0NlbnRlci54ID0gdGV4dFJvdGF0aW5nQ2VudGVyLnggKyAxO1xuICAgICAgICAgIHhBeGlzVGV4dHNbeGF0XS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKFwiLmNvbmNhdCh3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlLCBcIiBcIikuY29uY2F0KHRleHRSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KHRleHRSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgIHhBeGlzVGV4dHNbeGF0XS5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgXCJlbmRcIik7XG4gICAgICAgICAgdmFyIG9mZnNldEhlaWdodCA9IDEwO1xuICAgICAgICAgIHhBeGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoMCwgXCIuY29uY2F0KC1vZmZzZXRIZWlnaHQsIFwiKVwiKSk7XG4gICAgICAgICAgdmFyIHRTcGFuID0geEF4aXNUZXh0c1t4YXRdLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnRyaW0pIHtcbiAgICAgICAgICAgIGdyYXBoaWNzLnBsYWNlVGV4dFdpdGhFbGxpcHNpcyh0U3BhblswXSwgdFNwYW5bMF0udGV4dENvbnRlbnQsIHcuY29uZmlnLnhheGlzLmxhYmVscy5tYXhIZWlnaHQgLSA0MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgd2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmxhYmVscy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgX3hhdCA9IDA7IF94YXQgPCB4QXhpc1RleHRzLmxlbmd0aDsgX3hhdCsrKSB7XG4gICAgICAgICAgdmFyIF90U3BhbiA9IHhBeGlzVGV4dHNbX3hhdF0uY2hpbGROb2RlcztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMudHJpbSAmJiB3LmNvbmZpZy54YXhpcy50eXBlICE9PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICBncmFwaGljcy5wbGFjZVRleHRXaXRoRWxsaXBzaXMoX3RTcGFuWzBdLCBfdFNwYW5bMF0udGV4dENvbnRlbnQsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHlBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHRydW5jYXRlIHJvdGF0ZWQgeSBheGlzIGluIGJhciBjaGFydCAoeCBheGlzKVxuICAgICAgICB2YXIgZmlyc3RMYWJlbFBvc1ggPSB5QXhpc1RleHRzSW52ZXJzZWRbeUF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aCAtIDFdLmdldEJCb3goKTtcbiAgICAgICAgdmFyIGxhc3RMYWJlbFBvc1ggPSB5QXhpc1RleHRzSW52ZXJzZWRbMF0uZ2V0QkJveCgpO1xuXG4gICAgICAgIGlmIChmaXJzdExhYmVsUG9zWC54IDwgLTIwKSB7XG4gICAgICAgICAgeUF4aXNUZXh0c0ludmVyc2VkW3lBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGggLSAxXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHlBeGlzVGV4dHNJbnZlcnNlZFt5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RMYWJlbFBvc1gueCArIGxhc3RMYWJlbFBvc1gud2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgeUF4aXNUZXh0c0ludmVyc2VkWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeUF4aXNUZXh0c0ludmVyc2VkWzBdKTtcbiAgICAgICAgfSAvLyB0cnVuY2F0ZSByb3RhdGVkIHggYXhpcyBpbiBiYXIgY2hhcnQgKHkgYXhpcylcblxuXG4gICAgICAgIGZvciAodmFyIF94YXQyID0gMDsgX3hhdDIgPCB4QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoOyBfeGF0MisrKSB7XG4gICAgICAgICAgZ3JhcGhpY3MucGxhY2VUZXh0V2l0aEVsbGlwc2lzKHhBeGlzVGV4dHNJbnZlcnNlZFtfeGF0Ml0sIHhBeGlzVGV4dHNJbnZlcnNlZFtfeGF0Ml0udGV4dENvbnRlbnQsIHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5tYXhXaWR0aCAtIHBhcnNlSW50KHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmZvbnRTaXplKSAqIDIgLSAyMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlbmRlclhBeGlzQmFuZHMoKSB7XG4gICAgLy8gICBsZXQgdyA9IHRoaXMudztcbiAgICAvLyAgIGxldCBwbG90QmFuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICdyZWN0JylcbiAgICAvLyAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHBsb3RCYW5kKVxuICAgIC8vIH1cblxuICB9XSk7XG5cbiAgcmV0dXJuIFhBeGlzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWUF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWS1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWUF4aXNcbiAqKi9cblxudmFyIFlBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWUF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMueGF4aXNGb250U2l6ZSA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZTtcbiAgICB0aGlzLmF4aXNGb250RmFtaWx5ID0gdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgdGhpcy54YXhpc0ZvcmVDb2xvcnMgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY29sb3JzO1xuICAgIHRoaXMueEF4aXNvZmZYID0gMDtcblxuICAgIGlmICh3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMueEF4aXNvZmZYID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3bkxhYmVscyA9IFtdO1xuICAgIHRoaXMuYXhlc1V0aWxzID0gbmV3IEF4ZXNVdGlscyhjdHgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFlBeGlzLCBbe1xuICAgIGtleTogXCJkcmF3WWF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzKHJlYWxJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHlheGlzRm9udFNpemUgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5zdHlsZS5mb250U2l6ZTtcbiAgICAgIHZhciB5YXhpc0ZvbnRGYW1pbHkgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5zdHlsZS5mb250RmFtaWx5O1xuICAgICAgdmFyIGVsWWF4aXMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcycsXG4gICAgICAgIHJlbDogcmVhbEluZGV4LFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbcmVhbEluZGV4XSArICcsIDApJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5zaG93KSB7XG4gICAgICAgIHJldHVybiBlbFlheGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxZYXhpc1RleHRzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGV4dHMtZydcbiAgICAgIH0pO1xuICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RleHRzKTtcbiAgICAgIHZhciB0aWNrQW1vdW50ID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbcmVhbEluZGV4XS5yZXN1bHQubGVuZ3RoIC0gMTsgLy8gbGFiZWxzRGl2aWRlciBpcyBzaW1wbHkgc3ZnIGhlaWdodC9udW1iZXIgb2YgdGlja3NcblxuICAgICAgdmFyIGxhYmVsc0RpdmlkZXIgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQgKyAwLjE7IC8vIGluaXRpYWwgbGFiZWwgcG9zaXRpb24gPSAwO1xuXG4gICAgICB2YXIgbCA9IHcuZ2xvYmFscy50cmFuc2xhdGVZO1xuICAgICAgdmFyIGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbcmVhbEluZGV4XTtcbiAgICAgIHZhciBsYWJlbHMgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdLnJlc3VsdC5zbGljZSgpO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIGxhYmVscy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5zaG93KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aWNrQW1vdW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciB2YWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIodmFsLCBpKTtcbiAgICAgICAgICB2YXIgeFBhZCA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5vcHBvc2l0ZSAmJiB3LmNvbmZpZy55YXhpcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHhQYWQgPSB4UGFkICogLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeFBhZCxcbiAgICAgICAgICAgIHk6IGwgKyB0aWNrQW1vdW50IC8gMTAgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5vZmZzZXRZICsgMSxcbiAgICAgICAgICAgIHRleHQ6IHZhbCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgPyAnc3RhcnQnIDogJ2VuZCcsXG4gICAgICAgICAgICBmb250U2l6ZTogeWF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHlheGlzRm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuc3R5bGUuY29sb3IsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxZYXhpc1RleHRzLmFkZChsYWJlbCk7XG4gICAgICAgICAgdmFyIGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIobGFiZWwubm9kZSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBsYWJlbC5ub2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoXCIuY29uY2F0KHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdChsYWJlbFJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQobGFiZWxSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVsWWF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeCA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsWUF4aXNUaXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUtdGV4dCAnICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIF94ID0gMzEgKyBheGlzQm9yZGVyLm9mZnNldFg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICBfeCA9IC0zMSAtIGF4aXNCb3JkZXIub2Zmc2V0WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKF94LCB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIGF4aXNCb3JkZXIub2Zmc2V0WSAtIDIsIF94LCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIHcuZ2xvYmFscy50cmFuc2xhdGVZICsgYXhpc0JvcmRlci5vZmZzZXRZICsgMiwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWWF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgICAgdGhpcy5heGVzVXRpbHMuZHJhd1lBeGlzVGlja3MoX3gsIHRpY2tBbW91bnQsIGF4aXNCb3JkZXIsIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uYXhpc1RpY2tzLCByZWFsSW5kZXgsIGxhYmVsc0RpdmlkZXIsIGVsWWF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxZYXhpcztcbiAgICB9IC8vIFRoaXMgYWN0dWFsbHkgYmVjb21lcyBob3Jpem9uYWwgYXhpcyAoZm9yIGJhciBjaGFydHMpXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WWF4aXNJbnZlcnNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXNJbnZlcnNlZChyZWFsSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBlbFhheGlzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMgYXBleGNoYXJ0cy15YXhpcy1pbnZlcnNlZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGVsWGF4aXNUZXh0cyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRleHRzLWcnLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh3Lmdsb2JhbHMudHJhbnNsYXRlWEF4aXNYLCBcIiwgXCIpLmNvbmNhdCh3Lmdsb2JhbHMudHJhbnNsYXRlWEF4aXNZLCBcIilcIilcbiAgICAgIH0pO1xuICAgICAgZWxYYXhpcy5hZGQoZWxYYXhpc1RleHRzKTtcbiAgICAgIHZhciB0aWNrQW1vdW50ID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbcmVhbEluZGV4XS5yZXN1bHQubGVuZ3RoIC0gMTsgLy8gbGFiZWxzRGl2aWRlciBpcyBzaW1wbHkgc3ZnIHdpZHRoL251bWJlciBvZiB0aWNrc1xuXG4gICAgICB2YXIgbGFiZWxzRGl2aWRlciA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyB0aWNrQW1vdW50ICsgMC4xOyAvLyBpbml0aWFsIGxhYmVsIHBvc2l0aW9uO1xuXG4gICAgICB2YXIgbCA9IGxhYmVsc0RpdmlkZXIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WDtcbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICB2YXIgbGFiZWxzID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbcmVhbEluZGV4XS5yZXN1bHQuc2xpY2UoKTtcbiAgICAgIHZhciB0aW1lbGluZUxhYmVscyA9IHcuZ2xvYmFscy5pbnZlcnRlZFRpbWVsaW5lTGFiZWxzO1xuXG4gICAgICBpZiAodGltZWxpbmVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnhheGlzTGFiZWxzID0gdGltZWxpbmVMYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgbGFiZWxzID0gdGltZWxpbmVMYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgdGlja0Ftb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgbGFiZWxzLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRsID0gdGltZWxpbmVMYWJlbHMubGVuZ3RoO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnNob3cpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRsID8gMCA6IHRpY2tBbW91bnQ7IHRsID8gaSA8IHRsIC0gMSA6IGkgPj0gMDsgdGwgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgICB2YXIgdmFsID0gbGFiZWxzW2ldO1xuICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgaSk7XG4gICAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnBhZEhvcml6b250YWwgLSAobCAtIGxhYmVsc0RpdmlkZXIgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WCk7XG5cbiAgICAgICAgICBpZiAodGltZWxpbmVMYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmF4ZXNVdGlscy5nZXRMYWJlbChsYWJlbHMsIHRpbWVsaW5lTGFiZWxzLCB4LCBpLCB0aGlzLmRyYXduTGFiZWxzKTtcbiAgICAgICAgICAgIHggPSBsYWJlbC54O1xuICAgICAgICAgICAgdmFsID0gbGFiZWwudGV4dDtcbiAgICAgICAgICAgIHRoaXMuZHJhd25MYWJlbHMucHVzaChsYWJlbC50ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWxUaWNrID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHRoaXMueEF4aXNvZmZYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFkgKyAzMCxcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkodGhpcy54YXhpc0ZvcmVDb2xvcnMpID8gdGhpcy54YXhpc0ZvcmVDb2xvcnNbcmVhbEluZGV4XSA6IHRoaXMueGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMueGF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMueGF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWxhYmVsICcgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFhheGlzVGV4dHMuYWRkKGVsVGljayk7XG4gICAgICAgICAgZWxUaWNrLnRzcGFuKHZhbCk7XG4gICAgICAgICAgdmFyIGVsVG9vbHRpcFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3RpdGxlJyk7XG4gICAgICAgICAgZWxUb29sdGlwVGl0bGUudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbFlheGlzVGl0bGUgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlIGFwZXhjaGFydHMteWF4aXMtdGl0bGUtaW52ZXJzZWQnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxZQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMixcbiAgICAgICAgICB5OiB0aGlzLnhBeGlzb2ZmWCArIHBhcnNlSW50KHRoaXMueGF4aXNGb250U2l6ZSkgKyBwYXJzZUludCh3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSkgKyAyMCxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZS10ZXh0ICcgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIGVsVmVydGljYWxMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyBheGlzQm9yZGVyLm9mZnNldFgsIDEgKyBheGlzQm9yZGVyLm9mZnNldFksIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgYXhpc0JvcmRlci5vZmZzZXRYLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGF4aXNCb3JkZXIub2Zmc2V0WSwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWGF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWGF4aXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInlBeGlzVGl0bGVSb3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geUF4aXNUaXRsZVJvdGF0ZShyZWFsSW5kZXgsIHlBeGlzT3Bwb3NpdGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB5QXhpc0xhYmVsc0Nvb3JkID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIHlBeGlzVGl0bGVDb29yZCA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciBlbFlBeGlzTGFiZWxzV3JhcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIgLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQocmVhbEluZGV4LCBcIiddIC5hcGV4Y2hhcnRzLXlheGlzLXRleHRzLWdcIikpO1xuXG4gICAgICBpZiAoZWxZQXhpc0xhYmVsc1dyYXAgIT09IG51bGwpIHtcbiAgICAgICAgeUF4aXNMYWJlbHNDb29yZCA9IGVsWUF4aXNMYWJlbHNXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeUF4aXNUaXRsZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy15YXhpc1tyZWw9J1wiLmNvbmNhdChyZWFsSW5kZXgsIFwiJ10gLmFwZXhjaGFydHMteWF4aXMtdGl0bGUgdGV4dFwiKSk7XG5cbiAgICAgIGlmICh5QXhpc1RpdGxlICE9PSBudWxsKSB7XG4gICAgICAgIHlBeGlzVGl0bGVDb29yZCA9IHlBeGlzVGl0bGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXhpc1RpdGxlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy54UGFkZGluZ0ZvcllBeGlzVGl0bGUocmVhbEluZGV4LCB5QXhpc0xhYmVsc0Nvb3JkLCB5QXhpc1RpdGxlQ29vcmQsIHlBeGlzT3Bwb3NpdGUpO1xuICAgICAgICB5QXhpc1RpdGxlLnNldEF0dHJpYnV0ZSgneCcsIHgueFBvcyAtICh5QXhpc09wcG9zaXRlID8gMTAgOiAwKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXhpc1RpdGxlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0aXRsZVJvdGF0aW5nQ2VudGVyID0gZ3JhcGhpY3Mucm90YXRlQXJvdW5kQ2VudGVyKHlBeGlzVGl0bGUpO1xuXG4gICAgICAgIGlmICgheUF4aXNPcHBvc2l0ZSkge1xuICAgICAgICAgIHlBeGlzVGl0bGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZSgtXCIuY29uY2F0KHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUucm90YXRlLCBcIiBcIikuY29uY2F0KHRpdGxlUm90YXRpbmdDZW50ZXIueCwgXCIgXCIpLmNvbmNhdCh0aXRsZVJvdGF0aW5nQ2VudGVyLnksIFwiKVwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUF4aXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKFwiLmNvbmNhdCh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdCh0aXRsZVJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInhQYWRkaW5nRm9yWUF4aXNUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4UGFkZGluZ0ZvcllBeGlzVGl0bGUocmVhbEluZGV4LCB5QXhpc0xhYmVsc0Nvb3JkLCB5QXhpc1RpdGxlQ29vcmQsIHlBeGlzT3Bwb3NpdGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG9wcG9zaXRlQXhpc0NvdW50ID0gMDtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciBwYWRkID0gMTA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnRleHQgPT09IHVuZGVmaW5lZCB8fCByZWFsSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeFBvczogeCxcbiAgICAgICAgICBwYWRkOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXhpc09wcG9zaXRlKSB7XG4gICAgICAgIHggPSB5QXhpc0xhYmVsc0Nvb3JkLndpZHRoICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYICsgeUF4aXNUaXRsZUNvb3JkLndpZHRoIC8gMiArIHBhZGQgLyAyO1xuICAgICAgICBvcHBvc2l0ZUF4aXNDb3VudCArPSAxO1xuXG4gICAgICAgIGlmIChvcHBvc2l0ZUF4aXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHggPSB4IC0gcGFkZCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB5QXhpc0xhYmVsc0Nvb3JkLndpZHRoICogLTEgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLm9mZnNldFggKyBwYWRkIC8gMiArIHlBeGlzVGl0bGVDb29yZC53aWR0aCAvIDI7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICBwYWRkID0gMjU7XG4gICAgICAgICAgeCA9IHlBeGlzTGFiZWxzQ29vcmQud2lkdGggKiAtMSAtIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUub2Zmc2V0WCAtIHBhZGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeFBvczogeCxcbiAgICAgICAgcGFkZDogcGFkZFxuICAgICAgfTtcbiAgICB9IC8vIHNldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIHktYXhpcyBieSBjb3VudGluZyB0aGUgbGFiZWxzIHdpZHRoLCB0aXRsZSB3aWR0aCBhbmQgYW55IG9mZnNldFxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WUF4aXNYUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WUF4aXNYUG9zaXRpb24oeWF4aXNMYWJlbENvb3JkcywgeVRpdGxlQ29vcmRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4TGVmdCA9IDA7XG4gICAgICB2YXIgeFJpZ2h0ID0gMDtcbiAgICAgIHZhciBsZWZ0T2Zmc2V0WCA9IDIxO1xuICAgICAgdmFyIHJpZ2h0T2Zmc2V0WCA9IDE7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVZcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNob3VsZE5vdERyYXdBeGlzID0gdy5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xIHx8ICF5YXhlLnNob3cgfHwgeWF4ZS5mbG9hdGluZyB8fCB5YXhpc0xhYmVsQ29vcmRzW2luZGV4XS53aWR0aCA9PT0gMDtcbiAgICAgICAgdmFyIGF4aXNXaWR0aCA9IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoICsgeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aDtcblxuICAgICAgICBpZiAoIXlheGUub3Bwb3NpdGUpIHtcbiAgICAgICAgICB4TGVmdCA9IHcuZ2xvYmFscy50cmFuc2xhdGVYIC0gbGVmdE9mZnNldFg7XG5cbiAgICAgICAgICBpZiAoIXNob3VsZE5vdERyYXdBeGlzKSB7XG4gICAgICAgICAgICBsZWZ0T2Zmc2V0WCA9IGxlZnRPZmZzZXRYICsgYXhpc1dpZHRoICsgMjA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gPSB4TGVmdCArIHlheGUubGFiZWxzLm9mZnNldFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHhSaWdodCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCAtIDE7XG4gICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW2luZGV4XSA9IHhSaWdodCAtIHlheGUubGFiZWxzLm9mZnNldFg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhSaWdodCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCArIHJpZ2h0T2Zmc2V0WDtcblxuICAgICAgICAgICAgaWYgKCFzaG91bGROb3REcmF3QXhpcykge1xuICAgICAgICAgICAgICByaWdodE9mZnNldFggPSByaWdodE9mZnNldFggKyBheGlzV2lkdGggKyAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gPSB4UmlnaHQgLSB5YXhlLmxhYmVscy5vZmZzZXRYICsgMjA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WUF4aXNUZXh0QWxpZ25tZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZQXhpc1RleHRBbGlnbm1lbnRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeWF4aXMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMteWF4aXNcIik7XG4gICAgICB5YXhpcyA9IFV0aWxzLmxpc3RUb0FycmF5KHlheGlzKTtcbiAgICAgIHlheGlzLmZvckVhY2goZnVuY3Rpb24gKHksIGluZGV4KSB7XG4gICAgICAgIHZhciB5YXhlID0gdy5jb25maWcueWF4aXNbaW5kZXhdOyAvLyBwcm9jZWVkIG9ubHkgaWYgdXNlciBoYXMgc3BlY2lmaWVkIGFsaWdubWVudFxuXG4gICAgICAgIGlmICh5YXhlLmxhYmVscy5hbGlnbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHlBeGlzSW5uZXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQoaW5kZXgsIFwiJ10gLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZ1wiKSk7XG4gICAgICAgICAgdmFyIHlBeGlzVGV4dHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQoaW5kZXgsIFwiJ10gLmFwZXhjaGFydHMteWF4aXMtbGFiZWxcIikpO1xuICAgICAgICAgIHlBeGlzVGV4dHMgPSBVdGlscy5saXN0VG9BcnJheSh5QXhpc1RleHRzKTtcbiAgICAgICAgICB2YXIgcmVjdCA9IHlBeGlzSW5uZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAoeWF4ZS5sYWJlbHMuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgeUF4aXNUZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChsYWJlbCwgbEkpIHtcbiAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICgheWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgICAgICB5QXhpc0lubmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoLVwiLmNvbmNhdChyZWN0LndpZHRoLCBcIiwgMClcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoeWF4ZS5sYWJlbHMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5QXhpc1RleHRzLmZvckVhY2goZnVuY3Rpb24gKGxhYmVsLCBsSSkge1xuICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5QXhpc0lubmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHJlY3Qud2lkdGggLyAyICogKCF5YXhlLm9wcG9zaXRlID8gLTEgOiAxKSwgXCIsIDApXCIpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHlheGUubGFiZWxzLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB5QXhpc1RleHRzLmZvckVhY2goZnVuY3Rpb24gKGxhYmVsLCBsSSkge1xuICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgIHlBeGlzSW5uZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZShcIi5jb25jYXQocmVjdC53aWR0aCwgXCIsIDApXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBZQXhpcztcbn0oKTtcblxudmFyIFJhbmdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmFuZ2UoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzI2Njc5L2Nob29zaW5nLWFuLWF0dHJhY3RpdmUtbGluZWFyLXNjYWxlLWZvci1hLWdyYXBocy15LWF4aXNzXG4gIC8vIFRoaXMgcm91dGluZSBjcmVhdGVzIHRoZSBZIGF4aXMgdmFsdWVzIGZvciBhIGdyYXBoLlxuXG5cbiAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbe1xuICAgIGtleTogXCJuaWNlU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmljZVNjYWxlKHlNaW4sIHlNYXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciB0aWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTA7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUgJiYgeU1heCA9PT0gMCB8fCAhVXRpbHMuaXNOdW1iZXIoeU1pbikgJiYgIVV0aWxzLmlzTnVtYmVyKHlNYXgpIHx8IHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUgJiYgeU1heCA9PT0gLU51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgLy8gd2hlbiBhbGwgdmFsdWVzIGFyZSAwXG4gICAgICAgIHlNaW4gPSAwO1xuICAgICAgICB5TWF4ID0gdGlja3M7XG4gICAgICAgIHZhciBsaW5lYXJTY2FsZSA9IHRoaXMubGluZWFyU2NhbGUoeU1pbiwgeU1heCwgdGlja3MpO1xuICAgICAgICByZXR1cm4gbGluZWFyU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh5TWluID4geU1heCkge1xuICAgICAgICAvLyBpZiBzb21laG93IGR1ZSB0byBzb21lIHdyb25nIGNvbmZpZywgdXNlciBzZW50IG1heCBsZXNzIHRoYW4gbWluLFxuICAgICAgICAvLyBhZGp1c3QgdGhlIG1pbi9tYXggYWdhaW5cbiAgICAgICAgY29uc29sZS53YXJuKCd5YXhpcy5taW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB5YXhpcy5tYXgnKTtcbiAgICAgICAgeU1heCA9IHlNaW4gKyAwLjE7XG4gICAgICB9IGVsc2UgaWYgKHlNaW4gPT09IHlNYXgpIHtcbiAgICAgICAgLy8gSWYgeU1pbiBhbmQgeU1heCBhcmUgaWRlbnRpY2FsLCB0aGVuXG4gICAgICAgIC8vIGFkanVzdCB0aGUgeU1pbiBhbmQgeU1heCB2YWx1ZXMgdG8gYWN0dWFsbHlcbiAgICAgICAgLy8gbWFrZSBhIGdyYXBoLiBBbHNvIGF2b2lkcyBkaXZpc2lvbiBieSB6ZXJvIGVycm9ycy5cbiAgICAgICAgeU1pbiA9IHlNaW4gPT09IDAgPyAwIDogeU1pbiAtIDAuNTsgLy8gc29tZSBzbWFsbCB2YWx1ZVxuXG4gICAgICAgIHlNYXggPSB5TWF4ID09PSAwID8gMiA6IHlNYXggKyAwLjU7IC8vIHNvbWUgc21hbGwgdmFsdWVcbiAgICAgIH0gLy8gQ2FsY3VsYXRlIE1pbiBhbWQgTWF4IGdyYXBoaWNhbCBsYWJlbHMgYW5kIGdyYXBoXG4gICAgICAvLyBpbmNyZW1lbnRzLiAgVGhlIG51bWJlciBvZiB0aWNrcyBkZWZhdWx0cyB0b1xuICAgICAgLy8gMTAgd2hpY2ggaXMgdGhlIFNVR0dFU1RFRCB2YWx1ZS4gIEFueSB0aWNrIHZhbHVlXG4gICAgICAvLyBlbnRlcmVkIGlzIHVzZWQgYXMgYSBzdWdnZXN0ZWQgdmFsdWUgd2hpY2ggaXNcbiAgICAgIC8vIGFkanVzdGVkIHRvIGJlIGEgJ3ByZXR0eScgdmFsdWUuXG4gICAgICAvL1xuICAgICAgLy8gT3V0cHV0IHdpbGwgYmUgYW4gYXJyYXkgb2YgdGhlIFkgYXhpcyB2YWx1ZXMgdGhhdFxuICAgICAgLy8gZW5jb21wYXNzIHRoZSBZIHZhbHVlcy5cblxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107IC8vIERldGVybWluZSBSYW5nZVxuXG4gICAgICB2YXIgcmFuZ2UgPSB5TWF4IC0geU1pbjtcblxuICAgICAgaWYgKHJhbmdlIDwgMSAmJiB3LmNvbmZpZy55YXhpc1tpbmRleF0uZm9yY2VOaWNlU2NhbGUgJiYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgdy5jb25maWcuc2VyaWVzW2luZGV4XS50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHcuZ2xvYmFscy5pc1JhbmdlRGF0YSkpIHtcbiAgICAgICAgLyogZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzQzMCAqL1xuICAgICAgICB5TWF4ID0geU1heCAqIDEuMDE7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aWtzID0gdGlja3MgKyAxOyAvLyBBZGp1c3QgdGlja3MgaWYgbmVlZGVkXG5cbiAgICAgIGlmICh0aWtzIDwgMikge1xuICAgICAgICB0aWtzID0gMjtcbiAgICAgIH0gZWxzZSBpZiAodGlrcyA+IDIpIHtcbiAgICAgICAgdGlrcyAtPSAyO1xuICAgICAgfSAvLyBHZXQgcmF3IHN0ZXAgdmFsdWVcblxuXG4gICAgICB2YXIgdGVtcFN0ZXAgPSByYW5nZSAvIHRpa3M7IC8vIENhbGN1bGF0ZSBwcmV0dHkgc3RlcCB2YWx1ZVxuXG4gICAgICB2YXIgbWFnID0gTWF0aC5mbG9vcihVdGlscy5sb2cxMCh0ZW1wU3RlcCkpO1xuICAgICAgdmFyIG1hZ1BvdyA9IE1hdGgucG93KDEwLCBtYWcpO1xuICAgICAgdmFyIG1hZ01zZCA9IHBhcnNlSW50KHRlbXBTdGVwIC8gbWFnUG93KTtcbiAgICAgIHZhciBzdGVwU2l6ZSA9IG1hZ01zZCAqIG1hZ1BvdzsgLy8gYnVpbGQgWSBsYWJlbCBhcnJheS5cbiAgICAgIC8vIExvd2VyIGFuZCB1cHBlciBib3VuZHMgY2FsY3VsYXRpb25zXG5cbiAgICAgIHZhciBsYiA9IHN0ZXBTaXplICogTWF0aC5mbG9vcih5TWluIC8gc3RlcFNpemUpO1xuICAgICAgdmFyIHViID0gc3RlcFNpemUgKiBNYXRoLmNlaWwoeU1heCAvIHN0ZXBTaXplKTsgLy8gQnVpbGQgYXJyYXlcblxuICAgICAgdmFyIHZhbCA9IGxiO1xuXG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICB2YWwgKz0gc3RlcFNpemU7XG5cbiAgICAgICAgaWYgKHZhbCA+IHViKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLm1heCA9PT0gdW5kZWZpbmVkICYmIHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLm1pbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLmZvcmNlTmljZVNjYWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgbmljZU1pbjogcmVzdWx0WzBdLFxuICAgICAgICAgIG5pY2VNYXg6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdiA9IHlNaW47XG4gICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB2YXIgdmFsdWVzRGl2aWRlciA9IE1hdGguYWJzKHlNYXggLSB5TWluKSAvIHRpY2tzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRpY2tzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdiA9IHYgKyB2YWx1ZXNEaXZpZGVyO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgICAgbmljZU1heDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lYXJTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lYXJTY2FsZSh5TWluLCB5TWF4KSB7XG4gICAgICB2YXIgdGlja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwO1xuICAgICAgdmFyIHJhbmdlID0gTWF0aC5hYnMoeU1heCAtIHlNaW4pO1xuICAgICAgdmFyIHN0ZXAgPSByYW5nZSAvIHRpY2tzO1xuXG4gICAgICBpZiAodGlja3MgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgdGlja3MgPSAxMDtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB2ID0geU1pbjtcblxuICAgICAgd2hpbGUgKHRpY2tzID49IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godik7XG4gICAgICAgIHYgPSB2ICsgc3RlcDtcbiAgICAgICAgdGlja3MgLT0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIG5pY2VNaW46IHJlc3VsdFswXSxcbiAgICAgICAgbmljZU1heDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nYXJpdGhtaWNTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dhcml0aG1pY1NjYWxlKGluZGV4LCB5TWluLCB5TWF4LCB0aWNrcykge1xuICAgICAgaWYgKHlNaW4gPCAwIHx8IHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUpIHlNaW4gPSAwLjAxO1xuICAgICAgdmFyIGJhc2UgPSAxMDtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmxvZyh5TWluKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgICAgdmFyIG1heCA9IE1hdGgubG9nKHlNYXgpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgICB2YXIgcmFuZ2UgPSBNYXRoLmFicyh5TWF4IC0geU1pbik7XG4gICAgICB2YXIgc3RlcCA9IHJhbmdlIC8gdGlja3M7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgdiA9IHlNaW47XG5cbiAgICAgIHdoaWxlICh0aWNrcyA+PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB2ID0gdiArIHN0ZXA7XG4gICAgICAgIHRpY2tzIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2dzID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAobmljZU51bWJlciwgaSkge1xuICAgICAgICBpZiAobmljZU51bWJlciA8PSAwKSB7XG4gICAgICAgICAgbmljZU51bWJlciA9IDAuMDE7XG4gICAgICAgIH0gLy8gY2FsY3VsYXRlIGFkanVzdG1lbnQgZmFjdG9yXG5cblxuICAgICAgICB2YXIgc2NhbGUgPSAobWF4IC0gbWluKSAvICh5TWF4IC0geU1pbik7XG4gICAgICAgIHZhciBsb2dWYWwgPSBNYXRoLnBvdyhiYXNlLCBtaW4gKyBzY2FsZSAqIChuaWNlTnVtYmVyIC0gbWluKSk7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGxvZ1ZhbCAvIFV0aWxzLnJvdW5kVG9CYXNlKGxvZ1ZhbCwgYmFzZSkpICogVXRpbHMucm91bmRUb0Jhc2UobG9nVmFsLCBiYXNlKTtcbiAgICAgIH0pOyAvLyBNYXRoLmZsb29yIG1heSBoYXZlIHJvdW5kZWQgdGhlIHZhbHVlIHRvIDAsIHJldmVydCBiYWNrIHRvIDFcblxuICAgICAgaWYgKGxvZ3NbMF0gPT09IDApIGxvZ3NbMF0gPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBsb2dzLFxuICAgICAgICBuaWNlTWluOiBsb2dzWzBdLFxuICAgICAgICBuaWNlTWF4OiBsb2dzW2xvZ3MubGVuZ3RoIC0gMV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlTY2FsZUZvckluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFlTY2FsZUZvckluZGV4KGluZGV4LCBtaW5ZLCBtYXhZKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIHkgPSBnbC5pc0Jhckhvcml6b250YWwgPyBjbmYueGF4aXMgOiBjbmYueWF4aXNbaW5kZXhdO1xuXG4gICAgICBpZiAodHlwZW9mIGdsLnlBeGlzU2NhbGVbaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoeS5sb2dhcml0aG1pYykge1xuICAgICAgICBnbC5hbGxTZXJpZXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLmxvZ2FyaXRobWljU2NhbGUoaW5kZXgsIG1pblksIG1heFksIHkudGlja0Ftb3VudCA/IHkudGlja0Ftb3VudCA6IE1hdGguZmxvb3IoTWF0aC5sb2cxMChtYXhZKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1heFkgPT09IC1OdW1iZXIuTUFYX1ZBTFVFIHx8ICFVdGlscy5pc051bWJlcihtYXhZKSkge1xuICAgICAgICAgIC8vIG5vIGRhdGEgaW4gdGhlIGNoYXJ0LiBFaXRoZXIgYWxsIHNlcmllcyBjb2xsYXBzZWQgb3IgdXNlciBwYXNzZWQgYSBibGFuayBhcnJheVxuICAgICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0gdGhpcy5saW5lYXJTY2FsZSgwLCA1LCA1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVyZSBpcyBzb21lIGRhdGEuIFR1cm4gb2ZmIHRoZSBhbGxTZXJpZXNDb2xsYXBzZWQgZmxhZ1xuICAgICAgICAgIGdsLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCh5Lm1pbiAhPT0gdW5kZWZpbmVkIHx8IHkubWF4ICE9PSB1bmRlZmluZWQpICYmICF5LmZvcmNlTmljZVNjYWxlKSB7XG4gICAgICAgICAgICAvLyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvNDkyXG4gICAgICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IHRoaXMubGluZWFyU2NhbGUobWluWSwgbWF4WSwgeS50aWNrQW1vdW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLm5pY2VTY2FsZShtaW5ZLCBtYXhZLCBpbmRleCwgLy8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzM5N1xuICAgICAgICAgICAgeS50aWNrQW1vdW50ID8geS50aWNrQW1vdW50IDogbWF4WSA8IDUgJiYgbWF4WSA+IDEgPyBtYXhZICsgMSA6IDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdWx0aXBsZVlTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXVsdGlwbGVZU2NhbGVzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBtaW5ZQXJyID0gZ2wubWluWUFyci5jb25jYXQoW10pO1xuICAgICAgdmFyIG1heFlBcnIgPSBnbC5tYXhZQXJyLmNvbmNhdChbXSk7XG4gICAgICB2YXIgc2NhbGVzSW5kaWNlcyA9IFtdOyAvLyBoZXJlLCB3ZSBsb29wIHRocm91Z2ggdGhlIHlheGlzIGFycmF5IGFuZCBmaW5kIHRoZSBpdGVtIHdoaWNoIGhhcyBcInNlcmllc05hbWVcIiBwcm9wZXJ0eVxuXG4gICAgICBjbmYueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgICBjbmYuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgLy8gaWYgc2VyaWVzTmFtZSBtYXRjaGVzIGFuZCB0aGF0IHNlcmllcyBpcyBub3QgY29sbGFwc2VkLCB3ZSB1c2UgdGhhdCBzY2FsZVxuICAgICAgICAgIGlmIChzLm5hbWUgPT09IHlheGUuc2VyaWVzTmFtZSAmJiBnbC5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2Yoc2kpID09PSAtMSkge1xuICAgICAgICAgICAgaW5kZXggPSBzaTtcblxuICAgICAgICAgICAgaWYgKGkgIT09IHNpKSB7XG4gICAgICAgICAgICAgIHNjYWxlc0luZGljZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHNpLFxuICAgICAgICAgICAgICAgIHNpbWlsYXJJbmRleDogaSxcbiAgICAgICAgICAgICAgICBhbHJlYWR5RXhpc3RzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2NhbGVzSW5kaWNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogc2lcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pblkgPSBtaW5ZQXJyW2luZGV4XTtcbiAgICAgICAgdmFyIG1heFkgPSBtYXhZQXJyW2luZGV4XTtcblxuICAgICAgICBfdGhpcy5zZXRZU2NhbGVGb3JJbmRleChpLCBtaW5ZLCBtYXhZKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYW1lU2NhbGVJbk11bHRpcGxlQXhlcyhtaW5ZQXJyLCBtYXhZQXJyLCBzY2FsZXNJbmRpY2VzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2FtZVNjYWxlSW5NdWx0aXBsZUF4ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVNjYWxlSW5NdWx0aXBsZUF4ZXMobWluWUFyciwgbWF4WUFyciwgc2NhbGVzSW5kaWNlcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7IC8vIHdlIGdvdCB0aGUgc2NhbGVzSW5kaWNlcyBhcnJheSBpbiB0aGUgYWJvdmUgY29kZSwgYnV0IHdlIG5lZWQgdG8gZmlsdGVyIG91dCB0aGUgaXRlbXMgd2hpY2ggZG9lc24ndCBoYXZlIHNhbWUgc2NhbGVzXG5cbiAgICAgIHZhciBzaW1pbGFySW5kaWNlcyA9IFtdO1xuICAgICAgc2NhbGVzSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGUuYWxyZWFkeUV4aXN0cykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdLnB1c2goc2NhbGUuaW5kZXgpO1xuICAgICAgICAgIHNpbWlsYXJJbmRpY2VzW3NjYWxlLmluZGV4XS5wdXNoKHNjYWxlLnNpbWlsYXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2ltaWxhckluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2ksIGkpIHtcbiAgICAgICAgc2ltaWxhckluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2osIGopIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdChzaSwgc2opLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2ltaWxhckluZGljZXNbaV0gPSBzaW1pbGFySW5kaWNlc1tpXS5jb25jYXQoc2ltaWxhckluZGljZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gdGhlbiwgd2UgcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgc2ltaWxhclNjYWxlIGFycmF5XG5cbiAgICAgIHZhciB1bmlxdWVTaW1pbGFySW5kaWNlcyA9IHNpbWlsYXJJbmRpY2VzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5maWx0ZXIoZnVuY3Rpb24gKGksIHBvcykge1xuICAgICAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoaSkgPT09IHBvcztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gc29ydCBmdXJ0aGVyIHRvIHJlbW92ZSB3aG9sZSBkdXBsaWNhdGUgYXJyYXlzIGxhdGVyXG5cbiAgICAgIHZhciBzb3J0ZWRJbmRpY2VzID0gdW5pcXVlU2ltaWxhckluZGljZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnNvcnQoKTtcbiAgICAgIH0pOyAvLyByZW1vdmUgdW5kZWZpbmVkIGl0ZW1zXG5cbiAgICAgIHNpbWlsYXJJbmRpY2VzID0gc2ltaWxhckluZGljZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiAhIXM7XG4gICAgICB9KTtcbiAgICAgIHZhciBpbmRpY2VzID0gc29ydGVkSW5kaWNlcy5zbGljZSgpO1xuICAgICAgdmFyIHN0cmluZ0luZGljZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmQpO1xuICAgICAgfSk7XG4gICAgICBpbmRpY2VzID0gaW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGluZCwgcCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nSW5kaWNlcy5pbmRleE9mKEpTT04uc3RyaW5naWZ5KGluZCkpID09PSBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgc2FtZVNjYWxlTWluWUFyciA9IFtdO1xuICAgICAgdmFyIHNhbWVTY2FsZU1heFlBcnIgPSBbXTtcbiAgICAgIG1pbllBcnIuZm9yRWFjaChmdW5jdGlvbiAobWluWVZhbHVlLCB5aSkge1xuICAgICAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlLCBpKSB7XG4gICAgICAgICAgLy8gd2UgY29tcGFyZSBvbmx5IHRoZSB5SW5kZXggd2hpY2ggZXhpc3RzIGluIHRoZSBpbmRpY2VzIGFycmF5XG4gICAgICAgICAgaWYgKHNjYWxlLmluZGV4T2YoeWkpID4gLTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2FtZVNjYWxlTWluWUFycltpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc2FtZVNjYWxlTWluWUFycltpXSA9IFtdO1xuICAgICAgICAgICAgICBzYW1lU2NhbGVNYXhZQXJyW2ldID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNhbWVTY2FsZU1pbllBcnJbaV0ucHVzaCh7XG4gICAgICAgICAgICAgIGtleTogeWksXG4gICAgICAgICAgICAgIHZhbHVlOiBtaW5ZVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2FtZVNjYWxlTWF4WUFycltpXS5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiB5aSxcbiAgICAgICAgICAgICAgdmFsdWU6IG1heFlBcnJbeWldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc2FtZVNjYWxlTWluID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoaW5kaWNlcy5sZW5ndGgpKS5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCBOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgIHZhciBzYW1lU2NhbGVNYXggPSBBcnJheS5hcHBseShudWxsLCBBcnJheShpbmRpY2VzLmxlbmd0aCkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgIHNhbWVTY2FsZU1pbllBcnIuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNjLCBqKSB7XG4gICAgICAgICAgc2FtZVNjYWxlTWluW2ldID0gTWF0aC5taW4oc2MudmFsdWUsIHNhbWVTY2FsZU1pbltpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzYW1lU2NhbGVNYXhZQXJyLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChzYywgaikge1xuICAgICAgICAgIHNhbWVTY2FsZU1heFtpXSA9IE1hdGgubWF4KHNjLnZhbHVlLCBzYW1lU2NhbGVNYXhbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgbWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChtaW4sIGkpIHtcbiAgICAgICAgc2FtZVNjYWxlTWF4WUFyci5mb3JFYWNoKGZ1bmN0aW9uIChzLCBzaSkge1xuICAgICAgICAgIHZhciBtaW5ZID0gc2FtZVNjYWxlTWluW3NpXTtcbiAgICAgICAgICB2YXIgbWF4WSA9IHNhbWVTY2FsZU1heFtzaV07XG4gICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmQsIGspIHtcbiAgICAgICAgICAgIGlmIChzW2tdLmtleSA9PT0gaSkge1xuICAgICAgICAgICAgICBpZiAoY25mLnlheGlzW2ldLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbmYueWF4aXNbaV0ubWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBtaW5ZID0gY25mLnlheGlzW2ldLm1pbihnbC5taW5ZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWluWSA9IGNuZi55YXhpc1tpXS5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNuZi55YXhpc1tpXS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY25mLnlheGlzW2ldLm1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgbWF4WSA9IGNuZi55YXhpc1tpXS5tYXgoZ2wubWF4WSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1heFkgPSBjbmYueWF4aXNbaV0ubWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRZU2NhbGVGb3JJbmRleChpLCBtaW5ZLCBtYXhZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXV0b1NjYWxlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvU2NhbGVZKGN0eCwgZSkge1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY3R4ID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgY3R4LncuY29uZmlnLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZSkge1xuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIHZhciBmaXJzdCA9IHNlcmllLmRhdGEuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4WzBdID49IGUueGF4aXMubWluO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBmaXJzdFsxXTtcbiAgICAgICAgbWF4ID0gbWluID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgc2VyaWUuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGFbMF0gPD0gZS54YXhpcy5tYXggJiYgZGF0YVswXSA+PSBlLnhheGlzLm1pbikge1xuICAgICAgICAgICAgaWYgKGRhdGFbMV0gPiBtYXggJiYgZGF0YVsxXSAhPT0gbnVsbCkgbWF4ID0gZGF0YVsxXTtcbiAgICAgICAgICAgIGlmIChkYXRhWzFdIDwgbWluICYmIGRhdGFbMV0gIT09IG51bGwpIG1pbiA9IGRhdGFbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWluICo9IDAuOTU7XG4gICAgICAgIG1heCAqPSAxLjA1O1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhbmdlO1xufSgpO1xuXG4vKipcbiAqIFJhbmdlIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICpcbiAqIEBtb2R1bGUgUmFuZ2VcbiAqKi9cblxudmFyIFJhbmdlJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSYW5nZSQkMShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UkJDEpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgUmFuZ2UoY3R4KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYW5nZSQkMSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXRZUmFuZ2UoKTtcbiAgICAgIHRoaXMuc2V0WFJhbmdlKCk7XG4gICAgICB0aGlzLnNldFpSYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaW5ZTWF4WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW5ZTWF4WShzdGFydGluZ0luZGV4KSB7XG4gICAgICB2YXIgbG93ZXN0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBoaWdoZXN0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gICAgICBpZiAobGVuID09PSBudWxsKSB7XG4gICAgICAgIGxlbiA9IHN0YXJ0aW5nSW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzID0gZ2wuc2VyaWVzO1xuICAgICAgdmFyIHNlcmllc01pbiA9IHNlcmllcztcbiAgICAgIHZhciBzZXJpZXNNYXggPSBzZXJpZXM7XG5cbiAgICAgIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgc2VyaWVzTWluID0gZ2wuc2VyaWVzQ2FuZGxlTDtcbiAgICAgICAgc2VyaWVzTWF4ID0gZ2wuc2VyaWVzQ2FuZGxlSDtcbiAgICAgIH0gZWxzZSBpZiAoZ2wuaXNSYW5nZURhdGEpIHtcbiAgICAgICAgc2VyaWVzTWluID0gZ2wuc2VyaWVzUmFuZ2VTdGFydDtcbiAgICAgICAgc2VyaWVzTWF4ID0gZ2wuc2VyaWVzUmFuZ2VFbmQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydGluZ0luZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2wuZGF0YVBvaW50cyA9IE1hdGgubWF4KGdsLmRhdGFQb2ludHMsIHNlcmllc1tpXS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tpXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihzZXJpZXNbaV1bal0pKSB7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgc2VyaWVzTWF4W2ldW2pdKTtcbiAgICAgICAgICAgIGxvd2VzdFkgPSBNYXRoLm1pbihsb3dlc3RZLCBzZXJpZXNNaW5baV1bal0pO1xuICAgICAgICAgICAgaGlnaGVzdFkgPSBNYXRoLm1heChoaWdoZXN0WSwgc2VyaWVzTWluW2ldW2pdKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZ2wuc2VyaWVzQ2FuZGxlT1tpXVtqXSk7XG4gICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBnbC5zZXJpZXNDYW5kbGVIW2ldW2pdKTtcbiAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIGdsLnNlcmllc0NhbmRsZUxbaV1bal0pO1xuICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZ2wuc2VyaWVzQ2FuZGxlQ1tpXVtqXSk7XG4gICAgICAgICAgICAgIGhpZ2hlc3RZID0gbWF4WTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzRmxvYXQoc2VyaWVzW2ldW2pdKSkge1xuICAgICAgICAgICAgICBnbC55VmFsdWVEZWNpbWFsID0gTWF0aC5tYXgoZ2wueVZhbHVlRGVjaW1hbCwgc2VyaWVzW2ldW2pdLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWluWSA+IHNlcmllc01pbltpXVtqXSAmJiBzZXJpZXNNaW5baV1bal0gPCAwKSB7XG4gICAgICAgICAgICAgIG1pblkgPSBzZXJpZXNNaW5baV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmhhc051bGxWYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZLFxuICAgICAgICBsb3dlc3RZOiBsb3dlc3RZLFxuICAgICAgICBoaWdoZXN0WTogaGlnaGVzdFlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZUmFuZ2UoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgZ2wubWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICB2YXIgbG93ZXN0WUluQWxsU2VyaWVzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGdldCBtaW5ZIGFuZCBtYXhZIGZvciBtdWx0aXBsZSB5IGF4aXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWluWU1heFlBcnIgPSB0aGlzLmdldE1pbllNYXhZKGksIGxvd2VzdFlJbkFsbFNlcmllcywgbnVsbCwgaSArIDEpO1xuICAgICAgICAgIGdsLm1pbllBcnIucHVzaChtaW5ZTWF4WUFyci5taW5ZKTtcbiAgICAgICAgICBnbC5tYXhZQXJyLnB1c2gobWluWU1heFlBcnIubWF4WSk7XG4gICAgICAgICAgbG93ZXN0WUluQWxsU2VyaWVzID0gbWluWU1heFlBcnIubG93ZXN0WTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbmQgdGhlbiwgZ2V0IHRoZSBtaW5ZIGFuZCBtYXhZIGZyb20gYWxsIHNlcmllc1xuXG5cbiAgICAgIHZhciBtaW5ZTWF4WSA9IHRoaXMuZ2V0TWluWU1heFkoMCwgbG93ZXN0WUluQWxsU2VyaWVzLCBudWxsLCBnbC5zZXJpZXMubGVuZ3RoKTtcbiAgICAgIGdsLm1pblkgPSBtaW5ZTWF4WS5taW5ZO1xuICAgICAgZ2wubWF4WSA9IG1pbllNYXhZLm1heFk7XG4gICAgICBsb3dlc3RZSW5BbGxTZXJpZXMgPSBtaW5ZTWF4WS5sb3dlc3RZO1xuXG4gICAgICBpZiAoY25mLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgLy8gZm9yIHN0YWNrZWQgY2hhcnRzLCB3ZSBjYWxjdWxhdGUgZWFjaCBzZXJpZXMncyBwYXJhbGxlbCB2YWx1ZXMuIGkuZSwgc2VyaWVzWzBdW2pdICsgc2VyaWVzWzFdW2pdIC4uLi4gW3Nlcmllc1tpLmxlbmd0aF1bal1dIGFuZCBnZXQgdGhlIG1heCBvdXQgb2YgaXRcbiAgICAgICAgdmFyIHN0YWNrZWRQb3NzID0gW107XG4gICAgICAgIHZhciBzdGFja2VkTmVncyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHBvc3MgPSAwO1xuICAgICAgICAgIHZhciBuZWdzID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBnbC5zZXJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAoZ2wuc2VyaWVzW19pXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihnbC5zZXJpZXNbX2ldW2pdKSkge1xuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzW19pXVtqXSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyAwLjAwMDEgZml4ZXMgIzE4NSB3aGVuIHZhbHVlcyBhcmUgdmVyeSBzbWFsbFxuICAgICAgICAgICAgICAgIHBvc3MgPSBwb3NzICsgcGFyc2VGbG9hdChnbC5zZXJpZXNbX2ldW2pdKSArIDAuMDAwMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWdzID0gbmVncyArIHBhcnNlRmxvYXQoZ2wuc2VyaWVzW19pXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9pID09PSBnbC5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAvLyBwdXNoIGFsbCB0aGUgdG90YWxzIHRvIHRoZSBhcnJheSBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgICBzdGFja2VkUG9zcy5wdXNoKHBvc3MpO1xuICAgICAgICAgICAgICBzdGFja2VkTmVncy5wdXNoKG5lZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZXQgdGhlIG1heC9taW4gb3V0IG9mIHRoZSBhZGRlZCBwYXJhbGxlbCB2YWx1ZXNcblxuXG4gICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3RhY2tlZFBvc3MubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICBnbC5tYXhZID0gTWF0aC5tYXgoZ2wubWF4WSwgc3RhY2tlZFBvc3Nbel0pO1xuICAgICAgICAgIGdsLm1pblkgPSBNYXRoLm1pbihnbC5taW5ZLCBzdGFja2VkTmVnc1t6XSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgdGhlIG51bWJlcnMgYXJlIHRvbyBiaWcsIHJlZHVjZSB0aGUgcmFuZ2VcbiAgICAgIC8vIGZvciBlZywgaWYgbnVtYmVyIGlzIGJldHdlZW4gMTAwMDAwLTExMDAwMCwgcHV0dGluZyAwIGFzIHRoZSBsb3dlc3QgdmFsdWUgaXMgbm90IHNvIGdvb2QgaWRlYS4gU28gY2hhbmdlIHRoZSBnbC5taW5ZIGZvciBsaW5lL2FyZWEvY2FuZGxlc3RpY2tzXG5cblxuICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnbGluZScgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdhcmVhJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICBpZiAoZ2wubWluWSA9PT0gTnVtYmVyLk1JTl9WQUxVRSAmJiBsb3dlc3RZSW5BbGxTZXJpZXMgIT09IC1OdW1iZXIuTUFYX1ZBTFVFICYmIGxvd2VzdFlJbkFsbFNlcmllcyAhPT0gZ2wubWF4WSAvLyBzaW5nbGUgdmFsdWUgcG9zc2liaWxpdHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGdsLm1heFkgLSBsb3dlc3RZSW5BbGxTZXJpZXM7XG5cbiAgICAgICAgICAgIGlmIChsb3dlc3RZSW5BbGxTZXJpZXMgPj0gMCAmJiBsb3dlc3RZSW5BbGxTZXJpZXMgPD0gMTApIHtcbiAgICAgICAgICAgICAgLy8gaWYgbWluWSBpcyBhbHJlYWR5IDAvbG93IHZhbHVlLCB3ZSBkb24ndCB3YW50IHRvIGdvIG5lZ2F0aXZlcyBoZXJlIC0gc28gdGhpcyBjaGVjayBpcyBlc3NlbnRpYWwuXG4gICAgICAgICAgICAgIGRpZmYgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5taW5ZID0gbG93ZXN0WUluQWxsU2VyaWVzIC0gZGlmZiAqIDUgLyAxMDA7XG4gICAgICAgICAgICAvKiBmaXggaHR0cHM6Ly9naXRodWIuY29tL2FwZXhjaGFydHMvYXBleGNoYXJ0cy5qcy9pc3N1ZXMvNDI2ICovXG5cbiAgICAgICAgICAgIGdsLm1heFkgPSBnbC5tYXhZICsgZGlmZiAqIDUgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAvLyBvdmVycmlkZSBhbGwgbWluL21heCB2YWx1ZXMgYnkgdXNlciBkZWZpbmVkIHZhbHVlcyAoeSBheGlzKVxuICAgICAgICBpZiAoeWF4ZS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgeWF4ZS5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBnbC5tYXhZQXJyW2luZGV4XSA9IHlheGUubWF4O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHlheGUubWF4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBnbC5tYXhZQXJyW2luZGV4XSA9IHlheGUubWF4KGdsLm1heFkpO1xuICAgICAgICAgIH0gLy8gZ2wubWF4WSBpcyBmb3Igc2luZ2xlIHktYXhpcyBjaGFydCwgaXQgd2lsbCBiZSBpZ25vcmVkIGluIG11bHRpLXlheGlzXG5cblxuICAgICAgICAgIGdsLm1heFkgPSBnbC5tYXhZQXJyW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5YXhlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5YXhlLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGdsLm1pbllBcnJbaW5kZXhdID0geWF4ZS5taW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeWF4ZS5taW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGdsLm1pbllBcnJbaW5kZXhdID0geWF4ZS5taW4oZ2wubWluWSk7XG4gICAgICAgICAgfSAvLyBnbC5taW5ZIGlzIGZvciBzaW5nbGUgeS1heGlzIGNoYXJ0LCBpdCB3aWxsIGJlIGlnbm9yZWQgaW4gbXVsdGkteWF4aXNcblxuXG4gICAgICAgICAgZ2wubWluWSA9IGdsLm1pbllBcnJbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gZm9yIGhvcml6b250YWwgYmFyIGNoYXJ0cywgd2UgbmVlZCB0byBjaGVjayB4YXhpcyBtaW4vbWF4IGFzIHVzZXIgbWF5IGhhdmUgc3BlY2lmaWVkIHRoZXJlXG5cbiAgICAgIGlmIChnbC5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGNuZi54YXhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBnbC5taW5ZID0gY25mLnhheGlzLm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbmYueGF4aXMubWF4ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNuZi54YXhpcy5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZ2wubWF4WSA9IGNuZi54YXhpcy5tYXg7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG11bHRpIHktYXhpcyB3ZSBuZWVkIGRpZmZlcmVudCBzY2FsZXMgZm9yIGVhY2hcblxuXG4gICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgIHRoaXMuc2NhbGVzLnNldE11bHRpcGxlWVNjYWxlcygpO1xuICAgICAgICBnbC5taW5ZID0gbG93ZXN0WUluQWxsU2VyaWVzO1xuICAgICAgICBnbC55QXhpc1NjYWxlLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlLCBpKSB7XG4gICAgICAgICAgZ2wubWluWUFycltpXSA9IHNjYWxlLm5pY2VNaW47XG4gICAgICAgICAgZ2wubWF4WUFycltpXSA9IHNjYWxlLm5pY2VNYXg7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY2FsZXMuc2V0WVNjYWxlRm9ySW5kZXgoMCwgZ2wubWluWSwgZ2wubWF4WSk7XG4gICAgICAgIGdsLm1pblkgPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNaW47XG4gICAgICAgIGdsLm1heFkgPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNYXg7XG4gICAgICAgIGdsLm1pbllBcnJbMF0gPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNaW47XG4gICAgICAgIGdsLm1heFlBcnJbMF0gPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblk6IGdsLm1pblksXG4gICAgICAgIG1heFk6IGdsLm1heFksXG4gICAgICAgIG1pbllBcnI6IGdsLm1pbllBcnIsXG4gICAgICAgIG1heFlBcnI6IGdsLm1heFlBcnJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRYUmFuZ2UoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGlzWE51bWVyaWMgPSBjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnIHx8IGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnIHx8IGNuZi54YXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmICFnbC5ub0xhYmVsc1Byb3ZpZGVkIHx8IGdsLm5vTGFiZWxzUHJvdmlkZWQ7IC8vIG1pblggbWF4WCBzdGFydHMgaGVyZVxuXG4gICAgICBpZiAoZ2wuaXNYTnVtZXJpYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChnbC5sYWJlbHNbaV0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wubGFiZWxzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChnbC5sYWJlbHNbaV1bal0gIT09IG51bGwgJiYgVXRpbHMuaXNOdW1iZXIoZ2wubGFiZWxzW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgIGdsLm1heFggPSBNYXRoLm1heChnbC5tYXhYLCBnbC5sYWJlbHNbaV1bal0pO1xuICAgICAgICAgICAgICAgIGdsLmluaXRpYWxtYXhYID0gTWF0aC5tYXgoZ2wubWF4WCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5taW5YID0gTWF0aC5taW4oZ2wubWluWCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5pbml0aWFsbWluWCA9IE1hdGgubWluKGdsLm1pblgsIGdsLmxhYmVsc1tpXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdsLm5vTGFiZWxzUHJvdmlkZWQpIHtcbiAgICAgICAgaWYgKGNuZi54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGdsLm1heFggPSBnbC5sYWJlbHNbZ2wubGFiZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGdsLmluaXRpYWxtYXhYID0gZ2wubGFiZWxzW2dsLmxhYmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBnbC5taW5YID0gMTtcbiAgICAgICAgICBnbC5pbml0aWFsbWluWCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG51bWVyaWMgeGF4aXMsIHdlIG5lZWQgdG8gYWRqdXN0IHNvbWUgcGFkZGluZyBsZWZ0IGFuZCByaWdodCBmb3IgYmFyIGNoYXJ0c1xuXG5cbiAgICAgIGlmIChnbC5jb21ib0NoYXJ0c0hhc0JhcnMgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNuZi54YXhpcy50eXBlICE9PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgIGlmIChjbmYueGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIHZhciBtaW5YID0gZ2wubWluWCAtIGdsLnN2Z1dpZHRoIC8gZ2wuZGF0YVBvaW50cyAqIChNYXRoLmFicyhnbC5tYXhYIC0gZ2wubWluWCkgLyBnbC5zdmdXaWR0aCkgLyAyO1xuICAgICAgICAgIGdsLm1pblggPSBtaW5YO1xuICAgICAgICAgIGdsLmluaXRpYWxtaW5YID0gbWluWDtcbiAgICAgICAgICB2YXIgbWF4WCA9IGdsLm1heFggKyBnbC5zdmdXaWR0aCAvIGdsLmRhdGFQb2ludHMgKiAoTWF0aC5hYnMoZ2wubWF4WCAtIGdsLm1pblgpIC8gZ2wuc3ZnV2lkdGgpIC8gMjtcbiAgICAgICAgICBnbC5tYXhYID0gbWF4WDtcbiAgICAgICAgICBnbC5pbml0aWFsbWF4WCA9IG1heFg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChnbC5pc1hOdW1lcmljIHx8IGdsLm5vTGFiZWxzUHJvdmlkZWQpICYmICghY25mLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYyB8fCBnbC5kYXRhRm9ybWF0WE51bWVyaWMpKSB7XG4gICAgICAgIHZhciB0aWNrcztcblxuICAgICAgICBpZiAoY25mLnhheGlzLnRpY2tBbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpY2tzID0gTWF0aC5yb3VuZChnbC5zdmdXaWR0aCAvIDE1MCk7IC8vIG5vIGxhYmVscyBwcm92aWRlZCBhbmQgdG90YWwgbnVtYmVyIG9mIGRhdGFQb2ludHMgaXMgbGVzcyB0aGFuIDIwXG5cbiAgICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyAmJiBnbC5kYXRhUG9pbnRzIDwgMjApIHtcbiAgICAgICAgICAgIHRpY2tzID0gZ2wuZGF0YVBvaW50cyAtIDE7XG4gICAgICAgICAgfSAvLyB0aGlzIGNoZWNrIGlzIGZvciB3aGVuIHRpY2tzIGV4Y2VlZHMgdG90YWwgZGF0YXBvaW50cyBhbmQgdGhhdCB3b3VsZCByZXN1bHQgaW4gZHVwbGljYXRlIGxhYmVsc1xuXG5cbiAgICAgICAgICBpZiAodGlja3MgPiBnbC5kYXRhUG9pbnRzICYmIGdsLmRhdGFQb2ludHMgIT09IDApIHtcbiAgICAgICAgICAgIHRpY2tzID0gZ2wuZGF0YVBvaW50cyAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNuZi54YXhpcy50aWNrQW1vdW50ID09PSAnZGF0YVBvaW50cycpIHtcbiAgICAgICAgICB0aWNrcyA9IGdsLnNlcmllc1tnbC5tYXhWYWxzSW5BcnJheUluZGV4XS5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tzID0gY25mLnhheGlzLnRpY2tBbW91bnQ7XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgYWxsIG1pbi9tYXggdmFsdWVzIGJ5IHVzZXIgZGVmaW5lZCB2YWx1ZXMgKHggYXhpcylcblxuXG4gICAgICAgIGlmIChjbmYueGF4aXMubWF4ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNuZi54YXhpcy5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZ2wubWF4WCA9IGNuZi54YXhpcy5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjbmYueGF4aXMubWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGdsLm1pblggPSBjbmYueGF4aXMubWluO1xuICAgICAgICB9IC8vIGlmIHJhbmdlIGlzIHByb3ZpZGVkLCBhZGp1c3QgdGhlIG5ldyBtaW5YXG5cblxuICAgICAgICBpZiAoY25mLnhheGlzLnJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBnbC5taW5YID0gZ2wubWF4WCAtIGNuZi54YXhpcy5yYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbC5taW5YICE9PSBOdW1iZXIuTUFYX1ZBTFVFICYmIGdsLm1heFggIT09IC1OdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgZ2wueEF4aXNTY2FsZSA9IHRoaXMuc2NhbGVzLmxpbmVhclNjYWxlKGdsLm1pblgsIGdsLm1heFgsIHRpY2tzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC54QXhpc1NjYWxlID0gdGhpcy5zY2FsZXMubGluZWFyU2NhbGUoMSwgdGlja3MsIHRpY2tzKTtcblxuICAgICAgICAgIGlmIChnbC5ub0xhYmVsc1Byb3ZpZGVkICYmIGdsLmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnbC54QXhpc1NjYWxlID0gdGhpcy5zY2FsZXMubGluZWFyU2NhbGUoMSwgZ2wubGFiZWxzLmxlbmd0aCwgdGlja3MgLSAxKTsgLy8gdGhpcyBpcyB0aGUgb25seSBwbGFjZSBzZXJpZXNYIGlzIGFnYWluIG11dGF0ZWRcblxuICAgICAgICAgICAgZ2wuc2VyaWVzWCA9IGdsLmxhYmVscy5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB3ZSB3aWxsIHN0aWxsIHN0b3JlIHRoZXNlIGxhYmVscyBhcyB0aGUgY291bnQgZm9yIHRoaXMgd2lsbCBiZSBkaWZmZXJlbnQgKHRvIGRyYXcgZ3JpZCBhbmQgbGFiZWxzIHBsYWNlbWVudClcblxuXG4gICAgICAgIGlmIChpc1hOdW1lcmljKSB7XG4gICAgICAgICAgZ2wubGFiZWxzID0gZ2wueEF4aXNTY2FsZS5yZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ2wubWluWCA9PT0gZ2wubWF4WCkge1xuICAgICAgICAvLyBzaW5nbGUgZGF0YVBvaW50XG4gICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHZhciBuZXdNaW5YID0gbmV3IERhdGUoZ2wubWluWCk7XG4gICAgICAgICAgbmV3TWluWC5zZXREYXRlKG5ld01pblguZ2V0RGF0ZSgpIC0gMik7XG4gICAgICAgICAgZ2wubWluWCA9IG5ldyBEYXRlKG5ld01pblgpLmdldFRpbWUoKTtcbiAgICAgICAgICB2YXIgbmV3TWF4WCA9IG5ldyBEYXRlKGdsLm1heFgpO1xuICAgICAgICAgIG5ld01heFguc2V0RGF0ZShuZXdNYXhYLmdldERhdGUoKSArIDIpO1xuICAgICAgICAgIGdsLm1heFggPSBuZXcgRGF0ZShuZXdNYXhYKS5nZXRUaW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhZ2wubm9MYWJlbHNQcm92aWRlZCkge1xuICAgICAgICAgIGdsLm1pblggPSBnbC5taW5YIC0gMjtcbiAgICAgICAgICBnbC5tYXhYID0gZ2wubWF4WCArIDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdsLmlzWE51bWVyaWMpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBsZWFzdCB4IGRpZmYgaWYgbnVtZXJpYyB4IGF4aXMgaXMgcHJlc2VudFxuICAgICAgICBnbC5zZXJpZXNYLmZvckVhY2goZnVuY3Rpb24gKHNYLCBpKSB7XG4gICAgICAgICAgc1guZm9yRWFjaChmdW5jdGlvbiAocywgaikge1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB4RGlmZiA9IHMgLSBnbC5zZXJpZXNYW2ldW2ogLSAxXTtcbiAgICAgICAgICAgICAgZ2wubWluWERpZmYgPSBNYXRoLm1pbih4RGlmZiwgZ2wubWluWERpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxjTWluWERpZmZGb3JUaW55U2VyaWVzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IGdsLm1pblgsXG4gICAgICAgIG1heFg6IGdsLm1heFhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNNaW5YRGlmZkZvclRpbnlTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY01pblhEaWZmRm9yVGlueVNlcmllcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmxhYmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdy5nbG9iYWxzLm1pblhEaWZmID0gKHcuZ2xvYmFscy5tYXhYIC0gdy5nbG9iYWxzLm1pblgpIC8gbGVuIC8gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMubWluWERpZmYgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAvLyBwb3NzaWJseSBhIHNpbmdsZSBkYXRhUG9pbnQgKGZpeGVzIHJlYWN0LWFwZXhjaGFydHMvaXNzdWUjMzQpXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZW4gPSB3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW4gPCAzKSB7XG4gICAgICAgICAgICBsZW4gPSAzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5taW5YRGlmZiA9ICh3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5taW5YKSAvIGxlbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdy5nbG9iYWxzLm1pblhEaWZmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRaUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WlJhbmdlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7IC8vIG1pblosIG1heFogc3RhcnRzIGhlcmVcblxuICAgICAgaWYgKGdsLmlzRGF0YVhZWikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZ2wuc2VyaWVzWltpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzWltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzWltpXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihnbC5zZXJpZXNaW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgIGdsLm1heFogPSBNYXRoLm1heChnbC5tYXhaLCBnbC5zZXJpZXNaW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5taW5aID0gTWF0aC5taW4oZ2wubWluWiwgZ2wuc2VyaWVzWltpXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2UkJDE7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBTZXJpZXMgQ2xhc3MgZm9yIGludGVyYXRpb24gd2l0aCB0aGUgU2VyaWVzIG9mIHRoZSBjaGFydC5cbiAqXG4gKiBAbW9kdWxlIFNlcmllc1xuICoqL1xuXG52YXIgU2VyaWVzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VyaWVzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJpZXMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VyaWVzLCBbe1xuICAgIGtleTogXCJnZXRBbGxTZXJpZXNFbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsU2VyaWVzRWxzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VyaWVzQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc0J5TmFtZShzZXJpZXNOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzLlwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcoc2VyaWVzTmFtZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29sbGFwc2VkQ2xhc3NUb1Nlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCBpbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGZvciAodmFyIGNzID0gMDsgY3MgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgY3MrKykge1xuICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc1tjc10uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgZWxTZXJpZXMubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVTZXJpZXNPbkhvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNlcmllc09uSG92ZXIoZSwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWxsU2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1wiKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgdmFyIHNlcmllc0NudCA9IHBhcnNlSW50KHRhcmdldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxO1xuICAgICAgICB2YXIgc2VyaWVzRWwgPSBudWxsO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0NudCwgXCInXVwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nXCIuY29uY2F0KHNlcmllc0NudCArIDEsIFwiJ10gcGF0aFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBzZSA9IDA7IHNlIDwgYWxsU2VyaWVzRWxzLmxlbmd0aDsgc2UrKykge1xuICAgICAgICAgIGFsbFNlcmllc0Vsc1tzZV0uY2xhc3NMaXN0LmFkZCgnbGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcmllc0VsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgc2VyaWVzRWwucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VyaWVzRWwuY2xhc3NMaXN0LnJlbW92ZSgnbGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICBmb3IgKHZhciBfc2UgPSAwOyBfc2UgPCBhbGxTZXJpZXNFbHMubGVuZ3RoOyBfc2UrKykge1xuICAgICAgICAgIGFsbFNlcmllc0Vsc1tfc2VdLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWdobGlnaHRSYW5nZUluU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZ2hsaWdodFJhbmdlSW5TZXJpZXMoZSwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWxsSGVhdE1hcEVsZW1lbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtaGVhdG1hcC1yZWN0Jyk7XG5cbiAgICAgIHZhciBhbGxBY3RpdmUgPSBmdW5jdGlvbiBhbGxBY3RpdmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGFsbEluYWN0aXZlID0gZnVuY3Rpb24gYWxsSW5hY3RpdmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5hZGQoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHNlbGVjdGVkQWN0aXZlID0gZnVuY3Rpb24gc2VsZWN0ZWRBY3RpdmUocmFuZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxIZWF0TWFwRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQoYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgndmFsJykpO1xuXG4gICAgICAgICAgaWYgKHZhbCA+PSByYW5nZS5mcm9tICYmIHZhbCA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgYWxsQWN0aXZlKCk7XG4gICAgICAgIGFsbEluYWN0aXZlKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXNbc2VyaWVzQ250XTtcbiAgICAgICAgc2VsZWN0ZWRBY3RpdmUocmFuZ2UpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgYWxsQWN0aXZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZVNlcmllc0luZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZVNlcmllc0luZGV4KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGFjdGl2ZSBzZXJpZXMgZmxhZyBpcyByZXF1aXJlZCB0byBrbm93IGlmIHVzZXIgaGFzIG5vdCBkZWFjdGl2YXRlZCB2aWEgbGVnZW5kIGNsaWNrXG4gICAgICAgIHZhciBmaXJzdEFjdGl2ZVNlcmllc0luZGV4ID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoc2VyaWVzLmxlbmd0aCA+IDAgJiYgdy5jb25maWcuc2VyaWVzW2luZGV4XS50eXBlICE9PSAnYmFyJyAmJiB3LmNvbmZpZy5zZXJpZXNbaW5kZXhdLnR5cGUgIT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgZmlyc3RBY3RpdmVTZXJpZXNJbmRleC5sZW5ndGg7IGErKykge1xuICAgICAgICAgIGlmIChmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3RpdmVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBhY3RpdmUgc2VyaWVzIGZsYWcgaXMgcmVxdWlyZWQgdG8ga25vdyBpZiB1c2VyIGhhcyBub3QgZGVhY3RpdmF0ZWQgdmlhIGxlZ2VuZCBjbGlja1xuICAgICAgICB2YXIgZmlyc3RBY3RpdmVTZXJpZXNJbmRleCA9IHcuY29uZmlnLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoc2VyaWVzLmRhdGEgJiYgc2VyaWVzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXgubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBpZiAoZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByZXZpb3VzUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldmlvdXNQYXRocygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gcHVzaFBhdGhzKHNlcmllc0VscywgaSwgdHlwZSkge1xuICAgICAgICB2YXIgcGF0aHMgPSBzZXJpZXNFbHNbaV0uY2hpbGROb2RlcztcbiAgICAgICAgdmFyIGRBcnIgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBwYXRoczogW10sXG4gICAgICAgICAgcmVhbEluZGV4OiBzZXJpZXNFbHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChwYXRoc1tqXS5oYXNBdHRyaWJ1dGUoJ3BhdGhUbycpKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHBhdGhzW2pdLmdldEF0dHJpYnV0ZSgncGF0aFRvJyk7XG4gICAgICAgICAgICBkQXJyLnBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICBkOiBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKGRBcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtbGluZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChsaW5lUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBwID0gbGluZVBhdGhzLmxlbmd0aCAtIDE7IHAgPj0gMDsgcC0tKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGxpbmVQYXRocywgcCwgJ2xpbmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYXJlYXBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChhcmVhcGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJlYXBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGFyZWFwYXRocywgaSwgJ2FyZWEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmFyUGF0aHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoYmFyUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcCA9IDA7IF9wIDwgYmFyUGF0aHMubGVuZ3RoOyBfcCsrKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGJhclBhdGhzLCBfcCwgJ2JhcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW5kbGVzdGlja1BhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoY2FuZGxlc3RpY2tQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIF9wMiA9IDA7IF9wMiA8IGNhbmRsZXN0aWNrUGF0aHMubGVuZ3RoOyBfcDIrKykge1xuICAgICAgICAgIHB1c2hQYXRocyhjYW5kbGVzdGlja1BhdGhzLCBfcDIsICdjYW5kbGVzdGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByYWRhclBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtcmFkYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAocmFkYXJQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIF9wMyA9IDA7IF9wMyA8IHJhZGFyUGF0aHMubGVuZ3RoOyBfcDMrKykge1xuICAgICAgICAgIHB1c2hQYXRocyhyYWRhclBhdGhzLCBfcDMsICdyYWRhcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVwYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJ1YmJsZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChidWJibGVwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgYnViYmxlcGF0aHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLWJ1YmJsZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHMsIFwiJ10gY2lyY2xlXCIpKTtcbiAgICAgICAgICB2YXIgZEFyciA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlcmllc0Vscy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRBcnIucHVzaCh7XG4gICAgICAgICAgICAgIHg6IHNlcmllc0Vsc1tfaV0uZ2V0QXR0cmlidXRlKCdjeCcpLFxuICAgICAgICAgICAgICB5OiBzZXJpZXNFbHNbX2ldLmdldEF0dHJpYnV0ZSgnY3knKSxcbiAgICAgICAgICAgICAgcjogc2VyaWVzRWxzW19pXS5nZXRBdHRyaWJ1dGUoJ3InKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMucHVzaChkQXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc2NhdHRlcnBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2NhdHRlci1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChzY2F0dGVycGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcyA9IDA7IF9zIDwgc2NhdHRlcnBhdGhzLmxlbmd0aDsgX3MrKykge1xuICAgICAgICAgIHZhciBfc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNjYXR0ZXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChfcywgXCInXSBjaXJjbGVcIikpO1xuXG4gICAgICAgICAgdmFyIF9kQXJyID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfc2VyaWVzRWxzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIF9kQXJyLnB1c2goe1xuICAgICAgICAgICAgICB4OiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdjeCcpLFxuICAgICAgICAgICAgICB5OiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdjeScpLFxuICAgICAgICAgICAgICByOiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdyJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLnB1c2goX2RBcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWF0bWFwQ29sb3JzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtaGVhdG1hcCAuYXBleGNoYXJ0cy1zZXJpZXMnKTtcblxuICAgICAgaWYgKGhlYXRtYXBDb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGhlYXRtYXBDb2xvcnMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgX3Nlcmllc0VsczIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtaGVhdG1hcCAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoaCwgXCInXSByZWN0XCIpKTtcblxuICAgICAgICAgIHZhciBfZEFycjIgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9zZXJpZXNFbHMyLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIF9kQXJyMi5wdXNoKHtcbiAgICAgICAgICAgICAgY29sb3I6IF9zZXJpZXNFbHMyW19pM10uZ2V0QXR0cmlidXRlKCdjb2xvcicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKF9kQXJyMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAvLyBmb3Igbm9uLWF4aXMgY2hhcnRzIChpLmUuLCBjaXJjdWxhciBjaGFydHMsIHBhdGhGcm9tIGlzIG5vdCB1c2FibGUuIFdlIG5lZWQgd2hvbGUgc2VyaWVzKVxuICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocyA9IHcuZ2xvYmFscy5zZXJpZXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU5vRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVOb0RhdGEoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgbm9EYXRhT3B0cyA9IHcuY29uZmlnLm5vRGF0YTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhtZS5jdHgpO1xuICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC8gMjtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICB3Lmdsb2JhbHMubm9EYXRhID0gdHJ1ZTtcbiAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG5cbiAgICAgIGlmIChub0RhdGFPcHRzLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeCA9IDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSBpZiAobm9EYXRhT3B0cy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC0gMTA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vRGF0YU9wdHMudmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeSA9IDUwO1xuICAgICAgfSBlbHNlIGlmIChub0RhdGFPcHRzLnZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gNTA7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgbm9EYXRhT3B0cy5vZmZzZXRYO1xuICAgICAgeSA9IHkgKyBwYXJzZUludChub0RhdGFPcHRzLnN0eWxlLmZvbnRTaXplKSArIDI7XG5cbiAgICAgIGlmIChub0RhdGFPcHRzLnRleHQgIT09IHVuZGVmaW5lZCAmJiBub0RhdGFPcHRzLnRleHQgIT09ICcnKSB7XG4gICAgICAgIHZhciB0aXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IG5vRGF0YU9wdHMudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBub0RhdGFPcHRzLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IG5vRGF0YU9wdHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3I6IG5vRGF0YU9wdHMuc3R5bGUuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdGV4dC1ub2RhdGEnXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZVRleHQubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FwZXhjaGFydHMtdGl0bGUtdGV4dCcpO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLlBhcGVyLmFkZCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgIH0gLy8gV2hlbiB1c2VyIGNsaWNrcyBvbiBsZWdlbmRzLCB0aGUgY29sbGFwc2VkIHNlcmllcyBpcyBmaWxsZWQgd2l0aCBbMCwwLDAsLi4uLDBdXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYWx0ZXIgdGhlIHNlcmllcycgbGVuZ3RoIGFzIGl0IGlzIHVzZWQgYXQgbWFueSBwbGFjZXNcblxuICB9LCB7XG4gICAga2V5OiBcInNldE51bGxTZXJpZXNUb1plcm9WYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TnVsbFNlcmllc1RvWmVyb1ZhbHVlcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NsXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHNlcmllc1tzbF0ucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQWxsU2VyaWVzRXF1YWxYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0FsbFNlcmllc0VxdWFsWCgpIHtcbiAgICAgIHZhciBlcXVhbExlbiA9IHRydWU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJlZFNlclggPSB0aGlzLmZpbHRlcmVkU2VyaWVzWCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcmVkU2VyWC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGZpbHRlcmVkU2VyWFtpXVswXSAhPT0gZmlsdGVyZWRTZXJYW2kgKyAxXVswXSkge1xuICAgICAgICAgIGVxdWFsTGVuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0hhc0VxdWFsWCA9IGVxdWFsTGVuO1xuICAgICAgcmV0dXJuIGVxdWFsTGVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWx0ZXJlZFNlcmllc1hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyZWRTZXJpZXNYKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVyZWRTZXJpZXNYID0gdy5nbG9iYWxzLnNlcmllc1gubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgIGlmIChzZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBzZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZFNlcmllc1g7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlcmllcztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIERpbWVuc2lvbnMgQ2xhc3MgZm9yIGNhbGN1bGF0aW5nIHJlY3RzIG9mIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBkcmF3biBhbmQgd2lsbCBiZSBkcmF3bi5cbiAqXG4gKiBAbW9kdWxlIERpbWVuc2lvbnNcbiAqKi9cblxudmFyIERpbWVuc2lvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaW1lbnNpb25zKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaW1lbnNpb25zKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMubGdSZWN0ID0ge307XG4gICAgdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICB0aGlzLmlzU3BhcmtsaW5lID0gdGhpcy53LmNvbmZpZy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZDtcbiAgICB0aGlzLnhQYWRSaWdodCA9IDA7XG4gICAgdGhpcy54UGFkTGVmdCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3IC0gY2hhcnQgY29udGV4dFxuICAgKiovXG5cblxuICBfY3JlYXRlQ2xhc3MoRGltZW5zaW9ucywgW3tcbiAgICBrZXk6IFwicGxvdENvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbG90Q29vcmRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICB2YXIgbGdSZWN0ID0gdGhpcy5nZXRMZWdlbmRzUmVjdCgpO1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAvLyBmb3IgbGluZSAvIGFyZWEgLyBzY2F0dGVyIC8gY29sdW1uXG4gICAgICAgIHRoaXMuc2V0R3JpZENvb3Jkc0ZvckF4aXNDaGFydHMobGdSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZvciBwaWUgLyBkb251dHMgLyBjaXJjbGVcbiAgICAgICAgdGhpcy5zZXRHcmlkQ29vcmRzRm9yTm9uQXhpc0NoYXJ0cyhsZ1JlY3QpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpdGxlU3VidGl0bGVPZmZzZXQoKTsgLy8gYWZ0ZXIgY2FsY3VsYXRpbmcgZXZlcnl0aGluZywgYXBwbHkgcGFkZGluZyBzZXQgYnkgdXNlclxuXG4gICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuZ3JpZEhlaWdodCAtIHcuY29uZmlnLmdyaWQucGFkZGluZy50b3AgLSB3LmNvbmZpZy5ncmlkLnBhZGRpbmcuYm90dG9tO1xuICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZFdpZHRoIC0gdy5jb25maWcuZ3JpZC5wYWRkaW5nLmxlZnQgLSB3LmNvbmZpZy5ncmlkLnBhZGRpbmcucmlnaHQgLSB0aGlzLnhQYWRSaWdodCAtIHRoaXMueFBhZExlZnQ7XG4gICAgICBnbC50cmFuc2xhdGVYID0gZ2wudHJhbnNsYXRlWCArIHcuY29uZmlnLmdyaWQucGFkZGluZy5sZWZ0ICsgdGhpcy54UGFkTGVmdDtcbiAgICAgIGdsLnRyYW5zbGF0ZVkgPSBnbC50cmFuc2xhdGVZICsgdy5jb25maWcuZ3JpZC5wYWRkaW5nLnRvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZGl0aW9uYWxDaGVja3NGb3JBeGlzQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQ2hlY2tzRm9yQXhpc0Nvb3Jkcyh4YXhpc0xhYmVsQ29vcmRzLCB4dGl0bGVDb29yZHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy54QXhpc0hlaWdodCA9ICh4YXhpc0xhYmVsQ29vcmRzLmhlaWdodCArIHh0aXRsZUNvb3Jkcy5oZWlnaHQpICogdy5nbG9iYWxzLkxJTkVfSEVJR0hUX1JBVElPICsgMTU7XG4gICAgICB0aGlzLnhBeGlzV2lkdGggPSB4YXhpc0xhYmVsQ29vcmRzLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy54QXhpc0hlaWdodCAtIHh0aXRsZUNvb3Jkcy5oZWlnaHQgPiB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWF4SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWF4SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLm1pbkhlaWdodCAmJiB0aGlzLnhBeGlzSGVpZ2h0IDwgdy5jb25maWcueGF4aXMubGFiZWxzLm1pbkhlaWdodCkge1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gdy5jb25maWcueGF4aXMubGFiZWxzLm1pbkhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmZsb2F0aW5nKSB7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gdGhpcy5nZXRUb3RhbFlBeGlzV2lkdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzWzBdLndpZHRoICsgdy5nbG9iYWxzLnlUaXRsZUNvb3Jkc1swXS53aWR0aCArIDE1O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWUF4aXNXaWR0aCA9IDA7XG4gICAgICB2YXIgbWF4WUF4aXNXaWR0aCA9IDA7XG4gICAgICB3LmNvbmZpZy55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIG1pbllBeGlzV2lkdGggKz0geS5sYWJlbHMubWluV2lkdGg7XG4gICAgICAgIG1heFlBeGlzV2lkdGggKz0geS5sYWJlbHMubWF4V2lkdGg7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMueUF4aXNXaWR0aCA8IG1pbllBeGlzV2lkdGgpIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gbWluWUF4aXNXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueUF4aXNXaWR0aCA+IG1heFlBeGlzV2lkdGgpIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gbWF4WUF4aXNXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0R3JpZENvb3Jkc0ZvckF4aXNDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JpZENvb3Jkc0ZvckF4aXNDaGFydHMobGdSZWN0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciB5YXhpc0xhYmVsQ29vcmRzID0gdGhpcy5nZXR5QXhpc0xhYmVsc0Nvb3JkcygpO1xuICAgICAgdmFyIHhheGlzTGFiZWxDb29yZHMgPSB0aGlzLmdldHhBeGlzTGFiZWxzQ29vcmRzKCk7XG4gICAgICB2YXIgeVRpdGxlQ29vcmRzID0gdGhpcy5nZXR5QXhpc1RpdGxlQ29vcmRzKCk7XG4gICAgICB2YXIgeHRpdGxlQ29vcmRzID0gdGhpcy5nZXR4QXhpc1RpdGxlQ29vcmRzKCk7XG4gICAgICB3Lmdsb2JhbHMueUxhYmVsc0Nvb3JkcyA9IFtdO1xuICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3JkcyA9IFtdO1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAvLyBzdG9yZSB0aGUgbGFiZWxzIGFuZCB0aXRsZXMgY29vcmRzIGluIGdsb2JhbCB2YXJzXG4gICAgICAgIHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzLnB1c2goe1xuICAgICAgICAgIHdpZHRoOiB5YXhpc0xhYmVsQ29vcmRzW2luZGV4XS53aWR0aCxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHcuZ2xvYmFscy55VGl0bGVDb29yZHMucHVzaCh7XG4gICAgICAgICAgd2lkdGg6IHlUaXRsZUNvb3Jkc1tpbmRleF0ud2lkdGgsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsQ2hlY2tzRm9yQXhpc0Nvb3Jkcyh4YXhpc0xhYmVsQ29vcmRzLCB4dGl0bGVDb29yZHMpO1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNZID0gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyB0aGlzLnhBeGlzSGVpZ2h0IC8gOCA6IC00O1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNYID0gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgJiYgdy5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSA8PSAtNDUgPyAtdGhpcy54QXhpc1dpZHRoIC8gNCA6IDA7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgIGdsLnJvdGF0ZVhMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgZ2wudHJhbnNsYXRlWEF4aXNZID0gLTEgKiAocGFyc2VJbnQody5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDEuNSk7XG4gICAgICB9XG5cbiAgICAgIGdsLnRyYW5zbGF0ZVhBeGlzWSA9IGdsLnRyYW5zbGF0ZVhBeGlzWSArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRZO1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNYID0gZ2wudHJhbnNsYXRlWEF4aXNYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFg7XG4gICAgICB2YXIgeUF4aXNXaWR0aCA9IHRoaXMueUF4aXNXaWR0aDtcbiAgICAgIHZhciB4QXhpc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICBnbC54QXhpc0xhYmVsc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICBnbC54QXhpc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IDEwO1xuXG4gICAgICBpZiAoIXcuY29uZmlnLmdyaWQuc2hvdyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkYXInKSB7XG4gICAgICAgIHlBeGlzV2lkdGggPSAwO1xuICAgICAgICB4QXhpc0hlaWdodCA9IDM1O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1NwYXJrbGluZSkge1xuICAgICAgICBsZ1JlY3QgPSB7XG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgeUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZGl0aW9uYWxQYWRkaW5nWExhYmVscyh4YXhpc0xhYmVsQ29vcmRzKTtcblxuICAgICAgc3dpdGNoICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0geUF4aXNXaWR0aDtcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gbGdSZWN0LmhlaWdodCAtIHhBeGlzSGVpZ2h0IC0gKCF0aGlzLmlzU3BhcmtsaW5lID8gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyAxMCA6IDE1IDogMCk7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IGxnUmVjdC5oZWlnaHQgKyB0cmFuc2xhdGVZO1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBsZ1JlY3QuaGVpZ2h0IC0geEF4aXNIZWlnaHQgLSAoIXRoaXMuaXNTcGFya2xpbmUgPyB3Lmdsb2JhbHMucm90YXRlWExhYmVscyA/IDEwIDogMTUgOiAwKTtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIHlBeGlzV2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZVk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IGxnUmVjdC53aWR0aCArIHlBeGlzV2lkdGg7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIHhBeGlzSGVpZ2h0IC0gMTI7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSBsZ1JlY3Qud2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0geUF4aXNXaWR0aDtcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0geEF4aXNIZWlnaHQgLSAxMjtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIGxnUmVjdC53aWR0aCAtIHlBeGlzV2lkdGggLSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWdlbmQgcG9zaXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEdyaWRYUG9zRm9yRHVhbFlBeGlzKHlUaXRsZUNvb3JkcywgeWF4aXNMYWJlbENvb3Jkcyk7IC8vIGFmdGVyIGRyYXdpbmcgZXZlcnl0aGluZywgc2V0IHRoZSBZIGF4aXMgcG9zaXRpb25zXG5cbiAgICAgIHZhciBvYmp5QXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG4gICAgICBvYmp5QXhpcy5zZXRZQXhpc1hQb3NpdGlvbih5YXhpc0xhYmVsQ29vcmRzLCB5VGl0bGVDb29yZHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmlkQ29vcmRzRm9yTm9uQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmlkQ29vcmRzRm9yTm9uQXhpc0NoYXJ0cyhsZ1JlY3QpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIHhQYWQgPSAwO1xuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLnNob3cgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZykge1xuICAgICAgICB4UGFkID0gMjA7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZZID0gMTA7XG4gICAgICB2YXIgb2ZmWCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncGllJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgIG9mZlkgPSBvZmZZICsgdy5jb25maWcucGxvdE9wdGlvbnMucGllLm9mZnNldFk7XG4gICAgICAgIG9mZlggPSBvZmZYICsgdy5jb25maWcucGxvdE9wdGlvbnMucGllLm9mZnNldFg7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgIG9mZlkgPSBvZmZZICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLm9mZnNldFk7XG4gICAgICAgIG9mZlggPSBvZmZYICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLm9mZnNldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5jb25maWcubGVnZW5kLnNob3cpIHtcbiAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIDM1O1xuICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5ncmlkSGVpZ2h0O1xuICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWSAtIDEwO1xuICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIChnbC5zdmdXaWR0aCAtIGdsLmdyaWRXaWR0aCkgLyAyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAody5jb25maWcubGVnZW5kLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIGxnUmVjdC5oZWlnaHQgLSAzNTtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5ncmlkSGVpZ2h0O1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSBvZmZZIC0gMjA7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAoZ2wuc3ZnV2lkdGggLSBnbC5ncmlkV2lkdGgpIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBsZ1JlY3QuaGVpZ2h0IC0gMzU7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gbGdSZWN0LmhlaWdodCArIG9mZlk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAoZ2wuc3ZnV2lkdGggLSBnbC5ncmlkV2lkdGgpIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIGxnUmVjdC53aWR0aCAtIHhQYWQ7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRXaWR0aDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIGxnUmVjdC53aWR0aCArIHhQYWQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoIC0gbGdSZWN0LndpZHRoIC0geFBhZCAtIDU7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRXaWR0aDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIDEwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWdlbmQgcG9zaXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmlkWFBvc0ZvckR1YWxZQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmlkWFBvc0ZvckR1YWxZQXhpcyh5VGl0bGVDb29yZHMsIHlheGlzTGFiZWxDb29yZHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAody5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEgJiYgIXcuY29uZmlnLnlheGlzW2luZGV4XS5mbG9hdGluZyAmJiB3LmNvbmZpZy55YXhpc1tpbmRleF0uc2hvdykge1xuICAgICAgICAgIGlmICh5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWCA9IHcuZ2xvYmFscy50cmFuc2xhdGVYIC0gKHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoICsgeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aCkgLSBwYXJzZUludCh3LmNvbmZpZy55YXhpc1tpbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDEuMiAtIDEyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBTb21ldGltZXMsIHRoZSBsYXN0IGxhYmVscyBnZXRzIGNyb3BwZWQgaW4gY2F0ZWdvcnkvbnVtZXJpYyB4YXhpcy5cbiAgICAvLyBIZW5jZSwgd2UgYWRkIHNvbWUgYWRkaXRpb25hbCBwYWRkaW5nIGJhc2VkIG9uIHRoZSBsYWJlbCBsZW5ndGggdG8gYXZvaWQgdGhlIGxhc3QgbGFiZWwgYmVpbmcgY3JvcHBlZC5cbiAgICAvLyBOT1RFOiBkYXRldGltZSB4LWF4aXMgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IHdpdGggdGhpcyBhcyB3ZSBkb24ndCBrbm93IHRoZSBsYWJlbCBsZW5ndGggdGhlcmUgZHVlIHRvIG1hbnkgY29uc3RyYWludHMuXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRpdGlvbmFsUGFkZGluZ1hMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkaXRpb25hbFBhZGRpbmdYTGFiZWxzKHhheGlzTGFiZWxDb29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiB3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsIHx8IHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICB2YXIgcmlnaHRQYWQgPSBmdW5jdGlvbiByaWdodFBhZChsYWJlbHMpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wYWRkaW5nLnJpZ2h0IDwgbGFiZWxzLndpZHRoKSB7XG4gICAgICAgICAgICBfdGhpcy54UGFkUmlnaHQgPSBsYWJlbHMud2lkdGggLyAyICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxlZnRQYWQgPSBmdW5jdGlvbiBsZWZ0UGFkKGxhYmVscykge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnBhZGRpbmcubGVmdCA8IGxhYmVscy53aWR0aCkge1xuICAgICAgICAgICAgX3RoaXMueFBhZExlZnQgPSBsYWJlbHMud2lkdGggLyAyICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxpbmVBcmVhID0gdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdhcmVhJztcbiAgICAgICAgdy5jb25maWcueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaSkge1xuICAgICAgICAgIHZhciBzaG91bGRQYWQgPSAheWF4ZS5zaG93IHx8IHlheGUuZmxvYXRpbmcgfHwgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSAhPT0gLTEgfHwgbGluZUFyZWEgfHwgeWF4ZS5vcHBvc2l0ZSAmJiB3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsO1xuXG4gICAgICAgICAgaWYgKHNob3VsZFBhZCkge1xuICAgICAgICAgICAgaWYgKGxpbmVBcmVhICYmIHcuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSAhPT0gLTEgfHwgdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgIGxlZnRQYWQoeGF4aXNMYWJlbENvb3Jkcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB5YXhlLm9wcG9zaXRlICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xIHx8IGxpbmVBcmVhICYmICF3Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgICAgICAgIHJpZ2h0UGFkKHhheGlzTGFiZWxDb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpdGxlU3VidGl0bGVPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGl0bGVTdWJ0aXRsZU9mZnNldCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGdyaWRTaHJpbmtPZmZzZXQgPSB0aGlzLmlzU3BhcmtsaW5lIHx8ICF3Lmdsb2JhbHMuYXhpc0NoYXJ0cyA/IDAgOiAxMDtcblxuICAgICAgaWYgKHcuY29uZmlnLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHcuY29uZmlnLnRpdGxlLm1hcmdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gdGhpcy5pc1NwYXJrbGluZSB8fCAhdy5nbG9iYWxzLmF4aXNDaGFydHMgPyAwIDogNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnN1YnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHcuY29uZmlnLnN1YnRpdGxlLm1hcmdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gdGhpcy5pc1NwYXJrbGluZSB8fCAhdy5nbG9iYWxzLmF4aXNDaGFydHMgPyAwIDogNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5zaG93ICYmIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZyAmJiB3LmNvbmZpZy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IDEwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVDb29yZHMgPSB0aGlzLmdldFRpdGxlU3VidGl0bGVDb29yZHMoJ3RpdGxlJyk7XG4gICAgICB2YXIgc3VidGl0bGVDb29yZHMgPSB0aGlzLmdldFRpdGxlU3VidGl0bGVDb29yZHMoJ3N1YnRpdGxlJyk7XG4gICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuZ3JpZEhlaWdodCAtIHRpdGxlQ29vcmRzLmhlaWdodCAtIHN1YnRpdGxlQ29vcmRzLmhlaWdodCAtIGdyaWRTaHJpbmtPZmZzZXQ7XG4gICAgICBnbC50cmFuc2xhdGVZID0gZ2wudHJhbnNsYXRlWSArIHRpdGxlQ29vcmRzLmhlaWdodCArIHN1YnRpdGxlQ29vcmRzLmhlaWdodCArIGdyaWRTaHJpbmtPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvdGFsWUF4aXNXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbFlBeGlzV2lkdGgoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB5QXhpc1dpZHRoID0gMDtcbiAgICAgIHZhciBwYWRkaW5nID0gMTA7XG5cbiAgICAgIHZhciBpc0hpZGRlbllBeGlzID0gZnVuY3Rpb24gaXNIaWRkZW5ZQXhpcyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdy5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xO1xuICAgICAgfTtcblxuICAgICAgdy5nbG9iYWxzLnlMYWJlbHNDb29yZHMubWFwKGZ1bmN0aW9uICh5TGFiZWxDb29yZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGZsb2F0aW5nID0gdy5jb25maWcueWF4aXNbaW5kZXhdLmZsb2F0aW5nO1xuXG4gICAgICAgIGlmICh5TGFiZWxDb29yZC53aWR0aCA+IDAgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggKyB5TGFiZWxDb29yZC53aWR0aCArIHBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW5ZQXhpcyhpbmRleCkpIHtcbiAgICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoIC0geUxhYmVsQ29vcmQud2lkdGggLSBwYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCArIChmbG9hdGluZyB8fCAhdy5jb25maWcueWF4aXNbaW5kZXhdLnNob3cgPyAwIDogNSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3Jkcy5tYXAoZnVuY3Rpb24gKHlUaXRsZUNvb3JkLCBpbmRleCkge1xuICAgICAgICB2YXIgZmxvYXRpbmcgPSB3LmNvbmZpZy55YXhpc1tpbmRleF0uZmxvYXRpbmc7XG4gICAgICAgIHBhZGRpbmcgPSBwYXJzZUludCh3LmNvbmZpZy55YXhpc1tpbmRleF0udGl0bGUuc3R5bGUuZm9udFNpemUpO1xuXG4gICAgICAgIGlmICh5VGl0bGVDb29yZC53aWR0aCA+IDAgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggKyB5VGl0bGVDb29yZC53aWR0aCArIHBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW5ZQXhpcyhpbmRleCkpIHtcbiAgICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoIC0geVRpdGxlQ29vcmQud2lkdGggLSBwYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCArIChmbG9hdGluZyB8fCAhdy5jb25maWcueWF4aXNbaW5kZXhdLnNob3cgPyAwIDogNSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHlBeGlzV2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldHhBeGlzVGltZVNjYWxlTGFiZWxzQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldHhBeGlzVGltZVNjYWxlTGFiZWxzQ29vcmRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmVjdDtcbiAgICAgIHZhciB0aW1lc2NhbGVMYWJlbHMgPSB3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgdy5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICB0aW1lc2NhbGVMYWJlbHMgPSB3Lmdsb2JhbHMuaW52ZXJ0ZWRUaW1lbGluZUxhYmVscy5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxzID0gdGltZXNjYWxlTGFiZWxzLm1hcChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsLnZhbHVlO1xuICAgICAgfSk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgdmFyIHZhbCA9IGxhYmVscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLy8gaWYgdW5kZWZpbmVkLCBtYXliZSB1c2VyIGRpZG4ndCBwYXNzIHRoZSBkYXRldGltZSh4KSB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBoYXZlIHBvc3NpYmx5IHN1cHBsaWVkIGludmFsaWQgRGF0ZSBmb3JtYXQuIFBsZWFzZSBzdXBwbHkgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUnKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICByZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbCwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgIHZhciB0b3RhbFdpZHRoUm90YXRlZCA9IHJlY3Qud2lkdGggKiAxLjA1ICogbGFiZWxzLmxlbmd0aDtcblxuICAgICAgaWYgKHRvdGFsV2lkdGhSb3RhdGVkID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgIHcuZ2xvYmFscy5vdmVybGFwcGluZ1hMYWJlbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFggQXhpcyBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eEF4aXNMYWJlbHNDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eEF4aXNMYWJlbHNDb29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7XG4gICAgICB2YXIgcmVjdDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldHhBeGlzVGltZVNjYWxlTGFiZWxzQ29vcmRzKCk7XG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgd2lkdGg6IGNvb3Jkcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNvb3Jkcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZ1dpZHRoRm9yU2lkZUxlZ2VuZHMgPSB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0JyAmJiB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZyA/IHRoaXMubGdSZWN0LndpZHRoIDogMDsgLy8gIGdldCB0aGUgbG9uZ2VzdCBzdHJpbmcgZnJvbSB0aGUgbGFiZWxzIGFycmF5IGFuZCBhbHNvIGFwcGx5IGxhYmVsIGZvcm1hdHRlciB0byBpdFxuXG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIHhsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICAgIHhheGlzTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKHhsKSB7XG4gICAgICAgICAgdmFyIHhGb3JtYXQgPSBuZXcgRm9ybWF0dGVycyhfdGhpczIuY3R4KTtcbiAgICAgICAgICB2YXIgbGFiZWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHhsKTtcbiAgICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmFsID0gbGFiZWxzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgIH0sIDApOyAvLyB0aGUgbGFiZWxzIGdldHMgY2hhbmdlZCBmb3IgYmFyIGNoYXJ0c1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgdmFsID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ucmVzdWx0LnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHZhbCk7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB4TGFiZWxyZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbCwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogeExhYmVscmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHhMYWJlbHJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlY3Qud2lkdGggKiB4YXhpc0xhYmVscy5sZW5ndGggPiB3Lmdsb2JhbHMuc3ZnV2lkdGggLSBsZ1dpZHRoRm9yU2lkZUxlZ2VuZHMgLSB0aGlzLnlBeGlzV2lkdGggJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSAhPT0gMCkge1xuICAgICAgICAgIGlmICghdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPSB0cnVlO1xuICAgICAgICAgICAgeExhYmVscmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZSwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksIFwicm90YXRlKFwiLmNvbmNhdCh3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlLCBcIiAwIDApXCIpLCBmYWxzZSk7XG4gICAgICAgICAgICByZWN0LmhlaWdodCA9IHhMYWJlbHJlY3QuaGVpZ2h0IC8gMS42NjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXcuY29uZmlnLnhheGlzLmxhYmVscy5zaG93KSB7XG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgWSBBeGlzIERpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge3t3aWR0aCwgaGVpZ2h0fX1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXR5QXhpc0xhYmVsc0Nvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR5QXhpc0xhYmVsc0Nvb3JkcygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIHZhciBsYWJlbFBhZCA9IDEwO1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAoeWF4ZS5zaG93ICYmIHlheGUubGFiZWxzLnNob3cgJiYgdy5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLnJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpbmRleF07IC8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIC0xIGlzIHRoZSBpbmRleCBvZiB0aWNrIHdoaWNoIHVzZXIgY2FuIHVzZSBpbiB0aGUgZm9ybWF0dGVyXG5cbiAgICAgICAgICB2YXIgdmFsID0gbGJGb3JtYXR0ZXIody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXgsIC0xKTsgLy8gaWYgdXNlciBoYXMgc3BlY2lmaWVkIGEgY3VzdG9tIGZvcm1hdHRlciwgYW5kIHRoZSByZXN1bHQgaXMgbnVsbCBvciBlbXB0eSwgd2UgbmVlZCB0byBkaXNjYXJkIHRoZSBmb3JtYXR0ZXIgYW5kIHRha2UgdGhlIHZhbHVlIGFzIGl0IGlzLlxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBsYWJlbFBhZCA9IDA7XG4gICAgICAgICAgICB2YXIgYmFyWWF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgICAgICAgdmFsID0gYmFyWWF4aXNMYWJlbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhfdGhpczMuY3R4KTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHlheGUubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCArIGxhYmVsUGFkLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFggQXhpcyBUaXRsZSBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eEF4aXNUaXRsZUNvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc1RpdGxlQ29vcmRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMody5jb25maWcueGF4aXMudGl0bGUudGV4dCwgdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgWSBBeGlzIERpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge3t3aWR0aCwgaGVpZ2h0fX1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXR5QXhpc1RpdGxlQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldHlBeGlzVGl0bGVDb29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB3LmNvbmZpZy55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIGlmICh5YXhlLnNob3cgJiYgeWF4ZS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXM0LmN0eCk7XG4gICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMoeWF4ZS50aXRsZS50ZXh0LCB5YXhlLnRpdGxlLnN0eWxlLmZvbnRTaXplLCB5YXhlLnRpdGxlLnN0eWxlLmZvbnRGYW1pbHksICdyb3RhdGUoLTkwIDAgMCknLCBmYWxzZSk7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQ2hhcnQgVGl0bGUvU3VidGl0bGUgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlU3VidGl0bGVDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcyh0eXBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgIHZhciBmbG9hdGluZyA9IHR5cGUgPT09ICd0aXRsZScgPyB3LmNvbmZpZy50aXRsZS5mbG9hdGluZyA6IHcuY29uZmlnLnN1YnRpdGxlLmZsb2F0aW5nO1xuICAgICAgdmFyIGVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi10ZXh0XCIpKTtcblxuICAgICAgaWYgKGVsICE9PSBudWxsICYmICFmbG9hdGluZykge1xuICAgICAgICB2YXIgY29vcmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgd2lkdGggPSBjb29yZC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdy5nbG9iYWxzLmF4aXNDaGFydHMgPyBjb29yZC5oZWlnaHQgKyA1IDogY29vcmQuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZWdlbmRzUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWdlbmRzUmVjdCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsTGVnZW5kV3JhcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWxlZ2VuZCcpO1xuICAgICAgdmFyIGxnUmVjdCA9IE9iamVjdC5hc3NpZ24oe30sIFV0aWxzLmdldEJvdW5kaW5nQ2xpZW50UmVjdChlbExlZ2VuZFdyYXApKTtcblxuICAgICAgaWYgKGVsTGVnZW5kV3JhcCAhPT0gbnVsbCAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nICYmIHcuY29uZmlnLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgIHRoaXMubGdSZWN0ID0ge1xuICAgICAgICAgIHg6IGxnUmVjdC54LFxuICAgICAgICAgIHk6IGxnUmVjdC55LFxuICAgICAgICAgIGhlaWdodDogbGdSZWN0LmhlaWdodCxcbiAgICAgICAgICB3aWR0aDogbGdSZWN0LmhlaWdodCA9PT0gMCA/IDAgOiBsZ1JlY3Qud2lkdGhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGdSZWN0ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGdSZWN0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaW1lbnNpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVGltZVNjYWxlIENsYXNzIGZvciBnZW5lcmF0aW5nIHRpbWUgdGlja3MgZm9yIHgtYXhpcy5cbiAqXG4gKiBAbW9kdWxlIFRpbWVTY2FsZVxuICoqL1xuXG52YXIgVGltZVNjYWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVNjYWxlKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lU2NhbGUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy50aW1lU2NhbGVBcnJheSA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpbWVTY2FsZSwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRlVGltZVNjYWxlVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlVGltZVNjYWxlVGlja3MobWluWCwgbWF4WCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG51bGwgY2hlY2sgd2hlbiBubyBzZXJpZXMgdG8gc2hvd1xuXG4gICAgICBpZiAody5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICB3Lmdsb2JhbHMubGFiZWxzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy50aW1lbGluZUxhYmVscyA9IFtdO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF5c0RpZmYgPSAobWF4WCAtIG1pblgpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVJbnRlcnZhbChkYXlzRGlmZik7XG4gICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21JbiA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLmRpc2FibGVab29tT3V0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChkYXlzRGlmZiA8IDAuMDA1KSB7XG4gICAgICAgIHcuZ2xvYmFscy5kaXNhYmxlWm9vbUluID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF5c0RpZmYgPiA1MDAwMCkge1xuICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZUludGVydmFscyA9IGR0LmdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXAobWluWCwgbWF4WCk7XG4gICAgICB2YXIgZGF5c1dpZHRoT25YQXhpcyA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyBkYXlzRGlmZjtcbiAgICAgIHZhciBob3Vyc1dpZHRoT25YQXhpcyA9IGRheXNXaWR0aE9uWEF4aXMgLyAyNDtcbiAgICAgIHZhciBtaW51dGVzV2lkdGhPblhBeGlzID0gaG91cnNXaWR0aE9uWEF4aXMgLyA2MDtcbiAgICAgIHZhciBudW1iZXJPZkhvdXJzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAqIDI0KTtcbiAgICAgIHZhciBudW1iZXJPZk1pbnV0ZXMgPSBNYXRoLmZsb29yKGRheXNEaWZmICogMjQgKiA2MCk7XG4gICAgICB2YXIgbnVtYmVyT2ZEYXlzID0gTWF0aC5mbG9vcihkYXlzRGlmZik7XG4gICAgICB2YXIgbnVtYmVyT2ZNb250aHMgPSBNYXRoLmZsb29yKGRheXNEaWZmIC8gMzApO1xuICAgICAgdmFyIG51bWJlck9mWWVhcnMgPSBNYXRoLmZsb29yKGRheXNEaWZmIC8gMzY1KTtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHtcbiAgICAgICAgbWluTWludXRlOiB0aW1lSW50ZXJ2YWxzLm1pbk1pbnV0ZSxcbiAgICAgICAgbWluSG91cjogdGltZUludGVydmFscy5taW5Ib3VyLFxuICAgICAgICBtaW5EYXRlOiB0aW1lSW50ZXJ2YWxzLm1pbkRhdGUsXG4gICAgICAgIG1pbk1vbnRoOiB0aW1lSW50ZXJ2YWxzLm1pbk1vbnRoLFxuICAgICAgICBtaW5ZZWFyOiB0aW1lSW50ZXJ2YWxzLm1pblllYXJcbiAgICAgIH07XG4gICAgICB2YXIgY3VycmVudE1pbnV0ZSA9IGZpcnN0VmFsLm1pbk1pbnV0ZTtcbiAgICAgIHZhciBjdXJyZW50SG91ciA9IGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICB2YXIgY3VycmVudE1vbnRoRGF0ZSA9IGZpcnN0VmFsLm1pbkRhdGU7XG4gICAgICB2YXIgY3VycmVudERhdGUgPSBmaXJzdFZhbC5taW5EYXRlO1xuICAgICAgdmFyIGN1cnJlbnRNb250aCA9IGZpcnN0VmFsLm1pbk1vbnRoO1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gZmlyc3RWYWwubWluWWVhcjtcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIGZpcnN0VmFsOiBmaXJzdFZhbCxcbiAgICAgICAgY3VycmVudE1pbnV0ZTogY3VycmVudE1pbnV0ZSxcbiAgICAgICAgY3VycmVudEhvdXI6IGN1cnJlbnRIb3VyLFxuICAgICAgICBjdXJyZW50TW9udGhEYXRlOiBjdXJyZW50TW9udGhEYXRlLFxuICAgICAgICBjdXJyZW50RGF0ZTogY3VycmVudERhdGUsXG4gICAgICAgIGN1cnJlbnRNb250aDogY3VycmVudE1vbnRoLFxuICAgICAgICBjdXJyZW50WWVhcjogY3VycmVudFllYXIsXG4gICAgICAgIGRheXNXaWR0aE9uWEF4aXM6IGRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgIGhvdXJzV2lkdGhPblhBeGlzOiBob3Vyc1dpZHRoT25YQXhpcyxcbiAgICAgICAgbWludXRlc1dpZHRoT25YQXhpczogbWludXRlc1dpZHRoT25YQXhpcyxcbiAgICAgICAgbnVtYmVyT2ZNaW51dGVzOiBudW1iZXJPZk1pbnV0ZXMsXG4gICAgICAgIG51bWJlck9mSG91cnM6IG51bWJlck9mSG91cnMsXG4gICAgICAgIG51bWJlck9mRGF5czogbnVtYmVyT2ZEYXlzLFxuICAgICAgICBudW1iZXJPZk1vbnRoczogbnVtYmVyT2ZNb250aHMsXG4gICAgICAgIG51bWJlck9mWWVhcnM6IG51bWJlck9mWWVhcnNcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodGhpcy50aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVZZWFyU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICBjYXNlICdoYWxmX3llYXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVNb250aFNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW9udGhzX2RheXMnOlxuICAgICAgICBjYXNlICdtb250aHNfZm9ydG5pZ2h0JzpcbiAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgIGNhc2UgJ3dlZWtfZGF5cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZURheVNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVIb3VyU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlTWludXRlU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZmlyc3QsIHdlIHdpbGwgYWRqdXN0IHRoZSBtb250aCB2YWx1ZXMgaW5kZXhcbiAgICAgIC8vIGFzIGluIHRoZSB1cHBlciBmdW5jdGlvbiwgaXQgaXMgc3RhcnRpbmcgZnJvbSAwXG4gICAgICAvLyB3ZSB3aWxsIHN0YXJ0IHRoZW0gZnJvbSAxXG5cblxuICAgICAgdmFyIGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5ID0gdGhpcy50aW1lU2NhbGVBcnJheS5tYXAoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0UmV0dXJuID0ge1xuICAgICAgICAgIHBvc2l0aW9uOiB0cy5wb3NpdGlvbixcbiAgICAgICAgICB1bml0OiB0cy51bml0LFxuICAgICAgICAgIHllYXI6IHRzLnllYXIsXG4gICAgICAgICAgZGF5OiB0cy5kYXkgPyB0cy5kYXkgOiAxLFxuICAgICAgICAgIGhvdXI6IHRzLmhvdXIgPyB0cy5ob3VyIDogMCxcbiAgICAgICAgICBtb250aDogdHMubW9udGggKyAxXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJldHVybiwge1xuICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRzLnVuaXQgPT09ICdkYXknIHx8IHRzLnVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmV0dXJuLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHMudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cy51bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmV0dXJuLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHMudmFsdWUsXG4gICAgICAgICAgICBtaW51dGU6IHRzLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHM7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaWx0ZXJlZFRpbWVTY2FsZSA9IGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5LmZpbHRlcihmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgdmFyIG1vZHVsbyA9IDE7XG4gICAgICAgIHZhciB0aWNrcyA9IE1hdGguY2VpbCh3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTIwKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHMudmFsdWU7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpY2tBbW91bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpY2tzID0gdy5jb25maWcueGF4aXMudGlja0Ftb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGp1c3RlZE1vbnRoSW5UaW1lU2NhbGVBcnJheS5sZW5ndGggPiB0aWNrcykge1xuICAgICAgICAgIG1vZHVsbyA9IE1hdGguZmxvb3IoYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkubGVuZ3RoIC8gdGlja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZE5vdFNraXBVbml0ID0gZmFsc2U7IC8vIHRoZXJlIGlzIGEgYmlnIGNoYW5nZSBpbiB1bml0IGkuZSBkYXlzIHRvIG1vbnRoc1xuXG4gICAgICAgIHZhciBzaG91bGROb3RQcmludCA9IGZhbHNlOyAvLyBzaG91bGQgc2tpcCB0aGVzZSB2YWx1ZXNcblxuICAgICAgICBzd2l0Y2ggKF90aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgIGNhc2UgJ2hhbGZfeWVhcic6XG4gICAgICAgICAgICBtb2R1bG8gPSA3O1xuXG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgbW9kdWxvID0gMTtcblxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9udGhzX2ZvcnRuaWdodCc6XG4gICAgICAgICAgICBtb2R1bG8gPSAxNTtcblxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJyB8fCB0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9udGhzX2RheXMnOlxuICAgICAgICAgICAgbW9kdWxvID0gMTA7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnd2Vla19kYXlzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDg7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDE7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlICUgNSAhPT0gMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ21pbnV0ZXMnIHx8IF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ2hvdXJzJykge1xuICAgICAgICAgIGlmICghc2hvdWxkTm90UHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKHZhbHVlICUgbW9kdWxvID09PSAwIHx8IHNob3VsZE5vdFNraXBVbml0KSAmJiAhc2hvdWxkTm90UHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRUaW1lU2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0KGZpbHRlcmVkVGltZVNjYWxlLCBpbnZlcnRlZCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmVmb3JtYXR0ZWRUaW1lc2NhbGVBcnJheSA9IHRoaXMuZm9ybWF0RGF0ZXMoZmlsdGVyZWRUaW1lU2NhbGUpO1xuICAgICAgdmFyIHJlbW92ZWRPdmVybGFwcGluZ1RTID0gdGhpcy5yZW1vdmVPdmVybGFwcGluZ1RTKHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkpO1xuXG4gICAgICBpZiAoIWludmVydGVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy50aW1lbGluZUxhYmVscyA9IHJlbW92ZWRPdmVybGFwcGluZ1RTLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMuaW52ZXJ0ZWRUaW1lbGluZUxhYmVscyA9IHJlbW92ZWRPdmVybGFwcGluZ1RTLnNsaWNlKCk7XG4gICAgICB9IC8vIGF0IHRoaXMgc3RhZ2UsIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGNvb3JkcyBvZiB0aGUgZ3JpZCBhcyB0aW1lbGluZSBsYWJlbHMgbWF5IGhhdmUgYWx0ZXJlZCB0aGUgeGF4aXMgbGFiZWxzIGNvb3Jkc1xuICAgICAgLy8gVGhlIHJlYXNvbiB3ZSBjYW4ndCBkbyB0aGlzIHByaW9yIHRvIHRoaXMgc3RhZ2UgaXMgYmVjYXVzZSB0aW1lbGluZSBsYWJlbHMgZGVwZW5kcyBvbiBncmlkV2lkdGgsIGFuZCBhcyB0aGUgdGlja3MgYXJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gYXZhaWxhYmxlIGdyaWRXaWR0aCwgdGhlcmUgY2FuIGJlIHVua25vd24gbnVtYmVyIG9mIHRpY2tzIGdlbmVyYXRlZCBmb3IgZGlmZmVyZW50IG1pblggYW5kIG1heFhcbiAgICAgIC8vIERlcGVuZGVuY3kgb24gRGltZW5zaW9ucygpLCBuZWVkIHRvIHJlZmFjdG9yIGNvcnJlY3RseVxuICAgICAgLy8gVE9ETyAtIGZpbmQgYW4gYWx0ZXJuYXRlIHdheSB0byBhdm9pZCBjYWxsaW5nIHRoaXMgSGVhdnkgbWV0aG9kIHR3aWNlXG5cblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICBkaW1lbnNpb25zLnBsb3RDb29yZHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lSW50ZXJ2YWwoZGF5c0RpZmYpIHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIGRheXNEaWZmID4gMTgyNTpcbiAgICAgICAgICAvLyBkaWZmZXJlbmNlIGlzIG1vcmUgdGhhbiA1IHllYXJzXG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAneWVhcnMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiA4MDAgJiYgZGF5c0RpZmYgPD0gMTgyNTpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdoYWxmX3llYXInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAxODAgJiYgZGF5c0RpZmYgPD0gODAwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21vbnRocyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDkwICYmIGRheXNEaWZmIDw9IDE4MDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtb250aHNfZm9ydG5pZ2h0JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRheXNEaWZmID4gNjAgJiYgZGF5c0RpZmYgPD0gOTA6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnbW9udGhzX2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAzMCAmJiBkYXlzRGlmZiA8PSA2MDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICd3ZWVrX2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAyICYmIGRheXNEaWZmIDw9IDMwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAwLjEgJiYgZGF5c0RpZmYgPD0gMjpcbiAgICAgICAgICAvLyBsZXNzIHRoYW4gIDIgZGF5c1xuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ2hvdXJzJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRheXNEaWZmIDwgMC4xOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21pbnV0ZXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnZGF5cyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlWWVhclNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlWWVhclNjYWxlKHBhcmFtcykge1xuICAgICAgdmFyIGZpcnN0VmFsID0gcGFyYW1zLmZpcnN0VmFsLFxuICAgICAgICAgIGN1cnJlbnRNb250aCA9IHBhcmFtcy5jdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXIgPSBwYXJhbXMuY3VycmVudFllYXIsXG4gICAgICAgICAgZGF5c1dpZHRoT25YQXhpcyA9IHBhcmFtcy5kYXlzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mWWVhcnMgPSBwYXJhbXMubnVtYmVyT2ZZZWFycztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pblllYXI7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ3llYXInO1xuXG4gICAgICBpZiAoZmlyc3RWYWwubWluRGF0ZSA+IDEgJiYgZmlyc3RWYWwubWluTW9udGggPiAwKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdEYXlzID0gZHQuZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcihmaXJzdFZhbC5taW5ZZWFyLCBmaXJzdFZhbC5taW5Nb250aCwgZmlyc3RWYWwubWluRGF0ZSk7IC8vIHJlbWFpbmluZ0RheXNvZkZpcnN0TW9udGggaXMgdXNlZCB0byByZWFjaHQgdGhlIDJuZCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ0RheXNPZkZpcnN0WWVhciA9IGR0LmRldGVybWluZURheXNPZlllYXIoZmlyc3RWYWwubWluWWVhcikgLSByZW1haW5pbmdEYXlzICsgMTsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdEYXlzT2ZGaXJzdFllYXIgKiBkYXlzV2lkdGhPblhBeGlzO1xuICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pblllYXIgKyAxOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHllYXI6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChjdXJyZW50TW9udGggKyAxKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RWYWwubWluRGF0ZSA9PT0gMSAmJiBmaXJzdFZhbC5taW5Nb250aCA9PT0gMCkge1xuICAgICAgICAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogZmlyc3RUaWNrVmFsdWUsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QoY3VycmVudE1vbnRoICsgMSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gZmlyc3RUaWNrVmFsdWU7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mWWVhcnM7IGkrKykge1xuICAgICAgICB5ZWFyKys7XG4gICAgICAgIHBvcyA9IGR0LmRldGVybWluZURheXNPZlllYXIoeWVhciAtIDEpICogZGF5c1dpZHRoT25YQXhpcyArIHBvcztcbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgIHZhbHVlOiB5ZWFyLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVNb250aFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTW9udGhTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50TW9udGhEYXRlID0gcGFyYW1zLmN1cnJlbnRNb250aERhdGUsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBkYXlzV2lkdGhPblhBeGlzID0gcGFyYW1zLmRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgbnVtYmVyT2ZNb250aHMgPSBwYXJhbXMubnVtYmVyT2ZNb250aHM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBjdXJyZW50TW9udGg7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ21vbnRoJztcbiAgICAgIHZhciB5ckNvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAoZmlyc3RWYWwubWluRGF0ZSA+IDEpIHtcbiAgICAgICAgLy8gcmVtYWluaW5nRGF5c29mRmlyc3RNb250aCBpcyB1c2VkIHRvIHJlYWNodCB0aGUgMm5kIHRpY2sgcG9zaXRpb25cbiAgICAgICAgdmFyIHJlbWFpbmluZ0RheXNPZkZpcnN0TW9udGggPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMoY3VycmVudE1vbnRoICsgMSwgZmlyc3RWYWwubWluWWVhcikgLSBjdXJyZW50TW9udGhEYXRlICsgMTsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdEYXlzT2ZGaXJzdE1vbnRoICogZGF5c1dpZHRoT25YQXhpcztcbiAgICAgICAgZmlyc3RUaWNrVmFsdWUgPSBVdGlscy5tb250aE1vZChjdXJyZW50TW9udGggKyAxKTtcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIHlyQ291bnRlcjtcblxuICAgICAgICB2YXIgX21vbnRoID0gVXRpbHMubW9udGhNb2QoZmlyc3RUaWNrVmFsdWUpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGZpcnN0VGlja1ZhbHVlOyAvLyBpdCdzIEphbiwgc28gdXBkYXRlIHRoZSB5ZWFyXG5cbiAgICAgICAgaWYgKGZpcnN0VGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgdW5pdCA9ICd5ZWFyJztcbiAgICAgICAgICB2YWx1ZSA9IHllYXI7XG4gICAgICAgICAgX21vbnRoID0gMTtcbiAgICAgICAgICB5ckNvdW50ZXIgKz0gMTtcbiAgICAgICAgICB5ZWFyID0geWVhciArIHlyQ291bnRlcjtcbiAgICAgICAgfSAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG5cbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogX21vbnRoXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHVzaCB0aGUgZmlyc3QgdGljayBpbiB0aGUgYXJyYXlcbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogY3VycmVudFllYXIsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKGN1cnJlbnRNb250aClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb250aCA9IGZpcnN0VGlja1ZhbHVlICsgMTtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMTsgaSA8IG51bWJlck9mTW9udGhzOyBpKyssIGorKykge1xuICAgICAgICBtb250aCA9IFV0aWxzLm1vbnRoTW9kKG1vbnRoKTtcblxuICAgICAgICBpZiAobW9udGggPT09IDApIHtcbiAgICAgICAgICB1bml0ID0gJ3llYXInO1xuICAgICAgICAgIHlyQ291bnRlciArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaXQgPSAnbW9udGgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF95ZWFyID0gY3VycmVudFllYXIgKyBNYXRoLmZsb29yKG1vbnRoIC8gMTIpICsgeXJDb3VudGVyO1xuXG4gICAgICAgIHBvcyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCwgX3llYXIpICogZGF5c1dpZHRoT25YQXhpcyArIHBvcztcbiAgICAgICAgdmFyIG1vbnRoVmFsID0gbW9udGggPT09IDAgPyBfeWVhciA6IG1vbnRoO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IG1vbnRoVmFsLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogX3llYXIsXG4gICAgICAgICAgbW9udGg6IG1vbnRoID09PSAwID8gMSA6IG1vbnRoXG4gICAgICAgIH0pO1xuICAgICAgICBtb250aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZURheVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlRGF5U2NhbGUocGFyYW1zKSB7XG4gICAgICB2YXIgZmlyc3RWYWwgPSBwYXJhbXMuZmlyc3RWYWwsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBob3Vyc1dpZHRoT25YQXhpcyA9IHBhcmFtcy5ob3Vyc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZkRheXMgPSBwYXJhbXMubnVtYmVyT2ZEYXlzO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ2RheSc7XG4gICAgICB2YXIgcmVtYWluaW5nSG91cnMgPSAyNCAtIGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICB2YXIgeXJDb3VudGVyID0gMDsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IHJlbWFpbmluZ0hvdXJzICogaG91cnNXaWR0aE9uWEF4aXM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5EYXRlICsgMTtcbiAgICAgIHZhciB2YWwgPSBmaXJzdFRpY2tWYWx1ZTtcblxuICAgICAgdmFyIGNoYW5nZU1vbnRoID0gZnVuY3Rpb24gY2hhbmdlTW9udGgoZGF0ZVZhbCwgbW9udGgsIHllYXIpIHtcbiAgICAgICAgdmFyIG1vbnRoZGF5cyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCArIDEsIHllYXIpO1xuXG4gICAgICAgIGlmIChkYXRlVmFsID4gbW9udGhkYXlzKSB7XG4gICAgICAgICAgbW9udGggPSBtb250aCArIDE7XG4gICAgICAgICAgZGF0ZSA9IDE7XG4gICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgdmFsID0gbW9udGg7XG4gICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRhdGUgPSBmaXJzdFRpY2tWYWx1ZTtcbiAgICAgIHZhciBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIGN1cnJlbnRNb250aCwgY3VycmVudFllYXIpOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpLFxuICAgICAgICBkYXk6IGRhdGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvcyA9IGZpcnN0VGlja1Bvc2l0aW9uOyAvLyBrZWVwIGRyYXdpbmcgcmVzdCBvZiB0aGUgdGlja3NcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkRheXM7IGkrKykge1xuICAgICAgICBkYXRlICs9IDE7XG4gICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBtb250aCwgY3VycmVudFllYXIgKyBNYXRoLmZsb29yKG1vbnRoIC8gMTIpICsgeXJDb3VudGVyKTtcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG4gICAgICAgIHBvcyA9IDI0ICogaG91cnNXaWR0aE9uWEF4aXMgKyBwb3M7XG5cbiAgICAgICAgdmFyIF92YWwgPSBkYXRlID09PSAxID8gVXRpbHMubW9udGhNb2QobW9udGgpIDogZGF0ZTtcblxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IF92YWwsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChtb250aCksXG4gICAgICAgICAgZGF5OiBfdmFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZUhvdXJTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUhvdXJTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50RGF0ZSA9IHBhcmFtcy5jdXJyZW50RGF0ZSxcbiAgICAgICAgICBjdXJyZW50TW9udGggPSBwYXJhbXMuY3VycmVudE1vbnRoLFxuICAgICAgICAgIGN1cnJlbnRZZWFyID0gcGFyYW1zLmN1cnJlbnRZZWFyLFxuICAgICAgICAgIG1pbnV0ZXNXaWR0aE9uWEF4aXMgPSBwYXJhbXMubWludXRlc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZkhvdXJzID0gcGFyYW1zLm51bWJlck9mSG91cnM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG4gICAgICB2YXIgdW5pdCA9ICdob3VyJztcblxuICAgICAgdmFyIGNoYW5nZURhdGUgPSBmdW5jdGlvbiBjaGFuZ2VEYXRlKGRhdGVWYWwsIG1vbnRoKSB7XG4gICAgICAgIHZhciBtb250aGRheXMgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGggKyAxLCBjdXJyZW50WWVhcik7XG5cbiAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICBkYXRlID0gMTtcbiAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgIGRhdGU6IGRhdGVcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFuZ2VNb250aCA9IGZ1bmN0aW9uIGNoYW5nZU1vbnRoKGRhdGVWYWwsIG1vbnRoKSB7XG4gICAgICAgIHZhciBtb250aGRheXMgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGggKyAxLCBjdXJyZW50WWVhcik7XG5cbiAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVtYWluaW5nTWlucyA9IDYwIC0gZmlyc3RWYWwubWluTWludXRlO1xuICAgICAgdmFyIGZpcnN0VGlja1Bvc2l0aW9uID0gcmVtYWluaW5nTWlucyAqIG1pbnV0ZXNXaWR0aE9uWEF4aXM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5Ib3VyICsgMTtcbiAgICAgIHZhciBob3VyID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuXG4gICAgICBpZiAocmVtYWluaW5nTWlucyA9PT0gNjApIHtcbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICAgIGhvdXIgPSBmaXJzdFRpY2tWYWx1ZSArIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gY3VycmVudERhdGU7XG4gICAgICB2YXIgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBjdXJyZW50TW9udGgpOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSG91cnM7IGkrKykge1xuICAgICAgICB1bml0ID0gJ2hvdXInO1xuXG4gICAgICAgIGlmIChob3VyID49IDI0KSB7XG4gICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgZGF0ZSArPSAxO1xuICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICB2YXIgY2hlY2tOZXh0TW9udGggPSBjaGFuZ2VEYXRlKGRhdGUsIG1vbnRoKTtcbiAgICAgICAgICBtb250aCA9IGNoZWNrTmV4dE1vbnRoLm1vbnRoO1xuICAgICAgICAgIG1vbnRoID0gY2hhbmdlTW9udGgoZGF0ZSwgbW9udGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG4gICAgICAgIHBvcyA9IGhvdXIgPT09IDAgJiYgaSA9PT0gMCA/IHJlbWFpbmluZ01pbnMgKiBtaW51dGVzV2lkdGhPblhBeGlzIDogNjAgKiBtaW51dGVzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB2YXIgdmFsID0gaG91ciA9PT0gMCA/IGRhdGUgOiBob3VyO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgICB9KTtcbiAgICAgICAgaG91cisrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZU1pbnV0ZVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTWludXRlU2NhbGUocGFyYW1zKSB7XG4gICAgICB2YXIgZmlyc3RWYWwgPSBwYXJhbXMuZmlyc3RWYWwsXG4gICAgICAgICAgY3VycmVudE1pbnV0ZSA9IHBhcmFtcy5jdXJyZW50TWludXRlLFxuICAgICAgICAgIGN1cnJlbnRIb3VyID0gcGFyYW1zLmN1cnJlbnRIb3VyLFxuICAgICAgICAgIGN1cnJlbnREYXRlID0gcGFyYW1zLmN1cnJlbnREYXRlLFxuICAgICAgICAgIGN1cnJlbnRNb250aCA9IHBhcmFtcy5jdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXIgPSBwYXJhbXMuY3VycmVudFllYXIsXG4gICAgICAgICAgbWludXRlc1dpZHRoT25YQXhpcyA9IHBhcmFtcy5taW51dGVzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mTWludXRlcyA9IHBhcmFtcy5udW1iZXJPZk1pbnV0ZXM7XG4gICAgICB2YXIgeXJDb3VudGVyID0gMDtcbiAgICAgIHZhciB1bml0ID0gJ21pbnV0ZSc7XG4gICAgICB2YXIgcmVtYWluaW5nTWlucyA9IGN1cnJlbnRNaW51dGUgLSBmaXJzdFZhbC5taW5NaW51dGU7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSBtaW51dGVzV2lkdGhPblhBeGlzIC0gcmVtYWluaW5nTWlucztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbk1pbnV0ZSArIDE7XG4gICAgICB2YXIgbWludXRlID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuICAgICAgdmFyIGRhdGUgPSBjdXJyZW50RGF0ZTtcbiAgICAgIHZhciBtb250aCA9IGN1cnJlbnRNb250aDtcbiAgICAgIHZhciB5ZWFyID0gY3VycmVudFllYXI7XG4gICAgICB2YXIgaG91ciA9IGN1cnJlbnRIb3VyOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mTWludXRlczsgaSsrKSB7XG4gICAgICAgIGlmIChtaW51dGUgPj0gNjApIHtcbiAgICAgICAgICBtaW51dGUgPSAwO1xuICAgICAgICAgIGhvdXIgKz0gMTtcblxuICAgICAgICAgIGlmIChob3VyID09PSAyNCkge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF95ZWFyMiA9IGN1cnJlbnRZZWFyICsgTWF0aC5mbG9vcihtb250aCAvIDEyKSArIHlyQ291bnRlcjtcblxuICAgICAgICBwb3MgPSBtaW51dGVzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB2YXIgdmFsID0gbWludXRlO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgICAgbWludXRlOiBtaW51dGUsXG4gICAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICAgIHllYXI6IF95ZWFyMixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpXG4gICAgICAgIH0pO1xuICAgICAgICBtaW51dGUrKztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUmF3RGF0ZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYXdEYXRlU3RyaW5nKHRzLCB2YWx1ZSkge1xuICAgICAgdmFyIHJhdyA9IHRzLnllYXI7XG4gICAgICByYXcgKz0gJy0nICsgKCcwJyArIHRzLm1vbnRoLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTsgLy8gdW5pdCBpcyBkYXlcblxuICAgICAgaWYgKHRzLnVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgIHJhdyArPSB0cy51bml0ID09PSAnZGF5JyA/ICctJyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpIDogJy0wMSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXcgKz0gJy0nICsgKCcwJyArICh0cy5kYXkgPyB0cy5kYXkgOiAnMScpKS5zbGljZSgtMik7XG4gICAgICB9IC8vIHVuaXQgaXMgaG91clxuXG5cbiAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgcmF3ICs9IHRzLnVuaXQgPT09ICdob3VyJyA/ICdUJyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpIDogJ1QwMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXcgKz0gJ1QnICsgKCcwJyArICh0cy5ob3VyID8gdHMuaG91ciA6ICcwJykpLnNsaWNlKC0yKTtcbiAgICAgIH0gLy8gdW5pdCBpcyBtaW51dGVcblxuXG4gICAgICByYXcgKz0gdHMudW5pdCA9PT0gJ21pbnV0ZScgPyAnOicgKyAoJzAnICsgdmFsdWUpLnNsaWNlKC0yKSArICc6MDAuMDAwWicgOiAnOjAwOjAwLjAwMFonO1xuICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0RGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZXMoZmlsdGVyZWRUaW1lU2NhbGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWZvcm1hdHRlZFRpbWVzY2FsZUFycmF5ID0gZmlsdGVyZWRUaW1lU2NhbGUubWFwKGZ1bmN0aW9uICh0cykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cy52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUoX3RoaXMyLmN0eCk7XG5cbiAgICAgICAgdmFyIHJhdyA9IF90aGlzMi5jcmVhdGVSYXdEYXRlU3RyaW5nKHRzLCB2YWx1ZSk7IC8vIHBhcnNlIHRoZSB3aG9sZSBJU08gZGF0ZXN0cmluZ1xuXG5cbiAgICAgICAgdmFyIGRhdGVTdHJpbmcgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHJhdykpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY3VzdG9tRm9ybWF0ID0gJ2RkIE1NTSc7XG4gICAgICAgICAgdmFyIGR0Rm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmRhdGV0aW1lRm9ybWF0dGVyO1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLnllYXI7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtb250aCcpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLm1vbnRoO1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAnZGF5JykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIuZGF5O1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLmhvdXI7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtaW51dGUnKSBjdXN0b21Gb3JtYXQgPSBkdEZvcm1hdHRlci5taW51dGU7XG4gICAgICAgICAgdmFsdWUgPSBkdC5mb3JtYXREYXRlKGRhdGVTdHJpbmcsIGN1c3RvbUZvcm1hdCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZHQuZm9ybWF0RGF0ZShkYXRlU3RyaW5nLCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0ZVN0cmluZzogcmF3LFxuICAgICAgICAgIHBvc2l0aW9uOiB0cy5wb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdW5pdDogdHMudW5pdCxcbiAgICAgICAgICB5ZWFyOiB0cy55ZWFyLFxuICAgICAgICAgIG1vbnRoOiB0cy5tb250aFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVmb3JtYXR0ZWRUaW1lc2NhbGVBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlT3ZlcmxhcHBpbmdUU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVPdmVybGFwcGluZ1RTKGFycikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgbGFzdERyYXduSW5kZXggPSAwO1xuICAgICAgdmFyIGZpbHRlcmVkQXJyYXkgPSBhcnIubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwICYmIF90aGlzMy53LmNvbmZpZy54YXhpcy5sYWJlbHMuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKSB7XG4gICAgICAgICAgdmFyIHByZXZMYWJlbFdpZHRoID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGFycltsYXN0RHJhd25JbmRleF0udmFsdWUpLndpZHRoO1xuICAgICAgICAgIHZhciBwcmV2UG9zID0gYXJyW2xhc3REcmF3bkluZGV4XS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChwb3MgPiBwcmV2UG9zICsgcHJldkxhYmVsV2lkdGggKyAxMCkge1xuICAgICAgICAgICAgbGFzdERyYXduSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZmlsdGVyZWRBcnJheSA9IGZpbHRlcmVkQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmICE9PSBudWxsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRBcnJheTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGltZVNjYWxlO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQ29yZSBDbGFzcyByZXNwb25zaWJsZSBmb3IgbWFqb3IgY2FsY3VsYXRpb25zIGFuZCBjcmVhdGluZyBlbGVtZW50cy5cbiAqXG4gKiBAbW9kdWxlIENvcmVcbiAqKi9cblxudmFyIENvcmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb3JlKGVsLCBjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICB0aGlzLnR3b0RTZXJpZXMgPSBbXTtcbiAgICB0aGlzLnRocmVlRFNlcmllcyA9IFtdO1xuICAgIHRoaXMudHdvRFNlcmllc1ggPSBbXTtcbiAgfSAvLyBnZXQgZGF0YSBhbmQgc3RvcmUgaW50byBhcHByb3ByaWF0ZSB2YXJzXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29yZSwgW3tcbiAgICBrZXk6IFwic2V0dXBFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEVsZW1lbnRzKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZzsgLy8gY29uc3QgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpXG5cbiAgICAgIHZhciBjdCA9IGNuZi5jaGFydC50eXBlO1xuICAgICAgdmFyIGF4aXNDaGFydHNBcnJUeXBlcyA9IFsnbGluZScsICdhcmVhJywgJ2JhcicsICdyYW5nZUJhcicsIC8vICdyYW5nZUFyZWEnLFxuICAgICAgJ2NhbmRsZXN0aWNrJywgJ3JhZGFyJywgJ3NjYXR0ZXInLCAnYnViYmxlJywgJ2hlYXRtYXAnXTtcbiAgICAgIHZhciB4eUNoYXJ0c0FyclR5cGVzID0gWydsaW5lJywgJ2FyZWEnLCAnYmFyJywgJ3JhbmdlQmFyJywgLy8gJ3JhbmdlQXJlYScsXG4gICAgICAnY2FuZGxlc3RpY2snLCAnc2NhdHRlcicsICdidWJibGUnXTtcbiAgICAgIGdsLmF4aXNDaGFydHMgPSBheGlzQ2hhcnRzQXJyVHlwZXMuaW5kZXhPZihjdCkgPiAtMTtcbiAgICAgIGdsLnh5Q2hhcnRzID0geHlDaGFydHNBcnJUeXBlcy5pbmRleE9mKGN0KSA+IC0xO1xuICAgICAgZ2wuaXNCYXJIb3Jpem9udGFsID0gKGNuZi5jaGFydC50eXBlID09PSAnYmFyJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ3JhbmdlQmFyJykgJiYgY25mLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsO1xuICAgICAgZ2wuY2hhcnRDbGFzcyA9ICcuYXBleGNoYXJ0cycgKyBnbC5jdWlkO1xuICAgICAgZ2wuZG9tLmJhc2VFbCA9IHRoaXMuZWw7XG4gICAgICBnbC5kb20uZWxXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uZWxXcmFwLCB7XG4gICAgICAgIGlkOiBnbC5jaGFydENsYXNzLnN1YnN0cmluZygxKSxcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWNhbnZhcyAnICsgZ2wuY2hhcnRDbGFzcy5zdWJzdHJpbmcoMSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChnbC5kb20uZWxXcmFwKTtcbiAgICAgIGdsLmRvbS5QYXBlciA9IG5ldyB3aW5kb3cuU1ZHLkRvYyhnbC5kb20uZWxXcmFwKTtcbiAgICAgIGdsLmRvbS5QYXBlci5hdHRyKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXN2ZycsXG4gICAgICAgICd4bWxuczpkYXRhJzogJ0FwZXhDaGFydHNOUycsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGNuZi5jaGFydC5vZmZzZXRYLCBcIiwgXCIpLmNvbmNhdChjbmYuY2hhcnQub2Zmc2V0WSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGdsLmRvbS5QYXBlci5ub2RlLnN0eWxlLmJhY2tncm91bmQgPSBjbmYuY2hhcnQuYmFja2dyb3VuZDtcbiAgICAgIHRoaXMuc2V0U1ZHRGltZW5zaW9ucygpO1xuICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsID0gZ2wuZG9tLlBhcGVyLmdyb3VwKCkuYXR0cih7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1pbm5lciBhcGV4Y2hhcnRzLWdyYXBoaWNhbCdcbiAgICAgIH0pO1xuICAgICAgZ2wuZG9tLmVsRGVmcyA9IGdsLmRvbS5QYXBlci5kZWZzKCk7XG4gICAgICBnbC5kb20uZWxMZWdlbmRXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBnbC5kb20uZWxMZWdlbmRXcmFwLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICBnbC5kb20uZWxXcmFwLmFwcGVuZENoaWxkKGdsLmRvbS5lbExlZ2VuZFdyYXApOyAvLyBnbC5kb20uUGFwZXIuYWRkKGdsLmRvbS5lbExlZ2VuZFdyYXApXG5cbiAgICAgIGdsLmRvbS5QYXBlci5hZGQoZ2wuZG9tLmVsR3JhcGhpY2FsKTtcbiAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbC5hZGQoZ2wuZG9tLmVsRGVmcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsb3RDaGFydFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdENoYXJ0VHlwZShzZXIsIHh5UmF0aW9zKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciBsaW5lU2VyaWVzID0ge1xuICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICBpOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBhcmVhU2VyaWVzID0ge1xuICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICBpOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBzY2F0dGVyU2VyaWVzID0ge1xuICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICBpOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBjb2x1bW5TZXJpZXMgPSB7XG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIGk6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGNhbmRsZXN0aWNrU2VyaWVzID0ge1xuICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICBpOiBbXVxuICAgICAgfTtcbiAgICAgIGdsLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlcmllcywgc3QpIHtcbiAgICAgICAgLy8gaWYgdXNlciBoYXMgc3BlY2lmaWVkIGEgcGFydGljdWxhciB0eXBlIGZvciBwYXJ0aWN1bGFyIHNlcmllc1xuICAgICAgICBpZiAodHlwZW9mIHNlcltzdF0udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoc2VyW3N0XS50eXBlID09PSAnY29sdW1uJyB8fCBzZXJbc3RdLnR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgICB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCA9IGZhbHNlOyAvLyBob3Jpem9udGFsIGJhcnMgbm90IHN1cHBvcnRlZCBpbiBtaXhlZCBjaGFydHMsIGhlbmNlIGZvcmNlZnVsbHkgc2V0IHRvIGZhbHNlXG5cbiAgICAgICAgICAgIGNvbHVtblNlcmllcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgICAgICAgY29sdW1uU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdhcmVhJykge1xuICAgICAgICAgICAgYXJlYVNlcmllcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgICAgICAgYXJlYVNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIGxpbmVTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGxpbmVTZXJpZXMuaS5wdXNoKHN0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ3NjYXR0ZXInKSB7XG4gICAgICAgICAgICBzY2F0dGVyU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICAgICAgICBzY2F0dGVyU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdidWJibGUnKSA7IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZXIgaGFzIHNwZWNpZmllZCB0eXBlLCBidXQgaXQgaXMgbm90IHZhbGlkIChvdGhlciB0aGFuIGxpbmUvYXJlYS9jb2x1bW4pXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdSBoYXZlIHNwZWNpZmllZCBhbiB1bnJlY29nbml6ZWQgY2hhcnQgdHlwZS4gQXZhaWxhYmxlIHR5cGVzIGZvciB0aGlzIHByb3BlcnkgYXJlIGxpbmUvYXJlYS9jb2x1bW4vYmFyL3NjYXR0ZXIvYnViYmxlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuY29tYm9DaGFydHMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICBsaW5lU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgdmFyIGNhbmRsZXN0aWNrID0gbmV3IENhbmRsZVN0aWNrKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmFkaWFsQmFyID0gbmV3IFJhZGlhbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmFuZ2VCYXIgPSBuZXcgUmFuZ2VCYXIodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgIHZhciByYWRhciA9IG5ldyBSYWRhcih0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxHcmFwaCA9IFtdO1xuXG4gICAgICBpZiAoZ2wuY29tYm9DaGFydHMpIHtcbiAgICAgICAgaWYgKGFyZWFTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbEdyYXBoLnB1c2gobGluZS5kcmF3KGFyZWFTZXJpZXMuc2VyaWVzLCAnYXJlYScsIGFyZWFTZXJpZXMuaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtblNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICB2YXIgYmFyU3RhY2tlZCA9IG5ldyBCYXJTdGFja2VkKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICBlbEdyYXBoLnB1c2goYmFyU3RhY2tlZC5kcmF3KGNvbHVtblNlcmllcy5zZXJpZXMsIGNvbHVtblNlcmllcy5pKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiYXIgPSBuZXcgQmFyKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICBlbEdyYXBoLnB1c2goYmFyLmRyYXcoY29sdW1uU2VyaWVzLnNlcmllcywgY29sdW1uU2VyaWVzLmkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZVNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsR3JhcGgucHVzaChsaW5lLmRyYXcobGluZVNlcmllcy5zZXJpZXMsICdsaW5lJywgbGluZVNlcmllcy5pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FuZGxlc3RpY2tTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbEdyYXBoLnB1c2goY2FuZGxlc3RpY2suZHJhdyhjYW5kbGVzdGlja1Nlcmllcy5zZXJpZXMsIGNhbmRsZXN0aWNrU2VyaWVzLmkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2F0dGVyU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHNjYXR0ZXJMaW5lID0gbmV3IExpbmUodGhpcy5jdHgsIHh5UmF0aW9zLCB0cnVlKTtcbiAgICAgICAgICBlbEdyYXBoLnB1c2goc2NhdHRlckxpbmUuZHJhdyhzY2F0dGVyU2VyaWVzLnNlcmllcywgJ3NjYXR0ZXInLCBzY2F0dGVyU2VyaWVzLmkpKTtcbiAgICAgICAgfSAvLyBUT0RPOiBhbGxvdyBidWJibGUgc2VyaWVzIGluIGEgY29tYm8gY2hhcnRcbiAgICAgICAgLy8gaWYgKGJ1YmJsZVNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyAgIGNvbnN0IGJ1YmJsZUxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MsIHRydWUpXG4gICAgICAgIC8vICAgZWxHcmFwaC5wdXNoKFxuICAgICAgICAvLyAgICAgYnViYmxlTGluZS5kcmF3KGJ1YmJsZVNlcmllcy5zZXJpZXMsICdidWJibGUnLCBidWJibGVTZXJpZXMuaSlcbiAgICAgICAgLy8gICApXG4gICAgICAgIC8vIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjbmYuY2hhcnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgZWxHcmFwaCA9IGxpbmUuZHJhdyhnbC5zZXJpZXMsICdsaW5lJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2FyZWEnOlxuICAgICAgICAgICAgZWxHcmFwaCA9IGxpbmUuZHJhdyhnbC5zZXJpZXMsICdhcmVhJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgICAgICBpZiAoY25mLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9iYXJTdGFja2VkID0gbmV3IEJhclN0YWNrZWQodGhpcy5jdHgsIHh5UmF0aW9zKTtcblxuICAgICAgICAgICAgICBlbEdyYXBoID0gX2JhclN0YWNrZWQuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9iYXIgPSBuZXcgQmFyKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG5cbiAgICAgICAgICAgICAgZWxHcmFwaCA9IF9iYXIuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NhbmRsZXN0aWNrJzpcbiAgICAgICAgICAgIHZhciBjYW5kbGVTdGljayA9IG5ldyBDYW5kbGVTdGljayh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgZWxHcmFwaCA9IGNhbmRsZVN0aWNrLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFuZ2VCYXInOlxuICAgICAgICAgICAgZWxHcmFwaCA9IHJhbmdlQmFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaGVhdG1hcCc6XG4gICAgICAgICAgICB2YXIgaGVhdG1hcCA9IG5ldyBIZWF0TWFwKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICBlbEdyYXBoID0gaGVhdG1hcC5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BpZSc6XG4gICAgICAgICAgY2FzZSAnZG9udXQnOlxuICAgICAgICAgICAgZWxHcmFwaCA9IHBpZS5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JhZGlhbEJhcic6XG4gICAgICAgICAgICBlbEdyYXBoID0gcmFkaWFsQmFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkYXInOlxuICAgICAgICAgICAgZWxHcmFwaCA9IHJhZGFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxHcmFwaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U1ZHRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTVkdEaW1lbnNpb25zKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIGdsLnN2Z1dpZHRoID0gY25mLmNoYXJ0LndpZHRoO1xuICAgICAgZ2wuc3ZnSGVpZ2h0ID0gY25mLmNoYXJ0LmhlaWdodDtcbiAgICAgIHZhciBlbERpbSA9IFV0aWxzLmdldERpbWVuc2lvbnModGhpcy5lbCk7XG4gICAgICB2YXIgd2lkdGhVbml0ID0gY25mLmNoYXJ0LndpZHRoLnRvU3RyaW5nKCkuc3BsaXQoL1swLTldKy9nKS5wb3AoKTtcblxuICAgICAgaWYgKHdpZHRoVW5pdCA9PT0gJyUnKSB7XG4gICAgICAgIGlmIChVdGlscy5pc051bWJlcihlbERpbVswXSkpIHtcbiAgICAgICAgICBpZiAoZWxEaW1bMF0ud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIGVsRGltID0gVXRpbHMuZ2V0RGltZW5zaW9ucyh0aGlzLmVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLnN2Z1dpZHRoID0gZWxEaW1bMF0gKiBwYXJzZUludChjbmYuY2hhcnQud2lkdGgpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoVW5pdCA9PT0gJ3B4JyB8fCB3aWR0aFVuaXQgPT09ICcnKSB7XG4gICAgICAgIGdsLnN2Z1dpZHRoID0gcGFyc2VJbnQoY25mLmNoYXJ0LndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdsLnN2Z0hlaWdodCAhPT0gJ2F1dG8nICYmIGdsLnN2Z0hlaWdodCAhPT0gJycpIHtcbiAgICAgICAgdmFyIGhlaWdodFVuaXQgPSBjbmYuY2hhcnQuaGVpZ2h0LnRvU3RyaW5nKCkuc3BsaXQoL1swLTldKy9nKS5wb3AoKTtcblxuICAgICAgICBpZiAoaGVpZ2h0VW5pdCA9PT0gJyUnKSB7XG4gICAgICAgICAgdmFyIGVsUGFyZW50RGltID0gVXRpbHMuZ2V0RGltZW5zaW9ucyh0aGlzLmVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGdsLnN2Z0hlaWdodCA9IGVsUGFyZW50RGltWzFdICogcGFyc2VJbnQoY25mLmNoYXJ0LmhlaWdodCkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gcGFyc2VJbnQoY25mLmNoYXJ0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gZ2wuc3ZnV2lkdGggLyAxLjYxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnN2Z0hlaWdodCA9IGdsLnN2Z1dpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGdsLmRvbS5QYXBlci5ub2RlLCB7XG4gICAgICAgIHdpZHRoOiBnbC5zdmdXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBnbC5zdmdIZWlnaHRcbiAgICAgIH0pOyAvLyBnbC5kb20uUGFwZXIubm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUubWluV2lkdGggPSBnbC5zdmdXaWR0aCArIFwicHhcIjtcblxuICAgICAgdmFyIG9mZnNldFkgPSBjbmYuY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQgPyAwIDogZ2wuYXhpc0NoYXJ0cyA/IGNuZi5jaGFydC5wYXJlbnRIZWlnaHRPZmZzZXQgOiAwO1xuICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLm1pbkhlaWdodCA9IGdsLnN2Z0hlaWdodCArIG9mZnNldFkgKyAncHgnO1xuICAgICAgZ2wuZG9tLmVsV3JhcC5zdHlsZS53aWR0aCA9IGdsLnN2Z1dpZHRoICsgJ3B4JztcbiAgICAgIGdsLmRvbS5lbFdyYXAuc3R5bGUuaGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRHcmFwaFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0R3JhcGhQb3NpdGlvbigpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIHRZID0gZ2wudHJhbnNsYXRlWTtcbiAgICAgIHZhciB0WCA9IGdsLnRyYW5zbGF0ZVg7XG4gICAgICB2YXIgc2NhbGluZ0F0dHJzID0ge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRYICsgJywgJyArIHRZICsgJyknXG4gICAgICB9O1xuICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZ2wuZG9tLmVsR3JhcGhpY2FsLm5vZGUsIHNjYWxpbmdBdHRycyk7XG4gICAgfVxuICAgIC8qXG4gICAgICoqIEFsbCB0aGUgY2FsY3VsYXRpb25zIGZvciBzZXR0aW5nIHJhbmdlIGluIGNoYXJ0cyB3aWxsIGJlIGRvbmUgaGVyZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29yZUNhbGN1bGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3JlQ2FsY3VsYXRpb25zKCkge1xuICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlJDEodGhpcy5jdHgpO1xuICAgICAgcmFuZ2UuaW5pdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEdsb2JhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRHbG9iYWxzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICBnbC5zZXJpZXMgPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZU8gPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUggPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUwgPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUMgPSBbXTtcbiAgICAgIGdsLnNlcmllc1JhbmdlU3RhcnQgPSBbXTtcbiAgICAgIGdsLnNlcmllc1JhbmdlRW5kID0gW107XG4gICAgICBnbC5zZXJpZXNQZXJjZW50ID0gW107XG4gICAgICBnbC5zZXJpZXNYID0gW107XG4gICAgICBnbC5zZXJpZXNaID0gW107XG4gICAgICBnbC5zZXJpZXNOYW1lcyA9IFtdO1xuICAgICAgZ2wuc2VyaWVzVG90YWxzID0gW107XG4gICAgICBnbC5zdGFja2VkU2VyaWVzVG90YWxzID0gW107XG4gICAgICBnbC5sYWJlbHMgPSBbXTtcbiAgICAgIGdsLnRpbWVsaW5lTGFiZWxzID0gW107XG4gICAgICBnbC5ub0xhYmVsc1Byb3ZpZGVkID0gZmFsc2U7XG4gICAgICBnbC50aW1lc2NhbGVUaWNrcyA9IFtdO1xuICAgICAgZ2wucmVzaXplVGltZXIgPSBudWxsO1xuICAgICAgZ2wuc2VsZWN0aW9uUmVzaXplVGltZXIgPSBudWxsO1xuXG4gICAgICBnbC5zZXJpZXNYdmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9KCk7XG5cbiAgICAgIGdsLnNlcmllc1l2YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy53LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgIH0oKTtcblxuICAgICAgZ2wuZGVsYXllZEVsZW1lbnRzID0gW107XG4gICAgICBnbC5wb2ludHNBcnJheSA9IFtdO1xuICAgICAgZ2wuZGF0YUxhYmVsc1JlY3RzID0gW107XG4gICAgICBnbC5pc1hOdW1lcmljID0gZmFsc2U7XG4gICAgICBnbC5pc0RhdGFYWVogPSBmYWxzZTtcbiAgICAgIGdsLm1heFkgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLm1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgZ2wubWluWUFyciA9IFtdO1xuICAgICAgZ2wubWF4WUFyciA9IFtdO1xuICAgICAgZ2wubWF4WCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5pbml0aWFsbWF4WCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wuaW5pdGlhbG1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWF4RGF0ZSA9IDA7XG4gICAgICBnbC5taW5EYXRlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLm1pblogPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWF4WiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWERpZmYgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wueUF4aXNTY2FsZSA9IFtdO1xuICAgICAgZ2wueEF4aXNTY2FsZSA9IG51bGw7XG4gICAgICBnbC54QXhpc1RpY2tzUG9zaXRpb25zID0gW107XG4gICAgICBnbC55TGFiZWxzQ29vcmRzID0gW107XG4gICAgICBnbC55VGl0bGVDb29yZHMgPSBbXTtcbiAgICAgIGdsLnhSYW5nZSA9IDA7XG4gICAgICBnbC55UmFuZ2UgPSBbXTtcbiAgICAgIGdsLnpSYW5nZSA9IDA7XG4gICAgICBnbC5kYXRhUG9pbnRzID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNdWx0aXBsZVlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNdWx0aXBsZVkoKSB7XG4gICAgICAvLyB1c2VyIGhhcyBzdXBwbGllZCBhbiBhcnJheSBpbiB5YXhpcyBwcm9wZXJ0eS4gU28sIHR1cm4gb24gbXVsdGlwbGVZQXhpcyBmbGFnXG4gICAgICBpZiAodGhpcy53LmNvbmZpZy55YXhpcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgJiYgdGhpcy53LmNvbmZpZy55YXhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGZpcnN0LCB0dXJuIG9mZiBzdGFja2luZyBpZiBtdWx0aXBsZSB5IGF4aXNcbiAgICAgICAgdGhpcy53LmNvbmZpZy5jaGFydC5zdGFja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudy5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGNsdWRlQ29sbGFwc2VkU2VyaWVzSW5ZQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGNsdWRlQ29sbGFwc2VkU2VyaWVzSW5ZQXhpcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLm1hcChmdW5jdGlvbiAoY29sbGFwc2VkLCBpKSB7XG4gICAgICAgIGlmIChfdGhpczIudy5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAgIHJldHVybiBjb2xsYXBzZWQuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc011bHRpRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTXVsdGlGb3JtYXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Zvcm1hdFhZKCkgfHwgdGhpcy5pc0Zvcm1hdDJEQXJyYXkoKTtcbiAgICB9IC8vIGdpdmVuIGZvcm1hdCBpcyBbe3gsIHl9LCB7eCwgeX1dXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0Zvcm1hdFhZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRm9ybWF0WFkoKSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcbiAgICAgIHZhciBzciA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgdGhpcy5hY3RpdmVTZXJpZXNJbmRleCA9IHNyLmdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEgIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhLmxlbmd0aCA+IDAgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09IG51bGwgJiYgdHlwZW9mIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdLnggIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZ2l2ZW4gZm9ybWF0IGlzIFtbeCwgeV0sIFt4LCB5XV1cblxuICB9LCB7XG4gICAga2V5OiBcImlzRm9ybWF0MkRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zvcm1hdDJEQXJyYXkoKSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcbiAgICAgIHZhciBzciA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgdGhpcy5hY3RpdmVTZXJpZXNJbmRleCA9IHNyLmdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEgIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSAndW5kZWZpbmVkJyAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXSAhPT0gbnVsbCAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUZvcm1hdDJEQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRm9ybWF0MkRBcnJheShzZXIsIGkpIHtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXJbaV0uZGF0YVtqXVsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJbaV0uZGF0YVtqXVsxXSkgJiYgc2VyW2ldLmRhdGFbal1bMV0ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXMucHVzaChVdGlscy5wYXJzZU51bWJlcihzZXJbaV0uZGF0YVtqXVsxXVszXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXMucHVzaChVdGlscy5wYXJzZU51bWJlcihzZXJbaV0uZGF0YVtqXVsxXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLmRhdGFGb3JtYXRYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAvLyBpZiB0aW1lc3RhbXBzIGFyZSBwcm92aWRlZCBhbmQgeGF4aXMgdHlwZSBpcyBkYXRldHRpbWUsXG4gICAgICAgICAgdmFyIHRzID0gbmV3IERhdGUoc2VyW2ldLmRhdGFbal1bMF0pO1xuICAgICAgICAgIHRzID0gbmV3IERhdGUodHMpLmdldFRpbWUoKTtcbiAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2godHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChzZXJbaV0uZGF0YVtqXVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgX2orKykge1xuICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW19qXVsyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLnRocmVlRFNlcmllcy5wdXNoKHNlcltpXS5kYXRhW19qXVsyXSk7XG4gICAgICAgICAgZ2wuaXNEYXRhWFlaID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVGb3JtYXRYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGb3JtYXRYWShzZXIsIGkpIHtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIGFjdGl2ZUkgPSBpO1xuXG4gICAgICBpZiAoZ2wuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID4gLTEpIHtcbiAgICAgICAgLy8gZml4ICMzNjhcbiAgICAgICAgYWN0aXZlSSA9IHRoaXMuYWN0aXZlU2VyaWVzSW5kZXg7XG4gICAgICB9IC8vIGdldCBzZXJpZXNcblxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VyW2ldLmRhdGFbal0ueSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJbaV0uZGF0YVtqXS55KSkge1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal0ueVtzZXJbaV0uZGF0YVtqXS55Lmxlbmd0aCAtIDFdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHdvRFNlcmllcy5wdXNoKFV0aWxzLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdLnkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2V0IHNlcmllc1hcblxuXG4gICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBzZXJbYWN0aXZlSV0uZGF0YS5sZW5ndGg7IF9qMisrKSB7XG4gICAgICAgIHZhciBpc1hTdHJpbmcgPSB0eXBlb2Ygc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54ID09PSAnc3RyaW5nJztcbiAgICAgICAgdmFyIGlzWERhdGUgPSAhIWR0LmlzVmFsaWREYXRlKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueC50b1N0cmluZygpKTtcblxuICAgICAgICBpZiAoaXNYU3RyaW5nIHx8IGlzWERhdGUpIHtcbiAgICAgICAgICAvLyB1c2VyIHN1cHBsaWVkICcwMS8wMS8yMDE3JyBvciBhIGRhdGUgc3RyaW5nIChhIEpTIGRhdGUgb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgICAgaWYgKGlzWFN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmICFnbC5pc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goZHQucGFyc2VEYXRlKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYSBjYXRlZ29yeSBhbmQgbm90IGEgbnVtZXJpYyB4IHZhbHVlXG4gICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goZHQucGFyc2VEYXRlKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueC50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnbC5kYXRhRm9ybWF0WE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2gocGFyc2VGbG9hdChzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYSBudW1lcmljIHZhbHVlIGluIHggcHJvcGVydHlcbiAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VyW2ldLmRhdGFbMF0gJiYgdHlwZW9mIHNlcltpXS5kYXRhWzBdLnogIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgc2VyW2ldLmRhdGEubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB0aGlzLnRocmVlRFNlcmllcy5wdXNoKHNlcltpXS5kYXRhW3RdLnopO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuaXNEYXRhWFlaID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUmFuZ2VEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJhbmdlRGF0YShzZXIsIGkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIHJhbmdlID0ge307XG5cbiAgICAgIGlmICh0aGlzLmlzRm9ybWF0MkRBcnJheSgpKSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5oYW5kbGVSYW5nZURhdGFGb3JtYXQoJ2FycmF5Jywgc2VyLCBpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0Zvcm1hdFhZKCkpIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmhhbmRsZVJhbmdlRGF0YUZvcm1hdCgneHknLCBzZXIsIGkpO1xuICAgICAgfVxuXG4gICAgICBnbC5zZXJpZXNSYW5nZVN0YXJ0LnB1c2gocmFuZ2Uuc3RhcnQpO1xuICAgICAgZ2wuc2VyaWVzUmFuZ2VFbmQucHVzaChyYW5nZS5lbmQpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDYW5kbGVTdGlja0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2FuZGxlU3RpY2tEYXRhKHNlciwgaSkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgb2hsYyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5pc0Zvcm1hdDJEQXJyYXkoKSkge1xuICAgICAgICBvaGxjID0gdGhpcy5oYW5kbGVDYW5kbGVTdGlja0RhdGFGb3JtYXQoJ2FycmF5Jywgc2VyLCBpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0Zvcm1hdFhZKCkpIHtcbiAgICAgICAgb2hsYyA9IHRoaXMuaGFuZGxlQ2FuZGxlU3RpY2tEYXRhRm9ybWF0KCd4eScsIHNlciwgaSk7XG4gICAgICB9XG5cbiAgICAgIGdsLnNlcmllc0NhbmRsZU8ucHVzaChvaGxjLm8pO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlSC5wdXNoKG9obGMuaCk7XG4gICAgICBnbC5zZXJpZXNDYW5kbGVMLnB1c2gob2hsYy5sKTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUMucHVzaChvaGxjLmMpO1xuICAgICAgcmV0dXJuIG9obGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVJhbmdlRGF0YUZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSYW5nZURhdGFGb3JtYXQoZm9ybWF0LCBzZXIsIGkpIHtcbiAgICAgIHZhciByYW5nZVN0YXJ0ID0gW107XG4gICAgICB2YXIgcmFuZ2VFbmQgPSBbXTtcbiAgICAgIHZhciBlcnIgPSAnUGxlYXNlIHByb3ZpZGUgW1N0YXJ0LCBFbmRdIHZhbHVlcyBpbiB2YWxpZCBmb3JtYXQuIFJlYWQgbW9yZSBodHRwczovL2FwZXhjaGFydHMuY29tL2RvY3Mvc2VyaWVzLyNyYW5nZWNoYXJ0cyc7XG4gICAgICB2YXIgc2VyT2JqID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSBzZXJPYmouZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoKTtcblxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAoc2VyW2FjdGl2ZUluZGV4XS5kYXRhWzBdWzFdLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJhbmdlU3RhcnQucHVzaChzZXJbaV0uZGF0YVtqXVsxXVswXSk7XG4gICAgICAgICAgcmFuZ2VFbmQucHVzaChzZXJbaV0uZGF0YVtqXVsxXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAneHknKSB7XG4gICAgICAgIGlmIChzZXJbYWN0aXZlSW5kZXhdLmRhdGFbMF0ueS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IHNlcltpXS5kYXRhLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgICByYW5nZVN0YXJ0LnB1c2goc2VyW2ldLmRhdGFbX2ozXS55WzBdKTtcbiAgICAgICAgICByYW5nZUVuZC5wdXNoKHNlcltpXS5kYXRhW19qM10ueVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHJhbmdlU3RhcnQsXG4gICAgICAgIGVuZDogcmFuZ2VFbmRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNhbmRsZVN0aWNrRGF0YUZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDYW5kbGVTdGlja0RhdGFGb3JtYXQoZm9ybWF0LCBzZXIsIGkpIHtcbiAgICAgIHZhciBzZXJPID0gW107XG4gICAgICB2YXIgc2VySCA9IFtdO1xuICAgICAgdmFyIHNlckwgPSBbXTtcbiAgICAgIHZhciBzZXJDID0gW107XG4gICAgICB2YXIgZXJyID0gJ1BsZWFzZSBwcm92aWRlIFtPcGVuLCBIaWdoLCBMb3cgYW5kIENsb3NlXSB2YWx1ZXMgaW4gdmFsaWQgZm9ybWF0LiBSZWFkIG1vcmUgaHR0cHM6Ly9hcGV4Y2hhcnRzLmNvbS9kb2NzL3Nlcmllcy8jY2FuZGxlc3RpY2snO1xuXG4gICAgICBpZiAoZm9ybWF0ID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmIChzZXJbaV0uZGF0YVswXVsxXS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZXJPLnB1c2goc2VyW2ldLmRhdGFbal1bMV1bMF0pO1xuICAgICAgICAgIHNlckgucHVzaChzZXJbaV0uZGF0YVtqXVsxXVsxXSk7XG4gICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW2pdWzFdWzJdKTtcbiAgICAgICAgICBzZXJDLnB1c2goc2VyW2ldLmRhdGFbal1bMV1bM10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3h5Jykge1xuICAgICAgICBpZiAoc2VyW2ldLmRhdGFbMF0ueS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IHNlcltpXS5kYXRhLmxlbmd0aDsgX2o0KyspIHtcbiAgICAgICAgICBzZXJPLnB1c2goc2VyW2ldLmRhdGFbX2o0XS55WzBdKTtcbiAgICAgICAgICBzZXJILnB1c2goc2VyW2ldLmRhdGFbX2o0XS55WzFdKTtcbiAgICAgICAgICBzZXJMLnB1c2goc2VyW2ldLmRhdGFbX2o0XS55WzJdKTtcbiAgICAgICAgICBzZXJDLnB1c2goc2VyW2ldLmRhdGFbX2o0XS55WzNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvOiBzZXJPLFxuICAgICAgICBoOiBzZXJILFxuICAgICAgICBsOiBzZXJMLFxuICAgICAgICBjOiBzZXJDXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZURhdGFBeGlzQ2hhcnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRGF0YUF4aXNDaGFydHMoc2VyKSB7XG4gICAgICB2YXIgY3R4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmN0eDtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUoY3R4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy50d29EU2VyaWVzID0gW107XG4gICAgICAgIHRoaXMudHdvRFNlcmllc1ggPSBbXTtcbiAgICAgICAgdGhpcy50aHJlZURTZXJpZXMgPSBbXTtcblxuICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJdCBpcyBhIHBvc3NpYmlsaXR5IHRoYXQgeW91IG1heSBoYXZlIG5vdCBpbmNsdWRlZCAnZGF0YScgcHJvcGVydHkgaW4gc2VyaWVzLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUJhcicgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdyYW5nZUFyZWEnIHx8IHNlcltpXS50eXBlID09PSAncmFuZ2VCYXInIHx8IHNlcltpXS50eXBlID09PSAncmFuZ2VBcmVhJykge1xuICAgICAgICAgIGdsLmlzUmFuZ2VEYXRhID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhhbmRsZVJhbmdlRGF0YShzZXIsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aUZvcm1hdCgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRm9ybWF0MkRBcnJheShzZXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0Zvcm1hdFhZKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRm9ybWF0WFkoc2VyLCBpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgc2VyW2ldLnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FuZGxlU3RpY2tEYXRhKHNlciwgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuc2VyaWVzLnB1c2godGhpcy50d29EU2VyaWVzKTtcbiAgICAgICAgICBnbC5sYWJlbHMucHVzaCh0aGlzLnR3b0RTZXJpZXNYKTtcbiAgICAgICAgICBnbC5zZXJpZXNYLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5KSB7XG4gICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGRpZG4ndCBzdXBwbGllZCBbe3gseX1dIG9yIFtbeCx5XV0sIGJ1dCBzaW5nbGUgYXJyYXkgaW4gZGF0YS5cbiAgICAgICAgICAgIC8vIEFsc28gbGFiZWxzL2NhdGVnb3JpZXMgd2VyZSBzdXBwbGllZCBkaWZmZXJlbnRseVxuICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBjbmYubGFiZWxzLmxlbmd0aCA+IDAgPyBjbmYubGFiZWxzLnNsaWNlKCkgOiBjbmYueGF4aXMuY2F0ZWdvcmllcy5zbGljZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZXNbal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRGF0ZSA9IGR0LmlzVmFsaWREYXRlKGRhdGVzW2pdKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChkdC5wYXJzZURhdGUoZGF0ZXNbal0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBwcm92aWRlZCBpbnZhbGlkIERhdGUgZm9ybWF0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB4ID0gY25mLmxhYmVscy5sZW5ndGggPiAwID8gY25mLmxhYmVscy5zbGljZSgpIDogY25mLnhheGlzLmNhdGVnb3JpZXMuc2xpY2UoKTtcblxuICAgICAgICAgICAgaWYgKHgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYID0geDtcbiAgICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLmxhYmVscy5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgIHZhciBzaW5nbGVBcnJheSA9IHNlcltpXS5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlTnVtYmVyKGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdsLnNlcmllcy5wdXNoKHNpbmdsZUFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnNlcmllc1oucHVzaCh0aGlzLnRocmVlRFNlcmllcyk7XG5cbiAgICAgICAgaWYgKHNlcltpXS5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKHNlcltpXS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKCdzZXJpZXMtJyArIHBhcnNlSW50KGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRhTm9uQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGFOb25BeGlzQ2hhcnRzKHNlcikge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIGdsLnNlcmllcyA9IHNlci5zbGljZSgpO1xuICAgICAgZ2wuc2VyaWVzTmFtZXMgPSBjbmYubGFiZWxzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2wuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChnbC5zZXJpZXNOYW1lc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ2wuc2VyaWVzTmFtZXMucHVzaCgnc2VyaWVzLScgKyAoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53O1xuICAgIH1cbiAgICAvKiogVXNlciBwb3NzaWJseSBzZXQgc3RyaW5nIGNhdGVnb3JpZXMgaW4geGF4aXMuY2F0ZWdvcmllcyBvciBsYWJlbHMgcHJvcFxuICAgICAqIE9yIGRpZG4ndCBzZXQgeGF4aXMgbGFiZWxzIGF0IGFsbCAtIGluIHdoaWNoIGNhc2Ugd2UgbWFudWFsbHkgZG8gaXQuXG4gICAgICogSWYgdXNlciBwYXNzZWQgc2VyaWVzIGRhdGEgYXMgW1szLCAyXSwgWzQsIDVdXSBvciBbeyB4OiAzLCB5OiA1NSB9XSxcbiAgICAgKiB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWRcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBzZXIgLSB0aGUgc2VyaWVzIHdoaWNoIHVzZXIgcGFzc2VkIHRvIHRoZSBjb25maWdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV4dGVybmFsTGFiZWxzRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbExhYmVsc0RhdGEoc2VyKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuXG4gICAgICBpZiAoY25mLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB1c2VyIHByb3ZpZGVkIGxhYmVscyBpbiB4YXhpcy5jYXRlZ29yeSBwcm9wXG4gICAgICAgIGdsLmxhYmVscyA9IGNuZi54YXhpcy5jYXRlZ29yaWVzO1xuICAgICAgfSBlbHNlIGlmIChjbmYubGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gdXNlciBwcm92aWRlZCBsYWJlbHMgaW4gbGFiZWxzIHByb3BzXG4gICAgICAgIGdsLmxhYmVscyA9IGNuZi5sYWJlbHMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mYWxsYmFja1RvQ2F0ZWdvcnkpIHtcbiAgICAgICAgLy8gdXNlciBwcm92aWRlZCBsYWJlbHMgaW4geCBwcm9wIGluIFt7IHg6IDMsIHk6IDU1IH1dIGRhdGEsIGFuZCB0aG9zZSBsYWJlbHMgYXJlIGFscmVhZHkgc3RvcmVkIGluIGdsLmxhYmVsc1swXSwgc28ganVzdCByZS1hcnJhbmdlIHRoZSBnbC5sYWJlbHMgYXJyYXlcbiAgICAgICAgZ2wubGFiZWxzID0gZ2wubGFiZWxzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlciBkaWRuJ3QgcHJvdmlkZWQgYW55IGxhYmVscywgZmFsbGJhY2sgdG8gMS0yLTMtNC01XG4gICAgICAgIHZhciBsYWJlbEFyciA9IFtdO1xuXG4gICAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgLy8gZm9yIGF4aXMgY2hhcnRzLCB3ZSBnZXQgdGhlIGxvbmdlc3Qgc2VyaWVzIGFuZCBjcmVhdGUgbGFiZWxzIGZyb20gaXRcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllc1tnbC5tYXhWYWxzSW5BcnJheUluZGV4XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxBcnIucHVzaChpICsgMSk7XG4gICAgICAgICAgfSAvLyBjcmVhdGUgZ2wuc2VyaWVzWCBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gY2FsY3VsYXRpb25zIG9mIHggcG9zaXRpb25zXG5cblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2gobGFiZWxBcnIpO1xuICAgICAgICAgIH0gLy8gdHVybiBvbiB0aGUgaXNYTnVtZXJpYyBmbGFnIHRvIGFsbG93IG1pblggYW5kIG1heFggdG8gZnVuY3Rpb24gcHJvcGVybHlcblxuXG4gICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgIH0gLy8gbm8gc2VyaWVzIHRvIHB1bGwgbGFiZWxzIGZyb20sIHB1dCBhIDAtMTAgc2VyaWVzXG4gICAgICAgIC8vIHBvc3NpYmx5LCB1c2VyIGNvbGxhcHNlZCBhbGwgc2VyaWVzLiBIZW5jZSB3ZSBjYW4ndCB3b3JrIHdpdGggYWJvdmUgY2FsY1xuXG5cbiAgICAgICAgaWYgKGxhYmVsQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsQXJyID0gWzAsIDEwXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNlci5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2gobGFiZWxBcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBGaW5hbGx5LCBwYXNzIHRoZSBsYWJlbEFyciBpbiBnbC5sYWJlbHMgd2hpY2ggd2lsbCBiZSBwcmludGVkIG9uIHgtYXhpc1xuXG5cbiAgICAgICAgZ2wubGFiZWxzID0gbGFiZWxBcnI7IC8vIFR1cm4gb24gdGhpcyBnbG9iYWwgZmxhZyB0byBpbmRpY2F0ZSBubyBsYWJlbHMgd2VyZSBwcm92aWRlZCBieSB1c2VyXG5cbiAgICAgICAgZ2wubm9MYWJlbHNQcm92aWRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBTZWdyZWdhdGUgdXNlciBwcm92aWRlZCBkYXRhIGludG8gYXBwcm9wcmlhdGUgdmFyc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRGF0YShzZXIpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdGhpcy5leGNsdWRlQ29sbGFwc2VkU2VyaWVzSW5ZQXhpcygpOyAvLyBJZiB3ZSBkZXRlY3RlZCBzdHJpbmcgaW4gWCBwcm9wIG9mIHNlcmllcywgd2UgZmFsbGJhY2sgdG8gY2F0ZWdvcnkgeC1heGlzXG5cbiAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0R2xvYmFscygpO1xuICAgICAgdGhpcy5pc011bHRpcGxlWSgpO1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAvLyBheGlzQ2hhcnRzIGluY2x1ZGVzIGxpbmUgLyBhcmVhIC8gY29sdW1uIC8gc2NhdHRlclxuICAgICAgICB0aGlzLnBhcnNlRGF0YUF4aXNDaGFydHMoc2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbi1heGlzIGNoYXJ0cyBhcmUgcGllIC8gZG9udXRcbiAgICAgICAgdGhpcy5wYXJzZURhdGFOb25BeGlzQ2hhcnRzKHNlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29yZVV0aWxzLmdldExhcmdlc3RTZXJpZXMoKTsgLy8gc2V0IE51bGwgdmFsdWVzIHRvIDAgaW4gYWxsIHNlcmllcyB3aGVuIHVzZXIgaGlkZXMvc2hvd3Mgc29tZSBzZXJpZXNcblxuICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnYmFyJyAmJiBjbmYuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICB2YXIgc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICAgIGdsLnNlcmllcyA9IHNlcmllcy5zZXROdWxsU2VyaWVzVG9aZXJvVmFsdWVzKGdsLnNlcmllcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29yZVV0aWxzLmdldFNlcmllc1RvdGFscygpO1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICB0aGlzLmNvcmVVdGlscy5nZXRTdGFja2VkU2VyaWVzVG90YWxzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29yZVV0aWxzLmdldFBlcmNlbnRTZXJpZXMoKTtcblxuICAgICAgaWYgKCFnbC5kYXRhRm9ybWF0WE51bWVyaWMgJiYgKCFnbC5pc1hOdW1lcmljIHx8IGNuZi54YXhpcy50eXBlID09PSAnbnVtZXJpYycgJiYgY25mLmxhYmVscy5sZW5ndGggPT09IDAgJiYgY25mLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAvLyB4LWF4aXMgbGFiZWxzIGNvdWxkbid0IGJlIGRldGVjdGVkOyBoZW5jZSB0cnkgc2VhcmNoaW5nIGV2ZXJ5IG9wdGlvbiBpbiBjb25maWdcbiAgICAgICAgdGhpcy5oYW5kbGVFeHRlcm5hbExhYmVsc0RhdGEoc2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieHlTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4eVNldHRpbmdzKCkge1xuICAgICAgdmFyIHh5UmF0aW9zID0gbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgIHZhciBjcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuICAgICAgICAgIGNyb3NzaGFpcnMuZHJhd1hDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgdmFyIF9jcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuXG4gICAgICAgICAgX2Nyb3NzaGFpcnMuZHJhd1lDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4eVJhdGlvcyA9IHRoaXMuY29yZVV0aWxzLmdldENhbGN1bGF0ZWRSYXRpb3MoKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgdHMgPSBuZXcgVGltZVNjYWxlKHRoaXMuY3R4KTtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZVNjYWxlO1xuXG4gICAgICAgICAgaWYgKGlzRmluaXRlKHcuZ2xvYmFscy5taW5YKSAmJiBpc0Zpbml0ZSh3Lmdsb2JhbHMubWF4WCkgJiYgIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFRpbWVTY2FsZSA9IHRzLmNhbGN1bGF0ZVRpbWVTY2FsZVRpY2tzKHcuZ2xvYmFscy5taW5YLCB3Lmdsb2JhbHMubWF4WCk7XG4gICAgICAgICAgICB0cy5yZWNhbGNEaW1lbnNpb25zQmFzZWRPbkZvcm1hdChmb3JtYXR0ZWRUaW1lU2NhbGUsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFRpbWVTY2FsZSA9IHRzLmNhbGN1bGF0ZVRpbWVTY2FsZVRpY2tzKHcuZ2xvYmFscy5taW5ZLCB3Lmdsb2JhbHMubWF4WSk7XG4gICAgICAgICAgICB0cy5yZWNhbGNEaW1lbnNpb25zQmFzZWRPbkZvcm1hdChmb3JtYXR0ZWRUaW1lU2NhbGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geHlSYXRpb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBeGlzKHR5cGUsIHh5UmF0aW9zKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB5QXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzICYmIHR5cGUgIT09ICdyYWRhcicpIHtcbiAgICAgICAgdmFyIGVsWGF4aXMsIGVsWWF4aXM7XG5cbiAgICAgICAgaWYgKGdsLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIGVsWWF4aXMgPSB5QXhpcy5kcmF3WWF4aXNJbnZlcnNlZCgwKTtcbiAgICAgICAgICBlbFhheGlzID0geEF4aXMuZHJhd1hheGlzSW52ZXJzZWQoMCk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbFhheGlzKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsWWF4aXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsWGF4aXMgPSB4QXhpcy5kcmF3WGF4aXMoKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsWGF4aXMpO1xuICAgICAgICAgIGNuZi55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoZ2wuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICAgICAgICBlbFlheGlzID0geUF4aXMuZHJhd1lheGlzKGluZGV4KTtcbiAgICAgICAgICAgICAgZ2wuZG9tLlBhcGVyLmFkZChlbFlheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAoZ2wuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICAgIHlBeGlzLnlBeGlzVGl0bGVSb3RhdGUoaW5kZXgsIHlheGUub3Bwb3NpdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBCcnVzaEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBCcnVzaEhhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG9ubHkgZm9yIGJydXNoIGNoYXJ0c1xuXG4gICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0LmJydXNoLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpZiB1c2VyIGhhcyBub3QgZGVmaW5lZCBhIGN1c3RvbSBmdW5jdGlvbiBmb3Igc2VsZWN0aW9uIC0gd2UgaGFuZGxlIHRoZSBicnVzaCBjaGFydFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlIGxlYXZlIGl0IHRvIHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgZnVuY3Rpb25hbGl0eSBmb3Igc2VsZWN0aW9uXG5cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0YXJnZXRzID0gdy5jb25maWcuY2hhcnQuYnJ1c2gudGFyZ2V0cyB8fCBbdy5jb25maWcuY2hhcnQuYnJ1c2gudGFyZ2V0XTsgLy8gcmV0cm8gY29tcGF0aWJpbGl0eSB3aXRoIHNpbmdsZSB0YXJnZXQgb3B0aW9uXG5cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0Q2hhcnQgPSBBcGV4Q2hhcnRzLmdldENoYXJ0QnlJRCh0YXJnZXQpO1xuICAgICAgICAgIHRhcmdldENoYXJ0LncuZ2xvYmFscy5icnVzaFNvdXJjZSA9IF90aGlzMy5jdHg7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlU291cmNlQ2hhcnQgPSBmdW5jdGlvbiB1cGRhdGVTb3VyY2VDaGFydCgpIHtcbiAgICAgICAgICAgIF90aGlzMy5jdHguX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0YXJnZXRDaGFydC53Lmdsb2JhbHMubWluWCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiB0YXJnZXRDaGFydC53Lmdsb2JhbHMubWF4WFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGRhdGVTb3VyY2VDaGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldENoYXJ0LncuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnNjcm9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGRhdGVTb3VyY2VDaGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID0gZnVuY3Rpb24gKGNoYXJ0LCBlKSB7XG4gICAgICAgICAgICB2YXIgeWF4aXMgPSBVdGlscy5jbG9uZSh3LmNvbmZpZy55YXhpcyk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5icnVzaC5hdXRvU2NhbGVZYXhpcykge1xuICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBuZXcgUmFuZ2UodGFyZ2V0Q2hhcnQpO1xuICAgICAgICAgICAgICB5YXhpcyA9IHNjYWxlLmF1dG9TY2FsZVkodGFyZ2V0Q2hhcnQsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRDaGFydC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgbWluOiBlLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IGUueGF4aXMubWF4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvcmU7XG59KCk7XG5cbi8qKlxuICogQHRoaXMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIGZpbmFsbHlDb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gUHJvbWlzZSQxKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlJDEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlJDEuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgIGlmIChcbiAgICAgIG5ld1ZhbHVlICYmXG4gICAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlJDEpIHtcbiAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3Qoc2VsZiwgZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHNlbGYuX3N0YXRlID0gMjtcbiAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIFByb21pc2UkMS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZSQxLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gIH1cbiAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKFxuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChzZWxmLCBleCk7XG4gIH1cbn1cblxuUHJvbWlzZSQxLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlJDEucHJvdG90eXBlWydmaW5hbGx5J10gPSBmaW5hbGx5Q29uc3RydWN0b3I7XG5cblByb21pc2UkMS5hbGwgPSBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFhcnIgfHwgdHlwZW9mIGFyci5sZW5ndGggPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZSQxLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSQxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UkMS5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UkMS5yYWNlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZSQxLl9pbW1lZGlhdGVGbiA9XG4gICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSkgfHxcbiAgZnVuY3Rpb24oZm4pIHtcbiAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gIH07XG5cblByb21pc2UkMS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9XG59O1xuXG52YXIgRXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cG9ydHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cG9ydHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXhwb3J0cywgW3tcbiAgICBrZXk6IFwiZ2V0U3ZnU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN2Z1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uUGFwZXIuc3ZnKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBoaWRlIHNvbWUgZWxlbWVudHMgdG8gYXZvaWQgcHJpbnRpbmcgdGhlbSBvbiBleHBvcnRlZCBzdmdcblxuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGNyb3NzaGFpcnMnKTtcbiAgICAgIHZhciB5Y3Jvc3NoYWlycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzJyk7XG5cbiAgICAgIGlmICh4Y3Jvc3NoYWlycykge1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3gnLCAtNTAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHljcm9zc2hhaXJzKSB7XG4gICAgICAgIHljcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneTEnLCAtMTAwKTtcbiAgICAgICAgeWNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd5MicsIC0xMDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdmdVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ZnVXJsKCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB2YXIgc3ZnRGF0YSA9IHRoaXMuZ2V0U3ZnU3RyaW5nKCk7XG4gICAgICB2YXIgc3ZnQmxvYiA9IG5ldyBCbG9iKFtzdmdEYXRhXSwge1xuICAgICAgICB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04J1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVVSSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhVVJJKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHcgPSBfdGhpcy53O1xuXG4gICAgICAgIF90aGlzLmNsZWFudXAoKTtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHcuZ2xvYmFscy5zdmdXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHcuZ2xvYmFscy5zdmdIZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNCZyA9IHcuY29uZmlnLmNoYXJ0LmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCcgPyAnI2ZmZicgOiB3LmNvbmZpZy5jaGFydC5iYWNrZ3JvdW5kO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjYW52YXNCZztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHZhciBET01VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXG4gICAgICAgIHZhciBzdmdEYXRhID0gX3RoaXMuZ2V0U3ZnU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIHN2Z1VybCA9ICdkYXRhOmltYWdlL3N2Zyt4bWwsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmdEYXRhKTtcblxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICBET01VUkwucmV2b2tlT2JqZWN0VVJMKHN2Z1VybCk7XG4gICAgICAgICAgdmFyIGltZ1VSSSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgIHJlc29sdmUoaW1nVVJJKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpbWcuc3JjID0gc3ZnVXJsO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4cG9ydFRvU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFRvU1ZHKCkge1xuICAgICAgdGhpcy50cmlnZ2VyRG93bmxvYWQodGhpcy5zdmdVcmwoKSwgJy5zdmcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0VG9QbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0VG9QbmcoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5kYXRhVVJJKCkudGhlbihmdW5jdGlvbiAoaW1nVVJJKSB7XG4gICAgICAgIF90aGlzMi50cmlnZ2VyRG93bmxvYWQoaW1nVVJJLCAnLnBuZycpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyaWdnZXJEb3dubG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyRG93bmxvYWQoaHJlZiwgZXh0KSB7XG4gICAgICB2YXIgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBocmVmO1xuICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gdGhpcy53Lmdsb2JhbHMuY2hhcnRJRCArIGV4dDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHBvcnRzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgR3JpZCBDbGFzcyBmb3IgZHJhd2luZyBDYXJ0ZXNpYW4gR3JpZC5cbiAqXG4gKiBAbW9kdWxlIEdyaWRcbiAqKi9cblxudmFyIEdyaWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcmlkKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpO1xuICAgIHRoaXMuYW5pbVggPSB3LmNvbmZpZy5ncmlkLnhheGlzLmxpbmVzLmFuaW1hdGUgJiYgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgIHRoaXMuYW5pbVkgPSB3LmNvbmZpZy5ncmlkLnlheGlzLmxpbmVzLmFuaW1hdGUgJiYgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuXG4gICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyAgdGltZWxpbmUgbGFiZWxzIGFyZSB0aGVyZVxuICAgICAgdGhpcy54YXhpc0xhYmVscyA9IHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5zbGljZSgpO1xuICAgIH1cbiAgfSAvLyAud2hlbiB1c2luZyBzcGFya2xpbmVzIG9yIHdoZW4gc2hvd2luZyBubyBncmlkLCB3ZSBuZWVkIHRvIGhhdmUgYSBncmlkIGFyZWEgd2hpY2ggaXMgcmV1c2VkIGF0IG1hbnkgcGxhY2VzIGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYXMgd2VsbFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEdyaWQsIFt7XG4gICAga2V5OiBcImRyYXdHcmlkQXJlYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JpZEFyZWEoKSB7XG4gICAgICB2YXIgZWxHcmlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuXG4gICAgICBpZiAoZWxHcmlkID09PSBudWxsKSB7XG4gICAgICAgIGVsR3JpZCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZ3JpZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsLCAxLCB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsICd0cmFuc3BhcmVudCcpO1xuICAgICAgdmFyIGVsSG9yekxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0LCAndHJhbnNwYXJlbnQnKTtcbiAgICAgIGVsR3JpZC5hZGQoZWxIb3J6TGluZSk7XG4gICAgICBlbEdyaWQuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgIHJldHVybiBlbEdyaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdHcmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgdmFyIHlheGlzID0gbmV3IFlBeGlzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGVsZ3JpZCA9IG51bGw7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnNob3cpIHtcbiAgICAgICAgICAvLyBncmlkIGlzIGRyYXduIGFmdGVyIHhheGlzIGFuZCB5YXhpcyBhcmUgZHJhd25cbiAgICAgICAgICBlbGdyaWQgPSB0aGlzLnJlbmRlckdyaWQoKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsZ3JpZC5lbCk7XG4gICAgICAgICAgdGhpcy5kcmF3R3JpZEFyZWEoZWxncmlkLmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZWxncmlkQXJlYSA9IHRoaXMuZHJhd0dyaWRBcmVhKCk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbGdyaWRBcmVhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGdyaWQgIT09IG51bGwpIHtcbiAgICAgICAgICB4QXhpcy54QXhpc0xhYmVsQ29ycmVjdGlvbnMoZWxncmlkLnhBeGlzVGlja1dpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlheGlzLnNldFlBeGlzVGV4dEFsaWdubWVudHMoKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgbWFzayB3aWxsIGNsaXAgb2ZmIG92ZXJmbG93aW5nIGdyYXBoaWNzIGZyb20gdGhlIGRyYXdhYmxlIGFyZWFcblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUdyaWRNYXNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUdyaWRNYXNrKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHN0cm9rZVNpemUgPSBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS53aWR0aCkgPyAwIDogdy5jb25maWcuc3Ryb2tlLndpZHRoO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpKSB7XG4gICAgICAgIHZhciBzdHJva2VNYXhTaXplID0gMDtcbiAgICAgICAgdy5jb25maWcuc3Ryb2tlLndpZHRoLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBzdHJva2VNYXhTaXplID0gTWF0aC5tYXgoc3Ryb2tlTWF4U2l6ZSwgbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJva2VTaXplID0gc3Ryb2tlTWF4U2l6ZTtcbiAgICAgIH1cblxuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGdsLlNWR05TLCAnY2xpcFBhdGgnKTtcbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgXCJncmlkUmVjdE1hc2tcIi5jb25jYXQoZ2wuY3VpZCkpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGdsLlNWR05TLCAnY2xpcFBhdGgnKTtcbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyTWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgXCJncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQoZ2wuY3VpZCkpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCgtc3Ryb2tlU2l6ZSAvIDIsIC1zdHJva2VTaXplIC8gMiwgZ2wuZ3JpZFdpZHRoICsgc3Ryb2tlU2l6ZSwgZ2wuZ3JpZEhlaWdodCArIHN0cm9rZVNpemUsIDAsICcjZmZmJyk7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzKTtcbiAgICAgIGNvcmVVdGlscy5nZXRMYXJnZXN0TWFya2VyU2l6ZSgpO1xuICAgICAgdmFyIG1hcmtlclNpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldCArIDE7XG4gICAgICBpZiAobWFya2VyU2l6ZSA8IDEwKSBtYXJrZXJTaXplID0gMTA7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hcmtlciA9IGdyYXBoaWNzLmRyYXdSZWN0KC1tYXJrZXJTaXplICogMiwgLW1hcmtlclNpemUgKiAyLCBnbC5ncmlkV2lkdGggKyBtYXJrZXJTaXplICogNCwgZ2wuZ3JpZEhlaWdodCArIG1hcmtlclNpemUgKiA0LCAwLCAnI2ZmZicpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXNrLmFwcGVuZENoaWxkKGdsLmRvbS5lbEdyaWRSZWN0Lm5vZGUpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrLmFwcGVuZENoaWxkKGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyLm5vZGUpO1xuICAgICAgdmFyIGRlZnMgPSBnbC5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3RNYXNrKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrKTtcbiAgICB9IC8vIGFjdHVhbCBncmlkIHJlbmRlcmluZ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyR3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJHcmlkKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IHcuY29uZmlnLmdyaWQuc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgdmFyIGVsZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWdyaWQnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbGdyaWRMaW5lc0ggPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1ncmlkbGluZXMtaG9yaXpvbnRhbCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGVsZ3JpZExpbmVzViA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWdyaWRsaW5lcy12ZXJ0aWNhbCdcbiAgICAgIH0pO1xuICAgICAgZWxnLmFkZChlbGdyaWRMaW5lc0gpO1xuICAgICAgZWxnLmFkZChlbGdyaWRMaW5lc1YpO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSA4O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMueUF4aXNTY2FsZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aWNrQW1vdW50ID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbaV0ucmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlja0Ftb3VudCA+IDIpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgeENvdW50O1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgeENvdW50ID0gdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7IC8vIGRyYXcgdmVydGljYWwgbGluZXNcblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93IHx8IHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgICAgdmFyIHgxID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG4gICAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgICB2YXIgeDI7XG4gICAgICAgICAgdmFyIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB4Q291bnQ7IF9pKyspIHtcbiAgICAgICAgICAgICAgeDEgPSB0aGlzLnhheGlzTGFiZWxzW19pXS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgeDIgPSB0aGlzLnhheGlzTGFiZWxzW19pXS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93ICYmIHgxID4gMCAmJiB4MSA8IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyLCB3LmNvbmZpZy5ncmlkLmJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuICAgICAgICAgICAgICAgIGxpbmUubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRsaW5lJyk7XG4gICAgICAgICAgICAgICAgZWxncmlkTGluZXNWLmFkZChsaW5lKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1YKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKGxpbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyOiAwXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHgyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgICAgICAgICB4QXhpcy5kcmF3WGF4aXNUaWNrcyh4MSwgZWxnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzID0geENvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0czsgX2kyKyspIHtcbiAgICAgICAgICAgICAgdmFyIHgxQ291bnQgPSB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cztcblxuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2JhcicpIHtcbiAgICAgICAgICAgICAgICB4MUNvdW50IC09IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHgxQ291bnQ7XG4gICAgICAgICAgICAgIHgyID0geDE7IC8vIHNraXAgdGhlIGxhc3QgbGluZVxuXG4gICAgICAgICAgICAgIGlmIChfaTIgPT09IHgxQ291bnQgLSAxKSBicmVhaztcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9saW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUoeDEsIHkxLCB4MiwgeTIsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgICAgICBfbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZGxpbmUnKTtcblxuICAgICAgICAgICAgICAgIGVsZ3JpZExpbmVzVi5hZGQoX2xpbmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbVgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUxpbmUoX2xpbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyOiAwXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHgyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX3hBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcblxuICAgICAgICAgICAgICBfeEF4aXMuZHJhd1hheGlzVGlja3MoeDEsIGVsZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueWF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgIHZhciBfeCA9IDA7XG4gICAgICAgICAgdmFyIF95ID0gMDtcbiAgICAgICAgICB2YXIgX3kyID0gMDtcbiAgICAgICAgICB2YXIgX3gyID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHRpY2tBbW91bnQgKyAxOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIF9saW5lMiA9IGdyYXBoaWNzLmRyYXdMaW5lKF94LCBfeSwgX3gyLCBfeTIsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgIGVsZ3JpZExpbmVzSC5hZGQoX2xpbmUyKTtcblxuICAgICAgICAgICAgX2xpbmUyLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmltWSkge1xuICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKF9saW5lMiwge1xuICAgICAgICAgICAgICAgIHkxOiBfeSArIDIwLFxuICAgICAgICAgICAgICAgIHkyOiBfeTIgKyAyMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeTE6IF95LFxuICAgICAgICAgICAgICAgIHkyOiBfeTJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF95ID0gX3kgKyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgICAgICBfeTIgPSBfeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhDb3VudCA9IHRpY2tBbW91bnQ7IC8vIGRyYXcgdmVydGljYWwgbGluZXNcblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93IHx8IHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgICAgdmFyIF94MyA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgICAgIHZhciBfeTMgPSAwO1xuXG4gICAgICAgICAgdmFyIF94NDtcblxuICAgICAgICAgIHZhciBfeTQgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHhDb3VudCArIDE7IF9pNCsrKSB7XG4gICAgICAgICAgICBfeDMgPSBfeDMgKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50ICsgMC4zO1xuICAgICAgICAgICAgX3g0ID0gX3gzOyAvLyBza2lwIHRoZSBsYXN0IHZlcnRpY2FsIGxpbmVcblxuICAgICAgICAgICAgaWYgKF9pNCA9PT0geENvdW50IC0gMSkgYnJlYWs7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnhheGlzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICAgICAgdmFyIF9saW5lMyA9IGdyYXBoaWNzLmRyYXdMaW5lKF94MywgX3kzLCBfeDQsIF95NCwgdy5jb25maWcuZ3JpZC5ib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcblxuICAgICAgICAgICAgICBfbGluZTMubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRsaW5lJyk7XG5cbiAgICAgICAgICAgICAgZWxncmlkTGluZXNWLmFkZChfbGluZTMpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1YKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlTGluZShfbGluZTMsIHtcbiAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgeDI6IDBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICB4MTogX3gzLFxuICAgICAgICAgICAgICAgICAgeDI6IF94NFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHNraXAgdGhlIGZpcnN0IHZlcnRpY2FsIGxpbmVcblxuXG4gICAgICAgICAgICB2YXIgX3hBeGlzMiA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgIF94QXhpczIuZHJhd1hheGlzVGlja3MoX3gzLCBlbGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBkcmF3IGhvcml6b250YWwgbGluZXNcblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnlheGlzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICB2YXIgX3g1ID0gMDtcbiAgICAgICAgICB2YXIgX3k1ID0gMDtcbiAgICAgICAgICB2YXIgX3k2ID0gMDtcbiAgICAgICAgICB2YXIgX3g2ID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzICsgMTsgX2k1KyspIHtcbiAgICAgICAgICAgIHZhciBfbGluZTQgPSBncmFwaGljcy5kcmF3TGluZShfeDUsIF95NSwgX3g2LCBfeTYsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgIGVsZ3JpZExpbmVzSC5hZGQoX2xpbmU0KTtcblxuICAgICAgICAgICAgX2xpbmU0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmltWSkge1xuICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKF9saW5lNCwge1xuICAgICAgICAgICAgICAgIHkxOiBfeTUgKyAyMCxcbiAgICAgICAgICAgICAgICB5MjogX3k2ICsgMjBcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHkxOiBfeTUsXG4gICAgICAgICAgICAgICAgeTI6IF95NlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3k1ID0gX3k1ICsgdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgICAgIF95NiA9IF95NTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3R3JpZEJhbmRzKGVsZywgeENvdW50LCB0aWNrQW1vdW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsOiBlbGcsXG4gICAgICAgIHhBeGlzVGlja1dpZHRoOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3R3JpZEJhbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkQmFuZHMoZWxnLCB4Q291bnQsIHRpY2tBbW91bnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTsgLy8gcm93cyBiYWNrZ3JvdW5kIGJhbmRzXG5cbiAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgeDEgPSAwO1xuICAgICAgICB2YXIgeTEgPSAwO1xuICAgICAgICB2YXIgeTIgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgIHZhciB4MiA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMgPSAwOyBpIDwgdGlja0Ftb3VudDsgaSsrLCBjKyspIHtcbiAgICAgICAgICBpZiAoYyA+PSB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnNbY107XG4gICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCh4MSwgeTEsIHgyLCB5MiwgMCwgY29sb3IsIHcuY29uZmlnLmdyaWQucm93Lm9wYWNpdHkpO1xuICAgICAgICAgIGVsZy5hZGQocmVjdCk7XG4gICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZFJvdycpO1xuICAgICAgICAgIHkxID0geTEgKyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29sdW1ucyBiYWNrZ3JvdW5kIGJhbmRzXG5cblxuICAgICAgaWYgKHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfeDcgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcbiAgICAgICAgdmFyIF95NyA9IDA7XG5cbiAgICAgICAgdmFyIF94OCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudDtcblxuICAgICAgICB2YXIgX3k4ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX2MgPSAwOyBfaTYgPCB4Q291bnQ7IF9pNisrLCBfYysrKSB7XG4gICAgICAgICAgaWYgKF9jID49IHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIF9jID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2NvbG9yID0gdy5jb25maWcuZ3JpZC5jb2x1bW4uY29sb3JzW19jXTtcblxuICAgICAgICAgIHZhciBfcmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KF94NywgX3k3LCBfeDgsIF95OCwgMCwgX2NvbG9yLCB3LmNvbmZpZy5ncmlkLmNvbHVtbi5vcGFjaXR5KTtcblxuICAgICAgICAgIF9yZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkQ29sdW1uJyk7XG5cbiAgICAgICAgICBlbGcuYWRkKF9yZWN0KTtcbiAgICAgICAgICBfeDcgPSBfeDcgKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVMaW5lKGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBpbml0aWFsQW5pbSA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnM7XG5cbiAgICAgIGlmIChpbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgc3BlZWQgPSBpbml0aWFsQW5pbS5zcGVlZDtcbiAgICAgICAgdGhpcy5hbmltLmFuaW1hdGVMaW5lKGxpbmUsIGZyb20sIHRvLCBzcGVlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyaWQ7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBMZWdlbmQgQ2xhc3MgdG8gZHJhdyBsZWdlbmQuXG4gKlxuICogQG1vZHVsZSBMZWdlbmRcbiAqKi9cblxudmFyIExlZ2VuZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExlZ2VuZChjdHgsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVnZW5kKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMub25MZWdlbmRDbGljayA9IHRoaXMub25MZWdlbmRDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25MZWdlbmRIb3ZlcmVkID0gdGhpcy5vbkxlZ2VuZEhvdmVyZWQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZWdlbmQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIHNob3dMZWdlbmRBbHdheXMgPSBjbmYubGVnZW5kLnNob3dGb3JTaW5nbGVTZXJpZXMgJiYgZ2wuc2VyaWVzLmxlbmd0aCA9PT0gMSB8fCBnbC5zZXJpZXMubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKChzaG93TGVnZW5kQWx3YXlzIHx8ICFnbC5heGlzQ2hhcnRzKSAmJiBjbmYubGVnZW5kLnNob3cpIHtcbiAgICAgICAgd2hpbGUgKGdsLmRvbS5lbExlZ2VuZFdyYXAuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAucmVtb3ZlQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0xlZ2VuZHMoKTtcblxuICAgICAgICBpZiAoIVV0aWxzLmlzSUUxMSgpKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb0ZvcmVpZ25PYmplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydHMgZm9yZWlnbk9iamVjdCwgaGVuY2UgYXBwZW5kIGl0IHRvIDxoZWFkPlxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQodGhpcy5nZXRMZWdlbmRTdHlsZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZEFsaWduSG9yaXpvbnRhbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcgfHwgY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRBbGlnblZlcnRpY2FsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVG9Gb3JlaWduT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRvRm9yZWlnbk9iamVjdCgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGVsRm9yZWlnbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhnbC5TVkdOUywgJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZ2wuc3ZnV2lkdGgpO1xuICAgICAgZWxGb3JlaWduLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgZ2wuc3ZnSGVpZ2h0KTtcbiAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyk7XG4gICAgICBlbEZvcmVpZ24uYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcCk7XG4gICAgICBlbEZvcmVpZ24uYXBwZW5kQ2hpbGQodGhpcy5nZXRMZWdlbmRTdHlsZXMoKSk7XG4gICAgICBnbC5kb20uUGFwZXIubm9kZS5pbnNlcnRCZWZvcmUoZWxGb3JlaWduLCBnbC5kb20uZWxHcmFwaGljYWwubm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMZWdlbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMZWdlbmRzKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHcuY29uZmlnLmxlZ2VuZC5mb250RmFtaWx5O1xuICAgICAgdmFyIGxlZ2VuZE5hbWVzID0gdy5nbG9iYWxzLnNlcmllc05hbWVzO1xuICAgICAgdmFyIGZpbGxjb2xvciA9IHcuZ2xvYmFscy5jb2xvcnMuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5jb2xvclNjYWxlLnJhbmdlcztcbiAgICAgICAgbGVnZW5kTmFtZXMgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChjb2xvclNjYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yU2NhbGUubmFtZSA/IGNvbG9yU2NhbGUubmFtZSA6IGNvbG9yU2NhbGUuZnJvbSArICcgLSAnICsgY29sb3JTY2FsZS50bztcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGxjb2xvciA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yLmNvbG9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZ2VuZEZvcm1hdHRlciA9IHcuZ2xvYmFscy5sZWdlbmRGb3JtYXR0ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxlZ2VuZE5hbWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IGxlZ2VuZEZvcm1hdHRlcihsZWdlbmROYW1lc1tpXSwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb2xsYXBzZWRTZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzW2NdLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgIGNvbGxhcHNlZFNlcmllcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXNbX2NdID09PSBpKSB7XG4gICAgICAgICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsTWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBlbE1hcmtlci5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKTtcbiAgICAgICAgdmFyIG1PZmZzZXRYID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgdmFyIG1PZmZzZXRZID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMub2Zmc2V0WTtcbiAgICAgICAgdmFyIG1IZWlnaHQgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5oZWlnaHQ7XG4gICAgICAgIHZhciBtV2lkdGggPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy53aWR0aDtcbiAgICAgICAgdmFyIG1Cb3JkZXJXaWR0aCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgbUJvcmRlckNvbG9yID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuc3Ryb2tlQ29sb3I7XG4gICAgICAgIHZhciBtQm9yZGVyUmFkaXVzID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMucmFkaXVzO1xuICAgICAgICB2YXIgbVN0eWxlID0gZWxNYXJrZXIuc3R5bGU7XG4gICAgICAgIG1TdHlsZS5iYWNrZ3JvdW5kID0gZmlsbGNvbG9yW2ldO1xuICAgICAgICBtU3R5bGUuY29sb3IgPSBmaWxsY29sb3JbaV07XG4gICAgICAgIG1TdHlsZS5oZWlnaHQgPSBBcnJheS5pc0FycmF5KG1IZWlnaHQpID8gcGFyc2VGbG9hdChtSGVpZ2h0W2ldKSArICdweCcgOiBwYXJzZUZsb2F0KG1IZWlnaHQpICsgJ3B4JztcbiAgICAgICAgbVN0eWxlLndpZHRoID0gQXJyYXkuaXNBcnJheShtV2lkdGgpID8gcGFyc2VGbG9hdChtV2lkdGhbaV0pICsgJ3B4JyA6IHBhcnNlRmxvYXQobVdpZHRoKSArICdweCc7XG4gICAgICAgIG1TdHlsZS5sZWZ0ID0gQXJyYXkuaXNBcnJheShtT2Zmc2V0WCkgPyBtT2Zmc2V0WFtpXSA6IG1PZmZzZXRYO1xuICAgICAgICBtU3R5bGUudG9wID0gQXJyYXkuaXNBcnJheShtT2Zmc2V0WSkgPyBtT2Zmc2V0WVtpXSA6IG1PZmZzZXRZO1xuICAgICAgICBtU3R5bGUuYm9yZGVyV2lkdGggPSBBcnJheS5pc0FycmF5KG1Cb3JkZXJXaWR0aCkgPyBtQm9yZGVyV2lkdGhbaV0gOiBtQm9yZGVyV2lkdGg7XG4gICAgICAgIG1TdHlsZS5ib3JkZXJDb2xvciA9IEFycmF5LmlzQXJyYXkobUJvcmRlckNvbG9yKSA/IG1Cb3JkZXJDb2xvcltpXSA6IG1Cb3JkZXJDb2xvcjtcbiAgICAgICAgbVN0eWxlLmJvcmRlclJhZGl1cyA9IEFycmF5LmlzQXJyYXkobUJvcmRlclJhZGl1cykgPyBwYXJzZUZsb2F0KG1Cb3JkZXJSYWRpdXNbaV0pICsgJ3B4JyA6IHBhcnNlRmxvYXQobUJvcmRlclJhZGl1cykgKyAncHgnO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5jdXN0b21IVE1MKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCkpIHtcbiAgICAgICAgICAgIGVsTWFya2VyLmlubmVySFRNTCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUxbaV0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxNYXJrZXIuaW5uZXJIVE1MID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsTWFya2VyLCB7XG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpjb2xsYXBzZWQnOiBjb2xsYXBzZWRTZXJpZXMgfHwgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb2xsYXBzZWRTZXJpZXMgfHwgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzKSB7XG4gICAgICAgICAgZWxNYXJrZXIuY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUtbGVnZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxMZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGVsTGVnZW5kVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZWxMZWdlbmRUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKTtcbiAgICAgICAgZWxMZWdlbmRUZXh0LmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIHZhciB0ZXh0Q29sb3IgPSB3LmNvbmZpZy5sZWdlbmQubGFiZWxzLnVzZVNlcmllc0NvbG9ycyA/IHcuZ2xvYmFscy5jb2xvcnNbaV0gOiB3LmNvbmZpZy5sZWdlbmQubGFiZWxzLmNvbG9ycztcblxuICAgICAgICBpZiAoIXRleHRDb2xvcikge1xuICAgICAgICAgIHRleHRDb2xvciA9IHcuY29uZmlnLmNoYXJ0LmZvcmVDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcbiAgICAgICAgZWxMZWdlbmRUZXh0LnN0eWxlLmZvbnRTaXplID0gcGFyc2VGbG9hdCh3LmNvbmZpZy5sZWdlbmQuZm9udFNpemUpICsgJ3B4JztcbiAgICAgICAgZWxMZWdlbmRUZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsTGVnZW5kVGV4dCwge1xuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxMZWdlbmQuYXBwZW5kQ2hpbGQoZWxNYXJrZXIpO1xuICAgICAgICBlbExlZ2VuZC5hcHBlbmRDaGlsZChlbExlZ2VuZFRleHQpO1xuICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQuc2hvd0Zvclplcm9TZXJpZXMpIHtcbiAgICAgICAgICB2YXIgdG90YWwgPSBjb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxCeUluZGV4KGkpO1xuXG4gICAgICAgICAgaWYgKHRvdGFsID09PSAwICYmIGNvcmVVdGlscy5zZXJpZXNIYXZlU2FtZVZhbHVlcyhpKSAmJiAhY29yZVV0aWxzLmlzU2VyaWVzTnVsbChpKSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1oaWRkZW4temVyby1zZXJpZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuY29uZmlnLmxlZ2VuZC5zaG93Rm9yTnVsbFNlcmllcykge1xuICAgICAgICAgIGlmIChjb3JlVXRpbHMuaXNTZXJpZXNOdWxsKGkpICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPT09IC0xICYmIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGRlbi1udWxsLXNlcmllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmFwcGVuZENoaWxkKGVsTGVnZW5kKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCh3LmNvbmZpZy5sZWdlbmQuaG9yaXpvbnRhbEFsaWduKTsgLy8gdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCh3LmNvbmZpZy5sZWdlbmQudmVydGljYWxBbGlnbilcblxuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcC5jbGFzc0xpc3QuYWRkKCdwb3NpdGlvbi0nICsgdy5jb25maWcubGVnZW5kLnBvc2l0aW9uKTtcbiAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzJyk7XG4gICAgICAgIGVsTGVnZW5kLnN0eWxlLm1hcmdpbiA9IFwiXCIuY29uY2F0KHcuY29uZmlnLmxlZ2VuZC5pdGVtTWFyZ2luLmhvcml6b250YWwsIFwicHggXCIpLmNvbmNhdCh3LmNvbmZpZy5sZWdlbmQuaXRlbU1hcmdpbi52ZXJ0aWNhbCwgXCJweFwiKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuc3R5bGUud2lkdGggPSB3LmNvbmZpZy5sZWdlbmQud2lkdGggPyB3LmNvbmZpZy5sZWdlbmQud2lkdGggKyAncHgnIDogJyc7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCA9IHcuY29uZmlnLmxlZ2VuZC5oZWlnaHQgPyB3LmNvbmZpZy5sZWdlbmQuaGVpZ2h0ICsgJ3B4JyA6ICcnO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbExlZ2VuZCwge1xuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcykge1xuICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlLWxlZ2VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQub25JdGVtQ2xpY2sudG9nZ2xlRGF0YVNlcmllcykge1xuICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ25vLWNsaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG5vdyAtIGp1c3QgcHJldmVudCBjbGljayBvbiBoZWF0bWFwIGxlZ2VuZCAtIGFuZCBhbGxvdyBob3ZlciBvbmx5XG5cblxuICAgICAgdmFyIGNsaWNrQWxsb3dlZCA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdoZWF0bWFwJztcblxuICAgICAgaWYgKGNsaWNrQWxsb3dlZCAmJiB3LmNvbmZpZy5sZWdlbmQub25JdGVtQ2xpY2sudG9nZ2xlRGF0YVNlcmllcykge1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYub25MZWdlbmRDbGljaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQub25JdGVtSG92ZXIuaGlnaGxpZ2h0RGF0YVNlcmllcykge1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLm9uTGVnZW5kSG92ZXJlZCwgdHJ1ZSk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxXcmFwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgc2VsZi5vbkxlZ2VuZEhvdmVyZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZWdlbmRCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlZ2VuZEJCb3goKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1sZWdlbmQnKTtcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBSZWN0ID0gY3VyckxlZ2VuZHNXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGN1cnJMZWdlbmRzV3JhcFdpZHRoID0gY3VyckxlZ2VuZHNXcmFwUmVjdC53aWR0aDtcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBIZWlnaHQgPSBjdXJyTGVnZW5kc1dyYXBSZWN0LmhlaWdodDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsd2g6IGN1cnJMZWdlbmRzV3JhcEhlaWdodCxcbiAgICAgICAgY2x3dzogY3VyckxlZ2VuZHNXcmFwV2lkdGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExlZ2VuZFdyYXBYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZWdlbmRXcmFwWFkob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxMZWdlbmRXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICB2YXIgbGVnZW5kUmVjdCA9IGVsTGVnZW5kV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSA9IHkgKyAody5nbG9iYWxzLnN2Z0hlaWdodCAtIGxlZ2VuZFJlY3QuaGVpZ2h0IC8gMik7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdmFyIGRpbSA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHRpdGxlSCA9IGRpbS5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCd0aXRsZScpLmhlaWdodDtcbiAgICAgICAgdmFyIHN1YnRpdGxlSCA9IGRpbS5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpLmhlaWdodDtcbiAgICAgICAgeSA9IHkgKyAodGl0bGVIID4gMCA/IHRpdGxlSCAtIDEwIDogMCkgKyAoc3VidGl0bGVIID4gMCA/IHN1YnRpdGxlSCAtIDEwIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB4ID0geCArIG9mZnNldFggKyB3LmNvbmZpZy5sZWdlbmQub2Zmc2V0WDtcbiAgICAgIHkgPSB5ICsgb2Zmc2V0WSArIHcuY29uZmlnLmxlZ2VuZC5vZmZzZXRZO1xuICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmJvdHRvbSA9IDEwICsgdy5jb25maWcubGVnZW5kLm9mZnNldFkgKyAncHgnO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5yaWdodCA9IDI1ICsgdy5jb25maWcubGVnZW5kLm9mZnNldFggKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMZWdlbmRXcmFwLnN0eWxlLndpZHRoKSB7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS53aWR0aCA9IHBhcnNlSW50KHcuY29uZmlnLmxlZ2VuZC53aWR0aCkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCkge1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUuaGVpZ2h0ID0gcGFyc2VJbnQody5jb25maWcubGVnZW5kLmhlaWdodCkgKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWdlbmRBbGlnbkhvcml6b250YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVnZW5kQWxpZ25Ib3Jpem9udGFsKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxMZWdlbmRXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICBlbExlZ2VuZFdyYXAuc3R5bGUucmlnaHQgPSAwO1xuICAgICAgdmFyIGxSZWN0ID0gdGhpcy5nZXRMZWdlbmRCQm94KCk7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgIHZhciB0aXRsZVJlY3QgPSBkaW1lbnNpb25zLmdldFRpdGxlU3VidGl0bGVDb29yZHMoJ3RpdGxlJyk7XG4gICAgICB2YXIgc3VidGl0bGVSZWN0ID0gZGltZW5zaW9ucy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpO1xuICAgICAgdmFyIG9mZnNldFggPSAyMDtcbiAgICAgIHZhciBvZmZzZXRZID0gMDsgLy8gdGhlIHdob2xlIGxlZ2VuZCBib3ggaXMgc2V0IHRvIGJvdHRvbVxuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICBvZmZzZXRZID0gLWxSZWN0LmNsd2ggLyAxLjg7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgb2Zmc2V0WSA9IHRpdGxlUmVjdC5oZWlnaHQgKyBzdWJ0aXRsZVJlY3QuaGVpZ2h0ICsgdy5jb25maWcudGl0bGUubWFyZ2luICsgdy5jb25maWcuc3VidGl0bGUubWFyZ2luIC0gMTU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0TGVnZW5kV3JhcFhZKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWdlbmRBbGlnblZlcnRpY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlZ2VuZEFsaWduVmVydGljYWwoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBsUmVjdCA9IHRoaXMuZ2V0TGVnZW5kQkJveCgpO1xuICAgICAgdmFyIG9mZnNldFkgPSAyMDtcbiAgICAgIHZhciBvZmZzZXRYID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIG9mZnNldFggPSAyMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBvZmZzZXRYID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC0gbFJlY3QuY2x3dyAtIDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldExlZ2VuZFdyYXBYWShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWdlbmRIb3ZlcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGVnZW5kSG92ZXJlZChlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBob3Zlck92ZXJMZWdlbmQgPSBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKSB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLW1hcmtlcicpO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgIGlmICghZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbmFjdGl2ZS1sZWdlbmQnKSAmJiBob3Zlck92ZXJMZWdlbmQpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICAgICAgc2VyaWVzLnRvZ2dsZVNlcmllc09uSG92ZXIoZSwgZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgaGVhdG1hcCBoYW5kbGluZ1xuICAgICAgICBpZiAoaG92ZXJPdmVyTGVnZW5kKSB7XG4gICAgICAgICAgdmFyIHNlcmllc0NudCA9IHBhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2xlZ2VuZEhvdmVyJywgW3RoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMud10pO1xuXG4gICAgICAgICAgdmFyIF9zZXJpZXMgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcblxuICAgICAgICAgIF9zZXJpZXMuaGlnaGxpZ2h0UmFuZ2VJblNlcmllcyhlLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWdlbmRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlZ2VuZENsaWNrKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKSB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLW1hcmtlcicpKSB7XG4gICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YTpjb2xsYXBzZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgICB2YXIgbGVnZW5kQ2xpY2sgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5sZWdlbmRDbGljaztcblxuICAgICAgICBpZiAodHlwZW9mIGxlZ2VuZENsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGVnZW5kQ2xpY2sodGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnbGVnZW5kQ2xpY2snLCBbdGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53XSk7XG4gICAgICAgIHZhciBtYXJrZXJDbGljayA9IHRoaXMudy5jb25maWcubGVnZW5kLm1hcmtlcnMub25DbGljaztcblxuICAgICAgICBpZiAodHlwZW9mIG1hcmtlckNsaWNrID09PSAnZnVuY3Rpb24nICYmIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJykpIHtcbiAgICAgICAgICBtYXJrZXJDbGljayh0aGlzLmN0eCwgc2VyaWVzQ250LCB0aGlzLncpO1xuICAgICAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnbGVnZW5kTWFya2VyQ2xpY2snLCBbdGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvZ2dsZURhdGFTZXJpZXMoc2VyaWVzQ250LCBpc0hpZGRlbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExlZ2VuZFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWdlbmRTdHlsZXMoKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXNoZWV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgdmFyIHRleHQgPSBcIlxcbiAgICBcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgcGFkZGluZzogMCAxMHB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tLCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tdG9wIHtcXG4gICAgICAgIGZsZXgtd3JhcDogd3JhcFxcbiAgICAgIH1cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tcmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1sZWZ0IHtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1ib3R0b20ubGVmdCwgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLXRvcC5sZWZ0LCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tcmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1sZWZ0IHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLWJvdHRvbS5jZW50ZXIsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AuY2VudGVyIHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyAgXFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1ib3R0b20ucmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AucmlnaHQge1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllcyB7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllc3tcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0ICosIC5hcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXIgKiB7XFxuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLW1hcmtlciB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnJpZ2h0IC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5sZWZ0IC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXN7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMubm8tY2xpY2sge1xcbiAgICAgICAgY3Vyc29yOiBhdXRvO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQgLmFwZXhjaGFydHMtaGlkZGVuLXplcm8tc2VyaWVzLCAuYXBleGNoYXJ0cy1sZWdlbmQgLmFwZXhjaGFydHMtaGlkZGVuLW51bGwtc2VyaWVzIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICB9XFxuXFxuICAgICAgLmluYWN0aXZlLWxlZ2VuZCB7XFxuICAgICAgICBvcGFjaXR5OiAwLjQ1O1xcbiAgICAgIH1cIjtcbiAgICAgIHZhciBydWxlcyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgc3R5bGVzaGVldC5hcHBlbmRDaGlsZChydWxlcyk7XG4gICAgICByZXR1cm4gc3R5bGVzaGVldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRUb2dnbGVEYXRhU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VG9nZ2xlRGF0YVNlcmllcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNlcmllc0VscyA9IG51bGw7XG4gICAgICB2YXIgcmVhbEluZGV4ZXMgPSBbXTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4XVwiKTtcbiAgICAgICAgc2VyaWVzRWxzID0gVXRpbHMubGlzdFRvQXJyYXkoc2VyaWVzRWxzKTtcbiAgICAgICAgc2VyaWVzRWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZWFsSW5kZXhlcy5wdXNoKHBhcnNlSW50KHYuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWxdXCIpO1xuICAgICAgICBzZXJpZXNFbHMgPSBVdGlscy5saXN0VG9BcnJheShzZXJpZXNFbHMpO1xuICAgICAgICBzZXJpZXNFbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJlYWxJbmRleGVzLnB1c2gocGFyc2VJbnQodi5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVhbEluZGV4ZXMuc29ydCgpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByaXNpbmdTZXJpZXMgPSB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLnNsaWNlKCk7XG4gICAgICAgIHZhciBzZXJpZXMgPSB3LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWFsSW5kZXhlcy5pbmRleE9mKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY10uaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICAgIHNlcmllc1tpbmRleF0uZGF0YSA9IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMuc2xpY2UoKVtjXS5kYXRhLnNsaWNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXJpZXNbaW5kZXhdID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5zbGljZSgpW2NdLmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJpc2luZ1Nlcmllcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1NlcmllcyA9IHJpc2luZ1NlcmllcztcbiAgICAgICAgdy5jb25maWcuc2VyaWVzID0gc2VyaWVzO1xuXG4gICAgICAgIHRoaXMuY3R4Ll91cGRhdGVTZXJpZXMody5jb25maWcuc2VyaWVzLCB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZURhdGFTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRGF0YVNlcmllcyhzZXJpZXNDbnQsIGlzSGlkZGVuKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgIHcuZ2xvYmFscy5yZXNpemVkID0gdHJ1ZTsgLy8gd2UgZG9uJ3Qgd2FudCBpbml0aWFsIGFuaW1hdGlvbnMgYWdhaW5cblxuICAgICAgICB2YXIgc2VyaWVzRWwgPSBudWxsO1xuICAgICAgICB2YXIgcmVhbEluZGV4ID0gbnVsbDsgLy8geWVzLCBtYWtlIGl0IG51bGwuIDEgc2VyaWVzIHdpbGwgcmlzZSBhdCBhIHRpbWVcblxuICAgICAgICB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzID0gW107XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0NudCwgXCInXVwiKSk7XG4gICAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc2VyaWVzRWwuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXVwiKSk7XG4gICAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc2VyaWVzRWwuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5yaXNlQ29sbGFwc2VkU2VyaWVzKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMsIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLCByZWFsSW5kZXgpO1xuICAgICAgICAgIHRoaXMucmlzZUNvbGxhcHNlZFNlcmllcyh3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzLCB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcywgcmVhbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGROb3RIaWRlWUF4aXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0gJiYgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5zaG93ICYmIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uc2hvd0Fsd2F5cykge1xuICAgICAgICAgICAgICBzaG91bGROb3RIaWRlWUF4aXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKHJlYWxJbmRleCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5wdXNoKHJlYWxJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzaG91bGROb3RIaWRlWUF4aXMpIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGEuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4T2ZSaXNpbmcgPSB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLmluZGV4T2YocmVhbEluZGV4KTtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1Nlcmllcy5zcGxpY2UocmVtb3ZlSW5kZXhPZlJpc2luZywgMSk7XG4gICAgICAgICAgICB9IC8vIFRPRE86IEFWT0lEIG11dGF0aW5nIHRoZSB1c2VyJ3MgY29uZmlnIG9iamVjdCBiZWxvd1xuXG5cbiAgICAgICAgICAgIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGEgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgZGF0YTogdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzZXJpZXNDaGlsZHJlbiA9IHNlcmllc0VsLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBzYyA9IDA7IHNjIDwgc2VyaWVzQ2hpbGRyZW4ubGVuZ3RoOyBzYysrKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2Vycy13cmFwJykpIHtcbiAgICAgICAgICAgICAgaWYgKHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtaGlkZScpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtaGlkZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA9PT0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgICAgICB0aGlzLmN0eC5fdXBkYXRlU2VyaWVzKHcuY29uZmlnLnNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3Igbm9uLWF4aXMgY2hhcnRzIGkuZSBwaWUgLyBkb251dHNcbiAgICAgICAgdmFyIF9zZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddIHBhdGhcIikpO1xuXG4gICAgICAgIF9zZXJpZXNFbC5maXJlKCdjbGljaycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyaXNlQ29sbGFwc2VkU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJpc2VDb2xsYXBzZWRTZXJpZXMoc2VyaWVzLCBzZXJpZXNJbmRpY2VzLCByZWFsSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBpZiAoc2VyaWVzW2NdLmluZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhID0gc2VyaWVzW2NdLmRhdGEuc2xpY2UoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNwbGljZShjLCAxKTtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kaWNlcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0gPSBzZXJpZXNbY10uZGF0YTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNwbGljZShjLCAxKTtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kaWNlcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN0eC5fdXBkYXRlU2VyaWVzKHcuY29uZmlnLnNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZWdlbmQ7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSZXNwb25zaXZlIENsYXNzIHRvIG92ZXJyaWRlIG9wdGlvbnMgZm9yIGRpZmZlcmVudCBzY3JlZW4gc2l6ZXMuXG4gKlxuICogQG1vZHVsZSBSZXNwb25zaXZlXG4gKiovXG5cbnZhciBSZXNwb25zaXZlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfSAvLyB0aGUgb3B0cyBwYXJhbWV0ZXIgaWYgbm90IG51bGwgaGFzIHRvIGJlIHNldCBvdmVycmlkaW5nIGV2ZXJ5dGhpbmdcbiAgLy8gYXMgdGhlIG9wdHMgaXMgc2V0IGJ5IHVzZXIgZXh0ZXJuYWxseVxuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmUsIFt7XG4gICAga2V5OiBcImNoZWNrUmVzcG9uc2l2ZUNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc3BvbnNpdmVDb25maWcob3B0cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7IC8vIGNoZWNrIGlmIHJlc3BvbnNpdmUgY29uZmlnIGV4aXN0c1xuXG4gICAgICBpZiAoY25mLnJlc3BvbnNpdmUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmVzID0gY25mLnJlc3BvbnNpdmUuc2xpY2UoKTtcbiAgICAgIHJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJyZWFrcG9pbnQgPiBiLmJyZWFrcG9pbnQgPyAxIDogYi5icmVha3BvaW50ID4gYS5icmVha3BvaW50ID8gLTEgOiAwO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBDb25maWcoe30pO1xuXG4gICAgICB2YXIgaXRlcmF0ZVJlc3BvbnNpdmVPcHRpb25zID0gZnVuY3Rpb24gaXRlcmF0ZVJlc3BvbnNpdmVPcHRpb25zKCkge1xuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBsYXJnZXN0QnJlYWtwb2ludCA9IHJlc1swXS5icmVha3BvaW50O1xuICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA+IDAgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHNjcmVlbi53aWR0aDtcblxuICAgICAgICBpZiAod2lkdGggPiBsYXJnZXN0QnJlYWtwb2ludCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gQ29yZVV0aWxzLmV4dGVuZEFycmF5UHJvcHMoY29uZmlnLCB3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZyk7XG4gICAgICAgICAgbmV3T3B0aW9ucyA9IFV0aWxzLmV4dGVuZChvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICBuZXdPcHRpb25zID0gVXRpbHMuZXh0ZW5kKHcuY29uZmlnLCBuZXdPcHRpb25zKTtcblxuICAgICAgICAgIF90aGlzLm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IHJlc1tpXS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhjb25maWcsIHJlc1tpXS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh3LmNvbmZpZywgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMub3ZlcnJpZGVSZXNwb25zaXZlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gQ29yZVV0aWxzLmV4dGVuZEFycmF5UHJvcHMoY29uZmlnLCBvcHRzKTtcbiAgICAgICAgb3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh3LmNvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBVdGlscy5leHRlbmQob3B0aW9ucywgb3B0cyk7XG4gICAgICAgIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyh7fSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGVSZXNwb25zaXZlT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgbmV3Q29uZmlnID0gbmV3IENvbmZpZyhuZXdPcHRpb25zKS5pbml0KCk7XG4gICAgICB0aGlzLncuY29uZmlnID0gbmV3Q29uZmlnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zaXZlO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVGhlbWUgQ2xhc3MgZm9yIHNldHRpbmcgdGhlIGNvbG9ycyBhbmQgcGFsZXR0ZXMuXG4gKlxuICogQG1vZHVsZSBUaGVtZVxuICoqL1xuXG52YXIgVGhlbWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaGVtZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaGVtZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERlZmF1bHRDb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxzKCk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5jbGFzc0xpc3QuYWRkKHcuY29uZmlnLnRoZW1lLm1vZGUpO1xuXG4gICAgICBpZiAody5jb25maWcuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmNvbG9ycyA9IHRoaXMucHJlZGVmaW5lZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLmNvbG9ycyA9IHcuY29uZmlnLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuZW5hYmxlZCkge1xuICAgICAgICB2YXIgbW9ub0FyciA9IFtdO1xuICAgICAgICB2YXIgZ2xzQ250ID0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCAmJiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJykge1xuICAgICAgICAgIGdsc0NudCA9IHcuZ2xvYmFscy5zZXJpZXNbMF0ubGVuZ3RoICogdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFpbkNvbG9yID0gdy5jb25maWcudGhlbWUubW9ub2Nocm9tZS5jb2xvcjtcbiAgICAgICAgdmFyIHBhcnQgPSAxIC8gKGdsc0NudCAvIHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuc2hhZGVJbnRlbnNpdHkpO1xuICAgICAgICB2YXIgc2hhZGUgPSB3LmNvbmZpZy50aGVtZS5tb25vY2hyb21lLnNoYWRlVG87XG4gICAgICAgIHZhciBwZXJjZW50ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBnc2wgPSAwOyBnc2wgPCBnbHNDbnQ7IGdzbCsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKHNoYWRlID09PSAnZGFyaycpIHtcbiAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50ICogLTEsIG1haW5Db2xvcik7XG4gICAgICAgICAgICBwZXJjZW50ID0gcGVyY2VudCArIHBhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50LCBtYWluQ29sb3IpO1xuICAgICAgICAgICAgcGVyY2VudCA9IHBlcmNlbnQgKyBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vbm9BcnIucHVzaChuZXdDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gbW9ub0Fyci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdENvbG9ycyA9IHcuZ2xvYmFscy5jb2xvcnMuc2xpY2UoKTsgLy8gaWYgdXNlciBzcGVjZmllZCBsZXNzIGNvbG9ycyB0aGFuIG5vLiBvZiBzZXJpZXMsIHB1c2ggdGhlIHNhbWUgY29sb3JzIGFnYWluXG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5jb2xvcnMpOyAvLyBUaGUgQm9yZGVyIGNvbG9yc1xuXG4gICAgICBpZiAody5jb25maWcuc3Ryb2tlLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy5zdHJva2UuY29sb3JzID0gZGVmYXVsdENvbG9ycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5zdHJva2UuY29sb3JzID0gdy5jb25maWcuc3Ryb2tlLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpOyAvLyBUaGUgRklMTCBjb2xvcnNcblxuICAgICAgaWYgKHcuY29uZmlnLmZpbGwuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmZpbGwuY29sb3JzID0gZGVmYXVsdENvbG9ycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5maWxsLmNvbG9ycyA9IHcuY29uZmlnLmZpbGwuY29sb3JzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzID0gdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycywgNTApO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkYXIucG9seWdvbnMuZmlsbC5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMucmFkYXJQb2x5Z29ucy5maWxsLmNvbG9ycyA9IFsnI2ZmZiddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucy5maWxsLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMsIDIwKTsgLy8gVGhlIHBvaW50IGNvbG9yc1xuXG4gICAgICBpZiAody5jb25maWcubWFya2Vycy5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLm1hcmtlcnMuY29sb3JzID0gdy5jb25maWcubWFya2Vycy5jb2xvcnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5tYXJrZXJzLmNvbG9ycyk7XG4gICAgfSAvLyBXaGVuIHRoZSBudW1iZXIgb2YgY29sb3JzIHByb3ZpZGVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIHNlcmllcywgdGhpcyBtZXRob2RcbiAgICAvLyB3aWxsIHB1c2ggc2FtZSBjb2xvcnMgdG8gdGhlIGxpc3RcbiAgICAvLyBwYXJhbXM6XG4gICAgLy8gZGlzdHJpYnV0ZWQgaXMgb25seSB2YWxpZCBmb3IgZGlzdHJpYnV0ZWQgY29sdW1uL2JhciBjaGFydHNcblxuICB9LCB7XG4gICAga2V5OiBcInB1c2hFeHRyYUNvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoRXh0cmFDb2xvcnMoY29sb3JTZXJpZXMsIGxlbmd0aCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGVuID0gbGVuZ3RoIHx8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZGlzdHJpYnV0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgZGlzdHJpYnV0ZWQgPSB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2hlYXRtYXAnICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuY29sb3JTY2FsZS5pbnZlcnNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgbGVuID0gdy5nbG9iYWxzLnNlcmllc1swXS5sZW5ndGggKiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yU2VyaWVzLmxlbmd0aCA8IGxlbikge1xuICAgICAgICB2YXIgZGlmZiA9IGxlbiAtIGNvbG9yU2VyaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgIGNvbG9yU2VyaWVzLnB1c2goY29sb3JTZXJpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVRoZW1lT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUaGVtZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5jaGFydCA9IG9wdGlvbnMuY2hhcnQgfHwge307XG4gICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG4gICAgICB2YXIgbW9kZSA9IG9wdGlvbnMudGhlbWUubW9kZSB8fCAnbGlnaHQnO1xuICAgICAgdmFyIHBhbGV0dGUgPSBvcHRpb25zLnRoZW1lLnBhbGV0dGUgPyBvcHRpb25zLnRoZW1lLnBhbGV0dGUgOiBtb2RlID09PSAnZGFyaycgPyAncGFsZXR0ZTQnIDogJ3BhbGV0dGUxJztcbiAgICAgIHZhciBmb3JlQ29sb3IgPSBvcHRpb25zLmNoYXJ0LmZvcmVDb2xvciA/IG9wdGlvbnMuY2hhcnQuZm9yZUNvbG9yIDogbW9kZSA9PT0gJ2RhcmsnID8gJyNmNmY3ZjgnIDogJyMzNzNkM2YnO1xuICAgICAgb3B0aW9ucy50b29sdGlwLnRoZW1lID0gbW9kZTtcbiAgICAgIG9wdGlvbnMuY2hhcnQuZm9yZUNvbG9yID0gZm9yZUNvbG9yO1xuICAgICAgb3B0aW9ucy50aGVtZS5wYWxldHRlID0gcGFsZXR0ZTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVkZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRlZmluZWQoKSB7XG4gICAgICB2YXIgcGFsZXR0ZSA9IHRoaXMudy5jb25maWcudGhlbWUucGFsZXR0ZTsgLy8gRDZFM0Y4LCBGQ0VGRUYsIERDRTBEOSwgQTU5NzhCLCBFRERERDQsIEQ2RTNGOCwgRkVGNUVGXG5cbiAgICAgIHN3aXRjaCAocGFsZXR0ZSkge1xuICAgICAgICBjYXNlICdwYWxldHRlMSc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMwMDhGRkInLCAnIzAwRTM5NicsICcjRkVCMDE5JywgJyNGRjQ1NjAnLCAnIzc3NUREMCddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGUyJzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzNmNTFiNScsICcjMDNhOWY0JywgJyM0Y2FmNTAnLCAnI2Y5Y2UxZCcsICcjRkY5ODAwJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTMnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjMzNiMmRmJywgJyM1NDZFN0EnLCAnI2Q0NTI2ZScsICcjMTNkOGFhJywgJyNBNTk3OEInXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlNCc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyM0ZWNkYzQnLCAnI2M3ZjQ2NCcsICcjODFENEZBJywgJyNmZDZhNmEnLCAnIzU0NkU3QSddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU1JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzJiOTA4ZicsICcjZjlhM2E0JywgJyM5MGVlN2UnLCAnI2ZhNDQ0MycsICcjNjlkMmU3J107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTYnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjNDQ5REQxJywgJyNGODY2MjQnLCAnI0VBMzU0NicsICcjNjYyRTlCJywgJyNDNUQ4NkQnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlNyc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyNENzI2M0QnLCAnIzFCOTk4QicsICcjMkUyOTRFJywgJyNGNDYwMzYnLCAnI0UyQzA0NCddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU4JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzY2MkU5QicsICcjRjg2NjI0JywgJyNGOUM4MEUnLCAnI0VBMzU0NicsICcjNDNCQ0NEJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTknOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjNUM0NzQyJywgJyNBNTk3OEInLCAnIzhENUI0QycsICcjNUEyQTI3JywgJyNDNEJCQUYnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlMTAnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjQTMwMEQ2JywgJyM3RDAyRUInLCAnIzU2NTNGRScsICcjMjk4M0ZGJywgJyMwMEIxRjInXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjMDA4RkZCJywgJyMwMEUzOTYnLCAnI0ZFQjAxOScsICcjRkY0NTYwJywgJyM3NzVERDAnXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29sb3JzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaGVtZTtcbn0oKTtcblxudmFyIFV0aWxzJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVdGlscyh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVdGlscyk7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgfVxuICAvKipcbiAgICoqIFdoZW4gaG92ZXJpbmcgb3ZlciBzZXJpZXMsIHlvdSBuZWVkIHRvIGNhcHR1cmUgd2hpY2ggc2VyaWVzIGlzIGJlaW5nIGhvdmVyZWQgb24uXG4gICAqKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGJvdGggY2FwdHVyZWRzZXJpZXMgaW5kZXggYXMgd2VsbCBhcyBpbm5lciBpbmRleCBvZiB0aGF0IHNlcmllc1xuICAgKiBAbWVtYmVyb2YgVXRpbHNcbiAgICogQHBhcmFtIHtvYmplY3R9XG4gICAqIC0gaG92ZXJBcmVhID0gdGhlIHJlY3Qgb24gd2hpY2ggdXNlciBob3ZlcnNcbiAgICogLSBlbEdyaWQgPSBkaW1lbnNpb25zIG9mIHRoZSBob3ZlciByZWN0IChpdCBjYW4gYmUgZGlmZmVyZW50IHRoYW4gaG92ZXJhcmVhKVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhVdGlscywgW3tcbiAgICBrZXk6IFwiZ2V0TmVhcmVzdFZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZWFyZXN0VmFsdWVzKF9yZWYpIHtcbiAgICAgIHZhciBob3ZlckFyZWEgPSBfcmVmLmhvdmVyQXJlYSxcbiAgICAgICAgICBlbEdyaWQgPSBfcmVmLmVsR3JpZCxcbiAgICAgICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFksXG4gICAgICAgICAgaGFzQmFycyA9IF9yZWYuaGFzQmFycztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGhvdmVyV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgICAgdmFyIHhEaXZpc29yID0gaG92ZXJXaWR0aCAvICh3Lmdsb2JhbHMuZGF0YVBvaW50cyAtIDEpO1xuICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoaGFzQmFycyAmJiB3Lmdsb2JhbHMuY29tYm9DaGFydHMgfHwgaGFzQmFycykge1xuICAgICAgICB4RGl2aXNvciA9IGhvdmVyV2lkdGggLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyWCA9IGNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0O1xuICAgICAgdmFyIGhvdmVyWSA9IGNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3A7XG4gICAgICB2YXIgaW5SZWN0ID0gaG92ZXJYIDwgMCB8fCBob3ZlclkgPCAwIHx8IGhvdmVyWCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggfHwgaG92ZXJZID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgIGlmIChpblJlY3QpIHtcbiAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXpvb20nKTtcbiAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXBhbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCkge1xuICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy1wYW4nKTtcbiAgICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LmFkZCgnaG92ZXJpbmctem9vbScpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXpvb20nKTtcbiAgICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LmFkZCgnaG92ZXJpbmctcGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBNYXRoLnJvdW5kKGhvdmVyWCAvIHhEaXZpc29yKTtcblxuICAgICAgaWYgKGhhc0JhcnMpIHtcbiAgICAgICAgaiA9IE1hdGguY2VpbChob3ZlclggLyB4RGl2aXNvcik7XG4gICAgICAgIGogPSBqIC0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhcHR1cmVkU2VyaWVzID0gbnVsbDtcbiAgICAgIHZhciBjbG9zZXN0ID0gbnVsbDtcbiAgICAgIHZhciBzZXJpZXNYVmFsQXJyID0gW107XG4gICAgICB2YXIgc2VyaWVzWVZhbEFyciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHNlcmllc1hWYWxBcnIucHVzaChbdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbc11bMF0gLSAwLjAwMDAwMV0uY29uY2F0KHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3NdKSk7XG4gICAgICB9XG5cbiAgICAgIHNlcmllc1hWYWxBcnIgPSBzZXJpZXNYVmFsQXJyLm1hcChmdW5jdGlvbiAoc2VyaWVzWFZhbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzWFZhbC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNlcmllc1lWYWxBcnIgPSB3Lmdsb2JhbHMuc2VyaWVzWXZhbHVlcy5tYXAoZnVuY3Rpb24gKHNlcmllc1lWYWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc1lWYWwuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIGlmIFggYXhpcyB0eXBlIGlzIG5vdCBjYXRlZ29yeSBhbmQgdG9vbHRpcCBpcyBub3Qgc2hhcmVkLCB0aGVuIHdlIG5lZWQgdG8gZmluZCB0aGUgY3Vyc29yIHBvc2l0aW9uIGFuZCBnZXQgdGhlIG5lYXJlc3QgdmFsdWVcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIGNsb3Nlc3QgPSB0aGlzLmNsb3Nlc3RJbk11bHRpQXJyYXkoaG92ZXJYLCBob3ZlclksIHNlcmllc1hWYWxBcnIsIHNlcmllc1lWYWxBcnIpO1xuICAgICAgICBjYXB0dXJlZFNlcmllcyA9IGNsb3Nlc3QuaW5kZXg7XG4gICAgICAgIGogPSBjbG9zZXN0Lmo7XG5cbiAgICAgICAgaWYgKGNhcHR1cmVkU2VyaWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gaW5pdGlhbCBwdXNoLCBpdCBzaG91bGQgYmUgYSBsaXR0bGUgc21hbGxlciB0aGFuIHRoZSAxc3QgdmFsXG4gICAgICAgICAgc2VyaWVzWFZhbEFyciA9IHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW2NhcHR1cmVkU2VyaWVzXTtcbiAgICAgICAgICBjbG9zZXN0ID0gdGhpcy5jbG9zZXN0SW5BcnJheShob3ZlclgsIHNlcmllc1hWYWxBcnIpO1xuICAgICAgICAgIGogPSBjbG9zZXN0LmluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaiB8fCBqIDwgMSkgaiA9IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXB0dXJlZFNlcmllczogY2FwdHVyZWRTZXJpZXMsXG4gICAgICAgIGo6IGosXG4gICAgICAgIGhvdmVyWDogaG92ZXJYLFxuICAgICAgICBob3Zlclk6IGhvdmVyWVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdEluTXVsdGlBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0SW5NdWx0aUFycmF5KGhvdmVyWCwgaG92ZXJZLCBYYXJyYXlzLCBZYXJyYXlzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IDA7XG4gICAgICB2YXIgY3VyckluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBqID0gLTE7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSB0aGlzLmdldEZpcnN0QWN0aXZlWEFycmF5KFhhcnJheXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyckluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJZID0gWWFycmF5c1thY3RpdmVJbmRleF1bMF07XG4gICAgICB2YXIgY3VyclggPSBYYXJyYXlzW2FjdGl2ZUluZGV4XVswXTtcbiAgICAgIHZhciBkaWZmWCA9IE1hdGguYWJzKGhvdmVyWCAtIGN1cnJYKTtcbiAgICAgIHZhciBkaWZmWSA9IE1hdGguYWJzKGhvdmVyWSAtIGN1cnJZKTtcbiAgICAgIHZhciBkaWZmID0gZGlmZlkgKyBkaWZmWDtcbiAgICAgIFlhcnJheXMubWFwKGZ1bmN0aW9uIChhcnJZLCBhcnJJbmRleCkge1xuICAgICAgICBhcnJZLm1hcChmdW5jdGlvbiAoeSwgaW5uZXJLZXkpIHtcbiAgICAgICAgICB2YXIgbmV3ZGlmZlkgPSBNYXRoLmFicyhob3ZlclkgLSBZYXJyYXlzW2FyckluZGV4XVtpbm5lcktleV0pO1xuICAgICAgICAgIHZhciBuZXdkaWZmWCA9IE1hdGguYWJzKGhvdmVyWCAtIFhhcnJheXNbYXJySW5kZXhdW2lubmVyS2V5XSk7XG4gICAgICAgICAgdmFyIG5ld2RpZmYgPSBuZXdkaWZmWCArIG5ld2RpZmZZO1xuXG4gICAgICAgICAgaWYgKG5ld2RpZmYgPCBkaWZmKSB7XG4gICAgICAgICAgICBkaWZmID0gbmV3ZGlmZjtcbiAgICAgICAgICAgIGRpZmZYID0gbmV3ZGlmZlg7XG4gICAgICAgICAgICBkaWZmWSA9IG5ld2RpZmZZO1xuICAgICAgICAgICAgY3VyckluZGV4ID0gYXJySW5kZXg7XG4gICAgICAgICAgICBqID0gaW5uZXJLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IGN1cnJJbmRleCxcbiAgICAgICAgajogalxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rmlyc3RBY3RpdmVYQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RBY3RpdmVYQXJyYXkoWGFycmF5cykge1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gMDtcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBmaXJzdEFjdGl2ZVNlcmllc0luZGV4ID0gWGFycmF5cy5tYXAoZnVuY3Rpb24gKHhhcnIsIGluZGV4KSB7XG4gICAgICAgIGlmICh4YXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBmaXJzdEFjdGl2ZVNlcmllc0luZGV4Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IGNvcmVVdGlscy5nZXRTZXJpZXNUb3RhbEJ5SW5kZXgoYSk7XG5cbiAgICAgICAgaWYgKGZpcnN0QWN0aXZlU2VyaWVzSW5kZXhbYV0gIT09IC0xICYmIHRvdGFsICE9PSAwICYmICFjb3JlVXRpbHMuc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoYSkpIHtcbiAgICAgICAgICBhY3RpdmVJbmRleCA9IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXhbYV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGl2ZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZXN0SW5BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0SW5BcnJheSh2YWwsIGFycikge1xuICAgICAgdmFyIGN1cnIgPSBhcnJbMF07XG4gICAgICB2YXIgY3VyckluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModmFsIC0gY3Vycik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdkaWZmID0gTWF0aC5hYnModmFsIC0gYXJyW2ldKTtcblxuICAgICAgICBpZiAobmV3ZGlmZiA8IGRpZmYpIHtcbiAgICAgICAgICBkaWZmID0gbmV3ZGlmZjtcbiAgICAgICAgICBjdXJyID0gYXJyW2ldO1xuICAgICAgICAgIGN1cnJJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc2VyaWVzLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGRpZmZlcmVudCB4IHZhbHVlcyBmb3IgZWFjaCBzZXJpZXMuXG4gICAgICogQnV0IGl0IG1heSBiZSBwb3NzaWJsZSBpbiB0aG9zZSBtdWx0aXBsZSBzZXJpZXMsIHRoYXQgdGhlcmUgaXMgc2FtZSB4IHZhbHVlIGZvciAyIG9yIG1vcmVcbiAgICAgKiBzZXJpZXMuXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXG4gICAgICogQHBhcmFtIHtpbnR9XG4gICAgICogLSBqID0gaXMgdGhlIGlubmVyIGluZGV4IG9mIHNlcmllcyAtPiAoc2VyaWVzW2ldW2pdKVxuICAgICAqIEByZXR1cm4ge2Jvb2x9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1hvdmVybGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzWG92ZXJsYXAoaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeFNhbWVGb3JBbGxTZXJpZXNKQXJyID0gW107XG4gICAgICB2YXIgc2VyaWVzWCA9IHcuZ2xvYmFscy5zZXJpZXNYLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNbMF0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXJpZXNYLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXNYLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2VyaWVzWFtpXVtqXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNlcmllc1hbaSArIDFdW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHNlcmllc1hbaV1bal0gIT09IHNlcmllc1hbaSArIDFdW2pdKSB7XG4gICAgICAgICAgICAgIHhTYW1lRm9yQWxsU2VyaWVzSkFyci5wdXNoKCd1bkVxdWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4U2FtZUZvckFsbFNlcmllc0pBcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzaW5pdGlhbFNlcmllc1NhbWVMZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNpbml0aWFsU2VyaWVzU2FtZUxlbigpIHtcbiAgICAgIHZhciBzYW1lTGVuID0gdHJ1ZTtcbiAgICAgIHZhciBpbml0aWFsU2VyaWVzID0gdGhpcy53Lmdsb2JhbHMuaW5pdGlhbFNlcmllcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsU2VyaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoaW5pdGlhbFNlcmllc1tpXS5kYXRhLmxlbmd0aCAhPT0gaW5pdGlhbFNlcmllc1tpICsgMV0uZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBzYW1lTGVuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhbWVMZW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhcnNIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFyc0hlaWdodChhbGxiYXJzKSB7XG4gICAgICB2YXIgYmFycyA9IF90b0NvbnN1bWFibGVBcnJheShhbGxiYXJzKTtcblxuICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gYmFycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYmFyKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyBiYXIuZ2V0QkJveCgpLmhlaWdodDtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUFsbFRvb2x0aXBTZXJpZXNHcm91cHMoc3RhdGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgaWYgKHR0Q3R4LmFsbFRvb2x0aXBTZXJpZXNHcm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHR0Q3R4LmFsbFRvb2x0aXBTZXJpZXNHcm91cHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsVG9vbHRpcFNlcmllc0dyb3VwcyA9IHR0Q3R4LmFsbFRvb2x0aXBTZXJpZXNHcm91cHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVG9vbHRpcFNlcmllc0dyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlbmFibGUnKSB7XG4gICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLnN0eWxlLmRpc3BsYXkgPSB3LmNvbmZpZy50b29sdGlwLml0ZW1zLmRpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXRpbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sdGlwLkxhYmVscyBDbGFzcyB0byBkcmF3IHRleHRzIG9uIHRoZSB0b29sdGlwLlxuICpcbiAqIEBtb2R1bGUgVG9vbHRpcC5MYWJlbHNcbiAqKi9cblxudmFyIExhYmVscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhYmVscyh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbHMpO1xuXG4gICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gICAgdGhpcy50b29sdGlwVXRpbCA9IG5ldyBVdGlscyQxKHRvb2x0aXBDb250ZXh0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMYWJlbHMsIFt7XG4gICAga2V5OiBcImRyYXdTZXJpZXNUZXh0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3U2VyaWVzVGV4dHMoX3JlZikge1xuICAgICAgdmFyIF9yZWYkc2hhcmVkID0gX3JlZi5zaGFyZWQsXG4gICAgICAgICAgc2hhcmVkID0gX3JlZiRzaGFyZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHNoYXJlZCxcbiAgICAgICAgICB0dEl0ZW1zID0gX3JlZi50dEl0ZW1zLFxuICAgICAgICAgIF9yZWYkaSA9IF9yZWYuaSxcbiAgICAgICAgICBpID0gX3JlZiRpID09PSB2b2lkIDAgPyAwIDogX3JlZiRpLFxuICAgICAgICAgIF9yZWYkaiA9IF9yZWYuaixcbiAgICAgICAgICBqID0gX3JlZiRqID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRqO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmN1c3RvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VzdG9tVG9vbHRpcCh7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmVJbmFjdGl2ZVNlcmllcyhzaGFyZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXNUb1ByaW50KHtcbiAgICAgICAgaTogaSxcbiAgICAgICAgajogalxuICAgICAgfSk7XG4gICAgICB0aGlzLnByaW50TGFiZWxzKHtcbiAgICAgICAgaTogaSxcbiAgICAgICAgajogaixcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR0SXRlbXM6IHR0SXRlbXMsXG4gICAgICAgIHNoYXJlZDogc2hhcmVkXG4gICAgICB9KTsgLy8gUmUtY2FsY3VsYXRlIHRvb2x0aXAgZGltZW5zaW9ucyBub3cgdGhhdCB3ZSBoYXZlIGRyYXduIHRoZSB0ZXh0XG5cbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLnR0Q3R4LmdldEVsVG9vbHRpcCgpO1xuICAgICAgdGhpcy50dEN0eC50b29sdGlwUmVjdC50dFdpZHRoID0gdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgdGhpcy50dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCA9IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByaW50TGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50TGFiZWxzKF9yZWYyKSB7XG4gICAgICB2YXIgaSA9IF9yZWYyLmksXG4gICAgICAgICAgaiA9IF9yZWYyLmosXG4gICAgICAgICAgdmFsdWVzID0gX3JlZjIudmFsdWVzLFxuICAgICAgICAgIHR0SXRlbXMgPSBfcmVmMi50dEl0ZW1zLFxuICAgICAgICAgIHNoYXJlZCA9IF9yZWYyLnNoYXJlZDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHZhbDtcbiAgICAgIHZhciB4VmFsID0gdmFsdWVzLnhWYWwsXG4gICAgICAgICAgelZhbCA9IHZhbHVlcy56VmFsLFxuICAgICAgICAgIHhBeGlzVFRWYWwgPSB2YWx1ZXMueEF4aXNUVFZhbDtcbiAgICAgIHZhciBzZXJpZXNOYW1lID0gJyc7XG4gICAgICB2YXIgcENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tpXTtcblxuICAgICAgaWYgKGogIT09IG51bGwgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmRpc3RyaWJ1dGVkKSB7XG4gICAgICAgIHBDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbal07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHQgPSAwLCBpbnZlcnNldCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoIC0gMTsgdCA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyB0KyssIGludmVyc2V0LS0pIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldEZvcm1hdHRlcnMoaSk7XG4gICAgICAgIHNlcmllc05hbWUgPSB0aGlzLmdldFNlcmllc05hbWUoe1xuICAgICAgICAgIGZuOiBmLnlMYlRpdGxlRm9ybWF0dGVyLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGo6IGpcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgIHZhciB0SW5kZXggPSB3LmNvbmZpZy50b29sdGlwLmludmVyc2VPcmRlciA/IGludmVyc2V0IDogdDtcbiAgICAgICAgICBmID0gdGhpcy5nZXRGb3JtYXR0ZXJzKHRJbmRleCk7XG4gICAgICAgICAgc2VyaWVzTmFtZSA9IHRoaXMuZ2V0U2VyaWVzTmFtZSh7XG4gICAgICAgICAgICBmbjogZi55TGJUaXRsZUZvcm1hdHRlcixcbiAgICAgICAgICAgIGluZGV4OiB0SW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGo6IGpcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3RJbmRleF07IC8vIGZvciBwbG90IGNoYXJ0cywgbm90IGZvciBwaWUvZG9udXRzXG5cbiAgICAgICAgICB2YWwgPSBmLnlMYkZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzW3RJbmRleF1bal0sIHtcbiAgICAgICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiB0SW5kZXgsXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTsgLy8gZGlzY2FyZCAwIHZhbHVlcyBpbiBCQVJTXG5cbiAgICAgICAgICBpZiAodGhpcy50dEN0eC5oYXNCYXJzKCkgJiYgdy5jb25maWcuY2hhcnQuc3RhY2tlZCAmJiB3Lmdsb2JhbHMuc2VyaWVzW3RJbmRleF1bal0gPT09IDAgfHwgdHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNbdEluZGV4XVtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gZi55TGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1tpXVtqXSwge1xuICAgICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBmb3IgcGllIC8gZG9udXRzXG5cblxuICAgICAgICBpZiAoaiA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbCA9IGYueUxiRm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ET01IYW5kbGluZyh7XG4gICAgICAgICAgdDogdCxcbiAgICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICB4VmFsOiB4VmFsLFxuICAgICAgICAgICAgeEF4aXNUVFZhbDogeEF4aXNUVFZhbCxcbiAgICAgICAgICAgIHpWYWw6IHpWYWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgc2hhcmVkOiBzaGFyZWQsXG4gICAgICAgICAgcENvbG9yOiBwQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVycyhpKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpXTtcbiAgICAgIHZhciB5TGJUaXRsZUZvcm1hdHRlcjtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50dFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuZ2xvYmFscy50dFZhbCkpIHtcbiAgICAgICAgICB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRWYWxbaV0gJiYgdy5nbG9iYWxzLnR0VmFsW2ldLmZvcm1hdHRlcjtcbiAgICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbFtpXSAmJiB3Lmdsb2JhbHMudHRWYWxbaV0udGl0bGUgJiYgdy5nbG9iYWxzLnR0VmFsW2ldLnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRWYWwuZm9ybWF0dGVyO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMudHRWYWwudGl0bGUuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbC50aXRsZS5mb3JtYXR0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuY29uZmlnLnRvb2x0aXAueS50aXRsZS5mb3JtYXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgeUxiRm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1swXSkge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IGZ1bmN0aW9uIHlMYkZvcm1hdHRlcihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB5TGJUaXRsZUZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IGZ1bmN0aW9uIHlMYlRpdGxlRm9ybWF0dGVyKGxhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB5TGJGb3JtYXR0ZXI6IHlMYkZvcm1hdHRlcixcbiAgICAgICAgeUxiVGl0bGVGb3JtYXR0ZXI6IHlMYlRpdGxlRm9ybWF0dGVyXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc05hbWUoX3JlZjMpIHtcbiAgICAgIHZhciBmbiA9IF9yZWYzLmZuLFxuICAgICAgICAgIGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICAgICAgc2VyaWVzSW5kZXggPSBfcmVmMy5zZXJpZXNJbmRleCxcbiAgICAgICAgICBqID0gX3JlZjMuajtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIGZuKFN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaW5kZXhdKSwge1xuICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJET01IYW5kbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBET01IYW5kbGluZyhfcmVmNCkge1xuICAgICAgdmFyIHQgPSBfcmVmNC50LFxuICAgICAgICAgIHR0SXRlbXMgPSBfcmVmNC50dEl0ZW1zLFxuICAgICAgICAgIHZhbHVlcyA9IF9yZWY0LnZhbHVlcyxcbiAgICAgICAgICBzZXJpZXNOYW1lID0gX3JlZjQuc2VyaWVzTmFtZSxcbiAgICAgICAgICBzaGFyZWQgPSBfcmVmNC5zaGFyZWQsXG4gICAgICAgICAgcENvbG9yID0gX3JlZjQucENvbG9yO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIHZhbCA9IHZhbHVlcy52YWwsXG4gICAgICAgICAgeFZhbCA9IHZhbHVlcy54VmFsLFxuICAgICAgICAgIHhBeGlzVFRWYWwgPSB2YWx1ZXMueEF4aXNUVFZhbCxcbiAgICAgICAgICB6VmFsID0gdmFsdWVzLnpWYWw7XG4gICAgICB2YXIgdHRJdGVtc0NoaWxkcmVuID0gbnVsbDtcbiAgICAgIHR0SXRlbXNDaGlsZHJlbiA9IHR0SXRlbXNbdF0uY2hpbGRyZW47XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZpbGxTZXJpZXNDb2xvcikge1xuICAgICAgICAvLyAgZWxUb29sdGlwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvclxuICAgICAgICB0dEl0ZW1zW3RdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvcjtcbiAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEN0eC5zaG93VG9vbHRpcFRpdGxlKSB7XG4gICAgICAgIGlmICh0dEN0eC50b29sdGlwVGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgaXQgb25jZSBpZiBudWxsLCBhbmQgc3RvcmUgaXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICB0dEN0eC50b29sdGlwVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0dEN0eC50b29sdGlwVGl0bGUuaW5uZXJIVE1MID0geFZhbDtcbiAgICAgIH0gLy8gaWYgeGF4aXMgdG9vbHRpcCBpcyBjb25zdHJ1Y3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBpbm5lckhUTUxcblxuXG4gICAgICBpZiAodHRDdHguYmx4YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5pbm5lckhUTUwgPSB4QXhpc1RUVmFsICE9PSAnJyA/IHhBeGlzVFRWYWwgOiB4VmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRZTGFiZWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1sYWJlbCcpO1xuXG4gICAgICBpZiAodHRZTGFiZWwpIHtcbiAgICAgICAgdHRZTGFiZWwuaW5uZXJIVE1MID0gc2VyaWVzTmFtZSA/IHNlcmllc05hbWUgKyAnOiAnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciB0dFlWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC12YWx1ZScpO1xuXG4gICAgICBpZiAodHRZVmFsKSB7XG4gICAgICAgIHR0WVZhbC5pbm5lckhUTUwgPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEl0ZW1zQ2hpbGRyZW5bMF0gJiYgdHRJdGVtc0NoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy10b29sdGlwLW1hcmtlcicpKSB7XG4gICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5jb25maWcudG9vbHRpcC5tYXJrZXIuc2hvdykge1xuICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgaWYgKHpWYWwgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHR0WkxhYmVsID0gdHRJdGVtc1t0XS5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei1sYWJlbCcpO1xuICAgICAgICB0dFpMYWJlbC5pbm5lckhUTUwgPSB3LmNvbmZpZy50b29sdGlwLnoudGl0bGU7XG4gICAgICAgIHZhciB0dFpWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlJyk7XG4gICAgICAgIHR0WlZhbC5pbm5lckhUTUwgPSB6VmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcmVkICYmIHR0SXRlbXNDaGlsZHJlblswXSkge1xuICAgICAgICAvLyBoaWRlIHdoZW4gbm8gVmFsIG9yIHNlcmllcyBjb2xsYXBzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbCA9PT0gbnVsbCB8fCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKHQpID4gLTEpIHtcbiAgICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0ucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSB3LmNvbmZpZy50b29sdGlwLml0ZW1zLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXMoc2hhcmVkKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAvLyBtYWtlIGFsbCB0b29sdGlwcyBhY3RpdmVcbiAgICAgICAgdGhpcy50b29sdGlwVXRpbC50b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzKCdlbmFibGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpc2FibGUgYWxsIHRvb2x0aXAgdGV4dCBncm91cHNcbiAgICAgICAgdGhpcy50b29sdGlwVXRpbC50b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzKCdkaXNhYmxlJyk7IC8vIGVuYWJsZSB0aGUgZmlyc3QgdG9vbHRpcCB0ZXh0IGdyb3VwXG5cbiAgICAgICAgdmFyIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcblxuICAgICAgICBpZiAoZmlyc3RUb29sdGlwU2VyaWVzR3JvdXApIHtcbiAgICAgICAgICBmaXJzdFRvb2x0aXBTZXJpZXNHcm91cC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICBmaXJzdFRvb2x0aXBTZXJpZXNHcm91cC5zdHlsZS5kaXNwbGF5ID0gdy5jb25maWcudG9vbHRpcC5pdGVtcy5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlc1RvUHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVzVG9QcmludChfcmVmNSkge1xuICAgICAgdmFyIGkgPSBfcmVmNS5pLFxuICAgICAgICAgIGogPSBfcmVmNS5qO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVyZWRTZXJpZXNYID0gdGhpcy5jdHguc2VyaWVzLmZpbHRlcmVkU2VyaWVzWCgpO1xuICAgICAgdmFyIHhWYWwgPSAnJztcbiAgICAgIHZhciB4QXhpc1RUVmFsID0gJyc7XG4gICAgICB2YXIgelZhbCA9IG51bGw7XG4gICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgIHZhciBjdXN0b21Gb3JtYXR0ZXJPcHRzID0ge1xuICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfTtcbiAgICAgIHZhciB6Rm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0WkZvcm1hdHRlcjtcblxuICAgICAgaWYgKGogPT09IG51bGwpIHtcbiAgICAgICAgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHhWYWwgPSBmaWx0ZXJlZFNlcmllc1hbaV1bal07XG5cbiAgICAgICAgICBpZiAoZmlsdGVyZWRTZXJpZXNYW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYSBzZXJpZXMgKHBvc3NpYmx5IHRoZSBmaXJzdCBvbmUpIG1pZ2h0IGJlIGNvbGxhcHNlZCwgc28gZ2V0IHRoZSBuZXh0IGFjdGl2ZSBpbmRleFxuICAgICAgICAgICAgdmFyIGZpcnN0QWN0aXZlU2VyaWVzSW5kZXggPSB0aGlzLnRvb2x0aXBVdGlsLmdldEZpcnN0QWN0aXZlWEFycmF5KGZpbHRlcmVkU2VyaWVzWCk7XG4gICAgICAgICAgICB4VmFsID0gZmlsdGVyZWRTZXJpZXNYW2ZpcnN0QWN0aXZlU2VyaWVzSW5kZXhdW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4VmFsID0gdHlwZW9mIHcuZ2xvYmFscy5sYWJlbHNbal0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhYmVsc1tqXSA6ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJYVmFsID0geFZhbDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgdmFyIHhGb3JtYXQgPSBuZXcgRm9ybWF0dGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHhWYWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIsIGJ1ZmZlclhWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFZhbCA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIoYnVmZmVyWFZhbCwgY3VzdG9tRm9ybWF0dGVyT3B0cyk7XG4gICAgICB9IC8vIG92ZXJyaWRlIGRlZmF1bHQgeC1heGlzIGZvcm1hdHRlciB3aXRoIHRvb2x0aXAgZm9ybWF0dGVyXG5cblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4VmFsID0gdy5nbG9iYWxzLnR0S2V5Rm9ybWF0dGVyKGJ1ZmZlclhWYWwsIGN1c3RvbUZvcm1hdHRlck9wdHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLnNlcmllc1oubGVuZ3RoID4gMCAmJiB3Lmdsb2JhbHMuc2VyaWVzWlswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHpWYWwgPSB6Rm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNaW2ldW2pdLCB3KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy54YXhpcy50b29sdGlwLmZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB4QXhpc1RUVmFsID0gdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlcihidWZmZXJYVmFsLCBjdXN0b21Gb3JtYXR0ZXJPcHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhBeGlzVFRWYWwgPSB4VmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgeFZhbDogeFZhbCxcbiAgICAgICAgeEF4aXNUVFZhbDogeEF4aXNUVFZhbCxcbiAgICAgICAgelZhbDogelZhbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ3VzdG9tVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDdXN0b21Ub29sdGlwKF9yZWY2KSB7XG4gICAgICB2YXIgaSA9IF9yZWY2LmksXG4gICAgICAgICAgaiA9IF9yZWY2Lmo7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLnR0Q3R4LmdldEVsVG9vbHRpcCgpOyAvLyBvdmVycmlkZSBldmVyeXRoaW5nIHdpdGggYSBjdXN0b20gaHRtbCB0b29sdGlwIGFuZCByZXBsYWNlIGl0XG5cbiAgICAgIHRvb2x0aXBFbC5pbm5lckhUTUwgPSB3LmNvbmZpZy50b29sdGlwLmN1c3RvbSh7XG4gICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVG9vbHRpcC5Qb3NpdGlvbiBDbGFzcyB0byBtb3ZlIHRoZSB0b29sdGlwIGJhc2VkIG9uIHggYW5kIHkgcG9zaXRpb24uXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLlBvc2l0aW9uXG4gKiovXG5cbnZhciBQb3NpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvc2l0aW9uKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uKTtcblxuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgbW92ZSB0aGUgY3Jvc3NoYWlyICh0aGUgdmVydGljYWwvaG9yeiBsaW5lIHRoYXQgbW92ZXMgYWxvbmcgd2l0aCBtb3VzZSlcbiAgICogQWxvbmcgd2l0aCB0aGlzLCB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdGhlIHhheGlzTW92ZSBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICogQHBhcmFtIHtpbnR9IC0gY3ggPSBwb2ludCdzIHggcG9zaXRpb24sIHdoZXJldmVyIHBvaW50J3MgeCBpcywgeW91IG5lZWQgdG8gbW92ZSBjcm9zc2hhaXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUG9zaXRpb24sIFt7XG4gICAga2V5OiBcIm1vdmVYQ3Jvc3NoYWlyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWENyb3NzaGFpcnMoY3gpIHtcbiAgICAgIHZhciBqID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdHRDdHguZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgdmFyIHggPSBjeCAtIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggLyAyO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCkubGVuZ3RoO1xuXG4gICAgICBpZiAoaiAhPT0gbnVsbCkge1xuICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRpY2tBbW91bnQgKiBqO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcgfHwgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICBpZiAoeCArIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaiAhPT0gbnVsbCkge1xuICAgICAgICAgIHggPSB4ICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRpY2tBbW91bnQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4JywgeCk7XG4gICAgICAgIHhjcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneDEnLCB4KTtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4MicsIHgpO1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3kyJywgdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR0Q3R4LmJseGF4aXNUb29sdGlwKSB7XG4gICAgICAgIHZhciB0eCA9IHg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICd0aWNrV2lkdGgnIHx8IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICdiYXJXaWR0aCcpIHtcbiAgICAgICAgICB0eCA9IHggKyB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZVhBeGlzVG9vbHRpcCh0eCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBtb3ZlIHRoZSBjcm9zc2hhaXIgKHRoZSB2ZXJ0aWNhbC9ob3J6IGxpbmUgdGhhdCBtb3ZlcyBhbG9uZyB3aXRoIG1vdXNlKVxuICAgICAqIEFsb25nIHdpdGggdGhpcywgdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHRoZSB4YXhpc01vdmUgZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIGNyb3NzaGFpclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVlDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVZQ3Jvc3NoYWlycyhjeSkge1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgaWYgKHR0Q3R4Lnljcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHR0Q3R4Lnljcm9zc2hhaXJzLCB7XG4gICAgICAgICAgeTE6IGN5LFxuICAgICAgICAgIHkyOiBjeVxuICAgICAgICB9KTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnModHRDdHgueWNyb3NzaGFpcnNIaWRkZW4sIHtcbiAgICAgICAgICB5MTogY3ksXG4gICAgICAgICAgeTI6IGN5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiogQXhpc1Rvb2x0aXAgaXMgdGhlIHNtYWxsIHJlY3RhbmdsZSB3aGljaCBhcHBlYXJzIG9uIHggYXhpcyB3aXRoIHggdmFsdWUsIHdoZW4gdXNlciBtb3Zlc1xuICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7aW50fSAtIGN4ID0gcG9pbnQncyB4IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHggaXMsIHlvdSBuZWVkIHRvIG1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVYQXhpc1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVhBeGlzVG9vbHRpcChjeCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBpZiAodHRDdHgueGF4aXNUb29sdGlwICE9PSBudWxsKSB7XG4gICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgdmFyIGN5ID0gdHRDdHgueGF4aXNPZmZZICsgdy5jb25maWcueGF4aXMudG9vbHRpcC5vZmZzZXRZICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgKyAxICsgdy5jb25maWcueGF4aXMub2Zmc2V0WTtcbiAgICAgICAgdmFyIHhheGlzVFRUZXh0ID0gdHRDdHgueGF4aXNUb29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgeGF4aXNUVFRleHRXaWR0aCA9IHhheGlzVFRUZXh0LndpZHRoO1xuICAgICAgICBjeCA9IGN4IC0geGF4aXNUVFRleHRXaWR0aCAvIDI7XG5cbiAgICAgICAgaWYgKCFpc05hTihjeCkpIHtcbiAgICAgICAgICBjeCA9IGN4ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVg7XG4gICAgICAgICAgdmFyIHRleHRSZWN0ID0gMDtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICAgIHRleHRSZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuaW5uZXJIVE1MKTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LnN0eWxlLm1pbldpZHRoID0gdGV4dFJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zdHlsZS5sZWZ0ID0gY3ggKyAncHgnO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zdHlsZS50b3AgPSBjeSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVlBeGlzVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWUF4aXNUb29sdGlwKGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh0dEN0eC55YXhpc1RURWxzID09PSBudWxsKSB7XG4gICAgICAgIHR0Q3R4LnlheGlzVFRFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHljcm9zc2hhaXJzSGlkZGVuUmVjdFkxID0gcGFyc2VJbnQodHRDdHgueWNyb3NzaGFpcnNIaWRkZW4uZ2V0QXR0cmlidXRlKCd5MScpKTtcbiAgICAgIHZhciBjeSA9IHcuZ2xvYmFscy50cmFuc2xhdGVZICsgeWNyb3NzaGFpcnNIaWRkZW5SZWN0WTE7XG4gICAgICB2YXIgeUF4aXNUVFJlY3QgPSB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB5QXhpc1RUSGVpZ2h0ID0geUF4aXNUVFJlY3QuaGVpZ2h0O1xuICAgICAgdmFyIGN4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gLSAyO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbaW5kZXhdLm9wcG9zaXRlKSB7XG4gICAgICAgIGN4ID0gY3ggLSAyNjtcbiAgICAgIH1cblxuICAgICAgY3kgPSBjeSAtIHlBeGlzVFRIZWlnaHQgLyAyO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHR0Q3R4LnlheGlzVFRFbHNbaW5kZXhdLnN0eWxlLnRvcCA9IGN5ICsgJ3B4JztcbiAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uc3R5bGUubGVmdCA9IGN4ICsgdy5jb25maWcueWF4aXNbaW5kZXhdLnRvb2x0aXAub2Zmc2V0WCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICoqIG1vdmVzIHRoZSB3aG9sZSB0b29sdGlwIGJ5IGNoYW5naW5nIHgsIHkgYXR0cnNcbiAgICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeSA9IHBvaW50J3MgeSBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB5IGlzLCB5b3UgbmVlZCB0byBtb3ZlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge2ludH0gLSByID0gcG9pbnQncyByYWRpdXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUb29sdGlwKGN4LCBjeSkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdHRDdHguZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgdG9vbHRpcFJlY3QgPSB0dEN0eC50b29sdGlwUmVjdDtcbiAgICAgIHZhciBwb2ludFIgPSByICE9PSBudWxsID8gcGFyc2VJbnQocikgOiAxO1xuICAgICAgdmFyIHggPSBwYXJzZUludChjeCkgKyBwb2ludFIgKyA1O1xuICAgICAgdmFyIHkgPSBwYXJzZUludChjeSkgKyBwb2ludFIgLyAyOyAvLyAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMlxuXG4gICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyKSB7XG4gICAgICAgIHggPSB4IC0gdG9vbHRpcFJlY3QudHRXaWR0aCAtIHBvaW50UiAtIDE1O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0b29sdGlwUmVjdC50dFdpZHRoIC0gMTApIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0b29sdGlwUmVjdC50dFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IC0yMCkge1xuICAgICAgICB4ID0gLTIwO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAtIHNlcmllc0JvdW5kLnRvcCAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25DaGVja3ModG9vbHRpcFJlY3QsIHgsIHkpO1xuICAgICAgeCA9IG5ld1Bvc2l0aW9ucy54O1xuICAgICAgeSA9IG5ld1Bvc2l0aW9ucy55O1xuXG4gICAgICBpZiAoIWlzTmFOKHgpKSB7XG4gICAgICAgIHggPSB4ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVg7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25DaGVja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25DaGVja3ModG9vbHRpcFJlY3QsIHgsIHkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAodG9vbHRpcFJlY3QudHRIZWlnaHQgKyB5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTWFya2VycyhpLCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldID4gMCkge1xuICAgICAgICB2YXIgYWxsUG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIiAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoaSwgXCInXSAuYXBleGNoYXJ0cy1tYXJrZXJcIikpO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYWxsUG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgaWYgKHBhcnNlSW50KGFsbFBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSA9PT0gaikge1xuICAgICAgICAgICAgdHRDdHgubWFya2VyLnJlc2V0UG9pbnRzU2l6ZSgpO1xuICAgICAgICAgICAgdHRDdHgubWFya2VyLmVubGFyZ2VDdXJyZW50UG9pbnQoaiwgYWxsUG9pbnRzW3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR0Q3R4Lm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgICAgdGhpcy5tb3ZlRHluYW1pY1BvaW50T25Ib3ZlcihqLCBpKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIHNob3cgbWFya2Vycy9wb2ludHMgb25seSBvbiBob3ZlciAtXG4gICAgLy8gRElGRkVSRU5UIFggVkFMVUVTIGluIG11bHRpcGxlIHNlcmllc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZUR5bmFtaWNQb2ludE9uSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUR5bmFtaWNQb2ludE9uSG92ZXIoaiwgY2FwdHVyZWRTZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciBjeCA9IDA7XG4gICAgICB2YXIgY3kgPSAwO1xuICAgICAgdmFyIHBvaW50c0FyciA9IHcuZ2xvYmFscy5wb2ludHNBcnJheTtcbiAgICAgIHZhciBob3ZlclNpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG5cbiAgICAgIGlmIChob3ZlclNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBob3ZlclNpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2NhcHR1cmVkU2VyaWVzXSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY3ggPSBwb2ludHNBcnJbY2FwdHVyZWRTZXJpZXNdW2pdWzBdO1xuICAgICAgY3kgPSBwb2ludHNBcnJbY2FwdHVyZWRTZXJpZXNdW2pdWzFdID8gcG9pbnRzQXJyW2NhcHR1cmVkU2VyaWVzXVtqXVsxXSA6IDA7XG4gICAgICB2YXIgcG9pbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGNhcHR1cmVkU2VyaWVzLCBcIiddIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIGNpcmNsZVwiKSk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBob3ZlclNpemUpO1xuICAgICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ2N4JywgY3gpO1xuICAgICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ2N5JywgY3kpO1xuICAgICAgfSAvLyBwb2ludC5zdHlsZS5vcGFjaXR5ID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5vcGFjaXR5XG5cblxuICAgICAgdGhpcy5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICBpZiAoIXR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGN4LCBjeSwgaG92ZXJTaXplKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIHNob3cgbWFya2Vycy9wb2ludHMgb25seSBvbiBob3ZlciAtXG4gICAgLy8gU0FNRSBYIFZBTFVFUyBpbiBtdWx0aXBsZSBzZXJpZXNcblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVEeW5hbWljUG9pbnRzT25Ib3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlRHluYW1pY1BvaW50c09uSG92ZXIoaikge1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdHRDdHgudztcbiAgICAgIHZhciBjeCA9IDA7XG4gICAgICB2YXIgY3kgPSAwO1xuICAgICAgdmFyIGFjdGl2ZVNlcmllcyA9IDA7XG4gICAgICB2YXIgcG9pbnRzQXJyID0gdy5nbG9iYWxzLnBvaW50c0FycmF5O1xuICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgYWN0aXZlU2VyaWVzID0gc2VyaWVzLmdldEFjdGl2ZVNlcmllc0luZGV4KCk7XG4gICAgICB2YXIgaG92ZXJTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICBpZiAoaG92ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG92ZXJTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVthY3RpdmVTZXJpZXNdICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRzQXJyW2FjdGl2ZVNlcmllc10pIHtcbiAgICAgICAgY3ggPSBwb2ludHNBcnJbYWN0aXZlU2VyaWVzXVtqXVswXTtcbiAgICAgICAgY3kgPSBwb2ludHNBcnJbYWN0aXZlU2VyaWVzXVtqXVsxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50cyA9IG51bGw7XG4gICAgICB2YXIgYWxsUG9pbnRzID0gdHRDdHguZ2V0QWxsTWFya2VycygpO1xuXG4gICAgICBpZiAoYWxsUG9pbnRzICE9PSBudWxsKSB7XG4gICAgICAgIHBvaW50cyA9IGFsbFBvaW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIGNpcmNsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRzICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50QXJyID0gcG9pbnRzQXJyW3BdO1xuXG4gICAgICAgICAgaWYgKHBvaW50QXJyICYmIHBvaW50QXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBjeSA9IHBvaW50c0FycltwXVtqXVsxXTtcbiAgICAgICAgICAgIHBvaW50c1twXS5zZXRBdHRyaWJ1dGUoJ2N4JywgY3gpO1xuICAgICAgICAgICAgdmFyIHJlYWxJbmRleCA9IHBhcnNlSW50KHBvaW50c1twXS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuXG4gICAgICAgICAgICBpZiAocGN5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvaW50c1tyZWFsSW5kZXhdICYmIHBvaW50c1tyZWFsSW5kZXhdLnNldEF0dHJpYnV0ZSgncicsIGhvdmVyU2l6ZSk7XG4gICAgICAgICAgICAgIHBvaW50c1tyZWFsSW5kZXhdICYmIHBvaW50c1tyZWFsSW5kZXhdLnNldEF0dHJpYnV0ZSgnY3knLCBwY3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9pbnRzW3JlYWxJbmRleF0gJiYgcG9pbnRzW3JlYWxJbmRleF0uc2V0QXR0cmlidXRlKCdyJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgdmFyIHRjeSA9IGN5IHx8IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGN4LCB0Y3ksIGhvdmVyU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVN0aWNreVRvb2x0aXBPdmVyQmFycyhqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgakJhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9JzEnXSBwYXRoW2o9J1wiLmNvbmNhdChqLCBcIiddLCAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nMSddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddLCAuYXBleGNoYXJ0cy1yYW5nZWJhci1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nMSddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddXCIpKTtcbiAgICAgIHZhciBiY3ggPSBqQmFyID8gcGFyc2VGbG9hdChqQmFyLmdldEF0dHJpYnV0ZSgnY3gnKSkgOiAwO1xuICAgICAgdmFyIGJjeSA9IDA7XG4gICAgICB2YXIgYncgPSBqQmFyID8gcGFyc2VGbG9hdChqQmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSkgOiAwO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgYmN4ID0gYmN4IC0gYncgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmN4ID0gdHRDdHgueEF4aXNUaWNrc1Bvc2l0aW9uc1tqIC0gMV0gKyB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoIC8gMjtcblxuICAgICAgICBpZiAoaXNOYU4oYmN4KSkge1xuICAgICAgICAgIGJjeCA9IHR0Q3R4LnhBeGlzVGlja3NQb3NpdGlvbnNbal0gLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0b29sdGlwIHdpbGwgbW92ZSB2ZXJ0aWNhbGx5IGFsb25nIHdpdGggbW91c2UgYXMgaXQgaXMgYSBzaGFyZWQgdG9vbHRpcFxuXG5cbiAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJjeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMubW92ZVhDcm9zc2hhaXJzKGJjeCk7XG5cbiAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgIHZhciB0Y3kgPSBiY3kgfHwgdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICAgIHRoaXMubW92ZVRvb2x0aXAoYmN4LCB0Y3kpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3NpdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuTWFya2VyIENsYXNzIHRvIGRyYXcgdGV4dHMgb24gdGhlIHRvb2x0aXAuXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLk1hcmtlclxuICoqL1xuXG52YXIgTWFya2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFya2VyKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtlcik7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0b29sdGlwQ29udGV4dCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya2VyLCBbe1xuICAgIGtleTogXCJkcmF3RHluYW1pY1BvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RHluYW1pY1BvaW50cygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBtYXJrZXIgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxzU2VyaWVzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IHBhcnNlSW50KGVsc1Nlcmllc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuICAgICAgICB2YXIgcG9pbnRzTWFpbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoc2VyaWVzSW5kZXgsIFwiJ10gLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcFwiKSk7XG5cbiAgICAgICAgaWYgKHBvaW50c01haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpdCBjYW4gYmUgbnVsbCBhcyB3ZSBoYXZlIHRvb2x0aXBzIGluIGRvbnV0L2JhciBjaGFydHNcbiAgICAgICAgICB2YXIgcG9pbnQgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIFBvaW50Q2xhc3NlcyA9IFwiYXBleGNoYXJ0cy1tYXJrZXIgd1wiLmNvbmNhdCgoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCkpO1xuXG4gICAgICAgICAgaWYgKCh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnbGluZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2FyZWEnKSAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF3LmNvbmZpZy50b29sdGlwLmludGVyc2VjdCkge1xuICAgICAgICAgICAgUG9pbnRDbGFzc2VzICs9ICcgbm8tcG9pbnRlci1ldmVudHMnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFBvaW50T3B0aW9ucyA9IG1hcmtlci5nZXRNYXJrZXJDb25maWcoUG9pbnRDbGFzc2VzLCBzZXJpZXNJbmRleCk7XG4gICAgICAgICAgcG9pbnQgPSBncmFwaGljcy5kcmF3TWFya2VyKDAsIDAsIGVsUG9pbnRPcHRpb25zKTtcbiAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIDApO1xuICAgICAgICAgIHZhciBlbFBvaW50c0cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAnZycpO1xuICAgICAgICAgIGVsUG9pbnRzRy5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJyk7XG4gICAgICAgICAgZWxQb2ludHNHLmFwcGVuZENoaWxkKHBvaW50Lm5vZGUpO1xuICAgICAgICAgIHBvaW50c01haW4uYXBwZW5kQ2hpbGQoZWxQb2ludHNHKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmxhcmdlQ3VycmVudFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVubGFyZ2VDdXJyZW50UG9pbnQocmVsLCBwb2ludCkge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScpIHtcbiAgICAgICAgdGhpcy5uZXdQb2ludFNpemUocmVsLCBwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IHBvaW50LmdldEF0dHJpYnV0ZSgnY3gnKTtcbiAgICAgIHZhciBjeSA9IHBvaW50LmdldEF0dHJpYnV0ZSgnY3knKTtcblxuICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgICBjeCA9IHg7XG4gICAgICAgIGN5ID0geTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgaWYgKCF0aGlzLmZpeGVkVG9vbHRpcCkge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGFyJykge1xuICAgICAgICAgIHZhciBlbEdyaWQgPSB0aGlzLnR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjeCA9IHRoaXMudHRDdHguZS5jbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uLm1vdmVUb29sdGlwKGN4LCBjeSwgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5sYXJnZVBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmxhcmdlUG9pbnRzKGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgY29sID0gajtcbiAgICAgIHZhciBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXM6bm90KC5hcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQpIC5hcGV4Y2hhcnRzLW1hcmtlcicpO1xuICAgICAgdmFyIG5ld1NpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciByZWwgPSBwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdyZWwnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnaW5kZXgnKTtcblxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3U2l6ZSA9IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaW5kZXhdICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbCA9PT0gcGFyc2VJbnQocmVsKSkge1xuICAgICAgICAgIG1lLm5ld1BvaW50U2l6ZShjb2wsIHBvaW50c1twXSk7XG4gICAgICAgICAgdmFyIGN4ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3gnKTtcbiAgICAgICAgICB2YXIgY3kgPSBwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeScpO1xuICAgICAgICAgIG1lLnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgICAgIG1lLnRvb2x0aXBQb3NpdGlvbi5tb3ZlVG9vbHRpcChjeCwgY3ksIG5ld1NpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS5vbGRQb2ludFNpemUocG9pbnRzW3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXdQb2ludFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3UG9pbnRTaXplKHJlbCwgcG9pbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG5ld1NpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG4gICAgICB2YXIgZWxQb2ludCA9IG51bGw7XG5cbiAgICAgIGlmIChyZWwgPT09IDApIHtcbiAgICAgICAgZWxQb2ludCA9IHBvaW50LnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsUG9pbnQgPSBwb2ludC5wYXJlbnROb2RlLmxhc3RDaGlsZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZWxQb2ludC5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuXG4gICAgICBpZiAobmV3U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1NpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2luZGV4XSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZWxQb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBuZXdTaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2xkUG9pbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9sZFBvaW50U2l6ZShwb2ludCkge1xuICAgICAgdmFyIHNpemUgPSBwYXJzZUludChwb2ludC5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnKSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRQb2ludHNTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0UG9pbnRzU2l6ZSgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllczpub3QoLmFwZXhjaGFydHMtc2VyaWVzLWNvbGxhcHNlZCkgLmFwZXhjaGFydHMtbWFya2VyJyk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQocG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScpKTtcblxuICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoc2l6ZSkpIHtcbiAgICAgICAgICBwb2ludHNbcF0uc2V0QXR0cmlidXRlKCdyJywgc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRzW3BdLnNldEF0dHJpYnV0ZSgncicsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmtlcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuSW50ZXJzZWN0IENsYXNzLlxuICpcbiAqIEBtb2R1bGUgVG9vbHRpcC5JbnRlcnNlY3RcbiAqKi9cblxudmFyIEludGVyc2VjdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVyc2VjdCh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcnNlY3QpO1xuXG4gICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJzZWN0LCBbe1xuICAgIGtleTogXCJnZXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHIoZSwgYXR0cikge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlSGVhdFRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSGVhdFRvb2x0aXAoX3JlZikge1xuICAgICAgdmFyIGUgPSBfcmVmLmUsXG4gICAgICAgICAgb3B0ID0gX3JlZi5vcHQsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWhlYXRtYXAtcmVjdCcpKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRBdHRyKGUsICdpJyk7XG4gICAgICAgIHZhciBqID0gdGhpcy5nZXRBdHRyKGUsICdqJyk7XG4gICAgICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cihlLCAnY3gnKTtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyKGUsICdjeScpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldEF0dHIoZSwgJ3dpZHRoJyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEF0dHIoZSwgJ2hlaWdodCcpO1xuICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHggPSBjeCArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGggLyAyICsgd2lkdGg7XG4gICAgICAgIHkgPSBjeSArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiAtIGhlaWdodCAvIDI7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3ggKyB3aWR0aCAvIDIpO1xuXG4gICAgICAgIGlmICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIpIHtcbiAgICAgICAgICB4ID0gY3ggLSB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoIC8gMiArIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LncuY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8geCA9IHR0Q3R4LmUuY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnRcblxuICAgICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAvIDIgLSAxMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNYXJrZXJUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1hcmtlclRvb2x0aXAoX3JlZjIpIHtcbiAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMi5vcHQsXG4gICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnk7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBqO1xuXG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLW1hcmtlcicpKSB7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlSW50KG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgndmFsJykpO1xuICAgICAgICBqID0gcGFyc2VJbnQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgncmVsJykpO1xuICAgICAgICBpID0gcGFyc2VJbnQob3B0LnBhdGhzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcblxuICAgICAgICBpZiAodHRDdHguaW50ZXJzZWN0KSB7XG4gICAgICAgICAgdmFyIGVsID0gVXRpbHMuZmluZEFuY2VzdG9yKG9wdC5wYXRocywgJ2FwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGkgPSBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICB0dEl0ZW1zOiBvcHQudHRJdGVtcyxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgc2hhcmVkOiB0dEN0eC5zaG93T25JbnRlcnNlY3QgPyBmYWxzZSA6IHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgIHR0Q3R4Lm1hcmtlckNsaWNrKGUsIGksIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IGN4O1xuICAgICAgICB5ID0gY3kgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ICogMS40O1xuXG4gICAgICAgIGlmICh0dEN0eC53LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgeSA9IHR0Q3R4LmUuY2xpZW50WSArIHcuZ2xvYmFscy50cmFuc2xhdGVZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICB5ID0gY3k7XG4gICAgICAgIH1cblxuICAgICAgICB0dEN0eC5tYXJrZXIuZW5sYXJnZUN1cnJlbnRQb2ludChqLCBvcHQucGF0aHMsIHgsIHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVCYXJUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUJhclRvb2x0aXAoX3JlZjMpIHtcbiAgICAgIHZhciBlID0gX3JlZjMuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMy5vcHQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdHRDdHguZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgYnggPSAwO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwOyAvLyBsZXQgYlcgPSAwXG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBzdHJva2VXaWR0aDtcbiAgICAgIHZhciBiYXJYWSA9IHRoaXMuZ2V0QmFyVG9vbHRpcFhZKHtcbiAgICAgICAgZTogZSxcbiAgICAgICAgb3B0OiBvcHRcbiAgICAgIH0pO1xuICAgICAgaSA9IGJhclhZLmk7XG4gICAgICB2YXIgYmFySGVpZ2h0ID0gYmFyWFkuYmFySGVpZ2h0O1xuICAgICAgdmFyIGogPSBiYXJYWS5qO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0dEN0eC5oYXNCYXJzKCkgfHwgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIHggPSBiYXJYWS54O1xuICAgICAgICB5ID0gYmFyWFkueTtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS53aWR0aCkgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGhbaV0gOiB3LmNvbmZpZy5zdHJva2Uud2lkdGg7IC8vIGJXID0gYmFyWFkuYmFyV2lkdGhcblxuICAgICAgICBieCA9IHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgICBieCA9IGJ4IC8gMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyB5IGlzIE5hTiwgbWFrZSBpdCB0b3VjaCB0aGUgYm90dG9tIG9mIGdyaWQgYXJlYVxuXG5cbiAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICB5ID0gdy5nbG9iYWxzLnN2Z0hlaWdodCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0O1xuICAgICAgfSAvLyB4IGV4Y2VlZHMgZ3JpZFdpZHRoXG5cblxuICAgICAgaWYgKHggKyB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICB4ID0geCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgICAgIHggPSB4ICsgdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR0Q3R4LncuY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB5ID0gdHRDdHguZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgfSAvLyBpZiB0b29sdGlwIGlzIHN0aWxsIG51bGwsIHF1ZXJ5U2VsZWN0b3JcblxuXG4gICAgICBpZiAodHRDdHgudG9vbHRpcCA9PT0gbnVsbCkge1xuICAgICAgICB0dEN0eC50b29sdGlwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHNIYXNCYXJzKSB7XG4gICAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVYQ3Jvc3NoYWlycyhieCArIHN0cm9rZVdpZHRoIC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVYQ3Jvc3NoYWlycyhieCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbW92ZSB0b29sdGlwIGhlcmVcblxuXG4gICAgICBpZiAoIXR0Q3R4LmZpeGVkVG9vbHRpcCAmJiAoIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkIHx8IHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwgJiYgdHRDdHguaGFzQmFycygpKSkge1xuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArIHcuZ2xvYmFscy50cmFuc2xhdGVYICsgJ3B4JztcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gcGFyc2VJbnQob3B0LnBhdGhzLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgdmFyIGlzUmV2ZXJzZWQgPSB3Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzID8gdy5jb25maWcueWF4aXNbc2VyaWVzSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3Nlcmllc0luZGV4XS5yZXZlcnNlZCA6IHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkO1xuXG4gICAgICAgIGlmIChpc1JldmVyc2VkICYmICEody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0dEN0eC5oYXNCYXJzKCkpKSB7XG4gICAgICAgICAgeSA9IHkgKyBiYXJIZWlnaHQgLSAody5nbG9iYWxzLnNlcmllc1tpXVtqXSA8IDAgPyBiYXJIZWlnaHQgOiAwKSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgKyB5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgICB5ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCArIHcuZ2xvYmFscy50cmFuc2xhdGVZO1xuICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArIHcuZ2xvYmFscy50cmFuc2xhdGVZIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXJUb29sdGlwWFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFyVG9vbHRpcFhZKF9yZWY0KSB7XG4gICAgICB2YXIgZSA9IF9yZWY0LmUsXG4gICAgICAgICAgb3B0ID0gX3JlZjQub3B0O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaiA9IG51bGw7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIGJhcldpZHRoID0gMDtcbiAgICAgIHZhciBiYXJIZWlnaHQgPSAwO1xuICAgICAgdmFyIGNsID0gZS50YXJnZXQuY2xhc3NMaXN0O1xuXG4gICAgICBpZiAoY2wuY29udGFpbnMoJ2FwZXhjaGFydHMtYmFyLWFyZWEnKSB8fCBjbC5jb250YWlucygnYXBleGNoYXJ0cy1jYW5kbGVzdGljay1hcmVhJykgfHwgY2wuY29udGFpbnMoJ2FwZXhjaGFydHMtcmFuZ2ViYXItYXJlYScpKSB7XG4gICAgICAgIHZhciBiYXIgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGJhclJlY3QgPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IG9wdC5lbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBiaCA9IGJhclJlY3QuaGVpZ2h0O1xuICAgICAgICBiYXJIZWlnaHQgPSBiYXJSZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIGJ3ID0gYmFyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGN4ID0gcGFyc2VJbnQoYmFyLmdldEF0dHJpYnV0ZSgnY3gnKSk7XG4gICAgICAgIHZhciBjeSA9IHBhcnNlSW50KGJhci5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuICAgICAgICBiYXJXaWR0aCA9IHBhcnNlRmxvYXQoYmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSk7XG4gICAgICAgIHZhciBjbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuICAgICAgICBqID0gcGFyc2VJbnQoYmFyLmdldEF0dHJpYnV0ZSgnaicpKTtcbiAgICAgICAgaSA9IHBhcnNlSW50KGJhci5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgaSA9IHBhcnNlSW50KGJhci5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICAgIH0gLy8gaWYgKHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIC8vIHRoaXMgY2hlY2sgbm90IG5lZWRlZCAgYXQgdGhlIG1vbWVudFxuICAgICAgICAvLyAgIGNvbnN0IHlEaXZpc29yID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAody5nbG9iYWxzLnNlcmllcy5sZW5ndGgpXG4gICAgICAgIC8vICAgY29uc3QgaG92ZXJZID0gdHRDdHguY2xpZW50WSAtIHR0Q3R4LnNlcmllc0JvdW5kLnRvcFxuICAgICAgICAvLyAgIGogPSBNYXRoLmNlaWwoaG92ZXJZIC8geURpdmlzb3IpXG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICB0dEl0ZW1zOiBvcHQudHRJdGVtcyxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgc2hhcmVkOiB0dEN0eC5zaG93T25JbnRlcnNlY3QgPyBmYWxzZSA6IHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4ID0gY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQgKyAxNTtcbiAgICAgICAgICAgIHkgPSBjeSAtIHR0Q3R4LmRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmggLyAyIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gYncgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCArIGJ3IC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9IGUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiAtIDE1O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgeCA9IGN4O1xuXG4gICAgICAgICAgICBpZiAoeCA8IHR0Q3R4Lnh5UmF0aW9zLmJhc2VMaW5lSW52ZXJ0ZWRZKSB7XG4gICAgICAgICAgICAgIHggPSBjeCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSBjeSAtIHR0Q3R4LmRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmggLyAyIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBjb2x1bW5zXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gYncgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCArIGJ3IC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9IGN5OyAvLyAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiArIDEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGpcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludGVyc2VjdDtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuQXhlc1Rvb2x0aXAgQ2xhc3MuXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLkF4ZXNUb29sdGlwXG4gKiovXG52YXIgQXhlc1Rvb2x0aXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGVzVG9vbHRpcCh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBeGVzVG9vbHRpcCk7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyB0aGUgc2Vjb25kYXJ5IHRvb2x0aXAgd2hpY2ggYXBwZWFycyBiZWxvdyB4IGF4aXNcbiAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICoqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEF4ZXNUb29sdGlwLCBbe1xuICAgIGtleTogXCJkcmF3WGF4aXNUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc1Rvb2x0aXAoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgaXNCb3R0b20gPSB3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICB0dEN0eC54YXhpc09mZlkgPSBpc0JvdHRvbSA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgMSA6IDE7XG4gICAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gaXNCb3R0b20gPyAnYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tJyA6ICdhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3AnO1xuICAgICAgdmFyIHJlbmRlclRvID0gdy5nbG9iYWxzLmRvbS5lbFdyYXA7XG5cbiAgICAgIGlmICh0dEN0eC5ibHhheGlzVG9vbHRpcCkge1xuICAgICAgICB2YXIgeGF4aXNUb29sdGlwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXN0b29sdGlwJyk7XG5cbiAgICAgICAgaWYgKHhheGlzVG9vbHRpcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdG9vbHRpcENzc0NsYXNzICsgJyAnICsgdy5jb25maWcudG9vbHRpcC50aGVtZSk7XG4gICAgICAgICAgcmVuZGVyVG8uYXBwZW5kQ2hpbGQodHRDdHgueGF4aXNUb29sdGlwKTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10ZXh0Jyk7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5zdHlsZS5mb250RmFtaWx5ID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5zdHlsZS5mb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5zdHlsZS5mb250U2l6ZSA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuc3R5bGUuZm9udFNpemU7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLmFwcGVuZENoaWxkKHR0Q3R4LnhheGlzVG9vbHRpcFRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgdGhlIHNlY29uZGFyeSB0b29sdGlwIHdoaWNoIGFwcGVhcnMgYmVsb3cgeCBheGlzXG4gICAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WWF4aXNUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZYXhpc1Rvb2x0aXAoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5jb25maWcueWF4aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlzUmlnaHQgPSB3LmNvbmZpZy55YXhpc1tpXS5vcHBvc2l0ZSB8fCB3LmNvbmZpZy55YXhpc1tpXS5jcm9zc2hhaXJzLm9wcG9zaXRlO1xuICAgICAgICB0dEN0eC55YXhpc09mZlggPSBpc1JpZ2h0ID8gdy5nbG9iYWxzLmdyaWRXaWR0aCArIDEgOiAxO1xuICAgICAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gaXNSaWdodCA/IFwiYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtXCIuY29uY2F0KGksIFwiIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0XCIpIDogXCJhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1cIi5jb25jYXQoaSwgXCIgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdFwiKTtcbiAgICAgICAgdmFyIHJlbmRlclRvID0gdy5nbG9iYWxzLmRvbS5lbFdyYXA7XG5cbiAgICAgICAgaWYgKHR0Q3R4LmJseWF4aXNUb29sdGlwKSB7XG4gICAgICAgICAgdmFyIHlheGlzVG9vbHRpcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtXCIuY29uY2F0KGkpKTtcblxuICAgICAgICAgIGlmICh5YXhpc1Rvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0b29sdGlwQ3NzQ2xhc3MgKyAnICcgKyB3LmNvbmZpZy50b29sdGlwLnRoZW1lKTtcbiAgICAgICAgICAgIHJlbmRlclRvLmFwcGVuZENoaWxkKHR0Q3R4LnlheGlzVG9vbHRpcCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgdHRDdHgueWF4aXNUb29sdGlwVGV4dCA9IFtdO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwVGV4dC5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcFRleHRbaV0uY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtdGV4dCcpO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwLmFwcGVuZENoaWxkKHR0Q3R4LnlheGlzVG9vbHRpcFRleHRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFhDcm9zc2hhaXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRYQ3Jvc3NoYWlyV2lkdGgoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7IC8vIHNldCB4Y3Jvc3NoYWlycyB3aWR0aFxuXG4gICAgICB2YXIgeGNyb3NzaGFpcnMgPSB0dEN0eC5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gcGFyc2VJbnQody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCk7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAndGlja1dpZHRoJykge1xuICAgICAgICAgIHZhciBjb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gY291bnQ7XG4gICAgICAgIH0gZWxzZSBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgIHZhciBiYXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1iYXItYXJlYScpO1xuXG4gICAgICAgICAgaWYgKGJhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VGbG9hdChiYXIuZ2V0QXR0cmlidXRlKCdiYXJXaWR0aCcpKTtcbiAgICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSBiYXJXaWR0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2JhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWJhci1hcmVhJyk7XG5cbiAgICAgICAgaWYgKF9iYXIgIT09IG51bGwgJiYgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgIHZhciBfYmFyV2lkdGggPSBwYXJzZUZsb2F0KF9iYXIuZ2V0QXR0cmlidXRlKCdiYXJXaWR0aCcpKTtcblxuICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSBfYmFyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICd0aWNrV2lkdGgnKSB7XG4gICAgICAgICAgICB2YXIgX2NvdW50ID0gdy5nbG9iYWxzLmxhYmVscy5sZW5ndGg7XG4gICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIF9jb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh4Y3Jvc3NoYWlycyAhPT0gbnVsbCAmJiB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID4gMCkge1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVlDcm9zc2hhaXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlWUNyb3NzaGFpcigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDsgLy8gc2V0IHljcm9zc2hhaXJzIGhlaWdodFxuXG4gICAgICB0dEN0eC55Y3Jvc3NoYWlycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzJyk7XG4gICAgICB0dEN0eC55Y3Jvc3NoYWlyc0hpZGRlbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzLWhpZGRlbicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WWF4aXNUb29sdGlwVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXNUb29sdGlwVGV4dChpbmRleCwgY2xpZW50WSwgeHlSYXRpb3MpIHtcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzW2luZGV4XTtcblxuICAgICAgaWYgKHR0Q3R4LmJseWF4aXNUb29sdGlwKSB7XG4gICAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgaG92ZXJZID0gKGNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3ApICogeHlSYXRpb3MueVJhdGlvW2luZGV4XTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHcuZ2xvYmFscy5tYXhZQXJyW2luZGV4XSAtIHcuZ2xvYmFscy5taW5ZQXJyW2luZGV4XTtcbiAgICAgICAgdmFyIHZhbCA9IHcuZ2xvYmFscy5taW5ZQXJyW2luZGV4XSArIChoZWlnaHQgLSBob3ZlclkpO1xuICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVlDcm9zc2hhaXJzKGNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3ApO1xuICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2luZGV4XS5pbm5lckhUTUwgPSBsYkZvcm1hdHRlcih2YWwpO1xuICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVlBeGlzVG9vbHRpcChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF4ZXNUb29sdGlwO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQ29yZSBUb29sdGlwIENsYXNzIHRvIGhhbmRsZSB0aGUgdG9vbHRpcCBnZW5lcmF0aW9uLlxuICpcbiAqIEBtb2R1bGUgVG9vbHRpcFxuICoqL1xuXG52YXIgVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXAoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdGhpcy50b29sdGlwVXRpbCA9IG5ldyBVdGlscyQxKHRoaXMpO1xuICAgIHRoaXMudG9vbHRpcExhYmVscyA9IG5ldyBMYWJlbHModGhpcyk7XG4gICAgdGhpcy50b29sdGlwUG9zaXRpb24gPSBuZXcgUG9zaXRpb24odGhpcyk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgTWFya2VyKHRoaXMpO1xuICAgIHRoaXMuaW50ZXJzZWN0ID0gbmV3IEludGVyc2VjdCh0aGlzKTtcbiAgICB0aGlzLmF4ZXNUb29sdGlwID0gbmV3IEF4ZXNUb29sdGlwKHRoaXMpO1xuICAgIHRoaXMuc2hvd09uSW50ZXJzZWN0ID0gdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3Q7XG4gICAgdGhpcy5zaG93VG9vbHRpcFRpdGxlID0gdy5jb25maWcudG9vbHRpcC54LnNob3c7XG4gICAgdGhpcy5maXhlZFRvb2x0aXAgPSB3LmNvbmZpZy50b29sdGlwLmZpeGVkLmVuYWJsZWQ7XG4gICAgdGhpcy54YXhpc1Rvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMueWF4aXNUVEVscyA9IG51bGw7XG4gICAgdGhpcy5pc0JhclNoYXJlZCA9ICF3Lmdsb2JhbHMuaXNCYXJIb3Jpem9udGFsICYmIHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiBcImdldEVsVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbFRvb2x0aXAoY3R4KSB7XG4gICAgICBpZiAoIWN0eCkgY3R4ID0gdGhpcztcbiAgICAgIHJldHVybiBjdHgudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbFhDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsWENyb3NzaGFpcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14Y3Jvc3NoYWlycycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbEdyaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxHcmlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZ3JpZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VG9vbHRpcCh4eVJhdGlvcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLnh5UmF0aW9zID0geHlSYXRpb3M7XG4gICAgICB0aGlzLmJseGF4aXNUb29sdGlwID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5lbmFibGVkICYmIHcuZ2xvYmFscy5heGlzQ2hhcnRzO1xuICAgICAgdGhpcy5ibHlheGlzVG9vbHRpcCA9IHcuY29uZmlnLnlheGlzWzBdLnRvb2x0aXAuZW5hYmxlZCAmJiB3Lmdsb2JhbHMuYXhpc0NoYXJ0cztcbiAgICAgIHRoaXMuYWxsVG9vbHRpcFNlcmllc0dyb3VwcyA9IFtdO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXBUaXRsZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwJyk7XG4gICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LmFkZCh3LmNvbmZpZy50b29sdGlwLnRoZW1lKTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxXcmFwLmFwcGVuZENoaWxkKHRvb2x0aXBFbCk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLmRyYXdYYXhpc1Rvb2x0aXAoKTtcbiAgICAgICAgdGhpcy5heGVzVG9vbHRpcC5kcmF3WWF4aXNUb29sdGlwKCk7XG4gICAgICAgIHRoaXMuYXhlc1Rvb2x0aXAuc2V0WENyb3NzaGFpcldpZHRoKCk7XG4gICAgICAgIHRoaXMuYXhlc1Rvb2x0aXAuaGFuZGxlWUNyb3NzaGFpcigpO1xuICAgICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgICB0aGlzLnhBeGlzVGlja3NQb3NpdGlvbnMgPSB4QXhpcy5nZXRYQXhpc1RpY2tzUG9zaXRpb25zKCk7XG4gICAgICB9IC8vIHdlIGZvcmNlZnVsbHkgc2V0IGludGVyc2VjdCB0cnVlIGZvciB0aGVzZSBjb25kaXRpb25zXG5cblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQgfHwgdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3QgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkIHx8ICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFuZ2VCYXInKSAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgdGhpcy5zaG93T25JbnRlcnNlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcubWFya2Vycy5zaXplID09PSAwIHx8IHcuZ2xvYmFscy5tYXJrZXJzLmxhcmdlc3RTaXplID09PSAwKSB7XG4gICAgICAgIC8vIHdoZW4gdXNlciBkb24ndCB3YW50IHRvIHNob3cgcG9pbnRzIGFsbCB0aGUgdGltZSwgYnV0IG9ubHkgb24gd2hlbiBob3ZlcmluZyBvbiBzZXJpZXNcbiAgICAgICAgdGhpcy5tYXJrZXIuZHJhd0R5bmFtaWNQb2ludHModGhpcyk7XG4gICAgICB9IC8vIG5vIHZpc2libGUgc2VyaWVzLCBleGl0XG5cblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoID09PSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzRGl2aWRlZEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICB0aGlzLmRhdGFQb2ludHNEaXZpZGVkV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG5cbiAgICAgIGlmICh0aGlzLnNob3dUb29sdGlwVGl0bGUpIHtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLnN0eWxlLmZvbnRGYW1pbHkgPSB3LmNvbmZpZy50b29sdGlwLnN0eWxlLmZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUuc3R5bGUuZm9udFNpemUgPSB3LmNvbmZpZy50b29sdGlwLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICB0b29sdGlwRWwuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGl0bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRJdGVtc0NudCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyAvLyB3aGV0aGVyIHNoYXJlZCBvciBub3QsIGRlZmF1bHQgaXMgc2hhcmVkXG5cbiAgICAgIGlmICgody5nbG9iYWxzLnh5Q2hhcnRzIHx8IHcuZ2xvYmFscy5jb21ib0NoYXJ0cykgJiYgdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dPbkludGVyc2VjdCkge1xuICAgICAgICAgIHR0SXRlbXNDbnQgPSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dEl0ZW1zQ250ID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnR0SXRlbXMgPSB0aGlzLmNyZWF0ZVRURWxlbWVudHModHRJdGVtc0NudCk7XG4gICAgICB0aGlzLmFkZFNWR0V2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUVEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRURWxlbWVudHModHRJdGVtc0NudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRJdGVtcyA9IFtdO1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHRJdGVtc0NudDsgaSsrKSB7XG4gICAgICAgIHZhciBnVHh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGdUeHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cCcpO1xuICAgICAgICB2YXIgcG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHBvaW50LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC1tYXJrZXInKTtcbiAgICAgICAgcG9pbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tpXTtcbiAgICAgICAgZ1R4dC5hcHBlbmRDaGlsZChwb2ludCk7XG4gICAgICAgIHZhciBnWVogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ1laLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0Jyk7XG4gICAgICAgIGdZWi5zdHlsZS5mb250RmFtaWx5ID0gdy5jb25maWcudG9vbHRpcC5zdHlsZS5mb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgIGdZWi5zdHlsZS5mb250U2l6ZSA9IHcuY29uZmlnLnRvb2x0aXAuc3R5bGUuZm9udFNpemU7IC8vIHkgdmFsdWVzIGdyb3VwXG5cbiAgICAgICAgdmFyIGdZVmFsVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnWVZhbFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXktZ3JvdXAnKTtcbiAgICAgICAgdmFyIHR4dExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0eHRMYWJlbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1sYWJlbCcpO1xuICAgICAgICBnWVZhbFRleHQuYXBwZW5kQ2hpbGQodHh0TGFiZWwpO1xuICAgICAgICB2YXIgdHh0VmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHR4dFZhbHVlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXZhbHVlJyk7XG4gICAgICAgIGdZVmFsVGV4dC5hcHBlbmRDaGlsZCh0eHRWYWx1ZSk7IC8vIHogdmFsdWVzIGdyb3VwXG5cbiAgICAgICAgdmFyIGdaVmFsVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnWlZhbFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXotZ3JvdXAnKTtcbiAgICAgICAgdmFyIHR4dFpMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdHh0WkxhYmVsLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotbGFiZWwnKTtcbiAgICAgICAgZ1pWYWxUZXh0LmFwcGVuZENoaWxkKHR4dFpMYWJlbCk7XG4gICAgICAgIHZhciB0eHRaVmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHR4dFpWYWx1ZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlJyk7XG4gICAgICAgIGdaVmFsVGV4dC5hcHBlbmRDaGlsZCh0eHRaVmFsdWUpO1xuICAgICAgICBnWVouYXBwZW5kQ2hpbGQoZ1lWYWxUZXh0KTtcbiAgICAgICAgZ1laLmFwcGVuZENoaWxkKGdaVmFsVGV4dCk7XG4gICAgICAgIGdUeHQuYXBwZW5kQ2hpbGQoZ1laKTtcbiAgICAgICAgdG9vbHRpcEVsLmFwcGVuZENoaWxkKGdUeHQpO1xuICAgICAgICB0dEl0ZW1zLnB1c2goZ1R4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0dEl0ZW1zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTVkdFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU1ZHRXZlbnRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHlwZSA9IHcuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciBjb21tb25CYXIgPSAhISh0eXBlID09PSAnYmFyJyB8fCB0eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHR5cGUgPT09ICdyYW5nZUJhcicpO1xuICAgICAgdmFyIGhvdmVyQXJlYSA9IHcuZ2xvYmFscy5kb20uUGFwZXIubm9kZTtcbiAgICAgIHZhciBlbEdyaWQgPSB0aGlzLmdldEVsR3JpZCgpO1xuXG4gICAgICBpZiAoZWxHcmlkKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b29sdGlwWSA9IFtdO1xuICAgICAgdmFyIHRvb2x0aXBYID0gW107XG4gICAgICB2YXIgc2VyaWVzSG92ZXJQYXJhbXMgPSB7XG4gICAgICAgIGhvdmVyQXJlYTogaG92ZXJBcmVhLFxuICAgICAgICBlbEdyaWQ6IGVsR3JpZCxcbiAgICAgICAgdG9vbHRpcEVsOiB0b29sdGlwRWwsXG4gICAgICAgIHRvb2x0aXBZOiB0b29sdGlwWSxcbiAgICAgICAgdG9vbHRpcFg6IHRvb2x0aXBYLFxuICAgICAgICB0dEl0ZW1zOiB0aGlzLnR0SXRlbXNcbiAgICAgIH07XG4gICAgICB2YXIgcG9pbnRzO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcmVhJyB8fCB0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXInIHx8IHR5cGUgPT09ICdidWJibGUnKSB7XG4gICAgICAgICAgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpsb25nZXN0U2VyaWVzPSd0cnVlJ10gLmFwZXhjaGFydHMtbWFya2VyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbW1vbkJhcikge1xuICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1iYXItYXJlYSwgLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLWFyZWEsIC5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1yYW5nZWJhci1hcmVhJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgICAgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLWhlYXRtYXAnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmFkYXInKSB7XG4gICAgICAgICAgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLW1hcmtlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwb2ludHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHRvb2x0aXBZLnB1c2gocG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3knKSk7XG4gICAgICAgICAgICB0b29sdGlwWC5wdXNoKHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsaWRTaGFyZWRDaGFydFR5cGVzID0gdy5nbG9iYWxzLnh5Q2hhcnRzICYmICF0aGlzLnNob3dPbkludGVyc2VjdCB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXRoaXMuc2hvd09uSW50ZXJzZWN0IHx8IGNvbW1vbkJhciAmJiB0aGlzLmhhc0JhcnMoKSAmJiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZDtcblxuICAgICAgaWYgKHZhbGlkU2hhcmVkQ2hhcnRUeXBlcykge1xuICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoW2hvdmVyQXJlYV0sIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY29tbW9uQmFyICYmICF3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgdGhpcy5hZGRCYXJzRXZlbnRMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYnViYmxlJyB8fCB0eXBlID09PSAnc2NhdHRlcicgfHwgdHlwZSA9PT0gJ3JhZGFyJyB8fCB0aGlzLnNob3dPbkludGVyc2VjdCAmJiAodHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdsaW5lJykpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludHNFdmVudHNMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMgfHwgdHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgIHZhciBzZXJpZXNBbGwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMnKTtcbiAgICAgICAgdGhpcy5hZGRQYXRoc0V2ZW50TGlzdGVuZXJzKHNlcmllc0FsbCwgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93T25JbnRlcnNlY3QpIHtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1saW5lLXNlcmllcyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcblxuICAgICAgICBpZiAobGluZVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhbnkgbGluZVNlcmllcywgYWRkRXZlbnRMaXN0ZW5lcnMgZm9yIHRoZW1cbiAgICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMobGluZVBvaW50cywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZWFQb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcblxuICAgICAgICBpZiAoYXJlYVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhbnkgYXJlYVNlcmllcywgYWRkRXZlbnRMaXN0ZW5lcnMgZm9yIHRoZW1cbiAgICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoYXJlYVBvaW50cywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9IC8vIGNvbWJvIGNoYXJ0cyBtYXkgaGF2ZSBiYXJzLCBzbyBhZGQgZXZlbnQgbGlzdGVuZXJzIGhlcmUgdG9vXG5cblxuICAgICAgICBpZiAodGhpcy5oYXNCYXJzKCkgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgICAgdGhpcy5hZGRCYXJzRXZlbnRMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdGaXhlZFRvb2x0aXBSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdGaXhlZFRvb2x0aXBSZWN0KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciB0b29sdGlwUmVjdCA9IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0dFdpZHRoID0gdG9vbHRpcFJlY3Qud2lkdGggKyAxMDtcbiAgICAgIHZhciB0dEhlaWdodCA9IHRvb2x0aXBSZWN0LmhlaWdodCArIDEwO1xuICAgICAgdmFyIHggPSB3LmNvbmZpZy50b29sdGlwLmZpeGVkLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IHcuY29uZmlnLnRvb2x0aXAuZml4ZWQub2Zmc2V0WTtcblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuZml4ZWQucG9zaXRpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyaWdodCcpID4gLTEpIHtcbiAgICAgICAgeCA9IHggKyB3Lmdsb2JhbHMuc3ZnV2lkdGggLSB0dFdpZHRoICsgMTA7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZpeGVkLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xuICAgICAgICB5ID0geSArIHcuZ2xvYmFscy5zdmdIZWlnaHQgLSB0dEhlaWdodCAtIDEwO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgdHRXaWR0aDogdHRXaWR0aCxcbiAgICAgICAgdHRIZWlnaHQ6IHR0SGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQb2ludHNFdmVudHNMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRzRXZlbnRzTGlzdGVuZXJzKHNlcmllc0hvdmVyUGFyYW1zKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcbiAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhwb2ludHMsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQmFyc0V2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJhcnNFdmVudExpc3RlbmVycyhzZXJpZXNIb3ZlclBhcmFtcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYmFycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJhci1hcmVhLCAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1hcmVhLCAuYXBleGNoYXJ0cy1yYW5nZWJhci1hcmVhJyk7XG4gICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoYmFycywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQYXRoc0V2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMocGF0aHMsIG9wdHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocCkge1xuICAgICAgICB2YXIgZXh0ZW5kZWRPcHRzID0ge1xuICAgICAgICAgIHBhdGhzOiBwYXRoc1twXSxcbiAgICAgICAgICB0b29sdGlwRWw6IG9wdHMudG9vbHRpcEVsLFxuICAgICAgICAgIHRvb2x0aXBZOiBvcHRzLnRvb2x0aXBZLFxuICAgICAgICAgIHRvb2x0aXBYOiBvcHRzLnRvb2x0aXBYLFxuICAgICAgICAgIGVsR3JpZDogb3B0cy5lbEdyaWQsXG4gICAgICAgICAgaG92ZXJBcmVhOiBvcHRzLmhvdmVyQXJlYSxcbiAgICAgICAgICB0dEl0ZW1zOiBvcHRzLnR0SXRlbXNcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudy5nbG9iYWxzLnRvb2x0aXBPcHRzID0gZXh0ZW5kZWRPcHRzO1xuICAgICAgICB2YXIgZXZlbnRzID0gWydtb3VzZW1vdmUnLCAnbW91c2V1cCcsICd0b3VjaG1vdmUnLCAnbW91c2VvdXQnLCAndG91Y2hlbmQnXTtcbiAgICAgICAgZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aHNbcF0uYWRkRXZlbnRMaXN0ZW5lcihldiwgc2VsZi5zZXJpZXNIb3Zlci5iaW5kKHNlbGYsIGV4dGVuZGVkT3B0cyksIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGF0aHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgX2xvb3AocCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICoqIFRoZSBhY3R1YWwgc2VyaWVzIGhvdmVyIGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXJpZXNIb3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpZXNIb3ZlcihvcHQsIGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hhcnRHcm91cHMgPSBbXTtcbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBpZiB1c2VyIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJ0cyBpbiBncm91cCwgd2UgbmVlZCB0byBzeW5jXG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5ncm91cCkge1xuICAgICAgICBjaGFydEdyb3VwcyA9IHRoaXMuY3R4LmdldEdyb3VwZWRDaGFydHMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzICYmICh3Lmdsb2JhbHMubWluWCA9PT0gLUluZmluaXR5ICYmIHcuZ2xvYmFscy5tYXhYID09PSBJbmZpbml0eSB8fCB3Lmdsb2JhbHMuZGF0YVBvaW50cyA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhcnRHcm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGNoYXJ0R3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgdmFyIHRvb2x0aXBFbCA9IF90aGlzMi5nZXRFbFRvb2x0aXAoY2gpO1xuXG4gICAgICAgICAgdmFyIG5ld09wdHMgPSB7XG4gICAgICAgICAgICBwYXRoczogb3B0LnBhdGhzLFxuICAgICAgICAgICAgdG9vbHRpcEVsOiB0b29sdGlwRWwsXG4gICAgICAgICAgICB0b29sdGlwWTogb3B0LnRvb2x0aXBZLFxuICAgICAgICAgICAgdG9vbHRpcFg6IG9wdC50b29sdGlwWCxcbiAgICAgICAgICAgIGVsR3JpZDogb3B0LmVsR3JpZCxcbiAgICAgICAgICAgIGhvdmVyQXJlYTogb3B0LmhvdmVyQXJlYSxcbiAgICAgICAgICAgIHR0SXRlbXM6IGNoLncuZ2xvYmFscy50b29sdGlwLnR0SXRlbXMgLy8gYWxsIHRoZSBjaGFydHMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbWluWCBhbmQgbWF4WCAoc2FtZSB4YXhpcykgZm9yIG11bHRpcGxlIHRvb2x0aXBzIHRvIHdvcmsgY29ycmVjdGx5XG5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGNoLncuZ2xvYmFscy5taW5YID09PSBfdGhpczIudy5nbG9iYWxzLm1pblggJiYgY2gudy5nbG9iYWxzLm1heFggPT09IF90aGlzMi53Lmdsb2JhbHMubWF4WCkge1xuICAgICAgICAgICAgY2gudy5nbG9iYWxzLnRvb2x0aXAuc2VyaWVzSG92ZXJCeUNvbnRleHQoe1xuICAgICAgICAgICAgICBjaGFydEN0eDogY2gsXG4gICAgICAgICAgICAgIHR0Q3R4OiBjaC53Lmdsb2JhbHMudG9vbHRpcCxcbiAgICAgICAgICAgICAgb3B0OiBuZXdPcHRzLFxuICAgICAgICAgICAgICBlOiBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJpZXNIb3ZlckJ5Q29udGV4dCh7XG4gICAgICAgICAgY2hhcnRDdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIHR0Q3R4OiB0aGlzLncuZ2xvYmFscy50b29sdGlwLFxuICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgIGU6IGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmllc0hvdmVyQnlDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmllc0hvdmVyQnlDb250ZXh0KF9yZWYpIHtcbiAgICAgIHZhciBjaGFydEN0eCA9IF9yZWYuY2hhcnRDdHgsXG4gICAgICAgICAgdHRDdHggPSBfcmVmLnR0Q3R4LFxuICAgICAgICAgIG9wdCA9IF9yZWYub3B0LFxuICAgICAgICAgIGUgPSBfcmVmLmU7XG4gICAgICB2YXIgdyA9IGNoYXJ0Q3R4Lnc7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTsgLy8gdG9vbHRpcFJlY3QgaXMgY2FsY3VsYXRlZCBvbiBldmVyeSBtb3VzZW1vdmUsIGJlY2F1c2UgdGhlIHRleHQgaXMgZHluYW1pY1xuXG4gICAgICB0dEN0eC50b29sdGlwUmVjdCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHRXaWR0aDogdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuICAgICAgICB0dEhlaWdodDogdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHR0Q3R4LmUgPSBlOyAvLyBoaWdobGlnaHQgdGhlIGN1cnJlbnQgaG92ZXJlZCBiYXJzXG5cbiAgICAgIGlmICh0dEN0eC5oYXNCYXJzKCkgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdHRDdHguaXNCYXJTaGFyZWQpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAub25EYXRhc2V0SG92ZXIuaGlnaGxpZ2h0RGF0YVNlcmllcykge1xuICAgICAgICAgIHZhciBzZXJpZXMgPSBuZXcgU2VyaWVzKGNoYXJ0Q3R4KTtcbiAgICAgICAgICBzZXJpZXMudG9nZ2xlU2VyaWVzT25Ib3ZlcihlLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgIHR0Q3R4LmRyYXdGaXhlZFRvb2x0aXBSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICB0dEN0eC5heGlzQ2hhcnRzVG9vbHRpcHMoe1xuICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgdG9vbHRpcFJlY3Q6IHR0Q3R4LnRvb2x0aXBSZWN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnRzIGkuZSBwaWUvZG9udXQvY2lyY2xlXG4gICAgICAgIHR0Q3R4Lm5vbkF4aXNDaGFydHNUb29sdGlwcyh7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICB0b29sdGlwUmVjdDogdHRDdHgudG9vbHRpcFJlY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyB0b29sdGlwIGhhbmRsaW5nIGZvciBsaW5lL2FyZWEvYmFyL2NvbHVtbnMvc2NhdHRlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXhpc0NoYXJ0c1Rvb2x0aXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF4aXNDaGFydHNUb29sdGlwcyhfcmVmMikge1xuICAgICAgdmFyIGUgPSBfcmVmMi5lLFxuICAgICAgICAgIG9wdCA9IF9yZWYyLm9wdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGosIHgsIHk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2FwaiA9IG51bGw7XG4gICAgICB2YXIgc2VyaWVzQm91bmQgPSBvcHQuZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG4gICAgICB2YXIgY2xpZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WSA6IGUuY2xpZW50WTtcbiAgICAgIHRoaXMuY2xpZW50WSA9IGNsaWVudFk7XG4gICAgICB0aGlzLmNsaWVudFggPSBjbGllbnRYO1xuXG4gICAgICBpZiAoY2xpZW50WSA8IHNlcmllc0JvdW5kLnRvcCB8fCBjbGllbnRZID4gc2VyaWVzQm91bmQudG9wICsgc2VyaWVzQm91bmQuaGVpZ2h0KSB7XG4gICAgICAgIHNlbGYuaGFuZGxlTW91c2VPdXQob3B0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciB4Y3Jvc3NoYWlycyA9IHRoaXMuZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgdmFyIGlzU3RpY2t5VG9vbHRpcCA9IHcuZ2xvYmFscy54eUNoYXJ0cyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiAhdy5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0aGlzLmhhc0JhcnMoKSAmJiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZCB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgdGhpcy5oYXNCYXJzO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzQmFySG9yaXpvbnRhbCAmJiB0aGlzLmhhc0JhcnMoKSkge1xuICAgICAgICBpc1N0aWNreVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnljcm9zc2hhaXJzICE9PSBudWxsICYmIHNlbGYuYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgICBzZWxmLnljcm9zc2hhaXJzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3RpY2t5VG9vbHRpcCAmJiAhc2VsZi5zaG93T25JbnRlcnNlY3QpIHtcbiAgICAgICAgICBjYXBqID0gc2VsZi50b29sdGlwVXRpbC5nZXROZWFyZXN0VmFsdWVzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlbGYsXG4gICAgICAgICAgICBob3ZlckFyZWE6IG9wdC5ob3ZlckFyZWEsXG4gICAgICAgICAgICBlbEdyaWQ6IG9wdC5lbEdyaWQsXG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WSxcbiAgICAgICAgICAgIGhhc0JhcnM6IHNlbGYuaGFzQmFyc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGogPSBjYXBqLmo7XG4gICAgICAgICAgdmFyIGNhcHR1cmVkU2VyaWVzID0gY2Fwai5jYXB0dXJlZFNlcmllcztcblxuICAgICAgICAgIGlmIChjYXBqLmhvdmVyWCA8IDAgfHwgY2Fwai5ob3ZlclggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhcHR1cmVkU2VyaWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaWdub3JlTnVsbCA9IHcuZ2xvYmFscy5zZXJpZXNbY2FwdHVyZWRTZXJpZXNdW2pdID09PSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlTnVsbCkge1xuICAgICAgICAgICAgICBvcHQudG9vbHRpcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlcmllc1tjYXB0dXJlZFNlcmllc11bal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLnNoYXJlZCAmJiB0aGlzLnRvb2x0aXBVdGlsLmlzWG92ZXJsYXAoaikgJiYgdGhpcy50b29sdGlwVXRpbC5pc2luaXRpYWxTZXJpZXNTYW1lTGVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShlLCBzZWxmLCBjYXB0dXJlZFNlcmllcywgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGUsIHNlbGYsIGNhcHR1cmVkU2VyaWVzLCBqLCBvcHQudHRJdGVtcywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy50b29sdGlwVXRpbC5pc1hvdmVybGFwKGopKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jcmVhdGUoZSwgc2VsZiwgMCwgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvdWxkbid0IGNhcHR1cmUgYW55IHNlcmllcy4gY2hlY2sgaWYgc2hhcmVkIFggaXMgc2FtZSxcbiAgICAgICAgICAgIC8vIGlmIHllcywgZHJhdyBhIGdyb3VwZWQgdG9vbHRpcFxuICAgICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaXNYb3ZlcmxhcChqKSkge1xuICAgICAgICAgICAgICBzZWxmLmNyZWF0ZShlLCBzZWxmLCAwLCBqLCBvcHQudHRJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJYWSA9IHRoaXMuaW50ZXJzZWN0LmhhbmRsZUhlYXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeCA9IG1hcmtlclhZLng7XG4gICAgICAgICAgICB5ID0gbWFya2VyWFkueTtcbiAgICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0JhcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QuaGFuZGxlQmFyVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBvcHQ6IG9wdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTWFya2Vycykge1xuICAgICAgICAgICAgICAvLyBpbnRlcnNlY3QgLSBsaW5lL2FyZWEvc2NhdHRlci9idWJibGVcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QuaGFuZGxlTWFya2VyVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgICBmb3IgKHZhciB5dCA9IDA7IHl0IDwgdy5jb25maWcueWF4aXMubGVuZ3RoOyB5dCsrKSB7XG4gICAgICAgICAgICBzZWxmLmF4ZXNUb29sdGlwLmRyYXdZYXhpc1Rvb2x0aXBUZXh0KHl0LCBjbGllbnRZLCBzZWxmLnh5UmF0aW9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQudG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VPdXQob3B0KTtcbiAgICAgIH1cbiAgICB9IC8vIHRvb2x0aXAgaGFuZGxpbmcgZm9yIHBpZS9kb251dHNcblxuICB9LCB7XG4gICAga2V5OiBcIm5vbkF4aXNDaGFydHNUb29sdGlwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub25BeGlzQ2hhcnRzVG9vbHRpcHMoX3JlZjMpIHtcbiAgICAgIHZhciBlID0gX3JlZjMuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMy5vcHQsXG4gICAgICAgICAgdG9vbHRpcFJlY3QgPSBfcmVmMy50b29sdGlwUmVjdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJlbCA9IG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgc2VyaWVzQm91bmQgPSB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgIHR0SXRlbXM6IG9wdC50dEl0ZW1zLFxuICAgICAgICAgIGk6IHBhcnNlSW50KHJlbCkgLSAxLFxuICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4ID0gdy5nbG9iYWxzLmNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0IC0gdG9vbHRpcFJlY3QudHRXaWR0aCAvIDI7XG4gICAgICAgIHZhciB5ID0gdy5nbG9iYWxzLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgLSB0b29sdGlwUmVjdC50dEhlaWdodCAtIDEwO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0JyB8fCBlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWFjdGl2YXRlSG92ZXJGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZUhvdmVyRmlsdGVyKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGFsbFBhdGhzID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoXCIuYXBleGNoYXJ0cy1iYXItYXJlYVwiKTtcblxuICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBhbGxQYXRocy5sZW5ndGg7IGIrKykge1xuICAgICAgICBncmFwaGljcy5wYXRoTW91c2VMZWF2ZShhbGxQYXRoc1tiXSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdXNlT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlT3V0KG9wdCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeGNyb3NzaGFpcnMgPSB0aGlzLmdldEVsWENyb3NzaGFpcnMoKTtcbiAgICAgIG9wdC50b29sdGlwRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVIb3ZlckZpbHRlcigpO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScpIHtcbiAgICAgICAgdGhpcy5tYXJrZXIucmVzZXRQb2ludHNTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMueWNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy55Y3Jvc3NoYWlycy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmx4YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgdGhpcy54YXhpc1Rvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJseWF4aXNUb29sdGlwKSB7XG4gICAgICAgIGlmICh0aGlzLnlheGlzVFRFbHMgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnlheGlzVFRFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55YXhpc1RURWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy55YXhpc1RURWxzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsTWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbE1hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcgLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWxsTWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGxNYXJrZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc01hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTWFya2VycygpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRFbE1hcmtlcnMoKTtcbiAgICAgIHJldHVybiBtYXJrZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsQmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbEJhcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1iYXItc2VyaWVzLCAgLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stc2VyaWVzLCAuYXBleGNoYXJ0cy1yYW5nZWJhci1zZXJpZXMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNCYXJzKCkge1xuICAgICAgdmFyIGJhcnMgPSB0aGlzLmdldEVsQmFycygpO1xuICAgICAgcmV0dXJuIGJhcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya2VyQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya2VyQ2xpY2soZSwgc2VyaWVzSW5kZXgsIGRhdGFQb2ludEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMubWFya2VyQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLm1hcmtlckNsaWNrKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ21hcmtlckNsaWNrJywgW2UsIHRoaXMuY3R4LCB7XG4gICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGRhdGFQb2ludEluZGV4LFxuICAgICAgICB3OiB3XG4gICAgICB9XSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoZSwgY29udGV4dCwgY2FwdHVyZWRTZXJpZXMsIGosIHR0SXRlbXMpIHtcbiAgICAgIHZhciBzaGFyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IGNvbnRleHQ7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICB0aGlzLm1hcmtlckNsaWNrKGUsIGNhcHR1cmVkU2VyaWVzLCBqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoYXJlZCA9PT0gbnVsbCkgc2hhcmVkID0gdy5jb25maWcudG9vbHRpcC5zaGFyZWQ7XG4gICAgICB2YXIgaGFzTWFya2VycyA9IHRoaXMuaGFzTWFya2VycygpO1xuICAgICAgdmFyIGJhcnMgPSB0aGlzLmdldEVsQmFycygpO1xuXG4gICAgICBpZiAoc2hhcmVkKSB7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICAgIGk6IGNhcHR1cmVkU2VyaWVzLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgc2hhcmVkOiB0aGlzLnNob3dPbkludGVyc2VjdCA/IGZhbHNlIDogdy5jb25maWcudG9vbHRpcC5zaGFyZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLm1hcmtlcnMubGFyZ2VzdFNpemUgPiAwKSB7XG4gICAgICAgICAgICB0dEN0eC5tYXJrZXIuZW5sYXJnZVBvaW50cyhqKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVEeW5hbWljUG9pbnRzT25Ib3ZlcihqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNCYXJzKCkpIHtcbiAgICAgICAgICB0aGlzLmJhclNlcmllc0hlaWdodCA9IHRoaXMudG9vbHRpcFV0aWwuZ2V0QmFyc0hlaWdodChiYXJzKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJhclNlcmllc0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgIC8vIGhvdmVyIHN0YXRlLCBhY3RpdmF0ZSBzbmFwIGZpbHRlclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiLmFwZXhjaGFydHMtYmFyLWFyZWFbaj0nXCIuY29uY2F0KGosIFwiJ11cIikpOyAvLyBkZS1hY3RpdmF0ZSBmaXJzdFxuXG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVIb3ZlckZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwUG9zaXRpb24ubW92ZVN0aWNreVRvb2x0aXBPdmVyQmFycyhqKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBwYXRocy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICBncmFwaGljcy5wYXRoTW91c2VFbnRlcihwYXRoc1tiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICAgIGk6IGNhcHR1cmVkU2VyaWVzLFxuICAgICAgICAgIGo6IGpcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQmFycygpKSB7XG4gICAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnMoaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlTWFya2VycyhjYXB0dXJlZFNlcmllcywgaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oKTtcblxudmFyIGljb1BhbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiBmaWxsPVxcXCIjMDAwMDAwXFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCI+XFxuICAgIDxkZWZzPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgaWQ9XFxcImFcXFwiLz5cXG4gICAgPC9kZWZzPlxcbiAgICA8Y2xpcFBhdGggaWQ9XFxcImJcXFwiPlxcbiAgICAgICAgPHVzZSBvdmVyZmxvdz1cXFwidmlzaWJsZVxcXCIgeGxpbms6aHJlZj1cXFwiI2FcXFwiLz5cXG4gICAgPC9jbGlwUGF0aD5cXG4gICAgPHBhdGggY2xpcC1wYXRoPVxcXCJ1cmwoI2IpXFxcIiBkPVxcXCJNMjMgNS41VjIwYzAgMi4yLTEuOCA0LTQgNGgtNy4zYy0xLjA4IDAtMi4xLS40My0yLjg1LTEuMTlMMSAxNC44M3MxLjI2LTEuMjMgMS4zLTEuMjVjLjIyLS4xOS40OS0uMjkuNzktLjI5LjIyIDAgLjQyLjA2LjYuMTYuMDQuMDEgNC4zMSAyLjQ2IDQuMzEgMi40NlY0YzAtLjgzLjY3LTEuNSAxLjUtMS41UzExIDMuMTcgMTEgNHY3aDFWMS41YzAtLjgzLjY3LTEuNSAxLjUtMS41UzE1IC42NyAxNSAxLjVWMTFoMVYyLjVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjVWMTFoMVY1LjVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjV6XFxcIi8+XFxuPC9zdmc+XCI7XG5cbnZhciBpY29ab29tID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwiIzAwMDAwMFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QzE1LjQxIDEyLjU5IDE2IDExLjExIDE2IDkuNSAxNiA1LjkxIDEzLjA5IDMgOS41IDNTMyA1LjkxIDMgOS41IDUuOTEgMTYgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwVjB6XFxcIiBmaWxsPVxcXCJub25lXFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMiAxMGgtMnYySDl2LTJIN1Y5aDJWN2gxdjJoMnYxelxcXCIvPlxcbjwvc3ZnPlwiO1xuXG52YXIgaWNvUmVzZXQgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6XFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG48L3N2Zz5cIjtcblxudmFyIGljb1pvb21JbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNMTMgN2gtMnY0SDd2Mmg0djRoMnYtNGg0di0yaC00Vjd6bS0xLTVDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuXG52YXIgaWNvWm9vbU91dCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNNyAxMXYyaDEwdi0ySDd6bTUtOUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XFxcIi8+XFxuPC9zdmc+XFxuXCI7XG5cbnZhciBpY29TZWxlY3QgPSBcIjxzdmcgZmlsbD1cXFwiIzZFODE5MlxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTMgNWgyVjNjLTEuMSAwLTIgLjktMiAyem0wIDhoMnYtMkgzdjJ6bTQgOGgydi0ySDd2MnpNMyA5aDJWN0gzdjJ6bTEwLTZoLTJ2MmgyVjN6bTYgMHYyaDJjMC0xLjEtLjktMi0yLTJ6TTUgMjF2LTJIM2MwIDEuMS45IDIgMiAyem0tMi00aDJ2LTJIM3Yyek05IDNIN3YyaDJWM3ptMiAxOGgydi0yaC0ydjJ6bTgtOGgydi0yaC0ydjJ6bTAgOGMxLjEgMCAyLS45IDItMmgtMnYyem0wLTEyaDJWN2gtMnYyem0wIDhoMnYtMmgtMnYyem0tNCA0aDJ2LTJoLTJ2MnptMC0xNmgyVjNoLTJ2MnpcXFwiLz5cXG48L3N2Zz5cIjtcblxudmFyIGljb01lbnUgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgZD1cXFwiTTAgMGgyNHYyNEgwVjB6XFxcIi8+PHBhdGggZD1cXFwiTTMgMThoMTh2LTJIM3Yyem0wLTVoMTh2LTJIM3Yyem0wLTd2MmgxOFY2SDN6XFxcIi8+PC9zdmc+XCI7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sYmFyIENsYXNzIGZvciBjcmVhdGluZyB0b29sYmFyIGluIGF4aXMgYmFzZWQgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgVG9vbGJhclxuICoqL1xuXG52YXIgVG9vbGJhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2xiYXIoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2xiYXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5ldiA9IHRoaXMudy5jb25maWcuY2hhcnQuZXZlbnRzO1xuICAgIHRoaXMubG9jYWxlVmFsdWVzID0gdGhpcy53Lmdsb2JhbHMubG9jYWxlLnRvb2xiYXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbGJhciwgW3tcbiAgICBrZXk6IFwiY3JlYXRlVG9vbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUb29sYmFyKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxUb29sYmFyV3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZWxUb29sYmFyV3JhcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FwZXhjaGFydHMtdG9vbGJhcicpO1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQoZWxUb29sYmFyV3JhcCk7XG4gICAgICB0aGlzLmVsWm9vbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFpvb21JbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFpvb21PdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxQYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxTZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxab29tUmVzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxNZW51SWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbE1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxDdXN0b21JY29ucyA9IFtdO1xuICAgICAgdGhpcy50ID0gdy5jb25maWcuY2hhcnQudG9vbGJhci50b29scztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50LmN1c3RvbUljb25zKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudC5jdXN0b21JY29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWxDdXN0b21JY29ucy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVsTWVudUl0ZW1zID0gW107XG4gICAgICB2YXIgdG9vbGJhckNvbnRyb2xzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnQuem9vbWluICYmIHcuY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxab29tSW4sXG4gICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC56b29taW4gPT09ICdzdHJpbmcnID8gdGhpcy50Lnpvb21pbiA6IGljb1pvb21JbixcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuem9vbUluLFxuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy16b29tLWluLWljb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50Lnpvb21vdXQgJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFpvb21PdXQsXG4gICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC56b29tb3V0ID09PSAnc3RyaW5nJyA/IHRoaXMudC56b29tb3V0IDogaWNvWm9vbU91dCxcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuem9vbU91dCxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtem9vbS1vdXQtaWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnQuem9vbSAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsWm9vbSxcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50Lnpvb20gPT09ICdzdHJpbmcnID8gdGhpcy50Lnpvb20gOiBpY29ab29tLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5zZWxlY3Rpb25ab29tLFxuICAgICAgICAgIGNsYXNzOiB3Lmdsb2JhbHMuaXNUb3VjaERldmljZSA/ICdoaWRkZW4nIDogJ2FwZXhjaGFydHMtem9vbS1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5zZWxlY3Rpb24gJiYgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsU2VsZWN0aW9uLFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQuc2VsZWN0aW9uID09PSAnc3RyaW5nJyA/IHRoaXMudC5zZWxlY3Rpb24gOiBpY29TZWxlY3QsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLnNlbGVjdGlvbixcbiAgICAgICAgICBjbGFzczogdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UgPyAnaGlkZGVuJyA6ICdhcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5wYW4gJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFBhbixcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LnBhbiA9PT0gJ3N0cmluZycgPyB0aGlzLnQucGFuIDogaWNvUGFuLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5wYW4sXG4gICAgICAgICAgY2xhc3M6IHcuZ2xvYmFscy5pc1RvdWNoRGV2aWNlID8gJ2hpZGRlbicgOiAnYXBleGNoYXJ0cy1wYW4taWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnQucmVzZXQgJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFpvb21SZXNldCxcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LnJlc2V0ID09PSAnc3RyaW5nJyA/IHRoaXMudC5yZXNldCA6IGljb1Jlc2V0LFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5yZXNldCxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5kb3dubG9hZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxNZW51SWNvbixcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LmRvd25sb2FkID09PSAnc3RyaW5nJyA/IHRoaXMudC5kb3dubG9hZCA6IGljb01lbnUsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLm1lbnUsXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLW1lbnUtaWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmVsQ3VzdG9tSWNvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbEN1c3RvbUljb25zW19pXSxcbiAgICAgICAgICBpY29uOiB0aGlzLnQuY3VzdG9tSWNvbnNbX2ldLmljb24sXG4gICAgICAgICAgdGl0bGU6IHRoaXMudC5jdXN0b21JY29uc1tfaV0udGl0bGUsXG4gICAgICAgICAgaW5kZXg6IHRoaXMudC5jdXN0b21JY29uc1tfaV0uaW5kZXgsXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXRvb2xiYXItY3VzdG9tLWljb24gJyArIHRoaXMudC5jdXN0b21JY29uc1tfaV0uY2xhc3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRvb2xiYXJDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpbmRleCkge1xuICAgICAgICBpZiAodC5pbmRleCkge1xuICAgICAgICAgIFV0aWxzLm1vdmVJbmRleEluQXJyYXkodG9vbGJhckNvbnRyb2xzLCBpbmRleCwgdC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0b29sYmFyQ29udHJvbHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0b29sYmFyQ29udHJvbHNbX2kyXS5lbCwge1xuICAgICAgICAgIGNsYXNzOiB0b29sYmFyQ29udHJvbHNbX2kyXS5jbGFzcyxcbiAgICAgICAgICB0aXRsZTogdG9vbGJhckNvbnRyb2xzW19pMl0udGl0bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRvb2xiYXJDb250cm9sc1tfaTJdLmVsLmlubmVySFRNTCA9IHRvb2xiYXJDb250cm9sc1tfaTJdLmljb247XG4gICAgICAgIGVsVG9vbGJhcldyYXAuYXBwZW5kQ2hpbGQodG9vbGJhckNvbnRyb2xzW19pMl0uZWwpO1xuICAgICAgfVxuXG4gICAgICBlbFRvb2xiYXJXcmFwLmFwcGVuZENoaWxkKHRoaXMuZWxNZW51KTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHRoaXMuZWxNZW51LCB7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1tZW51J1xuICAgICAgfSk7XG4gICAgICB2YXIgbWVudUl0ZW1zID0gW3tcbiAgICAgICAgbmFtZTogJ2V4cG9ydFNWRycsXG4gICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5leHBvcnRUb1NWR1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnZXhwb3J0UE5HJyxcbiAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLmV4cG9ydFRvUE5HXG4gICAgICB9XTtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbWVudUl0ZW1zLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdGhpcy5lbE1lbnVJdGVtcy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJdGVtc1tfaTNdLmlubmVySFRNTCA9IG1lbnVJdGVtc1tfaTNdLnRpdGxlO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0aGlzLmVsTWVudUl0ZW1zW19pM10sIHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLW1lbnUtaXRlbSBcIi5jb25jYXQobWVudUl0ZW1zW19pM10ubmFtZSksXG4gICAgICAgICAgdGl0bGU6IG1lbnVJdGVtc1tfaTNdLnRpdGxlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsTWVudS5hcHBlbmRDaGlsZCh0aGlzLmVsTWVudUl0ZW1zW19pM10pO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFRvb2xiYXJFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb29sYmFyRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9vbGJhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5lbFpvb21SZXNldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbVJlc2V0LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbFNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbFpvb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVpvb21pbmcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsWm9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tSW4uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsWm9vbU91dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbU91dC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxQYW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVBhbm5pbmcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsTWVudUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsTWVudUl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKG0uY2xhc3NMaXN0LmNvbnRhaW5zKCdleHBvcnRTVkcnKSkge1xuICAgICAgICAgIG0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5kb3dubG9hZFNWRy5iaW5kKF90aGlzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydFBORycpKSB7XG4gICAgICAgICAgbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLmRvd25sb2FkUE5HLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50LmN1c3RvbUljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWxDdXN0b21JY29uc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudC5jdXN0b21JY29uc1tpXS5jbGljayk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZDtcblxuICAgICAgaWYgKCF0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVpvb21pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlWm9vbWluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQ7XG5cbiAgICAgIGlmICghdGhpcy5lbFpvb20uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb29sYmFySWNvbnNSZWZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICghdGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy16b29tLWljb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVsUGFuKSB7XG4gICAgICAgIHRoaXMuZWxQYW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1wYW4taWNvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWxTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVpvb21pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlWm9vbWluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxQYW4pIHtcbiAgICAgICAgdGhpcy5lbFBhbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVQYW5uaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVBhbm5pbmcoKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnBhbkVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5lbFBhbikge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsWm9vbSkge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVQYW5uaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVBhbm5pbmcoKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnBhbkVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMucGFuRW5hYmxlZDtcblxuICAgICAgaWYgKCF0aGlzLmVsUGFuLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZU90aGVyQ29udHJvbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlT3RoZXJDb250cm9scygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnBhbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHcuZ2xvYmFscy56b29tRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmVsUGFuKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlWm9vbUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21JbigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNlbnRlclggPSAody5nbG9iYWxzLm1pblggKyB3Lmdsb2JhbHMubWF4WCkgLyAyO1xuICAgICAgdmFyIG5ld01pblggPSAody5nbG9iYWxzLm1pblggKyBjZW50ZXJYKSAvIDI7XG4gICAgICB2YXIgbmV3TWF4WCA9ICh3Lmdsb2JhbHMubWF4WCArIGNlbnRlclgpIC8gMjtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZGlzYWJsZVpvb21Jbikge1xuICAgICAgICB0aGlzLnpvb21VcGRhdGVPcHRpb25zKG5ld01pblgsIG5ld01heFgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVab29tT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21PdXQoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudzsgLy8gYXZvaWQgem9vbWluZyBvdXQgYmV5b25kIDEwMDAgd2hpY2ggbWF5IHJlc3VsdCBpbiBOYU4gdmFsdWVzIGJlaW5nIHByaW50ZWQgb24geC1heGlzXG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmIG5ldyBEYXRlKHcuZ2xvYmFscy5taW5YKS5nZXRVVENGdWxsWWVhcigpIDwgMTAwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXJYID0gKHcuZ2xvYmFscy5taW5YICsgdy5nbG9iYWxzLm1heFgpIC8gMjtcbiAgICAgIHZhciBuZXdNaW5YID0gdy5nbG9iYWxzLm1pblggLSAoY2VudGVyWCAtIHcuZ2xvYmFscy5taW5YKTtcbiAgICAgIHZhciBuZXdNYXhYID0gdy5nbG9iYWxzLm1heFggLSAoY2VudGVyWCAtIHcuZ2xvYmFscy5tYXhYKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQpIHtcbiAgICAgICAgdGhpcy56b29tVXBkYXRlT3B0aW9ucyhuZXdNaW5YLCBuZXdNYXhYKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVVwZGF0ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbVVwZGF0ZU9wdGlvbnMobmV3TWluWCwgbmV3TWF4WCkge1xuICAgICAgdmFyIHhheGlzID0ge1xuICAgICAgICBtaW46IG5ld01pblgsXG4gICAgICAgIG1heDogbmV3TWF4WFxuICAgICAgfTtcbiAgICAgIHZhciBiZWZvcmVab29tUmFuZ2UgPSB0aGlzLmdldEJlZm9yZVpvb21SYW5nZSh4YXhpcyk7XG5cbiAgICAgIGlmIChiZWZvcmVab29tUmFuZ2UpIHtcbiAgICAgICAgeGF4aXMgPSBiZWZvcmVab29tUmFuZ2UueGF4aXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudy5nbG9iYWxzLnpvb21lZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICB9LCBmYWxzZSwgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG5cbiAgICAgIHRoaXMuem9vbUNhbGxiYWNrKHhheGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21DYWxsYmFjayh4YXhpcywgeWF4aXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ldi56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5ldi56b29tZWQodGhpcy5jdHgsIHtcbiAgICAgICAgICB4YXhpczogeGF4aXMsXG4gICAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCZWZvcmVab29tUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzLCB5YXhpcykge1xuICAgICAgdmFyIG5ld1JhbmdlID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmV2LmJlZm9yZVpvb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSB0aGlzLmV2LmJlZm9yZVpvb20odGhpcywge1xuICAgICAgICAgIHhheGlzOiB4YXhpcyxcbiAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgICAgaWYgKHRoaXMuZWxNZW51LmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKSB7XG4gICAgICAgIHRoaXMuZWxNZW51LmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxNZW51LmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWRQTkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRQTkcoKSB7XG4gICAgICB2YXIgZG93bmxvYWRQTkcgPSBuZXcgRXhwb3J0cyh0aGlzLmN0eCk7XG4gICAgICBkb3dubG9hZFBORy5leHBvcnRUb1BuZyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnRvZ2dsZU1lbnUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWRTVkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRTVkcoKSB7XG4gICAgICB2YXIgZG93bmxvYWRTVkcgPSBuZXcgRXhwb3J0cyh0aGlzLmN0eCk7XG4gICAgICBkb3dubG9hZFNWRy5leHBvcnRUb1NWRygpO1xuICAgICAgdGhpcy50b2dnbGVNZW51KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVpvb21SZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVab29tUmVzZXQoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGFydHMgPSB0aGlzLmN0eC5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgIGNoYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgdyA9IGNoLnc7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5taW5YICE9PSB3Lmdsb2JhbHMuaW5pdGlhbG1pblggJiYgdy5nbG9iYWxzLm1heFggIT09IHcuZ2xvYmFscy5pbml0aWFsbWF4WCkge1xuICAgICAgICAgIGNoLnJldmVydERlZmF1bHRBeGlzTWluTWF4KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF90aGlzMi56b29tQ2FsbGJhY2soe1xuICAgICAgICAgICAgICBtaW46IHcuY29uZmlnLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgbWF4OiB3LmNvbmZpZy54YXhpcy5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy56b29tZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGNoLl91cGRhdGVTZXJpZXMody5nbG9iYWxzLmluaXRpYWxTZXJpZXMsIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmVsWm9vbVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZWxab29tUmVzZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVpvb21SZXNldC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlWm9vbWluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFpvb21Jbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbUluLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbU91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbU91dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFBhbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlUGFubmluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsWm9vbSA9IG51bGw7XG4gICAgICB0aGlzLmVsWm9vbUluID0gbnVsbDtcbiAgICAgIHRoaXMuZWxab29tT3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZWxQYW4gPSBudWxsO1xuICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmVsWm9vbVJlc2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZWxNZW51SWNvbiA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2xiYXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBab29tIENsYXNzIGZvciBoYW5kbGluZyB6b29taW5nIGFuZCBwYW5uaW5nIG9uIGF4ZXMgYmFzZWQgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgWm9vbVBhblNlbGVjdGlvblxuICoqL1xuXG52YXIgWm9vbVBhblNlbGVjdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Rvb2xiYXIpIHtcbiAgX2luaGVyaXRzKFpvb21QYW5TZWxlY3Rpb24sIF9Ub29sYmFyKTtcblxuICBmdW5jdGlvbiBab29tUGFuU2VsZWN0aW9uKGN0eCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBab29tUGFuU2VsZWN0aW9uKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFpvb21QYW5TZWxlY3Rpb24pLmNhbGwodGhpcywgY3R4KSk7XG4gICAgX3RoaXMuY3R4ID0gY3R4O1xuICAgIF90aGlzLncgPSBjdHgudztcbiAgICBfdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgX3RoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXMuY3R4KTtcbiAgICBfdGhpcy5ldmVudExpc3QgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgIF90aGlzLmNsaWVudFggPSAwO1xuICAgIF90aGlzLmNsaWVudFkgPSAwO1xuICAgIF90aGlzLnN0YXJ0WCA9IDA7XG4gICAgX3RoaXMuZW5kWCA9IDA7XG4gICAgX3RoaXMuZHJhZ1ggPSAwO1xuICAgIF90aGlzLnN0YXJ0WSA9IDA7XG4gICAgX3RoaXMuZW5kWSA9IDA7XG4gICAgX3RoaXMuZHJhZ1kgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhab29tUGFuU2VsZWN0aW9uLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoX3JlZikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB4eVJhdGlvcyA9IF9yZWYueHlSYXRpb3M7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB0aGlzLnh5UmF0aW9zID0geHlSYXRpb3M7XG4gICAgICB0aGlzLnpvb21SZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICB0aGlzLmdyaWRSZWN0ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZ3JpZCcpO1xuICAgICAgdGhpcy56b29tUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtem9vbS1yZWN0Jyk7XG4gICAgICB0aGlzLnNlbGVjdGlvblJlY3Qubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0Jyk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh0aGlzLnpvb21SZWN0KTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHRoaXMuc2VsZWN0aW9uUmVjdCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24udHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0LmRyYWdnYWJsZSh7XG4gICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgIG1heFg6IHcuZ2xvYmFscy5ncmlkV2lkdGgsXG4gICAgICAgICAgbWF4WTogdy5nbG9iYWxzLmdyaWRIZWlnaHRcbiAgICAgICAgfSkub24oJ2RyYWdtb3ZlJywgdGhpcy5zZWxlY3Rpb25EcmFnZ2luZy5iaW5kKHRoaXMsICdkcmFnZ2luZycpKTtcbiAgICAgIH0gZWxzZSBpZiAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnR5cGUgPT09ICd5Jykge1xuICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdC5kcmFnZ2FibGUoe1xuICAgICAgICAgIG1pblg6IDAsXG4gICAgICAgICAgbWF4WDogdy5nbG9iYWxzLmdyaWRXaWR0aFxuICAgICAgICB9KS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3QgPSB0aGlzLnNlbGVjdGlvblJlY3QuZHJhZ2dhYmxlKCkub24oJ2RyYWdtb3ZlJywgdGhpcy5zZWxlY3Rpb25EcmFnZ2luZy5iaW5kKHRoaXMsICdkcmFnZ2luZycpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RlZFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy5ob3ZlckFyZWEgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKHcuZ2xvYmFscy5jaGFydENsYXNzKTtcbiAgICAgIHRoaXMuaG92ZXJBcmVhLmNsYXNzTGlzdC5hZGQoJ3pvb21hYmxlJyk7XG4gICAgICB0aGlzLmV2ZW50TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuaG92ZXJBcmVhLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG1lLnN2Z01vdXNlRXZlbnRzLmJpbmQobWUsIHh5UmF0aW9zKSwge1xuICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHdoaWNoIHdlcmUgcHJldmlvdXNseSBhZGRlZCBvbiBob3ZlciBhcmVhXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJBcmVhKSB7XG4gICAgICAgICAgX3RoaXMzLmhvdmVyQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBtZS5zdmdNb3VzZUV2ZW50cy5iaW5kKG1lLCBtZS54eVJhdGlvcyksIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2xEcmFnZ2FibGVSZWN0KSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0LmRyYWdnYWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0Lm9mZigpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3Qub2ZmKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdCA9IG51bGw7XG4gICAgICB0aGlzLnpvb21SZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JpZFJlY3QgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdmdNb3VzZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdmdNb3VzZUV2ZW50cyh4eVJhdGlvcywgZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmN0eC50b29sYmFyO1xuICAgICAgdmFyIHpvb210eXBlID0gdy5nbG9iYWxzLnpvb21FbmFibGVkID8gdy5jb25maWcuY2hhcnQuem9vbS50eXBlIDogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnR5cGU7XG5cbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuc2hpZnRXYXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdG9vbGJhci5lbmFibGVQYW5uaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zaGlmdFdhc1ByZXNzZWQpIHtcbiAgICAgICAgICB0b29sYmFyLmVuYWJsZVpvb21pbmcoKTtcbiAgICAgICAgICB0aGlzLnNoaWZ0V2FzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWxzZVBvc2l0aXZlcyA9IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZWxlY3Rpb24tcmVjdCcpIHx8IGUudGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXRvb2xiYXInKTtcbiAgICAgIGlmIChmYWxzZVBvc2l0aXZlcykgcmV0dXJuO1xuICAgICAgbWUuY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgIG1lLmNsaWVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGUud2hpY2ggPT09IDEpIHtcbiAgICAgICAgdmFyIGdyaWRSZWN0RGltID0gbWUuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG1lLnN0YXJ0WCA9IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0O1xuICAgICAgICBtZS5zdGFydFkgPSBtZS5jbGllbnRZIC0gZ3JpZFJlY3REaW0udG9wO1xuICAgICAgICBtZS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIG1lLncuZ2xvYmFscy5tb3VzZWRvd24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyAmJiBlLndoaWNoID09PSAxIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgbWUuZHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAobWUudy5nbG9iYWxzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgbWUucGFuRHJhZ2dpbmcoe1xuICAgICAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlLFxuICAgICAgICAgICAgICB4eVJhdGlvczogeHlSYXRpb3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWUudy5nbG9iYWxzLm1vdXNlZG93biAmJiB3Lmdsb2JhbHMuem9vbUVuYWJsZWQgfHwgbWUudy5nbG9iYWxzLm1vdXNlZG93biAmJiB3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uID0gbWUuc2VsZWN0aW9uRHJhd2luZyh7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgICAgICB6b29tdHlwZTogem9vbXR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgYmUgY2FsbGluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gZWFjaCBtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXBcbiAgICAgICAgdmFyIF9ncmlkUmVjdERpbSA9IG1lLmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmIChtZS53Lmdsb2JhbHMubW91c2Vkb3duKSB7XG4gICAgICAgICAgLy8gdXNlciByZWxlYXNlZCB0aGUgZHJhZywgbm93IGRvIGFsbCB0aGUgY2FsY3VsYXRpb25zXG4gICAgICAgICAgbWUuZW5kWCA9IG1lLmNsaWVudFggLSBfZ3JpZFJlY3REaW0ubGVmdDtcbiAgICAgICAgICBtZS5lbmRZID0gbWUuY2xpZW50WSAtIF9ncmlkUmVjdERpbS50b3A7XG4gICAgICAgICAgbWUuZHJhZ1ggPSBNYXRoLmFicyhtZS5lbmRYIC0gbWUuc3RhcnRYKTtcbiAgICAgICAgICBtZS5kcmFnWSA9IE1hdGguYWJzKG1lLmVuZFkgLSBtZS5zdGFydFkpO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCB8fCB3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uRHJhd24oe1xuICAgICAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgbWUuaGlkZVNlbGVjdGlvblJlY3QodGhpcy5zZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uUmVjdCkgcmV0dXJuO1xuICAgICAgdmFyIHJlY3REaW0gPSB0aGlzLnNlbGVjdGlvblJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHJlY3REaW0ud2lkdGggPiAwICYmIHJlY3REaW0uaGVpZ2h0ID4gMCkge1xuICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdC5zZWxlY3RpemUoKS5yZXNpemUoe1xuICAgICAgICAgIGNvbnN0cmFpbnQ6IHtcbiAgICAgICAgICAgIG1pblg6IDAsXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICAgIG1heFk6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbigncmVzaXppbmcnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ3Jlc2l6aW5nJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVzZWxlY3RlZFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZWxlY3RlZFNlbGVjdGlvbigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSAndW5kZWZpbmVkJyAmJiB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uUmVjdCh3Lmdsb2JhbHMuc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHggPSAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1pbiAtIHcuZ2xvYmFscy5taW5YKSAvIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSAody5nbG9iYWxzLm1heFggLSB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWF4KSAvIHh5UmF0aW9zLnhSYXRpbyAtIHg7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0LFxuICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uUmVjdChzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgICAgIHRoaXMubWFrZVNlbGVjdGlvblJlY3REcmFnZ2FibGUoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24odGhpcy5jdHgsIHtcbiAgICAgICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICAgICAgbWluOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluLFxuICAgICAgICAgICAgICAgICAgbWF4OiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWF4XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5YXhpczoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdTZWxlY3Rpb25SZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SZWN0KF9yZWYyKSB7XG4gICAgICB2YXIgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnksXG4gICAgICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWCA9IF9yZWYyLnRyYW5zbGF0ZVgsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9IF9yZWYyLnRyYW5zbGF0ZVk7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB6b29tUmVjdCA9IHRoaXMuem9vbVJlY3Q7XG4gICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdDtcblxuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCB8fCB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzY2FsaW5nQXR0cnMgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywgJyArIHRyYW5zbGF0ZVkgKyAnKScgLy8gY2hhbmdlIHN0eWxlcyBiYXNlZCBvbiB6b29tIG9yIHNlbGVjdGlvblxuICAgICAgICAgIC8vIHpvb20gaXMgRW5hYmxlZCBhbmQgdXNlciBoYXMgZHJhZ2dlZCwgc28gZHJhdyBibHVlIHJlY3RcblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQgJiYgdGhpcy5kcmFnZ2VkKSB7XG4gICAgICAgICAgem9vbVJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgZmlsbDogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLmZpbGwuY29sb3IsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZTogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLnN0cm9rZS5vcGFjaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoem9vbVJlY3Qubm9kZSwgc2NhbGluZ0F0dHJzKTtcbiAgICAgICAgfSAvLyBzZWxlY3Rpb24gaXMgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgc2VsZWN0aW9uUmVjdC5hdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoID4gMCA/IHdpZHRoIDogMCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ID4gMCA/IGhlaWdodCA6IDAsXG4gICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZmlsbC5jb2xvcixcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZmlsbC5vcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uc3Ryb2tlLmNvbG9yLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2UuZGFzaEFycmF5LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS5vcGFjaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoc2VsZWN0aW9uUmVjdC5ub2RlLCBzY2FsaW5nQXR0cnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVTZWxlY3Rpb25SZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVTZWxlY3Rpb25SZWN0KHJlY3QpIHtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uRHJhd2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3Rpb25EcmF3aW5nKF9yZWYzKSB7XG4gICAgICB2YXIgY29udGV4dCA9IF9yZWYzLmNvbnRleHQsXG4gICAgICAgICAgem9vbXR5cGUgPSBfcmVmMy56b29tdHlwZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gY29udGV4dDtcbiAgICAgIHZhciBncmlkUmVjdERpbSA9IHRoaXMuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc3RhcnRYID0gbWUuc3RhcnRYIC0gMTtcbiAgICAgIHZhciBzdGFydFkgPSBtZS5zdGFydFk7XG4gICAgICB2YXIgc2VsZWN0aW9uV2lkdGggPSBtZS5jbGllbnRYIC0gZ3JpZFJlY3REaW0ubGVmdCAtIHN0YXJ0WDtcbiAgICAgIHZhciBzZWxlY3Rpb25IZWlnaHQgPSBtZS5jbGllbnRZIC0gZ3JpZFJlY3REaW0udG9wIC0gc3RhcnRZO1xuICAgICAgdmFyIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgdmFyIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgdmFyIHNlbGVjdGlvblJlY3QgPSB7fTtcblxuICAgICAgaWYgKE1hdGguYWJzKHNlbGVjdGlvbldpZHRoICsgc3RhcnRYKSA+IHcuZ2xvYmFscy5ncmlkV2lkdGggfHwgbWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQgPCAwKSB7XG4gICAgICAgIC8vIHVzZXIgZHJhZ2dlZCB0aGUgbW91c2Ugb3V0c2lkZSBkcmF3aW5nIGFyZWFcbiAgICAgICAgLy8gVE9ETzogdGVzdCB0aGUgc2VsZWN0aW9uUmVjdCBhbmQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgY3Jvc3NlcyBkcmF3aW5nIGFyZWFcbiAgICAgICAgbWUuaGlkZVNlbGVjdGlvblJlY3QodGhpcy56b29tUmVjdCk7XG4gICAgICAgIG1lLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgfSAvLyBpbnZlcnNlIHNlbGVjdGlvbiBYXG5cblxuICAgICAgaWYgKHN0YXJ0WCA+IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0KSB7XG4gICAgICAgIHNlbGVjdGlvbldpZHRoID0gTWF0aC5hYnMoc2VsZWN0aW9uV2lkdGgpO1xuICAgICAgICB0cmFuc2xhdGVYID0gLXNlbGVjdGlvbldpZHRoO1xuICAgICAgfSAvLyBpbnZlcnNlIHNlbGVjdGlvbiBZXG5cblxuICAgICAgaWYgKHN0YXJ0WSA+IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3ApIHtcbiAgICAgICAgc2VsZWN0aW9uSGVpZ2h0ID0gTWF0aC5hYnMoc2VsZWN0aW9uSGVpZ2h0KTtcbiAgICAgICAgdHJhbnNsYXRlWSA9IC1zZWxlY3Rpb25IZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSB7XG4gICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHNlbGVjdGlvbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICB3aWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGVjdGlvbkhlaWdodCxcbiAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSB7XG4gICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICB3aWR0aDogc2VsZWN0aW9uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzZWxlY3Rpb25IZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiB0cmFuc2xhdGVZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1lLmRyYXdTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlY3QpO1xuICAgICAgbWUuc2VsZWN0aW9uRHJhZ2dpbmcoJ3Jlc2l6aW5nJyk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uUmVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uRHJhZ2dpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0aW9uRHJhZ2dpbmcodHlwZSwgZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcbiAgICAgIHZhciBzZWxSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0O1xuICAgICAgdmFyIHRpbWVySW50ZXJ2YWwgPSAwO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6aW5nJykge1xuICAgICAgICB0aW1lckludGVydmFsID0gMzA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBhIHNtYWxsIGRlYm91bmNlciBpcyByZXF1aXJlZCB3aGVuIHJlc2l6aW5nIHRvIGF2b2lkIGZyZWV6aW5nIHRoZSBjaGFydFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uUmVzaXplVGltZXIpO1xuICAgICAgICB0aGlzLncuZ2xvYmFscy5zZWxlY3Rpb25SZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZ3JpZFJlY3REaW0gPSBfdGhpczQuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHNlbFJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgbWluWCA9IHcuZ2xvYmFscy54QXhpc1NjYWxlLm5pY2VNaW4gKyAoc2VsZWN0aW9uUmVjdC5sZWZ0IC0gZ3JpZFJlY3REaW0ubGVmdCkgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgdmFyIG1heFggPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgKHNlbGVjdGlvblJlY3QucmlnaHQgLSBncmlkUmVjdERpbS5sZWZ0KSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgICB2YXIgbWluWSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gKyAoZ3JpZFJlY3REaW0uYm90dG9tIC0gc2VsZWN0aW9uUmVjdC5ib3R0b20pICogeHlSYXRpb3MueVJhdGlvWzBdO1xuICAgICAgICAgIHZhciBtYXhZID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1heCAtIChzZWxlY3Rpb25SZWN0LnRvcCAtIGdyaWRSZWN0RGltLnRvcCkgKiB4eVJhdGlvcy55UmF0aW9bMF07XG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbihfdGhpczQuY3R4LCB7XG4gICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICBtaW46IG1pblgsXG4gICAgICAgICAgICAgIG1heDogbWF4WFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgIG1pbjogbWluWSxcbiAgICAgICAgICAgICAgbWF4OiBtYXhZXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRpbWVySW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25EcmF3blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3Rpb25EcmF3bihfcmVmNCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBfcmVmNC5jb250ZXh0LFxuICAgICAgICAgIHpvb210eXBlID0gX3JlZjQuem9vbXR5cGU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmN0eC50b29sYmFyO1xuXG4gICAgICBpZiAobWUuc3RhcnRYID4gbWUuZW5kWCkge1xuICAgICAgICB2YXIgdGVtcFggPSBtZS5zdGFydFg7XG4gICAgICAgIG1lLnN0YXJ0WCA9IG1lLmVuZFg7XG4gICAgICAgIG1lLmVuZFggPSB0ZW1wWDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lLnN0YXJ0WSA+IG1lLmVuZFkpIHtcbiAgICAgICAgdmFyIHRlbXBZID0gbWUuc3RhcnRZO1xuICAgICAgICBtZS5zdGFydFkgPSBtZS5lbmRZO1xuICAgICAgICBtZS5lbmRZID0gdGVtcFk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgbWUuc3RhcnRYICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgdmFyIHhIaWdoZXN0VmFsdWUgPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgbWUuZW5kWCAqIHh5UmF0aW9zLnhSYXRpbzsgLy8gVE9ETzogd2Ugd2lsbCBjb25zaWRlciB0aGUgMXN0IHkgYXhpcyB2YWx1ZXMgaGVyZSBmb3IgZ2V0dGluZyBoaWdoZXN0IGFuZCBsb3dlc3QgeVxuXG4gICAgICB2YXIgeUhpZ2hlc3RWYWx1ZSA9IFtdO1xuICAgICAgdmFyIHlMb3dlc3RWYWx1ZSA9IFtdO1xuICAgICAgdy5jb25maWcueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgeUhpZ2hlc3RWYWx1ZS5wdXNoKE1hdGguZmxvb3Iody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXggLSB4eVJhdGlvcy55UmF0aW9baW5kZXhdICogbWUuc3RhcnRZKSk7XG4gICAgICAgIHlMb3dlc3RWYWx1ZS5wdXNoKE1hdGguZmxvb3Iody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXggLSB4eVJhdGlvcy55UmF0aW9baW5kZXhdICogbWUuZW5kWSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtZS5kcmFnZ2VkICYmIChtZS5kcmFnWCA+IDEwIHx8IG1lLmRyYWdZID4gMTApICYmIHhMb3dlc3RWYWx1ZSAhPT0geEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHlheGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpOyAvLyBiZWZvcmUgem9vbWluZyBpbi9vdXQsIHN0b3JlIHRoZSBsYXN0IHlheGlzIGFuZCB4YXhpcyByYW5nZSwgc28gdGhhdCB3aGVuIHVzZXIgaGl0cyB0aGUgUkVTRVQgYnV0dG9uLCB3ZSBnZXQgdGhlIG9yaWdpbmFsIHJhbmdlXG4gICAgICAgICAgLy8gYWxzbyAtIG1ha2Ugc3VyZSB1c2VyIGlzIG5vdCBhbHJlYWR5IHpvb21lZCBpbi9vdXQgLSBvdGhlcndpc2Ugd2Ugd2lsbCBzdG9yZSB6b29tZWQgdmFsdWVzIGluIGxhc3RBeGlzXG5cbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy56b29tZWQpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5sYXN0WEF4aXMgPSBVdGlscy5jbG9uZSh3LmNvbmZpZy54YXhpcyk7XG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFlBeGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4YXhpcyA9IHtcbiAgICAgICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3h5JyB8fCB6b29tdHlwZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICB5YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgICAgICB5YXhpc1tpbmRleF0ubWluID0geUxvd2VzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgeWF4aXNbaW5kZXhdLm1heCA9IHlIaWdoZXN0VmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG5ldyBSYW5nZShtZS5jdHgpO1xuICAgICAgICAgICAgeWF4aXMgPSBzY2FsZS5hdXRvU2NhbGVZKG1lLmN0eCwge1xuICAgICAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgYmVmb3JlWm9vbVJhbmdlID0gdG9vbGJhci5nZXRCZWZvcmVab29tUmFuZ2UoeGF4aXMsIHlheGlzKTtcblxuICAgICAgICAgICAgaWYgKGJlZm9yZVpvb21SYW5nZSkge1xuICAgICAgICAgICAgICB4YXhpcyA9IGJlZm9yZVpvb21SYW5nZS54YXhpcyA/IGJlZm9yZVpvb21SYW5nZS54YXhpcyA6IHhheGlzO1xuICAgICAgICAgICAgICB5YXhpcyA9IGJlZm9yZVpvb21SYW5nZS55YXhpcyA/IGJlZm9yZVpvb21SYW5nZS55YXhlIDogeWF4aXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHpvb210eXBlID09PSAneCcpIHtcbiAgICAgICAgICAgIG1lLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHhheGlzOiB4YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIG1lLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgICAgIG1lLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIG1lLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgeGF4aXM6IHhheGlzLFxuICAgICAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgICAgIH0sIGZhbHNlLCBtZS53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b29sYmFyLnpvb21DYWxsYmFjayh4YXhpcywgeWF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy56b29tZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgdmFyIF95YXhpcyA9IG51bGw7XG4gICAgICAgICAgdmFyIF94YXhpcyA9IG51bGw7XG4gICAgICAgICAgX3hheGlzID0ge1xuICAgICAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHpvb210eXBlID09PSAneHknIHx8IHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgICAgIF95YXhpcyA9IFV0aWxzLmNsb25lKHcuY29uZmlnLnlheGlzKTtcblxuICAgICAgICAgICAgX3lheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIF95YXhpc1tpbmRleF0ubWluID0geUxvd2VzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgX3lheGlzW2luZGV4XS5tYXggPSB5SGlnaGVzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3Rpb24gPSBtZS5zZWxlY3Rpb247XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24obWUuY3R4LCB7XG4gICAgICAgICAgICAgIHhheGlzOiBfeGF4aXMsXG4gICAgICAgICAgICAgIHlheGlzOiBfeWF4aXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5EcmFnZ2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5EcmFnZ2luZyhfcmVmNSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBfcmVmNS5jb250ZXh0LFxuICAgICAgICAgIHpvb210eXBlID0gX3JlZjUuem9vbXR5cGU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgbW92ZURpcmVjdGlvbjsgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIGRhdGEgdG8gY29tcGFyZSBhZ2FpbnN0XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbi54ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBnZXQgdGhlIGNoYW5nZSBmcm9tIGxhc3QgcG9zaXRpb24gdG8gdGhpcyBwb3NpdGlvblxuICAgICAgICB2YXIgZGVsdGFYID0gdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbi54IC0gbWUuY2xpZW50WDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24ueSAtIG1lLmNsaWVudFk7IC8vIGNoZWNrIHdoaWNoIGRpcmVjdGlvbiBoYWQgdGhlIGhpZ2hlc3QgYW1wbGl0dWRlIGFuZCB0aGVuIGZpZ3VyZSBvdXQgZGlyZWN0aW9uIGJ5IGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBpcyBncmVhdGVyIG9yIGxlc3MgdGhhbiB6ZXJvXG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA+IDApIHtcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSAmJiBkZWx0YVkgPiAwKSB7XG4gICAgICAgICAgbW92ZURpcmVjdGlvbiA9ICd1cCc7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgJiYgZGVsdGFZIDwgMCkge1xuICAgICAgICAgIG1vdmVEaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2V0IHRoZSBuZXcgbGFzdCBwb3NpdGlvbiB0byB0aGUgY3VycmVudCBmb3IgbmV4dCB0aW1lICh0byBnZXQgdGhlIHBvc2l0aW9uIG9mIGRyYWcpXG5cblxuICAgICAgdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogbWUuY2xpZW50WCxcbiAgICAgICAgeTogbWUuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgIHZhciB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFg7XG4gICAgICB0aGlzLnBhblNjcm9sbGVkKG1vdmVEaXJlY3Rpb24sIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhblNjcm9sbGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhblNjcm9sbGVkKG1vdmVEaXJlY3Rpb24sIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuICAgICAgdmFyIHlheGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpO1xuXG4gICAgICBpZiAobW92ZURpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy5taW5YICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFggKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTUgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICB9IGVsc2UgaWYgKG1vdmVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeExvd2VzdFZhbHVlID0gdy5nbG9iYWxzLm1pblggLSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTUgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgIHhIaWdoZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxNSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKHhMb3dlc3RWYWx1ZSA8IHcuZ2xvYmFscy5pbml0aWFsbWluWCB8fCB4SGlnaGVzdFZhbHVlID4gdy5nbG9iYWxzLmluaXRpYWxtYXhYKSB7XG4gICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy5taW5YO1xuICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFg7XG4gICAgICB9XG5cbiAgICAgIHZhciB4YXhpcyA9IHtcbiAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgIG1heDogeEhpZ2hlc3RWYWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gbmV3IFJhbmdlKG1lLmN0eCk7XG4gICAgICAgIHlheGlzID0gc2NhbGUuYXV0b1NjYWxlWShtZS5jdHgsIHtcbiAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICB9LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQodGhpcy5jdHgsIHtcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab29tUGFuU2VsZWN0aW9uO1xufShUb29sYmFyKTtcblxudmFyIFRpdGxlU3VidGl0bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaXRsZVN1YnRpdGxlKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaXRsZVN1YnRpdGxlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpdGxlU3VidGl0bGUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuZHJhd1RpdGxlU3VidGl0bGUoJ3RpdGxlJyk7XG4gICAgICB0aGlzLmRyYXdUaXRsZVN1YnRpdGxlKCdzdWJ0aXRsZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGl0bGVTdWJ0aXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGl0bGVTdWJ0aXRsZSh0eXBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0c0NvbmZpZyA9IHR5cGUgPT09ICd0aXRsZScgPyB3LmNvbmZpZy50aXRsZSA6IHcuY29uZmlnLnN1YnRpdGxlO1xuICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSB0c0NvbmZpZy5vZmZzZXRZO1xuICAgICAgdmFyIHRleHRBbmNob3IgPSAnbWlkZGxlJztcblxuICAgICAgaWYgKHRzQ29uZmlnLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeCA9IDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSBpZiAodHNDb25maWcuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAtIDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgdHNDb25maWcub2Zmc2V0WDtcbiAgICAgIHkgPSB5ICsgcGFyc2VJbnQodHNDb25maWcuc3R5bGUuZm9udFNpemUpICsgMjtcblxuICAgICAgaWYgKHRzQ29uZmlnLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB0ZXh0OiB0c0NvbmZpZy50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgZm9udFNpemU6IHRzQ29uZmlnLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHRzQ29uZmlnLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9yZUNvbG9yOiB0c0NvbmZpZy5zdHlsZS5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZVRleHQubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi10ZXh0XCIpKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGl0bGVTdWJ0aXRsZTtcbn0oKTtcblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCk7XG4gICAgfSk7XG4gICAgLyogYmVsb3cgY2hlY2sgZml4ZXMgIzQxMiAqL1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3QuZG9jdW1lbnQgPyBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpIDogZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHcsIHcuZG9jdW1lbnQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5TVkcgPSBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgLy8gRmluZCBnbG9iYWwgcmVmZXJlbmNlIC0gdXNlcyAndGhpcycgYnkgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZSxcbiAgLy8gZmFsbHMgYmFjayB0byAnd2luZG93JyBvdGhlcndpc2UgKGZvciBidW5kbGVycyBsaWtlIFdlYnBhY2spXG4gIHZhciBnbG9iYWxSZWYgPSB0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93OyAvLyBUaGUgbWFpbiB3cmFwcGluZyBlbGVtZW50XG5cbiAgdmFyIFNWRyA9IGdsb2JhbFJlZi5TVkcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChTVkcuc3VwcG9ydGVkKSB7XG4gICAgICBlbGVtZW50ID0gbmV3IFNWRy5Eb2MoZWxlbWVudCk7XG5cbiAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfTsgLy8gRGVmYXVsdCBuYW1lc3BhY2VzXG5cblxuICBTVkcubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBTVkcueG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICBTVkcueGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gIFNWRy5zdmdqcyA9ICdodHRwOi8vc3ZnanMuY29tL3N2Z2pzJzsgLy8gU3ZnIHN1cHBvcnQgdGVzdFxuXG4gIFNWRy5zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7IC8vICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmXG4gICAgLy8gICAgICEhIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcubnMsJ3N2ZycpLmNyZWF0ZVNWR1JlY3RcbiAgfSgpOyAvLyBEb24ndCBib3RoZXIgdG8gY29udGludWUgaWYgU1ZHIGlzIG5vdCBzdXBwb3J0ZWRcblxuXG4gIGlmICghU1ZHLnN1cHBvcnRlZCkgcmV0dXJuIGZhbHNlOyAvLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5cbiAgU1ZHLmRpZCA9IDEwMDA7IC8vIEdldCBuZXh0IG5hbWVkIGVsZW1lbnQgaWRcblxuICBTVkcuZWlkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gJ1N2Z2pzJyArIGNhcGl0YWxpemUobmFtZSkgKyBTVkcuZGlkKys7XG4gIH07IC8vIE1ldGhvZCBmb3IgZWxlbWVudCBjcmVhdGlvblxuXG5cbiAgU1ZHLmNyZWF0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gY3JlYXRlIGVsZW1lbnRcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKTsgLy8gYXBwbHkgdW5pcXVlIGlkXG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmVpZChuYW1lKSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07IC8vIE1ldGhvZCBmb3IgZXh0ZW5kaW5nIG9iamVjdHNcblxuXG4gIFNWRy5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZHVsZXMsIG1ldGhvZHMsIGtleSwgaTsgLy8gR2V0IGxpc3Qgb2YgbW9kdWxlc1xuXG4gICAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gR2V0IG9iamVjdCB3aXRoIGV4dGVuc2lvbnNcblxuICAgIG1ldGhvZHMgPSBtb2R1bGVzLnBvcCgpO1xuXG4gICAgZm9yIChpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKG1vZHVsZXNbaV0pIHtcbiAgICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgIG1vZHVsZXNbaV0ucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIE1ha2Ugc3VyZSBTVkcuU2V0IGluaGVyaXRzIGFueSBuZXdseSBhZGRlZCBtZXRob2RzXG5cblxuICAgIGlmIChTVkcuU2V0ICYmIFNWRy5TZXQuaW5oZXJpdCkge1xuICAgICAgU1ZHLlNldC5pbmhlcml0KCk7XG4gICAgfVxuICB9OyAvLyBJbnZlbnQgbmV3IGVsZW1lbnRcblxuXG4gIFNWRy5pbnZlbnQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaW5pdGlhbGl6ZXJcbiAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0eXBlb2YgY29uZmlnLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZy5jcmVhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShjb25maWcuY3JlYXRlKSk7XG4gICAgfTsgLy8gSW5oZXJpdCBwcm90b3R5cGVcblxuICAgIGlmIChjb25maWcuaW5oZXJpdCkge1xuICAgICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0KCk7XG4gICAgfSAvLyBFeHRlbmQgd2l0aCBtZXRob2RzXG5cblxuICAgIGlmIChjb25maWcuZXh0ZW5kKSB7XG4gICAgICBTVkcuZXh0ZW5kKGluaXRpYWxpemVyLCBjb25maWcuZXh0ZW5kKTtcbiAgICB9IC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxuXG5cbiAgICBpZiAoY29uZmlnLmNvbnN0cnVjdCkge1xuICAgICAgU1ZHLmV4dGVuZChjb25maWcucGFyZW50IHx8IFNWRy5Db250YWluZXIsIGNvbmZpZy5jb25zdHJ1Y3QpO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsaXplcjtcbiAgfTsgLy8gQWRvcHQgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRzXG5cblxuICBTVkcuYWRvcHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDsgLy8gbWFrZSBzdXJlIGEgbm9kZSBpc24ndCBhbHJlYWR5IGFkb3B0ZWRcblxuICAgIGlmIChub2RlLmluc3RhbmNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZTsgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcblxuICAgIHZhciBlbGVtZW50OyAvLyBhZG9wdCB3aXRoIGVsZW1lbnQtc3BlY2lmaWMgc2V0dGluZ3NcblxuICAgIGlmIChub2RlLm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICBlbGVtZW50ID0gbm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQgPyBuZXcgU1ZHLk5lc3RlZCgpIDogbmV3IFNWRy5Eb2MoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ2xpbmVhckdyYWRpZW50Jykge1xuICAgICAgZWxlbWVudCA9IG5ldyBTVkcuR3JhZGllbnQoJ2xpbmVhcicpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAncmFkaWFsR3JhZGllbnQnKSB7XG4gICAgICBlbGVtZW50ID0gbmV3IFNWRy5HcmFkaWVudCgncmFkaWFsJyk7XG4gICAgfSBlbHNlIGlmIChTVkdbY2FwaXRhbGl6ZShub2RlLm5vZGVOYW1lKV0pIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkVsZW1lbnQobm9kZSk7XG4gICAgfSAvLyBlbnN1cmUgcmVmZXJlbmNlc1xuXG5cbiAgICBlbGVtZW50LnR5cGUgPSBub2RlLm5vZGVOYW1lO1xuICAgIGVsZW1lbnQubm9kZSA9IG5vZGU7XG4gICAgbm9kZS5pbnN0YW5jZSA9IGVsZW1lbnQ7IC8vIFNWRy5DbGFzcyBzcGVjaWZpYyBwcmVwYXJhdGlvbnNcblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkRvYykge1xuICAgICAgZWxlbWVudC5uYW1lc3BhY2UoKS5kZWZzKCk7XG4gICAgfSAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXG5cblxuICAgIGVsZW1lbnQuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTsgLy8gSW5pdGlhbGl6ZSBwYXJzaW5nIGVsZW1lbnRcblxuXG4gIFNWRy5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNlbGVjdCBkb2N1bWVudCBib2R5IGFuZCBjcmVhdGUgaW52aXNpYmxlIHN2ZyBlbGVtZW50XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLFxuICAgICAgICBkcmF3ID0gKGJvZHkgPyBuZXcgU1ZHLkRvYyhib2R5KSA6IFNWRy5hZG9wdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLm5lc3RlZCgpKS5zaXplKDIsIDApOyAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdFxuXG4gICAgU1ZHLnBhcnNlciA9IHtcbiAgICAgIGJvZHk6IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgZHJhdzogZHJhdy5zdHlsZSgnb3BhY2l0eTowO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTEwMCU7dG9wOi0xMDAlO292ZXJmbG93OmhpZGRlbicpLm5vZGUsXG4gICAgICBwb2x5OiBkcmF3LnBvbHlsaW5lKCkubm9kZSxcbiAgICAgIHBhdGg6IGRyYXcucGF0aCgpLm5vZGUsXG4gICAgICBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXG4gICAgfTtcbiAgfTtcblxuICBTVkcucGFyc2VyID0ge1xuICAgIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgU1ZHLnByZXBhcmUoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTsgLy8gU3RvcmFnZSBmb3IgcmVndWxhciBleHByZXNzaW9uc1xuXG4gIFNWRy5yZWdleCA9IHtcbiAgICAvLyBQYXJzZSB1bml0IHZhbHVlXG4gICAgbnVtYmVyQW5kVW5pdDogL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaSxcbiAgICAvLyBQYXJzZSBoZXggdmFsdWVcbiAgICBoZXg6IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2ksXG4gICAgLy8gUGFyc2UgcmdiIHZhbHVlXG4gICAgcmdiOiAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvLFxuICAgIC8vIFBhcnNlIHJlZmVyZW5jZSBpZFxuICAgIHJlZmVyZW5jZTogLyMoW2EtejAtOVxcLV9dKykvaSxcbiAgICAvLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxuICAgIHRyYW5zZm9ybXM6IC9cXClcXHMqLD9cXHMqLyxcbiAgICAvLyBXaGl0ZXNwYWNlXG4gICAgd2hpdGVzcGFjZTogL1xccy9nLFxuICAgIC8vIFRlc3QgaGV4IHZhbHVlXG4gICAgaXNIZXg6IC9eI1thLWYwLTldezMsNn0kL2ksXG4gICAgLy8gVGVzdCByZ2IgdmFsdWVcbiAgICBpc1JnYjogL15yZ2JcXCgvLFxuICAgIC8vIFRlc3QgY3NzIGRlY2xhcmF0aW9uXG4gICAgaXNDc3M6IC9bXjpdKzpbXjtdKzs/LyxcbiAgICAvLyBUZXN0IGZvciBibGFuayBzdHJpbmdcbiAgICBpc0JsYW5rOiAvXihcXHMrKT8kLyxcbiAgICAvLyBUZXN0IGZvciBudW1lcmljIHN0cmluZ1xuICAgIGlzTnVtYmVyOiAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcbiAgICAvLyBUZXN0IGZvciBwZXJjZW50IHZhbHVlXG4gICAgaXNQZXJjZW50OiAvXi0/W1xcZFxcLl0rJSQvLFxuICAgIC8vIFRlc3QgZm9yIGltYWdlIHVybFxuICAgIGlzSW1hZ2U6IC9cXC4oanBnfGpwZWd8cG5nfGdpZnxzdmcpKFxcP1tePV0rLiopPy9pLFxuICAgIC8vIHNwbGl0IGF0IHdoaXRlc3BhY2UgYW5kIGNvbW1hXG4gICAgZGVsaW1pdGVyOiAvW1xccyxdKy8sXG4gICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBhcmUgdXNlZCB0byBwYXJzZSB0aGUgZCBhdHRyaWJ1dGUgb2YgYSBwYXRoXG4gICAgLy8gTWF0Y2hlcyBhbGwgaHlwaGVucyB3aGljaCBhcmUgbm90IGFmdGVyIGFuIGV4cG9uZW50XG4gICAgaHlwaGVuOiAvKFteZV0pXFwtL2dpLFxuICAgIC8vIFJlcGxhY2VzIGFuZCB0ZXN0cyBmb3IgYWxsIHBhdGggbGV0dGVyc1xuICAgIHBhdGhMZXR0ZXJzOiAvW01MSFZDU1FUQVpdL2dpLFxuICAgIC8vIHllcyB3ZSBuZWVkIHRoaXMgb25lLCB0b29cbiAgICBpc1BhdGhMZXR0ZXI6IC9bTUxIVkNTUVRBWl0vaSxcbiAgICAvLyBtYXRjaGVzIDAuMTU0LjIzLjQ1XG4gICAgbnVtYmVyc1dpdGhEb3RzOiAvKChcXGQ/XFwuXFxkKyg/OmVbKy1dP1xcZCspPykoKD86XFwuXFxkKyg/OmVbKy1dP1xcZCspPykrKSkrL2dpLFxuICAgIC8vIG1hdGNoZXMgLlxuICAgIGRvdHM6IC9cXC4vZ1xuICB9O1xuICBTVkcudXRpbHMgPSB7XG4gICAgLy8gTWFwIGZ1bmN0aW9uXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoYXJyYXksIGJsb2NrKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBpbCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIEZpbHRlciBmdW5jdGlvblxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGFycmF5LCBibG9jaykge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaWwgPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGlmIChibG9jayhhcnJheVtpXSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIERlZ3JlZXMgdG8gcmFkaWFuc1xuICAgIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZCkge1xuICAgICAgcmV0dXJuIGQgJSAzNjAgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH0sXG4gICAgLy8gUmFkaWFucyB0byBkZWdyZWVzXG4gICAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyKSB7XG4gICAgICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjA7XG4gICAgfSxcbiAgICBmaWx0ZXJTVkdFbGVtZW50czogZnVuY3Rpb24gZmlsdGVyU1ZHRWxlbWVudHMobm9kZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub2RlcywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBTVkcuZGVmYXVsdHMgPSB7XG4gICAgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgYXR0cnM6IHtcbiAgICAgIC8vIGZpbGwgYW5kIHN0cm9rZVxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgICAgJ3N0cm9rZS13aWR0aCc6IDAsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdidXR0JyxcbiAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIC8vIHBvc2l0aW9uXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGN4OiAwLFxuICAgICAgY3k6IDAsXG4gICAgICAvLyBzaXplXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIC8vIHJhZGl1c1xuICAgICAgcjogMCxcbiAgICAgIHJ4OiAwLFxuICAgICAgcnk6IDAsXG4gICAgICAvLyBncmFkaWVudFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICAgICAnc3RvcC1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgIC8vIHRleHRcbiAgICAgICdmb250LXNpemUnOiAxNixcbiAgICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAgICAgICd0ZXh0LWFuY2hvcic6ICdzdGFydCdcbiAgICB9IC8vIE1vZHVsZSBmb3IgY29sb3IgY29udmVydGlvbnNcblxuICB9O1xuXG4gIFNWRy5Db2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBtYXRjaDsgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuXG4gICAgdGhpcy5yID0gMDtcbiAgICB0aGlzLmcgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgaWYgKCFjb2xvcikgcmV0dXJuOyAvLyBwYXJzZSBjb2xvclxuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcikpIHtcbiAgICAgICAgLy8gZ2V0IHJnYiB2YWx1ZXNcbiAgICAgICAgbWF0Y2ggPSBTVkcucmVnZXgucmdiLmV4ZWMoY29sb3IucmVwbGFjZShTVkcucmVnZXgud2hpdGVzcGFjZSwgJycpKTsgLy8gcGFyc2UgbnVtZXJpYyB2YWx1ZXNcblxuICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikpIHtcbiAgICAgICAgLy8gZ2V0IGhleCB2YWx1ZXNcbiAgICAgICAgbWF0Y2ggPSBTVkcucmVnZXguaGV4LmV4ZWMoZnVsbEhleChjb2xvcikpOyAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xuXG4gICAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNik7XG4gICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGNvbG9yKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuciA9IGNvbG9yLnI7XG4gICAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgICAgdGhpcy5iID0gY29sb3IuYjtcbiAgICB9XG4gIH07XG5cbiAgU1ZHLmV4dGVuZChTVkcuQ29sb3IsIHtcbiAgICAvLyBEZWZhdWx0IHRvIGhleCBjb252ZXJzaW9uXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9LFxuICAgIC8vIEJ1aWxkIGhleCB2YWx1ZVxuICAgIHRvSGV4OiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgIHJldHVybiAnIycgKyBjb21wVG9IZXgodGhpcy5yKSArIGNvbXBUb0hleCh0aGlzLmcpICsgY29tcFRvSGV4KHRoaXMuYik7XG4gICAgfSxcbiAgICAvLyBCdWlsZCByZ2IgdmFsdWVcbiAgICB0b1JnYjogZnVuY3Rpb24gdG9SZ2IoKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJztcbiAgICB9LFxuICAgIC8vIENhbGN1bGF0ZSB0cnVlIGJyaWdodG5lc3NcbiAgICBicmlnaHRuZXNzOiBmdW5jdGlvbiBicmlnaHRuZXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuciAvIDI1NSAqIDAuMzAgKyB0aGlzLmcgLyAyNTUgKiAwLjU5ICsgdGhpcy5iIC8gMjU1ICogMC4xMTtcbiAgICB9LFxuICAgIC8vIE1ha2UgY29sb3IgbW9ycGhhYmxlXG4gICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKGNvbG9yKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Db2xvcihjb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIGNvbG9yIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gbm9ybWFsaXNlIHBvc1xuXG4gICAgICBwb3MgPSBwb3MgPCAwID8gMCA6IHBvcyA+IDEgPyAxIDogcG9zOyAvLyBnZW5lcmF0ZSBtb3JwaGVkIGNvbG9yXG5cbiAgICAgIHJldHVybiBuZXcgU1ZHLkNvbG9yKHtcbiAgICAgICAgcjogfn4odGhpcy5yICsgKHRoaXMuZGVzdGluYXRpb24uciAtIHRoaXMucikgKiBwb3MpLFxuICAgICAgICBnOiB+fih0aGlzLmcgKyAodGhpcy5kZXN0aW5hdGlvbi5nIC0gdGhpcy5nKSAqIHBvcyksXG4gICAgICAgIGI6IH5+KHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTsgLy8gVGVzdGVyc1xuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3Igc3RyaW5nXG5cbiAgU1ZHLkNvbG9yLnRlc3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBjb2xvciArPSAnJztcbiAgICByZXR1cm4gU1ZHLnJlZ2V4LmlzSGV4LnRlc3QoY29sb3IpIHx8IFNWRy5yZWdleC5pc1JnYi50ZXN0KGNvbG9yKTtcbiAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIHJnYiBvYmplY3RcblxuXG4gIFNWRy5Db2xvci5pc1JnYiA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiBjb2xvciAmJiB0eXBlb2YgY29sb3IuciA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmcgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5iID09PSAnbnVtYmVyJztcbiAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXG5cblxuICBTVkcuQ29sb3IuaXNDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiBTVkcuQ29sb3IuaXNSZ2IoY29sb3IpIHx8IFNWRy5Db2xvci50ZXN0KGNvbG9yKTtcbiAgfTsgLy8gTW9kdWxlIGZvciBhcnJheSBjb252ZXJzaW9uXG5cblxuICBTVkcuQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGZhbGxiYWNrKSB7XG4gICAgYXJyYXkgPSAoYXJyYXkgfHwgW10pLnZhbHVlT2YoKTsgLy8gaWYgYXJyYXkgaXMgZW1wdHkgYW5kIGZhbGxiYWNrIGlzIHByb3ZpZGVkLCB1c2UgZmFsbGJhY2tcblxuICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCAmJiBmYWxsYmFjaykge1xuICAgICAgYXJyYXkgPSBmYWxsYmFjay52YWx1ZU9mKCk7XG4gICAgfSAvLyBwYXJzZSBhcnJheVxuXG5cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZShhcnJheSk7XG4gIH07XG5cbiAgU1ZHLmV4dGVuZChTVkcuQXJyYXksIHtcbiAgICAvLyBNYWtlIGFycmF5IG1vcnBoYWJsZVxuICAgIG1vcnBoOiBmdW5jdGlvbiBtb3JwaChhcnJheSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHRoaXMucGFyc2UoYXJyYXkpOyAvLyBub3JtYWxpemUgbGVuZ3RoIG9mIGFycmF5c1xuXG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT0gdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMudmFsdWVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGxhc3REZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb25bdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGggLSAxXTtcblxuICAgICAgICB3aGlsZSAodGhpcy52YWx1ZS5sZW5ndGggPiB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ucHVzaChsYXN0RGVzdGluYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMudmFsdWUubGVuZ3RoIDwgdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlLnB1c2gobGFzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIENsZWFuIHVwIGFueSBkdXBsaWNhdGUgcG9pbnRzXG4gICAgc2V0dGxlOiBmdW5jdGlvbiBzZXR0bGUoKSB7XG4gICAgICAvLyBmaW5kIGFsbCB1bmlxdWUgdmFsdWVzXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgc2VlbiA9IFtdOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHRoaXMudmFsdWVbaV0pID09IC0xKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKHRoaXMudmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNldCBuZXcgdmFsdWVcblxuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHNlZW47XG4gICAgfSxcbiAgICAvLyBHZXQgbW9ycGhlZCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7IC8vIGdlbmVyYXRlIG1vcnBoZWQgYXJyYXlcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpcy52YWx1ZVtpXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldIC0gdGhpcy52YWx1ZVtpXSkgKiBwb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNWRy5BcnJheShhcnJheSk7XG4gICAgfSxcbiAgICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIC8vIFJlYWwgdmFsdWVcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICAvLyBQYXJzZSB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJyYXkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkudmFsdWVPZigpOyAvLyBpZiBhbHJlYWR5IGlzIGFuIGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5O1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoYXJyYXkpO1xuICAgIH0sXG4gICAgLy8gU3RyaXAgdW5uZWNlc3Nhcnkgd2hpdGVzcGFjZVxuICAgIHNwbGl0OiBmdW5jdGlvbiBzcGxpdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9LFxuICAgIC8vIFJldmVyc2UgYXJyYXlcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdGhpcy52YWx1ZS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICBjbG9uZS52YWx1ZSA9IGFycmF5X2Nsb25lKHRoaXMudmFsdWUpO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgfSk7IC8vIFBvbHkgcG9pbnRzIGFycmF5XG5cbiAgU1ZHLlBvaW50QXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGZhbGxiYWNrKSB7XG4gICAgU1ZHLkFycmF5LmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrIHx8IFtbMCwgMF1dKTtcbiAgfTsgLy8gSW5oZXJpdCBmcm9tIFNWRy5BcnJheVxuXG5cbiAgU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheSgpO1xuICBTVkcuUG9pbnRBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUG9pbnRBcnJheTtcbiAgU1ZHLmV4dGVuZChTVkcuUG9pbnRBcnJheSwge1xuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgLy8gY29udmVydCB0byBhIHBvbHkgcG9pbnQgc3RyaW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldLmpvaW4oJywnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheS5qb2luKCcgJyk7XG4gICAgfSxcbiAgICAvLyBDb252ZXJ0IGFycmF5IHRvIGxpbmUgb2JqZWN0XG4gICAgdG9MaW5lOiBmdW5jdGlvbiB0b0xpbmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogdGhpcy52YWx1ZVswXVswXSxcbiAgICAgICAgeTE6IHRoaXMudmFsdWVbMF1bMV0sXG4gICAgICAgIHgyOiB0aGlzLnZhbHVlWzFdWzBdLFxuICAgICAgICB5MjogdGhpcy52YWx1ZVsxXVsxXVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gZ2VuZXJhdGUgbW9ycGhlZCBwb2ludCBzdHJpbmdcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2goW3RoaXMudmFsdWVbaV1bMF0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVswXSAtIHRoaXMudmFsdWVbaV1bMF0pICogcG9zLCB0aGlzLnZhbHVlW2ldWzFdICsgKHRoaXMuZGVzdGluYXRpb25baV1bMV0gLSB0aGlzLnZhbHVlW2ldWzFdKSAqIHBvc10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KGFycmF5KTtcbiAgICB9LFxuICAgIC8vIFBhcnNlIHBvaW50IHN0cmluZyBhbmQgZmxhdCBhcnJheVxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShhcnJheSkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7IC8vIGlmIGl0IGlzIGFuIGFycmF5XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAvLyBhbmQgaXQgaXMgbm90IGZsYXQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcGFyc2UgaXRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHVzZSBhIGNsb25lXG4gICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5zbGljZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5WzBdLnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIGFsbG93IHBvaW50IG9iamVjdHMgdG8gYmUgcGFzc2VkXG4gICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWwueCwgZWwueV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVsc2UsIGl0IGlzIGNvbnNpZGVyZWQgYXMgYSBzdHJpbmdcbiAgICAgICAgLy8gcGFyc2UgcG9pbnRzXG4gICAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgIH0gLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xuICAgICAgLy8gT2RkIG51bWJlciBvZiBjb29yZGluYXRlcyBpcyBhbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgZHJvcCB0aGUgbGFzdCBvZGQgY29vcmRpbmF0ZS5cblxuXG4gICAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkgYXJyYXkucG9wKCk7IC8vIHdyYXAgcG9pbnRzIGluIHR3by10dXBsZXMgYW5kIHBhcnNlIHBvaW50cyBhcyBmbG9hdHNcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFthcnJheVtpXSwgYXJyYXlbaSArIDFdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcbiAgICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpOyAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XG5cbiAgICAgIHggLT0gYm94Lng7XG4gICAgICB5IC09IGJveC55OyAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG5cbiAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXSA9IFt0aGlzLnZhbHVlW2ldWzBdICsgeCwgdGhpcy52YWx1ZVtpXVsxXSArIHldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYm94LndpZHRoKSB0aGlzLnZhbHVlW2ldWzBdID0gKHRoaXMudmFsdWVbaV1bMF0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICBpZiAoYm94LmhlaWdodCkgdGhpcy52YWx1ZVtpXVsxXSA9ICh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXG4gICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICB9XG5cbiAgICAgIFNWRy5wYXJzZXIucG9seS5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gU1ZHLnBhcnNlci5wb2x5LmdldEJCb3goKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgcGF0aEhhbmRsZXJzID0ge1xuICAgIE06IGZ1bmN0aW9uIE0oYywgcCwgcDApIHtcbiAgICAgIHAueCA9IHAwLnggPSBjWzBdO1xuICAgICAgcC55ID0gcDAueSA9IGNbMV07XG4gICAgICByZXR1cm4gWydNJywgcC54LCBwLnldO1xuICAgIH0sXG4gICAgTDogZnVuY3Rpb24gTChjLCBwKSB7XG4gICAgICBwLnggPSBjWzBdO1xuICAgICAgcC55ID0gY1sxXTtcbiAgICAgIHJldHVybiBbJ0wnLCBjWzBdLCBjWzFdXTtcbiAgICB9LFxuICAgIEg6IGZ1bmN0aW9uIEgoYywgcCkge1xuICAgICAgcC54ID0gY1swXTtcbiAgICAgIHJldHVybiBbJ0gnLCBjWzBdXTtcbiAgICB9LFxuICAgIFY6IGZ1bmN0aW9uIFYoYywgcCkge1xuICAgICAgcC55ID0gY1swXTtcbiAgICAgIHJldHVybiBbJ1YnLCBjWzBdXTtcbiAgICB9LFxuICAgIEM6IGZ1bmN0aW9uIEMoYywgcCkge1xuICAgICAgcC54ID0gY1s0XTtcbiAgICAgIHAueSA9IGNbNV07XG4gICAgICByZXR1cm4gWydDJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XV07XG4gICAgfSxcbiAgICBTOiBmdW5jdGlvbiBTKGMsIHApIHtcbiAgICAgIHAueCA9IGNbMl07XG4gICAgICBwLnkgPSBjWzNdO1xuICAgICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dO1xuICAgIH0sXG4gICAgUTogZnVuY3Rpb24gUShjLCBwKSB7XG4gICAgICBwLnggPSBjWzJdO1xuICAgICAgcC55ID0gY1szXTtcbiAgICAgIHJldHVybiBbJ1EnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdXTtcbiAgICB9LFxuICAgIFQ6IGZ1bmN0aW9uIFQoYywgcCkge1xuICAgICAgcC54ID0gY1swXTtcbiAgICAgIHAueSA9IGNbMV07XG4gICAgICByZXR1cm4gWydUJywgY1swXSwgY1sxXV07XG4gICAgfSxcbiAgICBaOiBmdW5jdGlvbiBaKGMsIHAsIHAwKSB7XG4gICAgICBwLnggPSBwMC54O1xuICAgICAgcC55ID0gcDAueTtcbiAgICAgIHJldHVybiBbJ1onXTtcbiAgICB9LFxuICAgIEE6IGZ1bmN0aW9uIEEoYywgcCkge1xuICAgICAgcC54ID0gY1s1XTtcbiAgICAgIHAueSA9IGNbNl07XG4gICAgICByZXR1cm4gWydBJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XV07XG4gICAgfVxuICB9O1xuICB2YXIgbWxodnF0Y3NhID0gJ21saHZxdGNzYXonLnNwbGl0KCcnKTtcblxuICBmb3IgKHZhciBpID0gMCwgaWwgPSBtbGh2cXRjc2EubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHBhdGhIYW5kbGVyc1ttbGh2cXRjc2FbaV1dID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICAgICAgaWYgKGkgPT0gJ0gnKSBjWzBdID0gY1swXSArIHAueDtlbHNlIGlmIChpID09ICdWJykgY1swXSA9IGNbMF0gKyBwLnk7ZWxzZSBpZiAoaSA9PSAnQScpIHtcbiAgICAgICAgICBjWzVdID0gY1s1XSArIHAueCwgY1s2XSA9IGNbNl0gKyBwLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gYy5sZW5ndGg7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICBjW2pdID0gY1tqXSArIChqICUgMiA/IHAueSA6IHAueCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoSGFuZGxlcnNbaV0oYywgcCwgcDApO1xuICAgICAgfTtcbiAgICB9KG1saHZxdGNzYVtpXS50b1VwcGVyQ2FzZSgpKTtcbiAgfSAvLyBQYXRoIHBvaW50cyBhcnJheVxuXG5cbiAgU1ZHLlBhdGhBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgZmFsbGJhY2spIHtcbiAgICBTVkcuQXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgZmFsbGJhY2sgfHwgW1snTScsIDAsIDBdXSk7XG4gIH07IC8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcblxuXG4gIFNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheSgpO1xuICBTVkcuUGF0aEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5QYXRoQXJyYXk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIHBhdGggc3RyaW5nXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgICB2YXIgYm94ID0gdGhpcy5iYm94KCk7IC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcblxuICAgICAgeCAtPSBib3gueDtcbiAgICAgIHkgLT0gYm94Lnk7XG5cbiAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcbiAgICAgICAgZm9yICh2YXIgbCwgaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBsID0gdGhpcy52YWx1ZVtpXVswXTtcblxuICAgICAgICAgIGlmIChsID09ICdNJyB8fCBsID09ICdMJyB8fCBsID09ICdUJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5O1xuICAgICAgICAgIH0gZWxzZSBpZiAobCA9PSAnSCcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs0XSArPSB5O1xuXG4gICAgICAgICAgICBpZiAobCA9PSAnQycpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs1XSArPSB4O1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSArPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsID0gdGhpcy52YWx1ZVtpXVswXTtcblxuICAgICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAodGhpcy52YWx1ZVtpXVsyXSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnVicpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAodGhpcy52YWx1ZVtpXVsyXSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzNdID0gKHRoaXMudmFsdWVbaV1bM10gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNF0gPSAodGhpcy52YWx1ZVtpXVs0XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcblxuICAgICAgICAgIGlmIChsID09ICdDJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs1XSA9ICh0aGlzLnZhbHVlW2ldWzVdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQScpIHtcbiAgICAgICAgICAvLyByZXNpemUgcmFkaWlcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gdGhpcy52YWx1ZVtpXVsxXSAqIHdpZHRoIC8gYm94LndpZHRoO1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSB0aGlzLnZhbHVlW2ldWzJdICogaGVpZ2h0IC8gYm94LmhlaWdodDsgLy8gbW92ZSBwb3NpdGlvbiB2YWx1ZXNcblxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAodGhpcy52YWx1ZVtpXVs2XSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSA9ICh0aGlzLnZhbHVlW2ldWzddIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gVGVzdCBpZiB0aGUgcGFzc2VkIHBhdGggYXJyYXkgdXNlIHRoZSBzYW1lIHBhdGggZGF0YSBjb21tYW5kcyBhcyB0aGlzIHBhdGggYXJyYXlcbiAgICBlcXVhbENvbW1hbmRzOiBmdW5jdGlvbiBlcXVhbENvbW1hbmRzKHBhdGhBcnJheSkge1xuICAgICAgdmFyIGksIGlsLCBlcXVhbENvbW1hbmRzO1xuICAgICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KTtcbiAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gcGF0aEFycmF5LnZhbHVlLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aDsgZXF1YWxDb21tYW5kcyAmJiBpIDwgaWw7IGkrKykge1xuICAgICAgICBlcXVhbENvbW1hbmRzID0gdGhpcy52YWx1ZVtpXVswXSA9PT0gcGF0aEFycmF5LnZhbHVlW2ldWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXF1YWxDb21tYW5kcztcbiAgICB9LFxuICAgIC8vIE1ha2UgcGF0aCBhcnJheSBtb3JwaGFibGVcbiAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgocGF0aEFycmF5KSB7XG4gICAgICBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheShwYXRoQXJyYXkpO1xuXG4gICAgICBpZiAodGhpcy5lcXVhbENvbW1hbmRzKHBhdGhBcnJheSkpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHBhdGhBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIHBhdGggYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNvdXJjZUFycmF5ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5ID0gdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSxcbiAgICAgICAgICBhcnJheSA9IFtdLFxuICAgICAgICAgIHBhdGhBcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KCksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpbCxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGpsOyAvLyBBbmltYXRlIGhhcyBzcGVjaWZpZWQgaW4gdGhlIFNWRyBzcGVjXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYXRocy5odG1sI1BhdGhFbGVtZW50XG5cbiAgICAgIGZvciAoaSA9IDAsIGlsID0gc291cmNlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IFtzb3VyY2VBcnJheVtpXVswXV07XG5cbiAgICAgICAgZm9yIChqID0gMSwgamwgPSBzb3VyY2VBcnJheVtpXS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgYXJyYXlbaV1bal0gPSBzb3VyY2VBcnJheVtpXVtqXSArIChkZXN0aW5hdGlvbkFycmF5W2ldW2pdIC0gc291cmNlQXJyYXlbaV1bal0pICogcG9zO1xuICAgICAgICB9IC8vIEZvciB0aGUgdHdvIGZsYWdzIG9mIHRoZSBlbGxpcHRpY2FsIGFyYyBjb21tYW5kLCB0aGUgU1ZHIHNwZWMgc2F5OlxuICAgICAgICAvLyBGbGFncyBhbmQgYm9vbGVhbnMgYXJlIGludGVycG9sYXRlZCBhcyBmcmFjdGlvbnMgYmV0d2VlbiB6ZXJvIGFuZCBvbmUsIHdpdGggYW55IG5vbi16ZXJvIHZhbHVlIGNvbnNpZGVyZWQgdG8gYmUgYSB2YWx1ZSBvZiBvbmUvdHJ1ZVxuICAgICAgICAvLyBFbGxpcHRpY2FsIGFyYyBjb21tYW5kIGFzIGFuIGFycmF5IGZvbGxvd2VkIGJ5IGNvcnJlc3BvbmRpbmcgaW5kZXhlczpcbiAgICAgICAgLy8gWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICAvLyAgIDAgICAgMSAgIDIgICAgICAgIDMgICAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgNSAgICAgIDYgIDdcblxuXG4gICAgICAgIGlmIChhcnJheVtpXVswXSA9PT0gJ0EnKSB7XG4gICAgICAgICAgYXJyYXlbaV1bNF0gPSArKGFycmF5W2ldWzRdICE9IDApO1xuICAgICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPSAwKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEaXJlY3RseSBtb2RpZnkgdGhlIHZhbHVlIG9mIGEgcGF0aCBhcnJheSwgdGhpcyBpcyBkb25lIHRoaXMgd2F5IGZvciBwZXJmb3JtYW5jZVxuXG5cbiAgICAgIHBhdGhBcnJheS52YWx1ZSA9IGFycmF5O1xuICAgICAgcmV0dXJuIHBhdGhBcnJheTtcbiAgICB9LFxuICAgIC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJyYXkpIHtcbiAgICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgICAgaWYgKGFycmF5IGluc3RhbmNlb2YgU1ZHLlBhdGhBcnJheSkgcmV0dXJuIGFycmF5LnZhbHVlT2YoKTsgLy8gcHJlcGFyZSBmb3IgcGFyc2luZ1xuXG4gICAgICB2YXIgcyxcbiAgICAgICAgICBhcnIsXG4gICAgICAgICAgcGFyYW1DbnQgPSB7XG4gICAgICAgICdNJzogMixcbiAgICAgICAgJ0wnOiAyLFxuICAgICAgICAnSCc6IDEsXG4gICAgICAgICdWJzogMSxcbiAgICAgICAgJ0MnOiA2LFxuICAgICAgICAnUyc6IDQsXG4gICAgICAgICdRJzogNCxcbiAgICAgICAgJ1QnOiAyLFxuICAgICAgICAnQSc6IDcsXG4gICAgICAgICdaJzogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBhcnJheSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheS5yZXBsYWNlKFNWRy5yZWdleC5udW1iZXJzV2l0aERvdHMsIHBhdGhSZWdSZXBsYWNlKSAvLyBjb252ZXJ0IDQ1LjEyMy4xMjMgdG8gNDUuMTIzIC4xMjNcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLCAnICQmICcpIC8vIHB1dCBzb21lIHJvb20gYmV0d2VlbiBsZXR0ZXJzIGFuZCBudW1iZXJzXG4gICAgICAgIC5yZXBsYWNlKFNWRy5yZWdleC5oeXBoZW4sICckMSAtJykgLy8gYWRkIHNwYWNlIGJlZm9yZSBoeXBoZW5cbiAgICAgICAgLnRyaW0oKSAvLyB0cmltXG4gICAgICAgIC5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKTsgLy8gc3BsaXQgaW50byBhcnJheVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmNhbGwocHJldiwgY3Vycik7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH0gLy8gYXJyYXkgbm93IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHBhcnRzIG9mIGEgcGF0aCBlLmcuIFsnTScsICcwJywgJzAnLCAnTCcsICczMCcsICczMCcgLi4uXVxuXG5cbiAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICBwID0gbmV3IFNWRy5Qb2ludCgpLFxuICAgICAgICAgIHAwID0gbmV3IFNWRy5Qb2ludCgpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gVGVzdCBpZiB3ZSBoYXZlIGEgcGF0aCBsZXR0ZXJcbiAgICAgICAgaWYgKFNWRy5yZWdleC5pc1BhdGhMZXR0ZXIudGVzdChhcnJheVtpbmRleF0pKSB7XG4gICAgICAgICAgcyA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICArK2luZGV4OyAvLyBJZiBsYXN0IGxldHRlciB3YXMgYSBtb3ZlIGNvbW1hbmQgYW5kIHdlIGdvdCBubyBuZXcsIGl0IGRlZmF1bHRzIHRvIFtMXWluZVxuICAgICAgICB9IGVsc2UgaWYgKHMgPT0gJ00nKSB7XG4gICAgICAgICAgcyA9ICdMJztcbiAgICAgICAgfSBlbHNlIGlmIChzID09ICdtJykge1xuICAgICAgICAgIHMgPSAnbCc7XG4gICAgICAgIH1cblxuICAgICAgICBhcnIucHVzaChwYXRoSGFuZGxlcnNbc10uY2FsbChudWxsLCBhcnJheS5zbGljZShpbmRleCwgaW5kZXggPSBpbmRleCArIHBhcmFtQ250W3MudG9VcHBlckNhc2UoKV0pLm1hcChwYXJzZUZsb2F0KSwgcCwgcDApKTtcbiAgICAgIH0gd2hpbGUgKGxlbiA+IGluZGV4KTtcblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICAgIGJib3g6IGZ1bmN0aW9uIGJib3goKSB7XG4gICAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgfVxuXG4gICAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBTVkcucGFyc2VyLnBhdGguZ2V0QkJveCgpO1xuICAgIH1cbiAgfSk7IC8vIE1vZHVsZSBmb3IgdW5pdCBjb252ZXJ0aW9uc1xuXG4gIFNWRy5OdW1iZXIgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIHVuaXQpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgZGVmYXVsdHNcbiAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJzsgLy8gcGFyc2UgdmFsdWVcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gZW5zdXJlIGEgdmFsaWQgbnVtZXJpYyB2YWx1ZVxuICAgICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4IDogdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdW5pdCA9IHZhbHVlLm1hdGNoKFNWRy5yZWdleC5udW1iZXJBbmRVbml0KTtcblxuICAgICAgICBpZiAodW5pdCkge1xuICAgICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pOyAvLyBub3JtYWxpemVcblxuICAgICAgICAgIGlmICh1bml0WzVdID09ICclJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh1bml0WzVdID09ICdzJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSAqPSAxMDAwO1xuICAgICAgICAgIH0gLy8gc3RvcmUgdW5pdFxuXG5cbiAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgICB0aGlzLnVuaXQgPSB2YWx1ZS51bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU3RyaW5nYWxpemVcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVuaXQgPT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTYgOiB0aGlzLnVuaXQgPT0gJ3MnID8gdGhpcy52YWx1ZSAvIDFlMyA6IHRoaXMudmFsdWUpICsgdGhpcy51bml0O1xuICAgICAgfSxcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICAgIC8vIENvbnZlcnQgdG8gcHJpbWl0aXZlXG4gICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgbnVtYmVyXG4gICAgICBwbHVzOiBmdW5jdGlvbiBwbHVzKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyArIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTdWJ0cmFjdCBudW1iZXJcbiAgICAgIG1pbnVzOiBmdW5jdGlvbiBtaW51cyhudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgLSBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gICAgICB9LFxuICAgICAgLy8gTXVsdGlwbHkgbnVtYmVyXG4gICAgICB0aW1lczogZnVuY3Rpb24gdGltZXMobnVtYmVyKSB7XG4gICAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzICogbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICAgICAgfSxcbiAgICAgIC8vIERpdmlkZSBudW1iZXJcbiAgICAgIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyAvIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IHRvIGRpZmZlcmVudCB1bml0XG4gICAgICB0bzogZnVuY3Rpb24gdG8odW5pdCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG51bWJlci51bml0ID0gdW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9LFxuICAgICAgLy8gTWFrZSBudW1iZXIgbW9ycGhhYmxlXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuXG4gICAgICAgIGlmIChudW1iZXIucmVsYXRpdmUpIHtcbiAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlICs9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbW9ycGhlZCBudW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBHZW5lcmF0ZSBuZXcgbW9ycGhlZCBudW1iZXJcblxuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcy5kZXN0aW5hdGlvbikubWludXModGhpcykudGltZXMocG9zKS5wbHVzKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5FbGVtZW50ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobm9kZSkge1xuICAgICAgLy8gbWFrZSBzdHJva2UgdmFsdWUgYWNjZXNzaWJsZSBkeW5hbWljYWxseVxuICAgICAgdGhpcy5fc3Ryb2tlID0gU1ZHLmRlZmF1bHRzLmF0dHJzLnN0cm9rZTtcbiAgICAgIHRoaXMuX2V2ZW50ID0gbnVsbDsgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxuXG4gICAgICB0aGlzLmRvbSA9IHt9OyAvLyBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICAgIGlmICh0aGlzLm5vZGUgPSBub2RlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgIHRoaXMubm9kZS5pbnN0YW5jZSA9IHRoaXM7IC8vIHN0b3JlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlXG5cbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRoaXMuX3N0cm9rZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCBfeCk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICAgeTogZnVuY3Rpb24geShfeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgX3kpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICAgICBjeDogZnVuY3Rpb24gY3goeCkge1xuICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMueSgpICsgdGhpcy5oZWlnaHQoKSAvIDIgOiB0aGlzLnkoeSAtIHRoaXMuaGVpZ2h0KCkgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcbiAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy54KHgpLnkoeSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcbiAgICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignd2lkdGgnLCBfd2lkdGgpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoX2hlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBfaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoKG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpKS5oZWlnaHQobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBDbG9uZSBlbGVtZW50XG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUocGFyZW50KSB7XG4gICAgICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpOyAvLyBjbG9uZSBlbGVtZW50IGFuZCBhc3NpZ24gbmV3IGlkXG5cbiAgICAgICAgdmFyIGNsb25lID0gYXNzaWduTmV3SWQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIGluc2VydCB0aGUgY2xvbmUgaW4gdGhlIGdpdmVuIHBhcmVudCBvciBhZnRlciBteXNlbGZcblxuICAgICAgICBpZiAocGFyZW50KSBwYXJlbnQuYWRkKGNsb25lKTtlbHNlIHRoaXMuYWZ0ZXIoY2xvbmUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICB9LFxuICAgICAgLy8gUmVtb3ZlIGVsZW1lbnRcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQoKSkge1xuICAgICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlcGxhY2UgZWxlbWVudFxuICAgICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuYWZ0ZXIoZWxlbWVudCkucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIHNlbGZcbiAgICAgIGFkZFRvOiBmdW5jdGlvbiBhZGRUbyhwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdXQodGhpcyk7XG4gICAgICB9LFxuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG4gICAgICBwdXRJbjogZnVuY3Rpb24gcHV0SW4ocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCAvIHNldCBpZFxuICAgICAgaWQ6IGZ1bmN0aW9uIGlkKF9pZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcsIF9pZCk7XG4gICAgICB9LFxuICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGluc2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50XG4gICAgICBpbnNpZGU6IGZ1bmN0aW9uIGluc2lkZSh4LCB5KSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmJib3goKTtcbiAgICAgICAgcmV0dXJuIHggPiBib3gueCAmJiB5ID4gYm94LnkgJiYgeCA8IGJveC54ICsgYm94LndpZHRoICYmIHkgPCBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgLy8gU2hvdyBlbGVtZW50XG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICcnKTtcbiAgICAgIH0sXG4gICAgICAvLyBIaWRlIGVsZW1lbnRcbiAgICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIH0sXG4gICAgICAvLyBJcyBlbGVtZW50IHZpc2libGU/XG4gICAgICB2aXNpYmxlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScpICE9ICdub25lJztcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm4gaWQgb24gc3RyaW5nIGNvbnZlcnNpb25cbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaWQnKTtcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxuICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzKCkuaW5kZXhPZihuYW1lKSAhPSAtMTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcbiAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuY2xhc3NlcygpO1xuICAgICAgICAgIGFycmF5LnB1c2gobmFtZSk7XG4gICAgICAgICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxuICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmF0dHIoJ2NsYXNzJywgdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAhPSBuYW1lO1xuICAgICAgICAgIH0pLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcbiAgICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NsYXNzKG5hbWUpID8gdGhpcy5yZW1vdmVDbGFzcyhuYW1lKSA6IHRoaXMuYWRkQ2xhc3MobmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgcmVmZXJlbmNlOiBmdW5jdGlvbiByZWZlcmVuY2UoYXR0cikge1xuICAgICAgICByZXR1cm4gU1ZHLmdldCh0aGlzLmF0dHIoYXR0cikpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCh0eXBlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzOyAvLyBjaGVjayBmb3IgcGFyZW50XG5cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbDsgLy8gZ2V0IHBhcmVudCBlbGVtZW50XG5cbiAgICAgICAgcGFyZW50ID0gU1ZHLmFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICBpZiAoIXR5cGUpIHJldHVybiBwYXJlbnQ7IC8vIGxvb3AgdHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQubm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUgfHwgcGFyZW50Lm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PSAnI2RvY3VtZW50JykgcmV0dXJuIG51bGw7IC8vICM3NTksICM3MjBcblxuICAgICAgICAgIHBhcmVudCA9IFNWRy5hZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcbiAgICAgIGRvYzogZnVuY3Rpb24gZG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLkRvYyk7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcbiAgICAgIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHModHlwZSkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IFtdLFxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCh0eXBlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lm5vZGUpIGJyZWFrO1xuICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9IHdoaWxlIChwYXJlbnQucGFyZW50KTtcblxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgIH0sXG4gICAgICAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXG4gICAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBfbWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKTtcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm5zIHRoZSBzdmcgbm9kZSB0byBjYWxsIG5hdGl2ZSBzdmcgbWV0aG9kcyBvbiBpdFxuICAgICAgbmF0aXZlOiBmdW5jdGlvbiBuYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICB9LFxuICAgICAgLy8gSW1wb3J0IHJhdyBzdmdcbiAgICAgIHN2ZzogZnVuY3Rpb24gc3ZnKF9zdmcpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcbiAgICAgICAgdmFyIHdlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKTsgLy8gYWN0IGFzIGEgc2V0dGVyIGlmIHN2ZyBpcyBnaXZlblxuXG4gICAgICAgIGlmIChfc3ZnICYmIHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSB7XG4gICAgICAgICAgLy8gZHVtcCByYXcgc3ZnXG4gICAgICAgICAgd2VsbC5pbm5lckhUTUwgPSAnPHN2Zz4nICsgX3N2Zy5yZXBsYWNlKC9cXG4vLCAnJykucmVwbGFjZSgvPChbXFx3Oi1dKykoW148XSs/KVxcLz4vZywgJzwkMSQyPjwvJDE+JykgKyAnPC9zdmc+JzsgLy8gdHJhbnNwbGFudCBub2Rlc1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gd2VsbC5maXJzdENoaWxkLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHdlbGwuZmlyc3RDaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9IC8vIG90aGVyd2lzZSBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwaW5nIHN2ZyBlbGVtZW50IGluIGNhc2Ugb2YgcGFydGlhbCBjb250ZW50XG4gICAgICAgICAgd2VsbC5hcHBlbmRDaGlsZChfc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3ZnJykpOyAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuICAgICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTsgLy8gaW5zZXJ0IGEgY29weSBvZiB0aGlzIG5vZGVcblxuICAgICAgICAgIF9zdmcuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIHJldHVybiB0YXJnZXQgZWxlbWVudFxuXG5cbiAgICAgICAgICByZXR1cm4gd2VsbC5pbm5lckhUTUwucmVwbGFjZSgvXjxzdmc+LywgJycpLnJlcGxhY2UoLzxcXC9zdmc+JC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuICAgICAgd3JpdGVEYXRhVG9Eb206IGZ1bmN0aW9uIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgICAgICAvLyBkdW1wIHZhcmlhYmxlcyByZWN1cnNpdmVseVxuICAgICAgICBpZiAodGhpcy5lYWNoIHx8IHRoaXMubGluZXMpIHtcbiAgICAgICAgICB2YXIgZm4gPSB0aGlzLmVhY2ggPyB0aGlzIDogdGhpcy5saW5lcygpO1xuICAgICAgICAgIGZuLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIHJlbW92ZSBwcmV2aW91c2x5IHNldCBkYXRhXG5cblxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdmdqczpkYXRhJyk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kb20pKTtcbiAgICAgICAgfSAvLyBzZWUgIzQyOFxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEobykge1xuICAgICAgICB0aGlzLmRvbSA9IG87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGlzOiBmdW5jdGlvbiBpcyhvYmopIHtcbiAgICAgICAgcmV0dXJuIF9pcyh0aGlzLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5lYXNpbmcgPSB7XG4gICAgJy0nOiBmdW5jdGlvbiBfKHBvcykge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9LFxuICAgICc8Pic6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkpIC8gMiArIDAuNTtcbiAgICB9LFxuICAgICc+JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMik7XG4gICAgfSxcbiAgICAnPCc6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkgLyAyKSArIDE7XG4gICAgfVxuICB9O1xuXG4gIFNWRy5tb3JwaCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Nb3JwaE9iaihmcm9tLCB0bykuYXQocG9zKTtcbiAgICB9O1xuICB9O1xuXG4gIFNWRy5TaXR1YXRpb24gPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvKSB7XG4gICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFNWRy5OdW1iZXIoby5kdXJhdGlvbikudmFsdWVPZigpO1xuICAgICAgdGhpcy5kZWxheSA9IG5ldyBTVkcuTnVtYmVyKG8uZGVsYXkpLnZhbHVlT2YoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuZGVsYXk7XG4gICAgICB0aGlzLmZpbmlzaCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgICAgdGhpcy5lYXNlID0gby5lYXNlOyAvLyB0aGlzLmxvb3AgaXMgaW5jcmVtZW50ZWQgZnJvbSAwIHRvIHRoaXMubG9vcHNcbiAgICAgIC8vIGl0IGlzIGFsc28gaW5jcmVtZW50ZWQgd2hlbiBpbiBhbiBpbmZpbml0ZSBsb29wICh3aGVuIHRoaXMubG9vcHMgaXMgdHJ1ZSlcblxuICAgICAgdGhpcy5sb29wID0gMDtcbiAgICAgIHRoaXMubG9vcHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHsvLyBmdW5jdGlvblRvQ2FsbDogW2xpc3Qgb2YgbW9ycGhhYmxlIG9iamVjdHNdXG4gICAgICAgIC8vIGUuZy4gbW92ZTogW1NWRy5OdW1iZXIsIFNWRy5OdW1iZXJdXG4gICAgICB9O1xuICAgICAgdGhpcy5hdHRycyA9IHsvLyBob2xkcyBhbGwgYXR0cmlidXRlcyB3aGljaCBhcmUgbm90IHJlcHJlc2VudGVkIGZyb20gYSBmdW5jdGlvbiBzdmcuanMgcHJvdmlkZXNcbiAgICAgICAgLy8gZS5nLiBzb21lQXR0cjogU1ZHLk51bWJlclxuICAgICAgfTtcbiAgICAgIHRoaXMuc3R5bGVzID0gey8vIGhvbGRzIGFsbCBzdHlsZXMgd2hpY2ggc2hvdWxkIGJlIGFuaW1hdGVkXG4gICAgICAgIC8vIGUuZy4gZmlsbC1jb2xvcjogU1ZHLkNvbG9yXG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gWy8vIGhvbGRzIGFsbCB0cmFuc2Zvcm1hdGlvbnMgYXMgdHJhbnNmb3JtYXRpb24gb2JqZWN0c1xuICAgICAgICAvLyBlLmcuIFtTVkcuUm90YXRlLCBTVkcuVHJhbnNsYXRlLCBTVkcuTWF0cml4XVxuICAgICAgXTtcbiAgICAgIHRoaXMub25jZSA9IHsvLyBmdW5jdGlvbnMgdG8gZmlyZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uXG4gICAgICAgIC8vIGUuZy4gXCIwLjVcIjogZnVuY3Rpb24gZm9vKCl7fVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBTVkcuRlggPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5zaXR1YXRpb25zID0gW107XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFBvcyA9IDA7XG4gICAgICB0aGlzLnBvcyA9IDA7IC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBhbmltYXRpb24gaXMgaXRzIHBvc2l0aW9uIGluIHRoZSBjb250ZXh0IG9mIGl0cyBjb21wbGV0ZSBkdXJhdGlvbiAoaW5jbHVkaW5nIGRlbGF5IGFuZCBsb29wcylcbiAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGRlbGF5LCBhYnNQb3MgaXMgYmVsb3cgMCBhbmQgd2hlbiBwZXJmb3JtaW5nIGEgbG9vcCwgaXRzIHZhbHVlIGlzIGFib3ZlIDFcblxuICAgICAgdGhpcy5hYnNQb3MgPSAwO1xuICAgICAgdGhpcy5fc3BlZWQgPSAxO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAgKiBAcGFyYW0gbyBvYmplY3QgfHwgbnVtYmVyIEluIGNhc2Ugb2YgT2JqZWN0IGl0IGhvbGRzIGFsbCBwYXJhbWV0ZXJzLiBJbiBjYXNlIG9mIG51bWJlciBpdHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAqIEBwYXJhbSBlYXNlIGZ1bmN0aW9uIHx8IHN0cmluZyBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdXNlZCBmb3IgZWFzaW5nIG9yIGVhc2luZyBrZXl3b3JkXG4gICAgICAgKiBAcGFyYW0gZGVsYXkgTnVtYmVyIGluZGljYXRpbmcgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICAgICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xuICAgICAgICovXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKG8sIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG8pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGVhc2UgPSBvLmVhc2U7XG4gICAgICAgICAgZGVsYXkgPSBvLmRlbGF5O1xuICAgICAgICAgIG8gPSBvLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpdHVhdGlvbiA9IG5ldyBTVkcuU2l0dWF0aW9uKHtcbiAgICAgICAgICBkdXJhdGlvbjogbyB8fCAxMDAwLFxuICAgICAgICAgIGRlbGF5OiBkZWxheSB8fCAwLFxuICAgICAgICAgIGVhc2U6IFNWRy5lYXNpbmdbZWFzZSB8fCAnLSddIHx8IGVhc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWUoc2l0dWF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogc2V0cyBhIGRlbGF5IGJlZm9yZSB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBxdWV1ZSBpcyBjYWxsZWRcbiAgICAgICogQHBhcmFtIGRlbGF5IER1cmF0aW9uIG9mIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgICAgKiBAcmV0dXJuIHRoaXMudGFyZ2V0KClcbiAgICAgICovXG4gICAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoX2RlbGF5KSB7XG4gICAgICAgIC8vIFRoZSBkZWxheSBpcyBwZXJmb3JtZWQgYnkgYW4gZW1wdHkgc2l0dWF0aW9uIHdpdGggaXRzIGR1cmF0aW9uXG4gICAgICAgIC8vIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIGR1cmF0aW9uIG9mIHRoZSBkZWxheVxuICAgICAgICB2YXIgc2l0dWF0aW9uID0gbmV3IFNWRy5TaXR1YXRpb24oe1xuICAgICAgICAgIGR1cmF0aW9uOiBfZGVsYXksXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZWFzZTogU1ZHLmVhc2luZ1snLSddXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShzaXR1YXRpb24pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAqIEBwYXJhbSBudWxsIHx8IHRhcmdldCBTVkcuRWxlbWVudCB3aGljaCBzaG91bGQgYmUgc2V0IGFzIG5ldyB0YXJnZXRcbiAgICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xuICAgICAgKi9cbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KF90YXJnZXQpIHtcbiAgICAgICAgaWYgKF90YXJnZXQgJiYgX3RhcmdldCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gX3RhcmdldDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJucyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gYXQgYSBnaXZlbiB0aW1lXG4gICAgICB0aW1lVG9BYnNQb3M6IGZ1bmN0aW9uIHRpbWVUb0Fic1Bvcyh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuICh0aW1lc3RhbXAgLSB0aGlzLnNpdHVhdGlvbi5zdGFydCkgLyAodGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZCk7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJucyB0aGUgdGltZXN0YW1wIGZyb20gYSBnaXZlbiBhYnNvbHV0ZSBwb3NpdG9uXG4gICAgICBhYnNQb3NUb1RpbWU6IGZ1bmN0aW9uIGFic1Bvc1RvVGltZShhYnNQb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uIC8gdGhpcy5fc3BlZWQgKiBhYnNQb3MgKyB0aGlzLnNpdHVhdGlvbi5zdGFydDtcbiAgICAgIH0sXG4gICAgICAvLyBzdGFydHMgdGhlIGFuaW1hdGlvbmxvb3BcbiAgICAgIHN0YXJ0QW5pbUZyYW1lOiBmdW5jdGlvbiBzdGFydEFuaW1GcmFtZSgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICAvLyBjYW5jZWxzIHRoZSBhbmltYXRpb25mcmFtZVxuICAgICAgc3RvcEFuaW1GcmFtZTogZnVuY3Rpb24gc3RvcEFuaW1GcmFtZSgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIGtpY2tzIG9mZiB0aGUgYW5pbWF0aW9uIC0gb25seSBkb2VzIHNvbWV0aGluZyB3aGVuIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgbm90IGFjdGl2ZSBhbmQgYXQgbGVhc3Qgb25lIHNpdHVhdGlvbiBpcyBzZXRcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgLy8gZG9udCBzdGFydCBpZiBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSAmJiB0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q3VycmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gc3RhcnQgdGhlIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgICBzdGFydEN1cnJlbnQ6IGZ1bmN0aW9uIHN0YXJ0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24uc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuc2l0dWF0aW9uLmRlbGF5IC8gdGhpcy5fc3BlZWQ7XG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgdGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdEFuaW1hdGlvbnMoKS5zdGVwKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogYWRkcyBhIGZ1bmN0aW9uIC8gU2l0dWF0aW9uIHRvIHRoZSBhbmltYXRpb24gcXVldWVcbiAgICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIC8gc2l0dWF0aW9uIHRvIGFkZFxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICBxdWV1ZTogZnVuY3Rpb24gcXVldWUoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCBmbiBpbnN0YW5jZW9mIFNWRy5TaXR1YXRpb24pIHtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbnMucHVzaChmbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9uKSB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBwdWxscyBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgcXVldWUgYW5kIGV4ZWN1dGUgaXRcbiAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAqL1xuICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgICAgLy8gc3RvcCBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICB0aGlzLnN0b3AoKTsgLy8gZ2V0IG5leHQgYW5pbWF0aW9uIGZyb20gcXVldWVcblxuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbiBpbnN0YW5jZW9mIFNWRy5TaXR1YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGEgU1ZHLlNpdHVhdGlvbiwgdGhlbiBpdCBpcyBhIGZ1bmN0aW9uLCB3ZSBleGVjdXRlIGl0XG4gICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHVwZGF0ZXMgYWxsIGFuaW1hdGlvbnMgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHdoZW4gb25lIHByb3BlcnR5IGNvdWxkIGJlIGNoYW5nZWQgZnJvbSBhbm90aGVyIHByb3BlcnR5XG4gICAgICBpbml0QW5pbWF0aW9uczogZnVuY3Rpb24gaW5pdEFuaW1hdGlvbnMoKSB7XG4gICAgICAgIHZhciBpLCBqLCBzb3VyY2U7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaXR1YXRpb247XG4gICAgICAgIGlmIChzLmluaXQpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGZvciAoaSBpbiBzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLnRhcmdldCgpW2ldKCk7XG5cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgc291cmNlID0gW3NvdXJjZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHMuYW5pbWF0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIHMuYW5pbWF0aW9uc1tpXSA9IFtzLmFuaW1hdGlvbnNbaV1dO1xuICAgICAgICAgIH0gLy8gaWYocy5hbmltYXRpb25zW2ldLmxlbmd0aCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyAgc291cmNlLmNvbmNhdCA9IHNvdXJjZS5jb25jYXQocy5hbmltYXRpb25zW2ldLnNsaWNlKHNvdXJjZS5sZW5ndGgsIHMuYW5pbWF0aW9uc1tpXS5sZW5ndGgpKVxuICAgICAgICAgIC8vIH1cblxuXG4gICAgICAgICAgZm9yIChqID0gc291cmNlLmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbiBpcyBiZWNhdXNlIHNvbWUgbWV0aG9kcyByZXR1cm4gYSBub3JtYWwgbnVtYmVyIGluc3RlYWRcbiAgICAgICAgICAgIC8vIG9mIGEgU1ZHLk51bWJlclxuICAgICAgICAgICAgaWYgKHMuYW5pbWF0aW9uc1tpXVtqXSBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgICAgICAgc291cmNlW2pdID0gbmV3IFNWRy5OdW1iZXIoc291cmNlW2pdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldW2pdID0gc291cmNlW2pdLm1vcnBoKHMuYW5pbWF0aW9uc1tpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpIGluIHMuYXR0cnMpIHtcbiAgICAgICAgICBzLmF0dHJzW2ldID0gbmV3IFNWRy5Nb3JwaE9iaih0aGlzLnRhcmdldCgpLmF0dHIoaSksIHMuYXR0cnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpIGluIHMuc3R5bGVzKSB7XG4gICAgICAgICAgcy5zdHlsZXNbaV0gPSBuZXcgU1ZHLk1vcnBoT2JqKHRoaXMudGFyZ2V0KCkuc3R5bGUoaSksIHMuc3R5bGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uID0gdGhpcy50YXJnZXQoKS5tYXRyaXhpZnkoKTtcbiAgICAgICAgcy5pbml0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5zaXR1YXRpb25zID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNsZWFyQ3VycmVudDogZnVuY3Rpb24gY2xlYXJDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqIHN0b3BzIHRoZSBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICogQHBhcmFtIGp1bXBUb0VuZCBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgICogQHBhcmFtIGNsZWFyUXVldWUgQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byByZW1vdmUgcXVldWVkIGFuaW1hdGlvbiBhcyB3ZWxsLlxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGp1bXBUb0VuZCwgY2xlYXJRdWV1ZSkge1xuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyUXVldWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqdW1wVG9FbmQgJiYgdGhpcy5zaXR1YXRpb24pIHtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXR1YXRpb24gaWYgaXQgd2FzIG5vdFxuICAgICAgICAgICFhY3RpdmUgJiYgdGhpcy5zdGFydEN1cnJlbnQoKTtcbiAgICAgICAgICB0aGlzLmF0RW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJDdXJyZW50KCk7XG4gICAgICB9LFxuXG4gICAgICAvKiogcmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSBzdGF0ZSB3aGVyZSB0aGUgY3VycmVudCBlbGVtZW50IGhhcyBzdGFydGVkXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnNpdHVhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRlbXA7XG4gICAgICAgICAgdGhpcy5hdFN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBTdG9wIHRoZSBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb24sIHJlbW92ZSBhbGwgcXVldWVkIGFuaW1hdGlvbnMsIGFuZCBjb21wbGV0ZSBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKHRydWUsIGZhbHNlKTtcblxuICAgICAgICB3aGlsZSAodGhpcy5kZXF1ZXVlKCkuc2l0dWF0aW9uICYmIHRoaXMuc3RvcCh0cnVlLCBmYWxzZSkpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJRdWV1ZSgpLmNsZWFyQ3VycmVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIGFueSBsb29wcywgYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgICAgIGF0U3RhcnQ6IGZ1bmN0aW9uIGF0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KDAsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNldCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIHBvaW50ZXIgYXQgdGhlIGVuZCBwb3NpdGlvbiwgYWZ0ZXIgYWxsIHRoZSBsb29wcywgYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgICAgIGF0RW5kOiBmdW5jdGlvbiBhdEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgaW4gYSBpbmZpbml0ZSBsb29wLCB3ZSBlbmQgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcHMgPSB0aGlzLnNpdHVhdGlvbi5sb29wICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXR1YXRpb24ubG9vcHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gSWYgcGVyZm9ybWluZyBhIGZpbml0ZSBudW1iZXIgb2YgbG9vcHMsIHdlIGdvIGFmdGVyIGFsbCB0aGUgbG9vcHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnNpdHVhdGlvbi5sb29wcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm8gbG9vcHMsIHdlIGp1c3QgZ28gYXQgdGhlIGVuZFxuICAgICAgICAgIHJldHVybiB0aGlzLmF0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXG4gICAgICAvLyBpZiBpc0Fic1BvcyBpcyB0cnVlLCBwb3MgaXMgdHJlYXRlZCBhcyBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcywgaXNBYnNQb3MpIHtcbiAgICAgICAgdmFyIGR1ckRpdlNwZCA9IHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uIC8gdGhpcy5fc3BlZWQ7XG4gICAgICAgIHRoaXMuYWJzUG9zID0gcG9zOyAvLyBJZiBwb3MgaXMgbm90IGFuIGFic29sdXRlIHBvc2l0aW9uLCB3ZSBjb252ZXJ0IGl0IGludG8gb25lXG5cbiAgICAgICAgaWYgKCFpc0Fic1Bvcykge1xuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgdGhpcy5hYnNQb3MgPSAxIC0gdGhpcy5hYnNQb3M7XG4gICAgICAgICAgdGhpcy5hYnNQb3MgKz0gdGhpcy5zaXR1YXRpb24ubG9vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlKCkgLSB0aGlzLmFic1BvcyAqIGR1ckRpdlNwZDtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24uZmluaXNoID0gdGhpcy5zaXR1YXRpb24uc3RhcnQgKyBkdXJEaXZTcGQ7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXAodHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogc2V0cyBvciByZXR1cm5zIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xuICAgICAgKiBAcGFyYW0gc3BlZWQgbnVsbCB8fCBOdW1iZXIgVGhlIG5ldyBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xuICAgICAgKiBAcmV0dXJuIE51bWJlciB8fCB0aGlzXG4gICAgICAqL1xuICAgICAgc3BlZWQ6IGZ1bmN0aW9uIHNwZWVkKF9zcGVlZCkge1xuICAgICAgICBpZiAoX3NwZWVkID09PSAwKSByZXR1cm4gdGhpcy5wYXVzZSgpO1xuXG4gICAgICAgIGlmIChfc3BlZWQpIHtcbiAgICAgICAgICB0aGlzLl9zcGVlZCA9IF9zcGVlZDsgLy8gV2UgdXNlIGFuIGFic29sdXRlIHBvc2l0aW9uIGhlcmUgc28gdGhhdCBzcGVlZCBjYW4gYWZmZWN0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvblxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICAgICAgfSxcbiAgICAgIC8vIE1ha2UgbG9vcGFibGVcbiAgICAgIGxvb3A6IGZ1bmN0aW9uIGxvb3AodGltZXMsIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKTsgLy8gc3RvcmUgdG90YWwgbG9vcHNcblxuICAgICAgICBjLmxvb3BzID0gdGltZXMgIT0gbnVsbCA/IHRpbWVzIDogdHJ1ZTtcbiAgICAgICAgYy5sb29wID0gMDtcbiAgICAgICAgaWYgKHJldmVyc2UpIGMucmV2ZXJzaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gdW5wYXVzZSB0aGUgYW5pbWF0aW9uXG4gICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTsgLy8gV2UgdXNlIGFuIGFic29sdXRlIHBvc2l0aW9uIGhlcmUgc28gdGhhdCB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gY2FuIGJlIHBhdXNlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuYWJzUG9zLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiB0b2dnbGUgb3Igc2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAgKiB0cnVlIHNldHMgZGlyZWN0aW9uIHRvIGJhY2t3YXJkcyB3aGlsZSBmYWxzZSBzZXRzIGl0IHRvIGZvcndhcmRzXG4gICAgICAqIEBwYXJhbSByZXZlcnNlZCBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byByZXZlcnNlIHRoZSBhbmltYXRpb24gb3Igbm90IChkZWZhdWx0OiB0b2dnbGUgdGhlIHJldmVyc2Ugc3RhdHVzKVxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKHJldmVyc2VkKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYXN0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmV2ZXJzZWQgPT09ICd1bmRlZmluZWQnKSBjLnJldmVyc2VkID0gIWMucmV2ZXJzZWQ7ZWxzZSBjLnJldmVyc2VkID0gcmV2ZXJzZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHJldHVybnMgYSBmbG9hdCBmcm9tIDAtMSBpbmRpY2F0aW5nIHRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cbiAgICAgICogQHBhcmFtIGVhc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBzaG91bGQgYmUgZWFzZWQgb3Igbm90XG4gICAgICAqIEByZXR1cm4gbnVtYmVyXG4gICAgICAqL1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKGVhc2VJdCkge1xuICAgICAgICByZXR1cm4gZWFzZUl0ID8gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcykgOiB0aGlzLnBvcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBhZGRzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgICAqIEBwYXJhbSBmbiBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgY2FsbGJhY2tcbiAgICAgICogQHJldHVybiBudW1iZXJcbiAgICAgICovXG4gICAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZm4pIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZXRhaWwuc2l0dWF0aW9uID09IGMpIHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgYyk7XG4gICAgICAgICAgICB0aGlzLm9mZignZmluaXNoZWQuZngnLCB3cmFwcGVyKTsgLy8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRhcmdldCgpLm9uKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgLy8gYWRkcyBhIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuZXZlciBvbmUgYW5pbWF0aW9uIHN0ZXAgaXMgcGVyZm9ybWVkXG4gICAgICBkdXJpbmc6IGZ1bmN0aW9uIGR1cmluZyhmbikge1xuICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpLFxuICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRldGFpbC5zaXR1YXRpb24gPT0gYykge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBlLmRldGFpbC5wb3MsIFNWRy5tb3JwaChlLmRldGFpbC5wb3MpLCBlLmRldGFpbC5lYXNlZCwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBzZWUgYWJvdmVcblxuXG4gICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKS5vbignZHVyaW5nLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIHRoaXMuYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBjYWxscyBhZnRlciBBTEwgYW5pbWF0aW9ucyBpbiB0aGUgcXVldWUgYXJlIGZpbmlzaGVkXG4gICAgICBhZnRlckFsbDogZnVuY3Rpb24gYWZ0ZXJBbGwoZm4pIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpIHtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICB9OyAvLyBzZWUgYWJvdmVcblxuXG4gICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpLm9uKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgLy8gY2FsbHMgb24gZXZlcnkgYW5pbWF0aW9uIHN0ZXAgZm9yIGFsbCBhbmltYXRpb25zXG4gICAgICBkdXJpbmdBbGw6IGZ1bmN0aW9uIGR1cmluZ0FsbChmbikge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGZuLmNhbGwodGhpcywgZS5kZXRhaWwucG9zLCBTVkcubW9ycGgoZS5kZXRhaWwucG9zKSwgZS5kZXRhaWwuZWFzZWQsIGUuZGV0YWlsLnNpdHVhdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKTtcbiAgICAgICAgdGhpcy5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpdHVhdGlvbnMubGVuZ3RoID8gdGhpcy5zaXR1YXRpb25zW3RoaXMuc2l0dWF0aW9ucy5sZW5ndGggLSAxXSA6IHRoaXMuc2l0dWF0aW9uO1xuICAgICAgfSxcbiAgICAgIC8vIGFkZHMgb25lIHByb3BlcnR5IHRvIHRoZSBhbmltYXRpb25zXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChtZXRob2QsIGFyZ3MsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5sYXN0KClbdHlwZSB8fCAnYW5pbWF0aW9ucyddW21ldGhvZF0gPSBhcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKiogcGVyZm9ybSBvbmUgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAqICBAcGFyYW0gaWdub3JlVGltZSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBpZ25vcmUgdGltZSBhbmQgdXNlIHBvc2l0aW9uIGRpcmVjdGx5IG9yIHJlY2FsY3VsYXRlIHBvc2l0aW9uIGJhc2VkIG9uIHRpbWVcbiAgICAgICogIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHN0ZXA6IGZ1bmN0aW9uIHN0ZXAoaWdub3JlVGltZSkge1xuICAgICAgICAvLyBjb252ZXJ0IGN1cnJlbnQgdGltZSB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgICBpZiAoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKCkpOyAvLyBUaGlzIHBhcnQgY29udmVydCBhbiBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIHBvc2l0aW9uXG5cbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBhYnNQb3MsIGFic1Bvc0ludCwgbGFzdExvb3A7IC8vIElmIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpcyBiZWxvdyAwLCB3ZSBqdXN0IHRyZWF0IGl0IGFzIGlmIGl0IHdhcyAwXG5cbiAgICAgICAgICBhYnNQb3MgPSBNYXRoLm1heCh0aGlzLmFic1BvcywgMCk7XG4gICAgICAgICAgYWJzUG9zSW50ID0gTWF0aC5mbG9vcihhYnNQb3MpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlIHx8IGFic1Bvc0ludCA8IHRoaXMuc2l0dWF0aW9uLmxvb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcyAtIGFic1Bvc0ludDtcbiAgICAgICAgICAgIGxhc3RMb29wID0gdGhpcy5zaXR1YXRpb24ubG9vcDtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3AgPSBhYnNQb3NJbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWJzUG9zID0gdGhpcy5zaXR1YXRpb24ubG9vcHM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDE7IC8vIFRoZSAtMSBoZXJlIGlzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byB0b2dnbGUgcmV2ZXJzZWQgd2hlbiBhbGwgdGhlIGxvb3BzIGhhdmUgYmVlbiBjb21wbGV0ZWRcblxuICAgICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMTtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzaW5nKSB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgcmV2ZXJzZWQgaWYgYW4gb2RkIG51bWJlciBvZiBsb29wcyBhcyBvY2N1cmVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgb2Ygc3RlcFxuICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQgPSB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCAhPSBCb29sZWFuKCh0aGlzLnNpdHVhdGlvbi5sb29wIC0gbGFzdExvb3ApICUgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBsb29wLCB0aGUgYWJzb2x1dGUgcG9zaXRpb24gbXVzdCBub3QgYmUgYWJvdmUgMVxuICAgICAgICAgIHRoaXMuYWJzUG9zID0gTWF0aC5taW4odGhpcy5hYnNQb3MsIDEpO1xuICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5hYnNQb3M7XG4gICAgICAgIH0gLy8gd2hpbGUgdGhlIGFic29sdXRlIHBvc2l0aW9uIGNhbiBiZSBiZWxvdyAwLCB0aGUgcG9zaXRpb24gbXVzdCBub3QgYmUgYmVsb3cgMFxuXG5cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkgdGhpcy5wb3MgPSAwO1xuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQpIHRoaXMucG9zID0gMSAtIHRoaXMucG9zOyAvLyBhcHBseSBlYXNpbmdcblxuICAgICAgICB2YXIgZWFzZWQgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHRoaXMucG9zKTsgLy8gY2FsbCBvbmNlLWNhbGxiYWNrc1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zaXR1YXRpb24ub25jZSkge1xuICAgICAgICAgIGlmIChpID4gdGhpcy5sYXN0UG9zICYmIGkgPD0gZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV0uY2FsbCh0aGlzLnRhcmdldCgpLCB0aGlzLnBvcywgZWFzZWQpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZpcmUgZHVyaW5nIGNhbGxiYWNrIHdpdGggcG9zaXRpb24sIGVhc2VkIHBvc2l0aW9uIGFuZCBjdXJyZW50IHNpdHVhdGlvbiBhcyBwYXJhbWV0ZXJcblxuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7XG4gICAgICAgICAgcG9zOiB0aGlzLnBvcyxcbiAgICAgICAgICBlYXNlZDogZWFzZWQsXG4gICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgc2l0dWF0aW9uOiB0aGlzLnNpdHVhdGlvblxuICAgICAgICB9KTsgLy8gdGhlIHVzZXIgbWF5IGNhbGwgc3RvcCBvciBmaW5pc2ggaW4gdGhlIGR1cmluZyBjYWxsYmFja1xuICAgICAgICAvLyBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBzdGlsbCBoYXZlIGEgdmFsaWQgc2l0dWF0aW9uXG5cbiAgICAgICAgaWYgKCF0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IC8vIGFwcGx5IHRoZSBhY3R1YWwgYW5pbWF0aW9uIHRvIGV2ZXJ5IHByb3BlcnR5XG5cblxuICAgICAgICB0aGlzLmVhY2hBdCgpOyAvLyBkbyBmaW5hbCBjb2RlIHdoZW4gc2l0dWF0aW9uIGlzIGZpbmlzaGVkXG5cbiAgICAgICAgaWYgKHRoaXMucG9zID09IDEgJiYgIXRoaXMuc2l0dWF0aW9uLnJldmVyc2VkIHx8IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICYmIHRoaXMucG9zID09IDApIHtcbiAgICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBjYWxsYmFja1xuICAgICAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpOyAvLyBmaXJlIGZpbmlzaGVkIGNhbGxiYWNrIHdpdGggY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXG5cbiAgICAgICAgICB0aGlzLnRhcmdldCgpLmZpcmUoJ2ZpbmlzaGVkJywge1xuICAgICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgICBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0KCkuZmlyZSgnYWxsZmluaXNoZWQnKTsgLy8gUmVjaGVjayB0aGUgbGVuZ3RoIHNpbmNlIHRoZSB1c2VyIG1heSBjYWxsIGFuaW1hdGUgaW4gdGhlIGFmdGVyQWxsIGNhbGxiYWNrXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zaXR1YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldCgpLm9mZignLmZ4Jyk7IC8vIHRoZXJlIHNob3VsZG50IGJlIGFueSBiaW5kaW5nIGxlZnQsIGJ1dCB0byBtYWtlIHN1cmUuLi5cblxuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gc3RhcnQgbmV4dCBhbmltYXRpb25cblxuXG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB0aGlzLmRlcXVldWUoKTtlbHNlIHRoaXMuY2xlYXJDdXJyZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkICYmIHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgLy8gd2UgY29udGludWUgYW5pbWF0aW5nIHdoZW4gd2UgYXJlIG5vdCBhdCB0aGUgZW5kXG4gICAgICAgICAgdGhpcy5zdGFydEFuaW1GcmFtZSgpO1xuICAgICAgICB9IC8vIHNhdmUgbGFzdCBlYXNlZCBwb3NpdGlvbiBmb3Igb25jZSBjYWxsYmFjayB0cmlnZ2VyaW5nXG5cblxuICAgICAgICB0aGlzLmxhc3RQb3MgPSBlYXNlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gY2FsY3VsYXRlcyB0aGUgc3RlcCBmb3IgZXZlcnkgcHJvcGVydHkgYW5kIGNhbGxzIGJsb2NrIHdpdGggaXRcbiAgICAgIGVhY2hBdDogZnVuY3Rpb24gZWFjaEF0KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLFxuICAgICAgICAgICAgcyA9IHRoaXMuc2l0dWF0aW9uOyAvLyBhcHBseSBhbmltYXRpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgdHJvdWdoIGEgbWV0aG9kXG5cbiAgICAgICAgZm9yIChpIGluIHMuYW5pbWF0aW9ucykge1xuICAgICAgICAgIGF0ID0gW10uY29uY2F0KHMuYW5pbWF0aW9uc1tpXSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXRbaV0uYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgIH0gLy8gYXBwbHkgYW5pbWF0aW9uIHdoaWNoIGhhcyB0byBiZSBhcHBsaWVkIHdpdGggYXR0cigpXG5cblxuICAgICAgICBmb3IgKGkgaW4gcy5hdHRycykge1xuICAgICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLmF0dHJzW2ldKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5hdHRyLmFwcGx5KHRhcmdldCwgYXQpO1xuICAgICAgICB9IC8vIGFwcGx5IGFuaW1hdGlvbiB3aGljaCBoYXMgdG8gYmUgYXBwbGllZCB3aXRoIHN0eWxlKClcblxuXG4gICAgICAgIGZvciAoaSBpbiBzLnN0eWxlcykge1xuICAgICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLnN0eWxlc1tpXSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgIH0gLy8gYW5pbWF0ZSBpbml0aWFsVHJhbnNmb3JtYXRpb24gd2hpY2ggaGFzIHRvIGJlIGNoYWluZWRcblxuXG4gICAgICAgIGlmIChzLnRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZ2V0IGluaXRpYWwgaW5pdGlhbFRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgYXQgPSBzLmluaXRpYWxUcmFuc2Zvcm1hdGlvbjtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IG5leHQgdHJhbnNmb3JtYXRpb24gaW4gY2hhaW5cbiAgICAgICAgICAgIHZhciBhID0gcy50cmFuc2Zvcm1zW2ldOyAvLyBtdWx0aXBseSBtYXRyaXggZGlyZWN0bHlcblxuICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBTVkcuTWF0cml4KSB7XG4gICAgICAgICAgICAgIGlmIChhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdCA9IGF0Lm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIHdoZW4gdHJhbnNmb3JtYXRpb24gaXMgYWJzb2x1dGUgd2UgaGF2ZSB0byByZXNldCB0aGUgbmVlZGVkIHRyYW5zZm9ybWF0aW9uIGZpcnN0XG5cblxuICAgICAgICAgICAgaWYgKCFhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIGEudW5kbyhhdC5leHRyYWN0KCkpO1xuICAgICAgICAgICAgfSAvLyBhbmQgcmVhcHBseSBpdCBhZnRlclxuXG5cbiAgICAgICAgICAgIGF0ID0gYXQubXVsdGlwbHkoYS5hdChzLmVhc2UodGhpcy5wb3MpKSk7XG4gICAgICAgICAgfSAvLyBzZXQgbmV3IG1hdHJpeCBvbiBlbGVtZW50XG5cblxuICAgICAgICAgIHRhcmdldC5tYXRyaXgoYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxuICAgICAgb25jZTogZnVuY3Rpb24gb25jZShwb3MsIGZuLCBpc0Vhc2VkKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYXN0KCk7XG4gICAgICAgIGlmICghaXNFYXNlZCkgcG9zID0gYy5lYXNlKHBvcyk7XG4gICAgICAgIGMub25jZVtwb3NdID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9jYWxsU3RhcnQ6IGZ1bmN0aW9uIF9jYWxsU3RhcnQoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBtZXRob2QgdG8gcGFyZW50IGVsZW1lbnRzXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBHZXQgZnggbW9kdWxlIG9yIGNyZWF0ZSBhIG5ldyBvbmUsIHRoZW4gYW5pbWF0ZSB3aXRoIGdpdmVuIGR1cmF0aW9uIGFuZCBlYXNlXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKG8sIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5hbmltYXRlKG8sIGVhc2UsIGRlbGF5KTtcbiAgICAgIH0sXG4gICAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoX2RlbGF5Mikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZnggfHwgKHRoaXMuZnggPSBuZXcgU1ZHLkZYKHRoaXMpKSkuZGVsYXkoX2RlbGF5Mik7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZngpIHtcbiAgICAgICAgICB0aGlzLmZ4LnN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZnguZmluaXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBQYXVzZSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZngucGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFBsYXkgcGF1c2VkIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZngucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gU2V0L0dldCB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbnNcbiAgICAgIHNwZWVkOiBmdW5jdGlvbiBzcGVlZChfc3BlZWQyKSB7XG4gICAgICAgIGlmICh0aGlzLmZ4KSB7XG4gICAgICAgICAgaWYgKF9zcGVlZDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnguc3BlZWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5meC5zcGVlZChfc3BlZWQyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cblxuICBTVkcuTW9ycGhPYmogPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShmcm9tLCB0bykge1xuICAgICAgLy8gcHJlcGFyZSBjb2xvciBmb3IgbW9ycGhpbmdcbiAgICAgIGlmIChTVkcuQ29sb3IuaXNDb2xvcih0bykpIHJldHVybiBuZXcgU1ZHLkNvbG9yKGZyb20pLm1vcnBoKHRvKTsgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIGxpc3Qgb2YgdmFsdWVzXG5cbiAgICAgIGlmIChTVkcucmVnZXguZGVsaW1pdGVyLnRlc3QoZnJvbSkpIHtcbiAgICAgICAgLy8gcHJlcGFyZSBwYXRoIGZvciBtb3JwaGluZ1xuICAgICAgICBpZiAoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLnRlc3QoZnJvbSkpIHJldHVybiBuZXcgU1ZHLlBhdGhBcnJheShmcm9tKS5tb3JwaCh0byk7IC8vIHByZXBhcmUgdmFsdWUgbGlzdCBmb3IgbW9ycGhpbmdcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3IFNWRy5BcnJheShmcm9tKS5tb3JwaCh0byk7XG4gICAgICB9IC8vIHByZXBhcmUgbnVtYmVyIGZvciBtb3JwaGluZ1xuXG5cbiAgICAgIGlmIChTVkcucmVnZXgubnVtYmVyQW5kVW5pdC50ZXN0KHRvKSkgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKGZyb20pLm1vcnBoKHRvKTsgLy8gcHJlcGFyZSBmb3IgcGxhaW4gbW9ycGhpbmdcblxuICAgICAgdGhpcy52YWx1ZSA9IGZyb207XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdG87XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MsIHJlYWwpIHtcbiAgICAgICAgcmV0dXJuIHJlYWwgPCAxID8gdGhpcy52YWx1ZSA6IHRoaXMuZGVzdGluYXRpb247XG4gICAgICB9LFxuICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRlgsIHtcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCB2LCByZWxhdGl2ZSkge1xuICAgICAgLy8gYXBwbHkgYXR0cmlidXRlcyBpbmRpdmlkdWFsbHlcbiAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgIHRoaXMuYXR0cihrZXksIGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkKGEsIHYsICdhdHRycycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShzLCB2KSB7XG4gICAgICBpZiAoX3R5cGVvZihzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHMpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKGtleSwgc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGQocywgdiwgJ3N0eWxlcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEFuaW1hdGFibGUgeC1heGlzXG4gICAgeDogZnVuY3Rpb24geChfeDIsIHJlbGF0aXZlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5HKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgICB4OiBfeDJcbiAgICAgICAgfSwgcmVsYXRpdmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKF94Mik7XG4gICAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgneCcsIG51bSk7XG4gICAgfSxcbiAgICAvLyBBbmltYXRhYmxlIHktYXhpc1xuICAgIHk6IGZ1bmN0aW9uIHkoX3kyLCByZWxhdGl2ZSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuRykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgICAgeTogX3kyXG4gICAgICAgIH0sIHJlbGF0aXZlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBudW0gPSBuZXcgU1ZHLk51bWJlcihfeTIpO1xuICAgICAgbnVtLnJlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3knLCBudW0pO1xuICAgIH0sXG4gICAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgnY3gnLCBuZXcgU1ZHLk51bWJlcih4KSk7XG4gICAgfSxcbiAgICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcbiAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKCdjeScsIG5ldyBTVkcuTnVtYmVyKHkpKTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIG1vdmVcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLngoeCkueSh5KTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxuICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuVGV4dCkge1xuICAgICAgICAvLyBhbmltYXRlIGZvbnQgc2l6ZSBmb3IgVGV4dCBlbGVtZW50c1xuICAgICAgICB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIHdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFuaW1hdGUgYmJveCBiYXNlZCBzaXplIGZvciBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdmFyIGJveDtcblxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICBib3ggPSB0aGlzLnRhcmdldCgpLmJib3goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkKCd3aWR0aCcsIG5ldyBTVkcuTnVtYmVyKHdpZHRoKSkuYWRkKCdoZWlnaHQnLCBuZXcgU1ZHLk51bWJlcihoZWlnaHQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSB3aWR0aFxuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3dpZHRoJywgbmV3IFNWRy5OdW1iZXIoX3dpZHRoMikpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgaGVpZ2h0XG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoX2hlaWdodDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgnaGVpZ2h0JywgbmV3IFNWRy5OdW1iZXIoX2hlaWdodDIpKTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHBsb3RcbiAgICBwbG90OiBmdW5jdGlvbiBwbG90KGEsIGIsIGMsIGQpIHtcbiAgICAgIC8vIExpbmVzIGNhbiBiZSBwbG90dGVkIHdpdGggNCBhcmd1bWVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdChbYSwgYiwgYywgZF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3Bsb3QnLCBuZXcgKHRoaXMudGFyZ2V0KCkubW9ycGhBcnJheSkoYSkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXG4gICAgbGVhZGluZzogZnVuY3Rpb24gbGVhZGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0KCkubGVhZGluZyA/IHRoaXMuYWRkKCdsZWFkaW5nJywgbmV3IFNWRy5OdW1iZXIodmFsdWUpKSA6IHRoaXM7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gICAgdmlld2JveDogZnVuY3Rpb24gdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hZGQoJ3ZpZXdib3gnLCBuZXcgU1ZHLlZpZXdCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG8pIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlN0b3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpO1xuICAgICAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKTtcbiAgICAgICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0Jywgby5vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBTVkcuQm94ID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmICEoeCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSkge1xuICAgICAgICAvLyBjaHJvbWVzIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBoYXMgbm8geCBhbmQgeSBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gU1ZHLkJveC5jYWxsKHRoaXMsIHgubGVmdCAhPSBudWxsID8geC5sZWZ0IDogeC54LCB4LnRvcCAhPSBudWxsID8geC50b3AgOiB4LnksIHgud2lkdGgsIHguaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9IC8vIGFkZCBjZW50ZXIsIHJpZ2h0LCBib3R0b20uLi5cblxuXG4gICAgICBmdWxsQm94KHRoaXMpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuICAgICAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKGJveCkge1xuICAgICAgICB2YXIgYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7IC8vIG1lcmdlIGJveGVzXG5cbiAgICAgICAgYi54ID0gTWF0aC5taW4odGhpcy54LCBib3gueCk7XG4gICAgICAgIGIueSA9IE1hdGgubWluKHRoaXMueSwgYm94LnkpO1xuICAgICAgICBiLndpZHRoID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgYm94LnggKyBib3gud2lkdGgpIC0gYi54O1xuICAgICAgICBiLmhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBib3gueSArIGJveC5oZWlnaHQpIC0gYi55O1xuICAgICAgICByZXR1cm4gZnVsbEJveChiKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShtKSB7XG4gICAgICAgIHZhciB4TWluID0gSW5maW5pdHksXG4gICAgICAgICAgICB4TWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgICAgeU1pbiA9IEluZmluaXR5LFxuICAgICAgICAgICAgeU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgIGJib3g7XG4gICAgICAgIHZhciBwdHMgPSBbbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueSksIG5ldyBTVkcuUG9pbnQodGhpcy54MiwgdGhpcy55KSwgbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueTIpLCBuZXcgU1ZHLlBvaW50KHRoaXMueDIsIHRoaXMueTIpXTtcbiAgICAgICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBwID0gcC50cmFuc2Zvcm0obSk7XG4gICAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHAueCk7XG4gICAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueCk7XG4gICAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHAueSk7XG4gICAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHAueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiYm94ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgYmJveC54ID0geE1pbjtcbiAgICAgICAgYmJveC53aWR0aCA9IHhNYXggLSB4TWluO1xuICAgICAgICBiYm94LnkgPSB5TWluO1xuICAgICAgICBiYm94LmhlaWdodCA9IHlNYXggLSB5TWluO1xuICAgICAgICBmdWxsQm94KGJib3gpO1xuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQkJveCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBTVkcuQm94LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7IC8vIGdldCB2YWx1ZXMgaWYgZWxlbWVudCBpcyBnaXZlblxuXG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgIHZhciBib3g7IC8vIHllcyB0aGlzIGlzIHVnbHksIGJ1dCBGaXJlZm94IGNhbiBiZSBhIHBhaW4gd2hlbiBpdCBjb21lcyB0byBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IHJlbmRlcmVkXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucykge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcbiAgICAgICAgICAgIHZhciB0b3BQYXJlbnQgPSBlbGVtZW50Lm5vZGU7XG5cbiAgICAgICAgICAgIHdoaWxlICh0b3BQYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICB0b3BQYXJlbnQgPSB0b3BQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcFBhcmVudCAhPSBkb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBpbiB0aGUgZG9tJyk7XG4gICAgICAgICAgfSAvLyB0aGUgZWxlbWVudCBpcyBOT1QgaW4gdGhlIGRvbSwgdGhyb3cgZXJyb3JcbiAgICAgICAgICAvLyBkaXNhYmxpbmcgdGhlIGNoZWNrIGJlbG93IHdoaWNoIGZpeGVzIGlzc3VlICM3NlxuICAgICAgICAgIC8vIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQubm9kZSkpIHRocm93IG5ldyBFeGNlcHRpb24oJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKVxuICAgICAgICAgIC8vIGZpbmQgbmF0aXZlIGJib3hcblxuXG4gICAgICAgICAgYm94ID0gZWxlbWVudC5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLlNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgICAgICAgICAvLyBmaXhlcyBhcGV4Y2hhcnRzL3Z1ZS1hcGV4Y2hhcnRzICMxNFxuICAgICAgICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBlbGVtZW50LmNsb25lKFNWRy5wYXJzZXIuZHJhdy5pbnN0YW5jZSkuc2hvdygpO1xuICAgICAgICAgICAgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgICB4OiBlbGVtZW50Lm5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgeTogZWxlbWVudC5ub2RlLmNsaWVudFRvcCxcbiAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQubm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNWRy5Cb3guY2FsbCh0aGlzLCBib3gpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVmaW5lIGFuY2VzdG9yXG4gICAgaW5oZXJpdDogU1ZHLkJveCxcbiAgICAvLyBEZWZpbmUgUGFyZW50XG4gICAgcGFyZW50OiBTVkcuRWxlbWVudCxcbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gR2V0IGJvdW5kaW5nIGJveFxuICAgICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuQkJveCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuQkJveDtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIHRib3g6IGZ1bmN0aW9uIHRib3goKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzZSBvZiBUQm94IGlzIGRlcHJlY2F0ZWQgYW5kIG1hcHBlZCB0byBSQm94LiBVc2UgLnJib3goKSBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIHRoaXMucmJveCh0aGlzLmRvYygpKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuUkJveCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBTVkcuQm94LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgU1ZHLkJveC5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmhlcml0OiBTVkcuQm94LFxuICAgIC8vIGRlZmluZSBQYXJlbnRcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIGV4dGVuZDoge1xuICAgICAgYWRkT2Zmc2V0OiBmdW5jdGlvbiBhZGRPZmZzZXQoKSB7XG4gICAgICAgIC8vIG9mZnNldCBieSB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjaGFuZ2VzIHdoZW4gd2luZG93IGlzIHNjcm9sbGVkXG4gICAgICAgIHRoaXMueCArPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgIHRoaXMueSArPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIEdldCByZWN0IGJveFxuICAgICAgcmJveDogZnVuY3Rpb24gcmJveChlbCkge1xuICAgICAgICBpZiAoZWwpIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcykudHJhbnNmb3JtKGVsLnNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcykuYWRkT2Zmc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlJCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHLlJCb3g7XG4gIFNWRy5NYXRyaXggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBiYXNlID0gYXJyYXlUb01hdHJpeChbMSwgMCwgMCwgMSwgMCwgMF0pOyAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuXG4gICAgICBzb3VyY2UgPSBzb3VyY2UgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCA/IHNvdXJjZS5tYXRyaXhpZnkoKSA6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gYXJyYXlUb01hdHJpeChzb3VyY2Uuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKSA6IGFyZ3VtZW50cy5sZW5ndGggPT0gNiA/IGFycmF5VG9NYXRyaXgoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IGFycmF5VG9NYXRyaXgoc291cmNlKSA6IF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcgPyBzb3VyY2UgOiBiYXNlOyAvLyBtZXJnZSBzb3VyY2VcblxuICAgICAgZm9yIChpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHRoaXNbYWJjZGVmW2ldXSA9IHNvdXJjZVthYmNkZWZbaV1dICE9IG51bGwgPyBzb3VyY2VbYWJjZGVmW2ldXSA6IGJhc2VbYWJjZGVmW2ldXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBFeHRyYWN0IGluZGl2aWR1YWwgdHJhbnNmb3JtYXRpb25zXG4gICAgICBleHRyYWN0OiBmdW5jdGlvbiBleHRyYWN0KCkge1xuICAgICAgICAvLyBmaW5kIGRlbHRhIHRyYW5zZm9ybSBwb2ludHNcbiAgICAgICAgdmFyIHB4ID0gZGVsdGFUcmFuc2Zvcm1Qb2ludCh0aGlzLCAwLCAxKSxcbiAgICAgICAgICAgIHB5ID0gZGVsdGFUcmFuc2Zvcm1Qb2ludCh0aGlzLCAxLCAwKSxcbiAgICAgICAgICAgIHNrZXdYID0gMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbjIocHgueSwgcHgueCkgLSA5MDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvLyB0cmFuc2xhdGlvblxuICAgICAgICAgIHg6IHRoaXMuZSxcbiAgICAgICAgICB5OiB0aGlzLmYsXG4gICAgICAgICAgdHJhbnNmb3JtZWRYOiAodGhpcy5lICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZiAqIE1hdGguc2luKHNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYiksXG4gICAgICAgICAgdHJhbnNmb3JtZWRZOiAodGhpcy5mICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZSAqIE1hdGguc2luKC1za2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpLFxuICAgICAgICAgIC8vIHNrZXdcbiAgICAgICAgICBza2V3WDogLXNrZXdYLFxuICAgICAgICAgIHNrZXdZOiAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweS55LCBweS54KSxcbiAgICAgICAgICAvLyBzY2FsZVxuICAgICAgICAgIHNjYWxlWDogTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYiksXG4gICAgICAgICAgc2NhbGVZOiBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKSxcbiAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgIHJvdGF0aW9uOiBza2V3WCxcbiAgICAgICAgICBhOiB0aGlzLmEsXG4gICAgICAgICAgYjogdGhpcy5iLFxuICAgICAgICAgIGM6IHRoaXMuYyxcbiAgICAgICAgICBkOiB0aGlzLmQsXG4gICAgICAgICAgZTogdGhpcy5lLFxuICAgICAgICAgIGY6IHRoaXMuZixcbiAgICAgICAgICBtYXRyaXg6IG5ldyBTVkcuTWF0cml4KHRoaXMpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gQ2xvbmUgbWF0cml4XG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3JwaCBvbmUgbWF0cml4IGludG8gYW5vdGhlclxuICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKG1hdHJpeCkge1xuICAgICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gY2FsY3VsYXRlIG1vcnBoZWQgbWF0cml4IGF0IGEgZ2l2ZW4gcG9zaXRpb25cblxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgoe1xuICAgICAgICAgIGE6IHRoaXMuYSArICh0aGlzLmRlc3RpbmF0aW9uLmEgLSB0aGlzLmEpICogcG9zLFxuICAgICAgICAgIGI6IHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zLFxuICAgICAgICAgIGM6IHRoaXMuYyArICh0aGlzLmRlc3RpbmF0aW9uLmMgLSB0aGlzLmMpICogcG9zLFxuICAgICAgICAgIGQ6IHRoaXMuZCArICh0aGlzLmRlc3RpbmF0aW9uLmQgLSB0aGlzLmQpICogcG9zLFxuICAgICAgICAgIGU6IHRoaXMuZSArICh0aGlzLmRlc3RpbmF0aW9uLmUgLSB0aGlzLmUpICogcG9zLFxuICAgICAgICAgIGY6IHRoaXMuZiArICh0aGlzLmRlc3RpbmF0aW9uLmYgLSB0aGlzLmYpICogcG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfSxcbiAgICAgIC8vIE11bHRpcGxpZXMgYnkgZ2l2ZW4gbWF0cml4XG4gICAgICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLm11bHRpcGx5KHBhcnNlTWF0cml4KG1hdHJpeCkubmF0aXZlKCkpKTtcbiAgICAgIH0sXG4gICAgICAvLyBJbnZlcnNlcyBtYXRyaXhcbiAgICAgIGludmVyc2U6IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLmludmVyc2UoKSk7XG4gICAgICB9LFxuICAgICAgLy8gVHJhbnNsYXRlIG1hdHJpeFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS50cmFuc2xhdGUoeCB8fCAwLCB5IHx8IDApKTtcbiAgICAgIH0sXG4gICAgICAvLyBTY2FsZSBtYXRyaXhcbiAgICAgIHNjYWxlOiBmdW5jdGlvbiBzY2FsZSh4LCB5LCBjeCwgY3kpIHtcbiAgICAgICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2NhbGVcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgIGN5ID0gY3g7XG4gICAgICAgICAgY3ggPSB5O1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoeCwgMCwgMCwgeSwgMCwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFJvdGF0ZSBtYXRyaXhcbiAgICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKHIsIGN4LCBjeSkge1xuICAgICAgICAvLyBjb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgICByID0gU1ZHLnV0aWxzLnJhZGlhbnMocik7XG4gICAgICAgIHJldHVybiB0aGlzLmFyb3VuZChjeCwgY3ksIG5ldyBTVkcuTWF0cml4KE1hdGguY29zKHIpLCBNYXRoLnNpbihyKSwgLU1hdGguc2luKHIpLCBNYXRoLmNvcyhyKSwgMCwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcbiAgICAgIGZsaXA6IGZ1bmN0aW9uIGZsaXAoYSwgbykge1xuICAgICAgICByZXR1cm4gYSA9PSAneCcgPyB0aGlzLnNjYWxlKC0xLCAxLCBvLCAwKSA6IGEgPT0gJ3knID8gdGhpcy5zY2FsZSgxLCAtMSwgMCwgbykgOiB0aGlzLnNjYWxlKC0xLCAtMSwgYSwgbyAhPSBudWxsID8gbyA6IGEpO1xuICAgICAgfSxcbiAgICAgIC8vIFNrZXdcbiAgICAgIHNrZXc6IGZ1bmN0aW9uIHNrZXcoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNrZXdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgIGN5ID0gY3g7XG4gICAgICAgICAgY3ggPSB5O1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG5cblxuICAgICAgICB4ID0gU1ZHLnV0aWxzLnJhZGlhbnMoeCk7XG4gICAgICAgIHkgPSBTVkcudXRpbHMucmFkaWFucyh5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoMSwgTWF0aC50YW4oeSksIE1hdGgudGFuKHgpLCAxLCAwLCAwKSk7XG4gICAgICB9LFxuICAgICAgLy8gU2tld1hcbiAgICAgIHNrZXdYOiBmdW5jdGlvbiBza2V3WCh4LCBjeCwgY3kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwLCBjeCwgY3kpO1xuICAgICAgfSxcbiAgICAgIC8vIFNrZXdZXG4gICAgICBza2V3WTogZnVuY3Rpb24gc2tld1koeSwgY3gsIGN5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KTtcbiAgICAgIH0sXG4gICAgICAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XG4gICAgICBhcm91bmQ6IGZ1bmN0aW9uIGFyb3VuZChjeCwgY3ksIG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCBjeCB8fCAwLCBjeSB8fCAwKSkubXVsdGlwbHkobWF0cml4KS5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCAtY3ggfHwgMCwgLWN5IHx8IDApKTtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IHRvIG5hdGl2ZSBTVkdNYXRyaXhcbiAgICAgIG5hdGl2ZTogZnVuY3Rpb24gbmF0aXZlKCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IG1hdHJpeFxuICAgICAgICB2YXIgbWF0cml4ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHTWF0cml4KCk7IC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFiY2RlZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG1hdHJpeFthYmNkZWZbaV1dID0gdGhpc1thYmNkZWZbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBtYXRyaXggZGlyZWN0bHksIGF2b2lkIHZhbHVlcyB0aGF0IGFyZSB0b28gc21hbGxcbiAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArIGZsb2F0MzJTdHJpbmcodGhpcy5hKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5iKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5jKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5kKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5lKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5mKSArICcpJztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlZmluZSBwYXJlbnRcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBHZXQgY3VycmVudCBtYXRyaXhcbiAgICAgIGN0bTogZnVuY3Rpb24gY3RtKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgY3VycmVudCBzY3JlZW4gbWF0cml4XG4gICAgICBzY3JlZW5DVE06IGZ1bmN0aW9uIHNjcmVlbkNUTSgpIHtcbiAgICAgICAgLyogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM0NDUzN1xuICAgICAgICAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEZGIGRvZXMgbm90IHJldHVybiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICAgICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXG4gICAgICAgICAgIEhvd2V2ZXIgYWxsIG90aGVyIEJyb3dzZXJzIGRvIHRoYXQgKi9cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTVkcuTmVzdGVkKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3QoMSwgMSk7XG4gICAgICAgICAgdmFyIG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgcmVjdC5yZW1vdmUoKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgobSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuUG9pbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xuICAgICAgdmFyIHNvdXJjZSxcbiAgICAgICAgICBiYXNlID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICAgIH07XG4gICAgICBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID8ge1xuICAgICAgICB4OiB4WzBdLFxuICAgICAgICB5OiB4WzFdXG4gICAgICB9IDogX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgPyB7XG4gICAgICAgIHg6IHgueCxcbiAgICAgICAgeTogeC55XG4gICAgICB9IDogeCAhPSBudWxsID8ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5ICE9IG51bGwgPyB5IDogeFxuICAgICAgfSA6IGJhc2U7IC8vIElmIHkgaGFzIG5vIHZhbHVlLCB0aGVuIHggaXMgdXNlZCBoYXMgaXRzIHZhbHVlXG4gICAgICAvLyBtZXJnZSBzb3VyY2VcblxuICAgICAgdGhpcy54ID0gc291cmNlLng7XG4gICAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICB9LFxuICAgIC8vIEFkZCBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBDbG9uZSBwb2ludFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3JwaCBvbmUgcG9pbnQgaW50byBhbm90aGVyXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgoeCwgeSkge1xuICAgICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuUG9pbnQoeCwgeSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtb3JwaGVkIHBvaW50IGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBjYWxjdWxhdGUgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxuXG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBTVkcuUG9pbnQoe1xuICAgICAgICAgIHg6IHRoaXMueCArICh0aGlzLmRlc3RpbmF0aW9uLnggLSB0aGlzLngpICogcG9zLFxuICAgICAgICAgIHk6IHRoaXMueSArICh0aGlzLmRlc3RpbmF0aW9uLnkgLSB0aGlzLnkpICogcG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgLy8gQ29udmVydCB0byBuYXRpdmUgU1ZHUG9pbnRcbiAgICAgIG5hdGl2ZTogZnVuY3Rpb24gbmF0aXZlKCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IHBvaW50XG4gICAgICAgIHZhciBwb2ludCA9IFNWRy5wYXJzZXIubmF0aXZlLmNyZWF0ZVNWR1BvaW50KCk7IC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXG5cbiAgICAgICAgcG9pbnQueCA9IHRoaXMueDtcbiAgICAgICAgcG9pbnQueSA9IHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfSxcbiAgICAgIC8vIHRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50KHRoaXMubmF0aXZlKCkubWF0cml4VHJhbnNmb3JtKG1hdHJpeC5uYXRpdmUoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBHZXQgcG9pbnRcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQoeCwgeSkudHJhbnNmb3JtKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxuICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgdiwgbikge1xuICAgICAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgICAgICBhID0ge307XG4gICAgICAgIHYgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKG4gPSB2Lmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgICAgYVt2W25dLm5vZGVOYW1lXSA9IFNWRy5yZWdleC5pc051bWJlci50ZXN0KHZbbl0ubm9kZVZhbHVlKSA/IHBhcnNlRmxvYXQodltuXS5ub2RlVmFsdWUpIDogdltuXS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICAgIGZvciAodiBpbiBhKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKHYsIGFbdl0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYSk7XG4gICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcbiAgICAgICAgdiA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYSk7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgPyBTVkcuZGVmYXVsdHMuYXR0cnNbYV0gOiBTVkcucmVnZXguaXNOdW1iZXIudGVzdCh2KSA/IHBhcnNlRmxvYXQodikgOiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQlVHIEZJWDogc29tZSBicm93c2VycyB3aWxsIHJlbmRlciBhIHN0cm9rZSBpZiBhIGNvbG9yIGlzIGdpdmVuIGV2ZW4gdGhvdWdoIHN0cm9rZSB3aWR0aCBpcyAwXG4gICAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKCdzdHJva2UnLCBwYXJzZUZsb2F0KHYpID4gMCA/IHRoaXMuX3N0cm9rZSA6IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT0gJ3N0cm9rZScpIHtcbiAgICAgICAgICB0aGlzLl9zdHJva2UgPSB2O1xuICAgICAgICB9IC8vIGNvbnZlcnQgaW1hZ2UgZmlsbCBhbmQgc3Ryb2tlIHRvIHBhdHRlcm5zXG5cblxuICAgICAgICBpZiAoYSA9PSAnZmlsbCcgfHwgYSA9PSAnc3Ryb2tlJykge1xuICAgICAgICAgIGlmIChTVkcucmVnZXguaXNJbWFnZS50ZXN0KHYpKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5kb2MoKS5kZWZzKCkuaW1hZ2UodiwgMCwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTVkcuSW1hZ2UpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXR0ZXJuKDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGQodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHYgPSBuZXcgU1ZHLk51bWJlcih2KTtcbiAgICAgICAgfSAvLyBlbnN1cmUgZnVsbCBoZXggY29sb3JcbiAgICAgICAgZWxzZSBpZiAoU1ZHLkNvbG9yLmlzQ29sb3IodikpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkNvbG9yKHYpO1xuICAgICAgICAgIH0gLy8gcGFyc2UgYXJyYXkgdmFsdWVzXG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICB2ID0gbmV3IFNWRy5BcnJheSh2KTtcbiAgICAgICAgICAgIH0gLy8gaWYgdGhlIHBhc3NlZCBhdHRyaWJ1dGUgaXMgbGVhZGluZy4uLlxuXG5cbiAgICAgICAgaWYgKGEgPT0gJ2xlYWRpbmcnKSB7XG4gICAgICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcbiAgICAgICAgICBpZiAodGhpcy5sZWFkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxlYWRpbmcodik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNldCBnaXZlbiBhdHRyaWJ1dGUgb24gbm9kZVxuICAgICAgICAgIHR5cGVvZiBuID09PSAnc3RyaW5nJyA/IHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhuLCBhLCB2LnRvU3RyaW5nKCkpIDogdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLCB2LnRvU3RyaW5nKCkpO1xuICAgICAgICB9IC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcblxuXG4gICAgICAgIGlmICh0aGlzLnJlYnVpbGQgJiYgKGEgPT0gJ2ZvbnQtc2l6ZScgfHwgYSA9PSAneCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWJ1aWxkKGEsIHYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obywgcmVsYXRpdmUpIHtcbiAgICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICBiYm94OyAvLyBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgaWYgKF90eXBlb2YobykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeDtcbiAgICAgIH0gLy8gZ2V0IGN1cnJlbnQgbWF0cml4XG5cblxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KTsgLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcblxuICAgICAgcmVsYXRpdmUgPSAhIXJlbGF0aXZlIHx8ICEhby5yZWxhdGl2ZTsgLy8gYWN0IG9uIG1hdHJpeFxuXG4gICAgICBpZiAoby5hICE9IG51bGwpIHtcbiAgICAgICAgbWF0cml4ID0gcmVsYXRpdmUgLy8gcmVsYXRpdmVcbiAgICAgICAgPyBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgobykpIC8vIGFic29sdXRlXG4gICAgICAgIDogbmV3IFNWRy5NYXRyaXgobyk7IC8vIGFjdCBvbiByb3RhdGlvblxuICAgICAgfSBlbHNlIGlmIChvLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KTsgLy8gYXBwbHkgdHJhbnNmb3JtYXRpb25cblxuICAgICAgICBtYXRyaXggPSByZWxhdGl2ZSAvLyByZWxhdGl2ZVxuICAgICAgICA/IG1hdHJpeC5yb3RhdGUoby5yb3RhdGlvbiwgby5jeCwgby5jeSkgLy8gYWJzb2x1dGVcbiAgICAgICAgOiBtYXRyaXgucm90YXRlKG8ucm90YXRpb24gLSBtYXRyaXguZXh0cmFjdCgpLnJvdGF0aW9uLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIHNjYWxlXG4gICAgICB9IGVsc2UgaWYgKG8uc2NhbGUgIT0gbnVsbCB8fCBvLnNjYWxlWCAhPSBudWxsIHx8IG8uc2NhbGVZICE9IG51bGwpIHtcbiAgICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KTsgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcblxuICAgICAgICBvLnNjYWxlWCA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWCAhPSBudWxsID8gby5zY2FsZVggOiAxO1xuICAgICAgICBvLnNjYWxlWSA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWSAhPSBudWxsID8gby5zY2FsZVkgOiAxO1xuXG4gICAgICAgIGlmICghcmVsYXRpdmUpIHtcbiAgICAgICAgICAvLyBhYnNvbHV0ZTsgbXVsdGlwbHkgaW52ZXJzZWQgdmFsdWVzXG4gICAgICAgICAgdmFyIGUgPSBtYXRyaXguZXh0cmFjdCgpO1xuICAgICAgICAgIG8uc2NhbGVYID0gby5zY2FsZVggKiAxIC8gZS5zY2FsZVg7XG4gICAgICAgICAgby5zY2FsZVkgPSBvLnNjYWxlWSAqIDEgLyBlLnNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2tld1xuICAgICAgfSBlbHNlIGlmIChvLnNrZXcgIT0gbnVsbCB8fCBvLnNrZXdYICE9IG51bGwgfHwgby5za2V3WSAhPSBudWxsKSB7XG4gICAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcbiAgICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldCk7IC8vIGVuc3VyZSBza2V3IHZhbHVlcyBvbiBib3RoIGF4ZXNcblxuICAgICAgICBvLnNrZXdYID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdYICE9IG51bGwgPyBvLnNrZXdYIDogMDtcbiAgICAgICAgby5za2V3WSA9IG8uc2tldyAhPSBudWxsID8gby5za2V3IDogby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDA7XG5cbiAgICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAgIC8vIGFic29sdXRlOyByZXNldCBza2V3IHZhbHVlc1xuICAgICAgICAgIHZhciBlID0gbWF0cml4LmV4dHJhY3QoKTtcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgoKS5za2V3KGUuc2tld1gsIGUuc2tld1ksIG8uY3gsIG8uY3kpLmludmVyc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBtYXRyaXguc2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIGZsaXBcbiAgICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XG4gICAgICAgIGlmIChvLmZsaXAgPT0gJ3gnIHx8IG8uZmxpcCA9PSAneScpIHtcbiAgICAgICAgICBvLm9mZnNldCA9IG8ub2Zmc2V0ID09IG51bGwgPyB0YXJnZXQuYmJveCgpWydjJyArIG8uZmxpcF0gOiBvLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoby5vZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KCk7XG4gICAgICAgICAgICBvLmZsaXAgPSBiYm94LmN4O1xuICAgICAgICAgICAgby5vZmZzZXQgPSBiYm94LmN5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLmZsaXAoby5mbGlwLCBvLm9mZnNldCk7IC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICAgIH0gZWxzZSBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgLy8gcmVsYXRpdmVcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKG8ueCwgby55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhYnNvbHV0ZVxuICAgICAgICAgIGlmIChvLnggIT0gbnVsbCkgbWF0cml4LmUgPSBvLng7XG4gICAgICAgICAgaWYgKG8ueSAhPSBudWxsKSBtYXRyaXguZiA9IG8ueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkZYLCB7XG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obywgcmVsYXRpdmUpIHtcbiAgICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLFxuICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICBiYm94OyAvLyBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgaWYgKF90eXBlb2YobykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeDtcbiAgICAgIH0gLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcblxuXG4gICAgICByZWxhdGl2ZSA9ICEhcmVsYXRpdmUgfHwgISFvLnJlbGF0aXZlOyAvLyBhY3Qgb24gbWF0cml4XG5cbiAgICAgIGlmIChvLmEgIT0gbnVsbCkge1xuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChvKTsgLy8gYWN0IG9uIHJvdGF0aW9uXG4gICAgICB9IGVsc2UgaWYgKG8ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxuXG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuUm90YXRlKG8ucm90YXRpb24sIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2NhbGVcbiAgICAgIH0gZWxzZSBpZiAoby5zY2FsZSAhPSBudWxsIHx8IG8uc2NhbGVYICE9IG51bGwgfHwgby5zY2FsZVkgIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBlbnN1cmUgc2NhbGUgdmFsdWVzIG9uIGJvdGggYXhlc1xuXG4gICAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDE7XG4gICAgICAgIG8uc2NhbGVZID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVZICE9IG51bGwgPyBvLnNjYWxlWSA6IDE7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuU2NhbGUoby5zY2FsZVgsIG8uc2NhbGVZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIHNrZXdcbiAgICAgIH0gZWxzZSBpZiAoby5za2V3WCAhPSBudWxsIHx8IG8uc2tld1kgIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBlbnN1cmUgc2tldyB2YWx1ZXMgb24gYm90aCBheGVzXG5cbiAgICAgICAgby5za2V3WCA9IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwO1xuICAgICAgICBvLnNrZXdZID0gby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDA7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuU2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIGZsaXBcbiAgICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XG4gICAgICAgIGlmIChvLmZsaXAgPT0gJ3gnIHx8IG8uZmxpcCA9PSAneScpIHtcbiAgICAgICAgICBvLm9mZnNldCA9IG8ub2Zmc2V0ID09IG51bGwgPyB0YXJnZXQuYmJveCgpWydjJyArIG8uZmxpcF0gOiBvLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoby5vZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KCk7XG4gICAgICAgICAgICBvLmZsaXAgPSBiYm94LmN4O1xuICAgICAgICAgICAgby5vZmZzZXQgPSBiYm94LmN5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLmZsaXAoby5mbGlwLCBvLm9mZnNldCk7IC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICAgIH0gZWxzZSBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5UcmFuc2xhdGUoby54LCBvLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1hdHJpeCkgcmV0dXJuIHRoaXM7XG4gICAgICBtYXRyaXgucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgIHRoaXMubGFzdCgpLnRyYW5zZm9ybXMucHVzaChtYXRyaXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXG4gICAgdW50cmFuc2Zvcm06IGZ1bmN0aW9uIHVudHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbCk7XG4gICAgfSxcbiAgICAvLyBtZXJnZSB0aGUgd2hvbGUgdHJhbnNmb3JtYXRpb24gY2hhaW4gaW50byBvbmUgbWF0cml4IGFuZCByZXR1cm5zIGl0XG4gICAgbWF0cml4aWZ5OiBmdW5jdGlvbiBtYXRyaXhpZnkoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpLiAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHNwbGl0KFNWRy5yZWdleC50cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gZ2VuZXJhdGUga2V5ID0+IHZhbHVlIHBhaXJzXG4gICAgICAgIHZhciBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKTtcbiAgICAgICAgcmV0dXJuIFtrdlswXSwga3ZbMV0uc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICB9KV07XG4gICAgICB9KSAvLyBtZXJnZSBldmVyeSB0cmFuc2Zvcm1hdGlvbiBpbnRvIG9uZSBtYXRyaXhcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hdHJpeCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPT0gJ21hdHJpeCcpIHJldHVybiBtYXRyaXgubXVsdGlwbHkoYXJyYXlUb01hdHJpeCh0cmFuc2Zvcm1bMV0pKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKTtcbiAgICAgIH0sIG5ldyBTVkcuTWF0cml4KCkpO1xuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuICAgIC8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXG4gICAgdG9QYXJlbnQ6IGZ1bmN0aW9uIHRvUGFyZW50KHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMgPT0gcGFyZW50KSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjdG0gPSB0aGlzLnNjcmVlbkNUTSgpO1xuICAgICAgdmFyIHBDdG0gPSBwYXJlbnQuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xuICAgICAgdGhpcy5hZGRUbyhwYXJlbnQpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXG4gICAgdG9Eb2M6IGZ1bmN0aW9uIHRvRG9jKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQodGhpcy5kb2MoKSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRyYW5zZm9ybWF0aW9uID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBpbnZlcnNlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHNvdXJjZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW3RoaXMuYXJndW1lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmludmVyc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChpbnZlcnNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmludmVyc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgIG1ldGhvZDogJycsXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHRoaXMuX3VuZG8gfHwgbmV3IFNWRy5NYXRyaXgoKTtcbiAgICAgICAgbSA9IG5ldyBTVkcuTWF0cml4KCkubW9ycGgoU1ZHLk1hdHJpeC5wcm90b3R5cGVbdGhpcy5tZXRob2RdLmFwcGx5KG0sIHBhcmFtcykpLmF0KHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2VkID8gbS5pbnZlcnNlKCkgOiBtO1xuICAgICAgfSxcbiAgICAgIHVuZG86IGZ1bmN0aW9uIHVuZG8obykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBvW3RoaXMuYXJndW1lbnRzW2ldXSA9IHR5cGVvZiB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogb1t0aGlzLmFyZ3VtZW50c1tpXV07XG4gICAgICAgIH0gLy8gVGhlIG1ldGhvZCBTVkcuTWF0cml4LmV4dHJhY3Qgd2hpY2ggd2FzIHVzZWQgYmVmb3JlIGNhbGxpbmcgdGhpc1xuICAgICAgICAvLyBtZXRob2QgdG8gb2J0YWluIGEgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIgbyBkb2Vzbid0IHJldHVybiBhIGN4IGFuZFxuICAgICAgICAvLyBhIGN5IHNvIHdlIHVzZSB0aGUgb25lcyB0aGF0IHdlcmUgcHJvdmlkZWQgdG8gdGhpcyBvYmplY3QgYXQgaXRzIGNyZWF0aW9uXG5cblxuICAgICAgICBvLmN4ID0gdGhpcy5jeDtcbiAgICAgICAgby5jeSA9IHRoaXMuY3k7XG4gICAgICAgIHRoaXMuX3VuZG8gPSBuZXcgU1ZHW2NhcGl0YWxpemUodGhpcy5tZXRob2QpXShvLCB0cnVlKS5hdCgxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRyYW5zbGF0ZSA9IFNWRy5pbnZlbnQoe1xuICAgIHBhcmVudDogU1ZHLk1hdHJpeCxcbiAgICBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb24sXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhcmd1bWVudHM6IFsndHJhbnNmb3JtZWRYJywgJ3RyYW5zZm9ybWVkWSddLFxuICAgICAgbWV0aG9kOiAndHJhbnNsYXRlJ1xuICAgIH1cbiAgfSk7XG4gIFNWRy5Sb3RhdGUgPSBTVkcuaW52ZW50KHtcbiAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgaW52ZXJzZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbJ3JvdGF0aW9uJywgJ2N4JywgJ2N5J10sXG4gICAgICBtZXRob2Q6ICdyb3RhdGUnLFxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICB2YXIgbSA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKG5ldyBTVkcuTnVtYmVyKCkubW9ycGgodGhpcy5yb3RhdGlvbiAtICh0aGlzLl91bmRvID8gdGhpcy5fdW5kby5yb3RhdGlvbiA6IDApKS5hdChwb3MpLCB0aGlzLmN4LCB0aGlzLmN5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJzZWQgPyBtLmludmVyc2UoKSA6IG07XG4gICAgICB9LFxuICAgICAgdW5kbzogZnVuY3Rpb24gdW5kbyhvKSB7XG4gICAgICAgIHRoaXMuX3VuZG8gPSBvO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuU2NhbGUgPSBTVkcuaW52ZW50KHtcbiAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgaW52ZXJzZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnY3gnLCAnY3knXSxcbiAgICAgIG1ldGhvZDogJ3NjYWxlJ1xuICAgIH1cbiAgfSk7XG4gIFNWRy5Ta2V3ID0gU1ZHLmludmVudCh7XG4gICAgcGFyZW50OiBTVkcuTWF0cml4LFxuICAgIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvbixcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGludmVyc2VkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGFyZ3VtZW50czogWydza2V3WCcsICdza2V3WScsICdjeCcsICdjeSddLFxuICAgICAgbWV0aG9kOiAnc2tldydcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gRHluYW1pYyBzdHlsZSBnZW5lcmF0b3JcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUocywgdikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAvLyBnZXQgZnVsbCBzdHlsZVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vIGFwcGx5IGV2ZXJ5IHN0eWxlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodiBpbiBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKHYsIHNbdl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNDc3MudGVzdChzKSkge1xuICAgICAgICAgIC8vIHBhcnNlIGNzcyBzdHJpbmdcbiAgICAgICAgICBzID0gcy5zcGxpdCgvXFxzKjtcXHMqLykgLy8gZmlsdGVyIG91dCBzdWZmaXggOyBhbmQgc3R1ZmYgbGlrZSA7O1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWU7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgICAgICAgfSk7IC8vIGFwcGx5IGV2ZXJ5IGRlZmluaXRpb24gaW5kaXZpZHVhbGx5XG5cbiAgICAgICAgICB3aGlsZSAodiA9IHMucG9wKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUodlswXSwgdlsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHMpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV0gPSB2ID09PSBudWxsIHx8IFNWRy5yZWdleC5pc0JsYW5rLnRlc3QodikgPyAnJyA6IHY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5QYXJlbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGQgZWxlbWVudHNcbiAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIFNWRy51dGlscy5tYXAoU1ZHLnV0aWxzLmZpbHRlclNWR0VsZW1lbnRzKHRoaXMubm9kZS5jaGlsZE5vZGVzKSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChlbGVtZW50LCBpKSB7XG4gICAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lm5vZGUgIT0gdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQubm9kZSwgdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG4gICAgICBwdXQ6IGZ1bmN0aW9uIHB1dChlbGVtZW50LCBpKSB7XG4gICAgICAgIHRoaXMuYWRkKGVsZW1lbnQsIGkpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0sXG4gICAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwO1xuICAgICAgfSxcbiAgICAgIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaSkge1xuICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZmlyc3QgY2hpbGRcbiAgICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgbGFzdCBjaGlsZFxuICAgICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgfSxcbiAgICAgIC8vIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcmVuIGFuZCBpbnZva2VzIGEgZ2l2ZW4gYmxvY2tcbiAgICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goYmxvY2ssIGRlZXApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpbCxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlZXAgJiYgY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5lYWNoKGJsb2NrLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuICAgICAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcblxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZGVmc1xuICAgICAgZGVmczogZnVuY3Rpb24gZGVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jKCkuZGVmcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xuICAgIHVuZ3JvdXA6IGZ1bmN0aW9uIHVuZ3JvdXAocGFyZW50LCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID09PSAwIHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuRGVmcyB8fCB0aGlzLm5vZGUgPT0gU1ZHLnBhcnNlci5kcmF3KSByZXR1cm4gdGhpcztcbiAgICAgIHBhcmVudCA9IHBhcmVudCB8fCAodGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLlBhcmVudCkpO1xuICAgICAgZGVwdGggPSBkZXB0aCB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU1ZHLkRlZnMpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnQpIHJldHVybiB0aGlzLnVuZ3JvdXAocGFyZW50LCBkZXB0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50b1BhcmVudChwYXJlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZCB8fCB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKHBhcmVudCwgZGVwdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZ3JvdXAocGFyZW50LCBkZXB0aCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkNvbnRhaW5lciA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnRcbiAgfSk7XG4gIFNWRy5WaWV3Qm94ID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlKSB7XG4gICAgICB2YXIgYmFzZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICB2aWV3LFxuICAgICAgICAgIHdlLFxuICAgICAgICAgIGhlLFxuICAgICAgICAgIHdtID0gMSxcbiAgICAgICAgICAvLyB3aWR0aCBtdWx0aXBsaWVyXG4gICAgICBobSA9IDEsXG4gICAgICAgICAgLy8gaGVpZ2h0IG11bHRpcGxpZXJcbiAgICAgIHJlZyA9IC9bKy1dPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8vZ2k7XG5cbiAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCkge1xuICAgICAgICB3ZSA9IHNvdXJjZTtcbiAgICAgICAgaGUgPSBzb3VyY2U7XG4gICAgICAgIHZpZXcgPSAoc291cmNlLmF0dHIoJ3ZpZXdCb3gnKSB8fCAnJykubWF0Y2gocmVnKTtcbiAgICAgICAgYm94ID0gc291cmNlLmJib3g7IC8vIGdldCBkaW1lbnNpb25zIG9mIGN1cnJlbnQgbm9kZVxuXG4gICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIoc291cmNlLndpZHRoKCkpO1xuICAgICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihzb3VyY2UuaGVpZ2h0KCkpOyAvLyBmaW5kIG5lYXJlc3Qgbm9uLXBlcmNlbnR1YWwgZGltZW5zaW9uc1xuXG4gICAgICAgIHdoaWxlICh3aWR0aC51bml0ID09ICclJykge1xuICAgICAgICAgIHdtICo9IHdpZHRoLnZhbHVlO1xuICAgICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIod2UgaW5zdGFuY2VvZiBTVkcuRG9jID8gd2UucGFyZW50KCkub2Zmc2V0V2lkdGggOiB3ZS5wYXJlbnQoKS53aWR0aCgpKTtcbiAgICAgICAgICB3ZSA9IHdlLnBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGhlaWdodC51bml0ID09ICclJykge1xuICAgICAgICAgIGhtICo9IGhlaWdodC52YWx1ZTtcbiAgICAgICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihoZSBpbnN0YW5jZW9mIFNWRy5Eb2MgPyBoZS5wYXJlbnQoKS5vZmZzZXRIZWlnaHQgOiBoZS5wYXJlbnQoKS5oZWlnaHQoKSk7XG4gICAgICAgICAgaGUgPSBoZS5wYXJlbnQoKTtcbiAgICAgICAgfSAvLyBlbnN1cmUgZGVmYXVsdHNcblxuXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHdtO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIGhtO1xuICAgICAgICB0aGlzLnpvb20gPSAxO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSB2aWV3Ym94XG4gICAgICAgICAgeCA9IHBhcnNlRmxvYXQodmlld1swXSk7XG4gICAgICAgICAgeSA9IHBhcnNlRmxvYXQodmlld1sxXSk7XG4gICAgICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHZpZXdbMl0pO1xuICAgICAgICAgIGhlaWdodCA9IHBhcnNlRmxvYXQodmlld1szXSk7IC8vIGNhbGN1bGF0ZSB6b29tIGFjY29yaW5nIHRvIHZpZXdib3hcblxuICAgICAgICAgIHRoaXMuem9vbSA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCA+IHdpZHRoIC8gaGVpZ2h0ID8gdGhpcy5oZWlnaHQgLyBoZWlnaHQgOiB0aGlzLndpZHRoIC8gd2lkdGg7IC8vIGNhbGN1bGF0ZSByZWFsIHBpeGVsIGRpbWVuc2lvbnMgb24gcGFyZW50IFNWRy5Eb2MgZWxlbWVudFxuXG4gICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcbiAgICAgICAgc291cmNlID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubWF0Y2gocmVnKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwpO1xuICAgICAgICB9KSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcgPyBbc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdIDogYXJndW1lbnRzLmxlbmd0aCA9PSA0ID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogYmFzZTtcbiAgICAgICAgdGhpcy54ID0gc291cmNlWzBdO1xuICAgICAgICB0aGlzLnkgPSBzb3VyY2VbMV07XG4gICAgICAgIHRoaXMud2lkdGggPSBzb3VyY2VbMl07XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlWzNdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KFt0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvcywgdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3MsIHRoaXMud2lkdGggKyAodGhpcy5kZXN0aW5hdGlvbi53aWR0aCAtIHRoaXMud2lkdGgpICogcG9zLCB0aGlzLmhlaWdodCArICh0aGlzLmRlc3RpbmF0aW9uLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSAqIHBvc10pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVmaW5lIHBhcmVudFxuICAgIHBhcmVudDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gZ2V0L3NldCB2aWV3Ym94XG4gICAgICB2aWV3Ym94OiBmdW5jdGlvbiB2aWV3Ym94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHNcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KHRoaXMpO1xuICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIHNldHRlclxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSAvLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG4gIDtcbiAgWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgLy8gLCAnbW91c2VlbnRlcicgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxuICAvLyAsICdtb3VzZWxlYXZlJyAtPiBub3Qgc3VwcG9ydGVkIGJ5IElFXG4gICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGxlYXZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnRcbiAgICBTVkcuRWxlbWVudC5wcm90b3R5cGVbZXZlbnRdID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgIC8vIGJpbmQgZXZlbnQgdG8gZWxlbWVudCByYXRoZXIgdGhhbiBlbGVtZW50IG5vZGVcbiAgICAgIFNWRy5vbih0aGlzLm5vZGUsIGV2ZW50LCBmKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pOyAvLyBJbml0aWFsaXplIGxpc3RlbmVycyBzdGFja1xuXG4gIFNWRy5saXN0ZW5lcnMgPSBbXTtcbiAgU1ZHLmhhbmRsZXJNYXAgPSBbXTtcbiAgU1ZHLmxpc3RlbmVySWQgPSAwOyAvLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5cbiAgU1ZHLm9uID0gZnVuY3Rpb24gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICAgIC8vIGNyZWF0ZSBsaXN0ZW5lciwgZ2V0IG9iamVjdC1pbmRleFxuICAgIHZhciBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUuaW5zdGFuY2UgfHwgbm9kZSksXG4gICAgICAgIGluZGV4ID0gKFNWRy5oYW5kbGVyTWFwLmluZGV4T2Yobm9kZSkgKyAxIHx8IFNWRy5oYW5kbGVyTWFwLnB1c2gobm9kZSkpIC0gMSxcbiAgICAgICAgZXYgPSBldmVudC5zcGxpdCgnLicpWzBdLFxuICAgICAgICBucyA9IGV2ZW50LnNwbGl0KCcuJylbMV0gfHwgJyonOyAvLyBlbnN1cmUgdmFsaWQgb2JqZWN0XG5cbiAgICBTVkcubGlzdGVuZXJzW2luZGV4XSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdIHx8IHt9O1xuICAgIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSB8fCB7fTtcbiAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSB8fCB7fTtcblxuICAgIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xuICAgICAgbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCA9ICsrU1ZHLmxpc3RlbmVySWQ7XG4gICAgfSAvLyByZWZlcmVuY2UgbGlzdGVuZXJcblxuXG4gICAgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGw7IC8vIGFkZCBsaXN0ZW5lclxuXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKTtcbiAgfTsgLy8gQWRkIGV2ZW50IHVuYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5cblxuICBTVkcub2ZmID0gZnVuY3Rpb24gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHZhciBpbmRleCA9IFNWRy5oYW5kbGVyTWFwLmluZGV4T2Yobm9kZSksXG4gICAgICAgIGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXSxcbiAgICAgICAgbnMgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzFdLFxuICAgICAgICBuYW1lc3BhY2UgPSAnJztcbiAgICBpZiAoaW5kZXggPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkO1xuICAgICAgaWYgKCFsaXN0ZW5lcikgcmV0dXJuOyAvLyByZW1vdmUgbGlzdGVuZXIgcmVmZXJlbmNlXG5cbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ10pIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLCBmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChucyAmJiBldikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxuICAgICAgaWYgKFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAmJiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdKSB7XG4gICAgICAgIGZvciAobGlzdGVuZXIgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSkge1xuICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2LCBuc10uam9pbignLicpLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5zKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBuYW1lc3BhY2VcbiAgICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZlbnRdKSB7XG4gICAgICAgICAgaWYgKG5zID09PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2ZW50LCBuc10uam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKSB7XG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSkge1xuICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2LCBuYW1lc3BhY2VdLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcbiAgICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pIHtcbiAgICAgICAgU1ZHLm9mZihub2RlLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XTtcbiAgICAgIGRlbGV0ZSBTVkcuaGFuZGxlck1hcFtpbmRleF07XG4gICAgfVxuICB9OyAvL1xuXG5cbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIEJpbmQgZ2l2ZW4gZXZlbnQgdG8gbGlzdGVuZXJcbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgICBTVkcub24odGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgU1ZHLm9mZih0aGlzLm5vZGUsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcbiAgICBmaXJlOiBmdW5jdGlvbiBmaXJlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBEaXNwYXRjaCBldmVudFxuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50KSB7XG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50ID0gbmV3IFNWRy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXZlbnQ6IGZ1bmN0aW9uIGV2ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgfSk7XG4gIFNWRy5EZWZzID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnZGVmcycsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuICB9KTtcbiAgU1ZHLkcgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdnJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94Mykge1xuICAgICAgICByZXR1cm4gX3gzID09IG51bGwgPyB0aGlzLnRyYW5zZm9ybSgneCcpIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICAgIHg6IF94MyAtIHRoaXMueCgpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgICAgIHk6IGZ1bmN0aW9uIHkoX3kzKSB7XG4gICAgICAgIHJldHVybiBfeTMgPT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtKCd5JykgOiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgICAgeTogX3kzIC0gdGhpcy55KClcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgIGN4OiBmdW5jdGlvbiBjeCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmdib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5nYm94KCkud2lkdGggLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuZ2JveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmdib3goKS5oZWlnaHQgLyAyKTtcbiAgICAgIH0sXG4gICAgICBnYm94OiBmdW5jdGlvbiBnYm94KCkge1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuYmJveCgpLFxuICAgICAgICAgICAgdHJhbnMgPSB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICBiYm94LnggKz0gdHJhbnMueDtcbiAgICAgICAgYmJveC54MiArPSB0cmFucy54O1xuICAgICAgICBiYm94LmN4ICs9IHRyYW5zLng7XG4gICAgICAgIGJib3gueSArPSB0cmFucy55O1xuICAgICAgICBiYm94LnkyICs9IHRyYW5zLnk7XG4gICAgICAgIGJib3guY3kgKz0gdHJhbnMueTtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudFxuICAgICAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Eb2MgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAvLyBlbnN1cmUgdGhlIHByZXNlbmNlIG9mIGEgZG9tIGVsZW1lbnRcbiAgICAgICAgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpIDogZWxlbWVudDsgLy8gSWYgdGhlIHRhcmdldCBpcyBhbiBzdmcgZWxlbWVudCwgdXNlIHRoYXQgZWxlbWVudCBhcyB0aGUgbWFpbiB3cmFwcGVyLlxuICAgICAgICAvLyBUaGlzIGFsbG93cyBzdmcuanMgdG8gd29yayB3aXRoIHN2ZyBkb2N1bWVudHMgYXMgd2VsbC5cblxuICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnc3ZnJykpO1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgICB0aGlzLnNpemUoJzEwMCUnLCAnMTAwJScpO1xuICAgICAgICB9IC8vIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBlbnN1cmUgZGVmcyBub2RlXG5cblxuICAgICAgICB0aGlzLm5hbWVzcGFjZSgpLmRlZnMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBuYW1lc3BhY2VzXG4gICAgICBuYW1lc3BhY2U6IGZ1bmN0aW9uIG5hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih7XG4gICAgICAgICAgeG1sbnM6IFNWRy5ucyxcbiAgICAgICAgICB2ZXJzaW9uOiAnMS4xJ1xuICAgICAgICB9KS5hdHRyKCd4bWxuczp4bGluaycsIFNWRy54bGluaywgU1ZHLnhtbG5zKS5hdHRyKCd4bWxuczpzdmdqcycsIFNWRy5zdmdqcywgU1ZHLnhtbG5zKTtcbiAgICAgIH0sXG4gICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuICAgICAgZGVmczogZnVuY3Rpb24gZGVmcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZzKSB7XG4gICAgICAgICAgdmFyIGRlZnM7IC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcblxuICAgICAgICAgIGlmIChkZWZzID0gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJylbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZnMgPSBTVkcuYWRvcHQoZGVmcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZnMgPSBuZXcgU1ZHLkRlZnMoKTtcbiAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgZGVmcyBub2RlIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHN0YWNrXG5cblxuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kZWZzLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZnM7XG4gICAgICB9LFxuICAgICAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcbiAgICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wYXJlbnROb2RlIHx8IHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSxcbiAgICAgIC8vIEZpeCBmb3IgcG9zc2libGUgc3ViLXBpeGVsIG9mZnNldC4gU2VlOlxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjA4ODEyXG4gICAgICBzcG9mOiBmdW5jdGlvbiBzcG9mKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpO1xuXG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKCdsZWZ0JywgLXBvcy5lICUgMSArICdweCcpLnN0eWxlKCd0b3AnLCAtcG9zLmYgJSAxICsgJ3B4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmVzIHRoZSBkb2MgZnJvbSB0aGUgRE9NXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcblxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzOyAvLyBhZGQgYmFjayBwYXJzZXJcblxuICAgICAgICBpZiAoU1ZHLnBhcnNlci5kcmF3ICYmICFTVkcucGFyc2VyLmRyYXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChTVkcucGFyc2VyLmRyYXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKHBhcmVudCkge1xuICAgICAgICAvLyB3cml0ZSBkb20gZGF0YSB0byB0aGUgZG9tIHNvIHRoZSBjbG9uZSBjYW4gcGlja3VwIHRoZSBkYXRhXG4gICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTsgLy8gZ2V0IHJlZmVyZW5jZSB0byBub2RlXG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7IC8vIGNsb25lIGVsZW1lbnQgYW5kIGFzc2lnbiBuZXcgaWRcblxuICAgICAgICB2YXIgY2xvbmUgPSBhc3NpZ25OZXdJZChub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIGluc2VydCB0aGUgY2xvbmUgaW4gdGhlIGdpdmVuIHBhcmVudCBvciBhZnRlciBteXNlbGZcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgKHBhcmVudC5ub2RlIHx8IHBhcmVudCkuYXBwZW5kQ2hpbGQoY2xvbmUubm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZS5ub2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyAjIyMgVGhpcyBtb2R1bGUgYWRkcyBiYWNrd2FyZCAvIGZvcndhcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50cy5cbiAgLy9cblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCk7XG4gICAgfSxcbiAgICAvLyBHZXQgdGhlIGN1cmVudCBwb3NpdGlvbiBzaWJsaW5nc1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmluZGV4KHRoaXMpO1xuICAgIH0sXG4gICAgLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXTtcbiAgICB9LFxuICAgIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXTtcbiAgICB9LFxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBmb3J3YXJkXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpICsgMSxcbiAgICAgICAgICBwID0gdGhpcy5wYXJlbnQoKTsgLy8gbW92ZSBub2RlIG9uZSBzdGVwIGZvcndhcmRcblxuICAgICAgcC5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpKTsgLy8gbWFrZSBzdXJlIGRlZnMgbm9kZSBpcyBhbHdheXMgYXQgdGhlIHRvcFxuXG4gICAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpIHtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHAuZGVmcygpLm5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbiBiYWNrd2FyZCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpO1xuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBmcm9udFxuICAgIGZyb250OiBmdW5jdGlvbiBmcm9udCgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGZvcndhcmRcblxuICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7IC8vIE1ha2Ugc3VyZSBkZWZzIG5vZGUgaXMgYWx3YXlzIGF0IHRoZSB0b3BcblxuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBTVkcuRG9jKSB7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGJhY2tcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBJbnNlcnRzIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUgdGhlIHRhcmdldGVkIGVsZW1lbnRcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gSW5zdGVycyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLk1hc2sgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdtYXNrJykpOyAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gbWFza2VkIGVsZW1lbnRzXG5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudGFyZ2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICh0aGlzLnRhcmdldHNbaV0pIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bm1hc2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTsgLy8gcmVtb3ZlIG1hc2sgZnJvbSBwYXJlbnRcblxuICAgICAgICBTVkcuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBtYXNraW5nIGVsZW1lbnRcbiAgICAgIG1hc2s6IGZ1bmN0aW9uIG1hc2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5NYXNrKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcbiAgICBtYXNrV2l0aDogZnVuY3Rpb24gbWFza1dpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgdGhpcy5tYXNrZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLk1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpOyAvLyBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrXG5cbiAgICAgIHRoaXMubWFza2VyLnRhcmdldHMucHVzaCh0aGlzKTsgLy8gYXBwbHkgbWFza1xuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgJ3VybChcIiMnICsgdGhpcy5tYXNrZXIuYXR0cignaWQnKSArICdcIiknKTtcbiAgICB9LFxuICAgIC8vIFVubWFzayBlbGVtZW50XG4gICAgdW5tYXNrOiBmdW5jdGlvbiB1bm1hc2soKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXNrZXI7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkNsaXBQYXRoID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnY2xpcFBhdGgnKSk7IC8vIGtlZXAgcmVmZXJlbmNlcyB0byBjbGlwcGVkIGVsZW1lbnRzXG5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXRzW2ldKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldHNbaV0udW5jbGlwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YXJnZXRzID0gW107IC8vIHJlbW92ZSBjbGlwUGF0aCBmcm9tIHBhcmVudFxuXG4gICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcbiAgICAgIGNsaXA6IGZ1bmN0aW9uIGNsaXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5DbGlwUGF0aCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvL1xuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBEaXN0cmlidXRlIGNsaXBQYXRoIHRvIHN2ZyBlbGVtZW50XG4gICAgY2xpcFdpdGg6IGZ1bmN0aW9uIGNsaXBXaXRoKGVsZW1lbnQpIHtcbiAgICAgIC8vIHVzZSBnaXZlbiBjbGlwIG9yIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgIHRoaXMuY2xpcHBlciA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuQ2xpcFBhdGggPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5jbGlwKCkuYWRkKGVsZW1lbnQpOyAvLyBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrXG5cbiAgICAgIHRoaXMuY2xpcHBlci50YXJnZXRzLnB1c2godGhpcyk7IC8vIGFwcGx5IG1hc2tcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgJ3VybChcIiMnICsgdGhpcy5jbGlwcGVyLmF0dHIoJ2lkJykgKyAnXCIpJyk7XG4gICAgfSxcbiAgICAvLyBVbmNsaXAgZWxlbWVudFxuICAgIHVuY2xpcDogZnVuY3Rpb24gdW5jbGlwKCkge1xuICAgICAgZGVsZXRlIHRoaXMuY2xpcHBlcjtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIG51bGwpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5HcmFkaWVudCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHR5cGUpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKHR5cGUgKyAnR3JhZGllbnQnKSk7IC8vIHN0b3JlIHR5cGVcblxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBhIGNvbG9yIHN0b3BcbiAgICAgIGF0OiBmdW5jdGlvbiBhdChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlN0b3AoKSkudXBkYXRlKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpO1xuICAgICAgfSxcbiAgICAgIC8vIFVwZGF0ZSBncmFkaWVudFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoYmxvY2spIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBzdG9wc1xuICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICAgICAgZmlsbDogZnVuY3Rpb24gZmlsbCgpIHtcbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSc7XG4gICAgICB9LFxuICAgICAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsKCk7XG4gICAgICB9LFxuICAgICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICAgICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhID09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJztcbiAgICAgICAgcmV0dXJuIFNWRy5Db250YWluZXIucHJvdG90eXBlLmF0dHIuY2FsbCh0aGlzLCBhLCBiLCBjKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXG4gICAgICBncmFkaWVudDogZnVuY3Rpb24gZ3JhZGllbnQodHlwZSwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KHR5cGUsIGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBBZGQgYW5pbWF0YWJsZSBtZXRob2RzIHRvIGJvdGggZ3JhZGllbnQgYW5kIGZ4IG1vZHVsZVxuXG4gIFNWRy5leHRlbmQoU1ZHLkdyYWRpZW50LCBTVkcuRlgsIHtcbiAgICAvLyBGcm9tIHBvc2l0aW9uXG4gICAgZnJvbTogZnVuY3Rpb24gZnJvbSh4LCB5KSB7XG4gICAgICByZXR1cm4gKHRoaXMuX3RhcmdldCB8fCB0aGlzKS50eXBlID09ICdyYWRpYWwnID8gdGhpcy5hdHRyKHtcbiAgICAgICAgZng6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICBmeTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pIDogdGhpcy5hdHRyKHtcbiAgICAgICAgeDE6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICB5MTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVG8gcG9zaXRpb25cbiAgICB0bzogZnVuY3Rpb24gdG8oeCwgeSkge1xuICAgICAgcmV0dXJuICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZSA9PSAncmFkaWFsJyA/IHRoaXMuYXR0cih7XG4gICAgICAgIGN4OiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgY3k6IG5ldyBTVkcuTnVtYmVyKHkpXG4gICAgICB9KSA6IHRoaXMuYXR0cih7XG4gICAgICAgIHgyOiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgeTI6IG5ldyBTVkcuTnVtYmVyKHkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBCYXNlIGdyYWRpZW50IGdlbmVyYXRpb25cblxuICBTVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XG4gICAgLy8gZGVmaW5lIGdyYWRpZW50XG4gICAgZ3JhZGllbnQ6IGZ1bmN0aW9uIGdyYWRpZW50KHR5cGUsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HcmFkaWVudCh0eXBlKSkudXBkYXRlKGJsb2NrKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuU3RvcCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3N0b3AnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBhZGQgY29sb3Igc3RvcHNcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIHNldCBhdHRyaWJ1dGVzXG5cblxuICAgICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KTtcbiAgICAgICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcik7XG4gICAgICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkcuTnVtYmVyKG8ub2Zmc2V0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5QYXR0ZXJuID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAncGF0dGVybicsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKCkge1xuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJztcbiAgICAgIH0sXG4gICAgICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShibG9jaykge1xuICAgICAgICAvLyByZW1vdmUgY29udGVudFxuICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEFsaWFzIHN0cmluZyBjb252ZXJ0aW9uIHRvIGZpbGxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbCgpO1xuICAgICAgfSxcbiAgICAgIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cbiAgICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSA9PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJztcbiAgICAgICAgcmV0dXJuIFNWRy5Db250YWluZXIucHJvdG90eXBlLmF0dHIuY2FsbCh0aGlzLCBhLCBiLCBjKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICAgIHBhdHRlcm46IGZ1bmN0aW9uIHBhdHRlcm4od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnBhdHRlcm4od2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAvLyBEZWZpbmUgZ3JhZGllbnRcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbiBwYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXR0ZXJuKCkpLnVwZGF0ZShibG9jaykuYXR0cih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlNoYXBlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnRcbiAgfSk7XG4gIFNWRy5CYXJlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQsIGluaGVyaXQpIHtcbiAgICAgIC8vIGNvbnN0cnVjdCBlbGVtZW50XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShlbGVtZW50KSk7IC8vIGluaGVyaXQgY3VzdG9tIG1ldGhvZHNcblxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIGluaGVyaXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0gPSBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXG4gICAgLy8gQWRkIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEluc2VydCBzb21lIHBsYWluIHRleHRcbiAgICAgIHdvcmRzOiBmdW5jdGlvbiB3b3Jkcyh0ZXh0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBjb250ZW50c1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyBjcmVhdGUgdGV4dCBub2RlXG5cblxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBkZXNjcmliZWQgYnkgU1ZHLmpzXG4gICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudChfZWxlbWVudCwgaW5oZXJpdCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQmFyZShfZWxlbWVudCwgaW5oZXJpdCkpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5TeW1ib2wgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdzeW1ib2wnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBjcmVhdGUgc3ltYm9sXG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3ltYm9sKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Vc2UgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICd1c2UnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcbiAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoX2VsZW1lbnQyLCBmaWxlKSB7XG4gICAgICAgIC8vIFNldCBsaW5lZCBlbGVtZW50XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBfZWxlbWVudDIsIFNWRy54bGluayk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcbiAgICAgIHVzZTogZnVuY3Rpb24gdXNlKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVXNlKCkpLmVsZW1lbnQoZWxlbWVudCwgZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlJlY3QgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdyZWN0JyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHJlY3QgZWxlbWVudFxuICAgICAgcmVjdDogZnVuY3Rpb24gcmVjdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQ2lyY2xlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnY2lyY2xlJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBjaXJjbGUgZWxlbWVudCwgYmFzZWQgb24gZWxsaXBzZVxuICAgICAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5DaXJjbGUoKSkucngobmV3IFNWRy5OdW1iZXIoc2l6ZSkuZGl2aWRlKDIpKS5tb3ZlKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkZYLCB7XG4gICAgLy8gUmFkaXVzIHggdmFsdWVcbiAgICByeDogZnVuY3Rpb24gcngoX3J4KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgX3J4KTtcbiAgICB9LFxuICAgIC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXG4gICAgcnk6IGZ1bmN0aW9uIHJ5KF9yeSkge1xuICAgICAgcmV0dXJuIHRoaXMucngoX3J5KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuRWxsaXBzZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2VsbGlwc2UnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2Uod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5FbGxpcHNlKCkpLnNpemUod2lkdGgsIGhlaWdodCkubW92ZSgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGxpcHNlLCBTVkcuUmVjdCwgU1ZHLkZYLCB7XG4gICAgLy8gUmFkaXVzIHggdmFsdWVcbiAgICByeDogZnVuY3Rpb24gcngoX3J4Mikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncngnLCBfcngyKTtcbiAgICB9LFxuICAgIC8vIFJhZGl1cyB5IHZhbHVlXG4gICAgcnk6IGZ1bmN0aW9uIHJ5KF9yeTIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgX3J5Mik7XG4gICAgfVxuICB9KTsgLy8gQWRkIGNvbW1vbiBtZXRob2RcblxuICBTVkcuZXh0ZW5kKFNWRy5DaXJjbGUsIFNWRy5FbGxpcHNlLCB7XG4gICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgIHg6IGZ1bmN0aW9uIHgoX3g0KSB7XG4gICAgICByZXR1cm4gX3g0ID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KF94NCArIHRoaXMucngoKSk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgeTogZnVuY3Rpb24geShfeTQpIHtcbiAgICAgIHJldHVybiBfeTQgPT0gbnVsbCA/IHRoaXMuY3koKSAtIHRoaXMucnkoKSA6IHRoaXMuY3koX3k0ICsgdGhpcy5yeSgpKTtcbiAgICB9LFxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmF0dHIoJ2N4JykgOiB0aGlzLmF0dHIoJ2N4JywgeCk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgIGN5OiBmdW5jdGlvbiBjeSh5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5hdHRyKCdjeScpIDogdGhpcy5hdHRyKCdjeScsIHkpO1xuICAgIH0sXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoMykge1xuICAgICAgcmV0dXJuIF93aWR0aDMgPT0gbnVsbCA/IHRoaXMucngoKSAqIDIgOiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKF93aWR0aDMpLmRpdmlkZSgyKSk7XG4gICAgfSxcbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0Mykge1xuICAgICAgcmV0dXJuIF9oZWlnaHQzID09IG51bGwgPyB0aGlzLnJ5KCkgKiAyIDogdGhpcy5yeShuZXcgU1ZHLk51bWJlcihfaGVpZ2h0MykuZGl2aWRlKDIpKTtcbiAgICB9LFxuICAgIC8vIEN1c3RvbSBzaXplIGZ1bmN0aW9uXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcy5yeChuZXcgU1ZHLk51bWJlcihwLndpZHRoKS5kaXZpZGUoMikpLnJ5KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMikpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5MaW5lID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnbGluZScsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBHZXQgYXJyYXlcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnRBcnJheShbW3RoaXMuYXR0cigneDEnKSwgdGhpcy5hdHRyKCd5MScpXSwgW3RoaXMuYXR0cigneDInKSwgdGhpcy5hdHRyKCd5MicpXV0pO1xuICAgICAgfSxcbiAgICAgIC8vIE92ZXJ3cml0ZSBuYXRpdmUgcGxvdCgpIG1ldGhvZFxuICAgICAgcGxvdDogZnVuY3Rpb24gcGxvdCh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHkxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHgxID0ge1xuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MSA9IG5ldyBTVkcuUG9pbnRBcnJheSh4MSkudG9MaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHgxKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLm1vdmUoeCwgeSkudG9MaW5lKCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgICAgbGluZTogZnVuY3Rpb24gbGluZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgLy8geDEgaXMgbm90IG5lY2Vzc2FyaWx5IGEgbnVtYmVyLCBpdCBjYW4gYWxzbyBiZSBhbiBhcnJheSwgYSBzdHJpbmcgYW5kIGEgU1ZHLlBvaW50QXJyYXlcbiAgICAgICAgcmV0dXJuIFNWRy5MaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KHRoaXMucHV0KG5ldyBTVkcuTGluZSgpKSwgeDEgIT0gbnVsbCA/IFt4MSwgeTEsIHgyLCB5Ml0gOiBbMCwgMCwgMCwgMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Qb2x5bGluZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3BvbHlsaW5lJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWxpbmUgZWxlbWVudFxuICAgICAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKHApIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgU1ZHLlBvaW50QXJyYXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBvbHlnb24gPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwb2x5Z29uJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uKHApIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcblxuICBTVkcuZXh0ZW5kKFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIHtcbiAgICAvLyBHZXQgYXJyYXlcbiAgICBhcnJheTogZnVuY3Rpb24gYXJyYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkgfHwgKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHRoaXMuYXR0cigncG9pbnRzJykpKTtcbiAgICB9LFxuICAgIC8vIFBsb3QgbmV3IHBhdGhcbiAgICBwbG90OiBmdW5jdGlvbiBwbG90KHApIHtcbiAgICAgIHJldHVybiBwID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHApKTtcbiAgICB9LFxuICAgIC8vIENsZWFyIGFycmF5IGNhY2hlXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2FycmF5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpO1xuICAgIH0sXG4gICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpO1xuICAgIH1cbiAgfSk7IC8vIHVuaWZ5IGFsbCBwb2ludCB0byBwb2ludCBlbGVtZW50c1xuXG4gIFNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIHtcbiAgICAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XG4gICAgbW9ycGhBcnJheTogU1ZHLlBvaW50QXJyYXksXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbiB4KF94NSkge1xuICAgICAgcmV0dXJuIF94NSA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZShfeDUsIHRoaXMuYmJveCgpLnkpO1xuICAgIH0sXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgICB5OiBmdW5jdGlvbiB5KF95NSkge1xuICAgICAgcmV0dXJuIF95NSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCBfeTUpO1xuICAgIH0sXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoNCkge1xuICAgICAgdmFyIGIgPSB0aGlzLmJib3goKTtcbiAgICAgIHJldHVybiBfd2lkdGg0ID09IG51bGwgPyBiLndpZHRoIDogdGhpcy5zaXplKF93aWR0aDQsIGIuaGVpZ2h0KTtcbiAgICB9LFxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQ0KSB7XG4gICAgICB2YXIgYiA9IHRoaXMuYmJveCgpO1xuICAgICAgcmV0dXJuIF9oZWlnaHQ0ID09IG51bGwgPyBiLmhlaWdodCA6IHRoaXMuc2l6ZShiLndpZHRoLCBfaGVpZ2h0NCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBhdGggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwYXRoJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXksXG4gICAgICAvLyBHZXQgYXJyYXlcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSk7XG4gICAgICB9LFxuICAgICAgLy8gUGxvdCBuZXcgcGF0aFxuICAgICAgcGxvdDogZnVuY3Rpb24gcGxvdChkKSB7XG4gICAgICAgIHJldHVybiBkID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cignZCcsIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiB0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KGQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBDbGVhciBhcnJheSBjYWNoZVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24geChfeDYpIHtcbiAgICAgICAgcmV0dXJuIF94NiA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZShfeDYsIHRoaXMuYmJveCgpLnkpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95Nikge1xuICAgICAgICByZXR1cm4gX3k2ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIF95Nik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKF93aWR0aDUpIHtcbiAgICAgICAgcmV0dXJuIF93aWR0aDUgPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKF93aWR0aDUsIHRoaXMuYmJveCgpLmhlaWdodCk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0NSkge1xuICAgICAgICByZXR1cm4gX2hlaWdodDUgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmhlaWdodCA6IHRoaXMuc2l6ZSh0aGlzLmJib3goKS53aWR0aCwgX2hlaWdodDUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgICBwYXRoOiBmdW5jdGlvbiBwYXRoKGQpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdGgoKSkucGxvdChkIHx8IG5ldyBTVkcuUGF0aEFycmF5KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5JbWFnZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2ltYWdlJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIChyZSlsb2FkIGltYWdlXG4gICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgICBpZiAoIXVybCkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTsgLy8gcHJlbG9hZCBpbWFnZVxuXG4gICAgICAgIFNWRy5vbihpbWcsICdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFNWRy5vZmYoaW1nKTtcbiAgICAgICAgICB2YXIgcCA9IHNlbGYucGFyZW50KFNWRy5QYXR0ZXJuKTtcbiAgICAgICAgICBpZiAocCA9PT0gbnVsbCkgcmV0dXJuOyAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxuXG4gICAgICAgICAgaWYgKHNlbGYud2lkdGgoKSA9PSAwICYmIHNlbGYuaGVpZ2h0KCkgPT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICAgICAgfSAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcblxuXG4gICAgICAgICAgaWYgKHAgJiYgcC53aWR0aCgpID09IDAgJiYgcC5oZWlnaHQoKSA9PSAwKSB7XG4gICAgICAgICAgICBwLnNpemUoc2VsZi53aWR0aCgpLCBzZWxmLmhlaWdodCgpKTtcbiAgICAgICAgICB9IC8vIGNhbGxiYWNrXG5cblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fbG9hZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmLl9sb2FkZWQuY2FsbChzZWxmLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodCxcbiAgICAgICAgICAgICAgcmF0aW86IGltZy53aWR0aCAvIGltZy5oZWlnaHQsXG4gICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBTVkcub24oaW1nLCAnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIFNWRy5vZmYoaW1nKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGYuX2Vycm9yLmNhbGwoc2VsZiwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIGltZy5zcmMgPSB0aGlzLnNyYyA9IHVybCwgU1ZHLnhsaW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgbG9hZGVkIGNhbGxiYWNrXG4gICAgICBsb2FkZWQ6IGZ1bmN0aW9uIGxvYWRlZChfbG9hZGVkKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IF9sb2FkZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIGNyZWF0ZSBpbWFnZSBlbGVtZW50LCBsb2FkIGltYWdlIGFuZCBzZXQgaXRzIHNpemVcbiAgICAgIGltYWdlOiBmdW5jdGlvbiBpbWFnZShzb3VyY2UsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuSW1hZ2UoKSkubG9hZChzb3VyY2UpLnNpemUod2lkdGggfHwgMCwgaGVpZ2h0IHx8IHdpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5UZXh0ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgndGV4dCcpKTtcbiAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcigxLjMpOyAvLyBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nXG5cbiAgICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlOyAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuXG4gICAgICB0aGlzLl9idWlsZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgZm9yIGFkZGluZyBtdWx0aXBsZSBsaW5lc1xuICAgICAgLy8gc2V0IGRlZmF1bHQgZm9udFxuXG4gICAgICB0aGlzLmF0dHIoJ2ZvbnQtZmFtaWx5JywgU1ZHLmRlZmF1bHRzLmF0dHJzWydmb250LWZhbWlseSddKTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24geChfeDcpIHtcbiAgICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgICBpZiAoX3g3ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgX3g3KTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95Nykge1xuICAgICAgICB2YXIgb3kgPSB0aGlzLmF0dHIoJ3knKSxcbiAgICAgICAgICAgIG8gPSB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSB0aGlzLmJib3goKS55IDogMDsgLy8gYWN0IGFzIGdldHRlclxuXG4gICAgICAgIGlmIChfeTcgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSBvIDogb3k7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdHlwZW9mIF95Ny52YWx1ZU9mKCkgPT09ICdudW1iZXInID8gX3k3ICsgbyA6IF95Nyk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgIGN4OiBmdW5jdGlvbiBjeCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5iYm94KCkud2lkdGggLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIF90ZXh0ID0gJyc7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgaWYgKGkgIT0gMCAmJiBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPSAzICYmIFNWRy5hZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxuXG5cbiAgICAgICAgICAgIF90ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgICAgfSAvLyByZW1vdmUgZXhpc3RpbmcgY29udGVudFxuXG5cbiAgICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBjYWxsIGJsb2NrXG4gICAgICAgICAgX3RleHQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdG9yZSB0ZXh0IGFuZCBtYWtlIHN1cmUgdGV4dCBpcyBub3QgYmxhbmtcbiAgICAgICAgICBfdGV4dCA9IF90ZXh0LnNwbGl0KCdcXG4nKTsgLy8gYnVpbGQgbmV3IGxpbmVzXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBfdGV4dC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRzcGFuKF90ZXh0W2ldKS5uZXdMaW5lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLnJlYnVpbGQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZm9udCBzaXplXG4gICAgICBzaXplOiBmdW5jdGlvbiBzaXplKF9zaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIF9zaXplKS5yZWJ1aWxkKCk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IC8gZ2V0IGxlYWRpbmdcbiAgICAgIGxlYWRpbmc6IGZ1bmN0aW9uIGxlYWRpbmcodmFsdWUpIHtcbiAgICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRvbS5sZWFkaW5nO1xuICAgICAgICB9IC8vIGFjdCBhcyBzZXR0ZXJcblxuXG4gICAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgYWxsIHRoZSBmaXJzdCBsZXZlbCBsaW5lc1xuICAgICAgbGluZXM6IGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlOyAvLyBmaWx0ZXIgdHNwYW5zIGFuZCBtYXAgdGhlbSB0byBTVkcuanMgaW5zdGFuY2VzXG5cbiAgICAgICAgdmFyIGxpbmVzID0gU1ZHLnV0aWxzLm1hcChTVkcudXRpbHMuZmlsdGVyU1ZHRWxlbWVudHMobm9kZS5jaGlsZE5vZGVzKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChlbCk7XG4gICAgICAgIH0pOyAvLyByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgU1ZHLnNldFxuXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlNldChsaW5lcyk7XG4gICAgICB9LFxuICAgICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgICAgIHJlYnVpbGQ6IGZ1bmN0aW9uIHJlYnVpbGQoX3JlYnVpbGQpIHtcbiAgICAgICAgLy8gc3RvcmUgbmV3IHJlYnVpbGQgZmxhZyBpZiBnaXZlblxuICAgICAgICBpZiAodHlwZW9mIF9yZWJ1aWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aGlzLl9yZWJ1aWxkID0gX3JlYnVpbGQ7XG4gICAgICAgIH0gLy8gZGVmaW5lIHBvc2l0aW9uIG9mIGFsbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHRoaXMuX3JlYnVpbGQpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDAsXG4gICAgICAgICAgICAgIGR5ID0gdGhpcy5kb20ubGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHRoaXMuYXR0cignZm9udC1zaXplJykpO1xuICAgICAgICAgIHRoaXMubGluZXMoKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbS5uZXdMaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoIXNlbGYudGV4dFBhdGgoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxuICAgICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKF9idWlsZCkge1xuICAgICAgICB0aGlzLl9idWlsZCA9ICEhX2J1aWxkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBvdmVyd3JpdGUgbWV0aG9kIGZyb20gcGFyZW50IHRvIHNldCBkYXRhIHByb3Blcmx5XG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKG8pIHtcbiAgICAgICAgdGhpcy5kb20gPSBvO1xuICAgICAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoby5sZWFkaW5nIHx8IDEuMyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQoKSkudGV4dChfdGV4dDIpO1xuICAgICAgfSxcbiAgICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgICAgIHBsYWluOiBmdW5jdGlvbiBwbGFpbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQoKSkucGxhaW4odGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRzcGFuID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndHNwYW4nLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU2V0IHRleHQgY29udGVudFxuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dDMpIHtcbiAgICAgICAgaWYgKF90ZXh0MyA9PSBudWxsKSByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJyk7XG4gICAgICAgIHR5cGVvZiBfdGV4dDMgPT09ICdmdW5jdGlvbicgPyBfdGV4dDMuY2FsbCh0aGlzLCB0aGlzKSA6IHRoaXMucGxhaW4oX3RleHQzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gU2hvcnRjdXQgZHhcbiAgICAgIGR4OiBmdW5jdGlvbiBkeChfZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBfZHgpO1xuICAgICAgfSxcbiAgICAgIC8vIFNob3J0Y3V0IGR5XG4gICAgICBkeTogZnVuY3Rpb24gZHkoX2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2R5JywgX2R5KTtcbiAgICAgIH0sXG4gICAgICAvLyBDcmVhdGUgbmV3IGxpbmVcbiAgICAgIG5ld0xpbmU6IGZ1bmN0aW9uIG5ld0xpbmUoKSB7XG4gICAgICAgIC8vIGZldGNoIHRleHQgcGFyZW50XG4gICAgICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoU1ZHLlRleHQpOyAvLyBtYXJrIG5ldyBsaW5lXG5cbiAgICAgICAgdGhpcy5kb20ubmV3TGluZWQgPSB0cnVlOyAvLyBhcHBseSBuZXcgaHnCoW5cblxuICAgICAgICByZXR1cm4gdGhpcy5keSh0LmRvbS5sZWFkaW5nICogdC5hdHRyKCdmb250LXNpemUnKSkuYXR0cigneCcsIHQueCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5UZXh0LCBTVkcuVHNwYW4sIHtcbiAgICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBub2RlXG4gICAgcGxhaW46IGZ1bmN0aW9uIHBsYWluKHRleHQpIHtcbiAgICAgIC8vIGNsZWFyIGlmIGJ1aWxkIG1vZGUgaXMgZGlzYWJsZWRcbiAgICAgIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSAvLyBjcmVhdGUgdGV4dCBub2RlXG5cblxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQ3JlYXRlIGEgdHNwYW5cbiAgICB0c3BhbjogZnVuY3Rpb24gdHNwYW4odGV4dCkge1xuICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZSxcbiAgICAgICAgICB0c3BhbiA9IG5ldyBTVkcuVHNwYW4oKTsgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxuXG4gICAgICBpZiAodGhpcy5fYnVpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIH0gLy8gYWRkIG5ldyB0c3BhblxuXG5cbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHNwYW4ubm9kZSk7XG4gICAgICByZXR1cm4gdHNwYW4udGV4dCh0ZXh0KTtcbiAgICB9LFxuICAgIC8vIENsZWFyIGFsbCBsaW5lc1xuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHZhciBub2RlID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGU7IC8vIHJlbW92ZSBleGlzdGluZyBjaGlsZCBub2Rlc1xuXG4gICAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcbiAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndGV4dFBhdGgnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXG4gICAgLy8gRGVmaW5lIHBhcmVudCBjbGFzc1xuICAgIHBhcmVudDogU1ZHLlRleHQsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXksXG4gICAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dFBhdGggZWxlbWVudFxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBTVkcuVGV4dFBhdGgoKSxcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy5kb2MoKS5kZWZzKCkucGF0aChkKTsgLy8gbW92ZSBsaW5lcyB0byB0ZXh0cGF0aFxuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgcGF0aC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfSAvLyBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlXG5cblxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocGF0aC5ub2RlKTsgLy8gbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudFxuXG4gICAgICAgIHBhdGguYXR0cignaHJlZicsICcjJyArIHRyYWNrLCBTVkcueGxpbmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5hcnJheSgpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBQbG90IHBhdGggaWYgYW55XG4gICAgICBwbG90OiBmdW5jdGlvbiBwbG90KGQpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpLFxuICAgICAgICAgICAgcGF0aEFycmF5ID0gbnVsbDtcblxuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCA/IHBhdGhBcnJheSA6IHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgICAgIHRyYWNrOiBmdW5jdGlvbiB0cmFjaygpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnRleHRQYXRoKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5yZWZlcmVuY2UoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgdGV4dFBhdGggY2hpbGRcbiAgICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5maXJzdENoaWxkICYmIHRoaXMubm9kZS5maXJzdENoaWxkLm5vZGVOYW1lID09ICd0ZXh0UGF0aCcpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5OZXN0ZWQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSk7XG4gICAgICB0aGlzLnN0eWxlKCdvdmVyZmxvdycsICd2aXNpYmxlJyk7XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgbmVzdGVkIHN2ZyBkb2N1bWVudFxuICAgICAgbmVzdGVkOiBmdW5jdGlvbiBuZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk5lc3RlZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2EnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIExpbmsgdXJsXG4gICAgICB0bzogZnVuY3Rpb24gdG8odXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIFNWRy54bGluayk7XG4gICAgICB9LFxuICAgICAgLy8gTGluayBzaG93IGF0dHJpYnV0ZVxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignc2hvdycsIHRhcmdldCwgU1ZHLnhsaW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBMaW5rIHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KF90YXJnZXQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIF90YXJnZXQyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgICAgbGluazogZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQSgpKS50byh1cmwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgIGxpbmtUbzogZnVuY3Rpb24gbGlua1RvKHVybCkge1xuICAgICAgdmFyIGxpbmsgPSBuZXcgU1ZHLkEoKTtcblxuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdXJsLmNhbGwobGluaywgbGluayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLnRvKHVybCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLnB1dChsaW5rKS5wdXQodGhpcyk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLk1hcmtlciA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ21hcmtlcicsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGg2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgX3dpZHRoNik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0Nikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJIZWlnaHQnLCBfaGVpZ2h0Nik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IG1hcmtlciByZWZYIGFuZCByZWZZXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3JlZlgnLCB4KS5hdHRyKCdyZWZZJywgeSk7XG4gICAgICB9LFxuICAgICAgLy8gVXBkYXRlIG1hcmtlclxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoYmxvY2spIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBjb250ZW50XG4gICAgICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIG1hcmtlcjogZnVuY3Rpb24gbWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZXIgZWxlbWVudCBpbiBkZWZzXG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAvLyBDcmVhdGUgbWFya2VyXG4gICAgbWFya2VyOiBmdW5jdGlvbiBtYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHZpZXdib3ggdG8gbWF0Y2ggdGhlIHdpZHRoIGFuZCBoZWlnaHQsIHNldCByZWYgdG8gY3ggYW5kIGN5IGFuZCBzZXQgb3JpZW50IHRvIGF1dG9cbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk1hcmtlcigpKS5zaXplKHdpZHRoLCBoZWlnaHQpLnJlZih3aWR0aCAvIDIsIGhlaWdodCAvIDIpLnZpZXdib3goMCwgMCwgd2lkdGgsIGhlaWdodCkuYXR0cignb3JpZW50JywgJ2F1dG8nKS51cGRhdGUoYmxvY2spO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIFNWRy5QYXRoLCB7XG4gICAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xuICAgIG1hcmtlcjogZnVuY3Rpb24gbWFya2VyKF9tYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICB2YXIgYXR0ciA9IFsnbWFya2VyJ107IC8vIEJ1aWxkIGF0dHJpYnV0ZSBuYW1lXG5cbiAgICAgIGlmIChfbWFya2VyICE9ICdhbGwnKSBhdHRyLnB1c2goX21hcmtlcik7XG4gICAgICBhdHRyID0gYXR0ci5qb2luKCctJyk7IC8vIFNldCBtYXJrZXIgYXR0cmlidXRlXG5cbiAgICAgIF9tYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBTVkcuTWFya2VyID8gYXJndW1lbnRzWzFdIDogdGhpcy5kb2MoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBfbWFya2VyKTtcbiAgICB9XG4gIH0pOyAvLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXG5cbiAgdmFyIHN1Z2FyID0ge1xuICAgIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddLFxuICAgIGZpbGw6IFsnY29sb3InLCAnb3BhY2l0eScsICdydWxlJ10sXG4gICAgcHJlZml4OiBmdW5jdGlvbiBwcmVmaXgodCwgYSkge1xuICAgICAgcmV0dXJuIGEgPT0gJ2NvbG9yJyA/IHQgOiB0ICsgJy0nICsgYTtcbiAgICB9IC8vIEFkZCBzdWdhciBmb3IgZmlsbCBhbmQgc3Ryb2tlXG5cbiAgfTtcbiAgWydmaWxsJywgJ3N0cm9rZSddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICB2YXIgaSxcbiAgICAgICAgZXh0ZW5zaW9uID0ge307XG5cbiAgICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBTVkcuQ29sb3IuaXNSZ2IobykgfHwgbyAmJiB0eXBlb2Ygby5maWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYXR0cihtLCBvKTtcbiAgICAgIH0gZWxzZSAvLyBzZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSBzdWdhci5maWxsIGFuZCBzdWdhci5zdHJva2UgbGlzdFxuICAgICAgICB7XG4gICAgICAgICAgZm9yIChpID0gc3VnYXJbbV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChvW3N1Z2FyW21dW2ldXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIGV4dGVuc2lvbik7XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIHtcbiAgICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXG4gICAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUoZCwgY3gsIGN5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICByb3RhdGlvbjogZCxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4gICAgc2tldzogZnVuY3Rpb24gc2tldyh4LCB5LCBjeCwgY3kpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICBza2V3OiB4LFxuICAgICAgICBjeDogeSxcbiAgICAgICAgY3k6IGN4XG4gICAgICB9KSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2tld1g6IHgsXG4gICAgICAgIHNrZXdZOiB5LFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgc2NhbGUgdG8gdHJhbnNmb3JtXG4gICAgc2NhbGU6IGZ1bmN0aW9uIHNjYWxlKHgsIHksIGN4LCBjeSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09IDMgPyB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIHNjYWxlOiB4LFxuICAgICAgICBjeDogeSxcbiAgICAgICAgY3k6IGN4XG4gICAgICB9KSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2NhbGVYOiB4LFxuICAgICAgICBzY2FsZVk6IHksXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE1hcCB0cmFuc2xhdGUgdG8gdHJhbnNmb3JtXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgZmxpcCB0byB0cmFuc2Zvcm1cbiAgICBmbGlwOiBmdW5jdGlvbiBmbGlwKGEsIG8pIHtcbiAgICAgIG8gPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogbztcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIGZsaXA6IGEgfHwgJ2JvdGgnLFxuICAgICAgICBvZmZzZXQ6IG9cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gTWFwIG1hdHJpeCB0byB0cmFuc2Zvcm1cbiAgICBtYXRyaXg6IGZ1bmN0aW9uIG1hdHJpeChtKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgU1ZHLk1hdHJpeChhcmd1bWVudHMubGVuZ3RoID09IDYgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBtKSk7XG4gICAgfSxcbiAgICAvLyBPcGFjaXR5XG4gICAgb3BhY2l0eTogZnVuY3Rpb24gb3BhY2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignb3BhY2l0eScsIHZhbHVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiAgICBkeDogZnVuY3Rpb24gZHgoeCkge1xuICAgICAgcmV0dXJuIHRoaXMueChuZXcgU1ZHLk51bWJlcih4KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy54KCkpLCB0cnVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB5IGF4aXNcbiAgICBkeTogZnVuY3Rpb24gZHkoeSkge1xuICAgICAgcmV0dXJuIHRoaXMueShuZXcgU1ZHLk51bWJlcih5KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy55KCkpLCB0cnVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcbiAgICBkbW92ZTogZnVuY3Rpb24gZG1vdmUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuUmVjdCwgU1ZHLkVsbGlwc2UsIFNWRy5DaXJjbGUsIFNWRy5HcmFkaWVudCwgU1ZHLkZYLCB7XG4gICAgLy8gQWRkIHggYW5kIHkgcmFkaXVzXG4gICAgcmFkaXVzOiBmdW5jdGlvbiByYWRpdXMoeCwgeSkge1xuICAgICAgdmFyIHR5cGUgPSAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGU7XG4gICAgICByZXR1cm4gdHlwZSA9PSAncmFkaWFsJyB8fCB0eXBlID09ICdjaXJjbGUnID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWRy5OdW1iZXIoeCkpIDogdGhpcy5yeCh4KS5yeSh5ID09IG51bGwgPyB4IDogeSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aCwge1xuICAgIC8vIEdldCBwYXRoIGxlbmd0aFxuICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIH0sXG4gICAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uIHBvaW50QXQobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIFNWRy5UZXh0LCBTVkcuVHNwYW4sIFNWRy5GWCwge1xuICAgIC8vIFNldCBmb250XG4gICAgZm9udDogZnVuY3Rpb24gZm9udChhLCB2KSB7XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2IGluIGEpIHtcbiAgICAgICAgICB0aGlzLmZvbnQodiwgYVt2XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPT0gJ2xlYWRpbmcnID8gdGhpcy5sZWFkaW5nKHYpIDogYSA9PSAnYW5jaG9yJyA/IHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2KSA6IGEgPT0gJ3NpemUnIHx8IGEgPT0gJ2ZhbWlseScgfHwgYSA9PSAnd2VpZ2h0JyB8fCBhID09ICdzdHJldGNoJyB8fCBhID09ICd2YXJpYW50JyB8fCBhID09ICdzdHlsZScgPyB0aGlzLmF0dHIoJ2ZvbnQtJyArIGEsIHYpIDogdGhpcy5hdHRyKGEsIHYpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5TZXQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobWVtYmVycykge1xuICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGVcbiAgICAgIEFycmF5LmlzQXJyYXkobWVtYmVycykgPyB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIDogdGhpcy5jbGVhcigpO1xuICAgIH0sXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBlbGVtZW50IHRvIHNldFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWwsXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1lbWJlcnMucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHNldFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgoZWxlbWVudCk7IC8vIHJlbW92ZSBnaXZlbiBjaGlsZFxuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLm1lbWJlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBtZW1iZXJzXG4gICAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGJsb2NrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgYmxvY2suYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBbaSwgdGhpcy5tZW1iZXJzXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZXN0b3JlIHRvIGRlZmF1bHRzXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgc3RvcmVcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIGEgc2V0XG4gICAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBwcmVzZW50IGluIHNldFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwO1xuICAgICAgfSxcbiAgICAgIC8vIHJldHVucyBpbmRleCBvZiBnaXZlbiBlbGVtZW50IGluIHNldFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtZW1iZXIgYXQgZ2l2ZW4gaW5kZXhcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1tpXTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZmlyc3QgbWVtYmVyXG4gICAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbGFzdCBtZW1iZXJcbiAgICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxuICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhbGwgbWVtYmVycyBpbmNsdWRlZCBvciBlbXB0eSBib3ggaWYgc2V0IGhhcyBubyBpdGVtc1xuICAgICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgICAgLy8gcmV0dXJuIGFuIGVtcHR5IGJveCBvZiB0aGVyZSBhcmUgbm8gbWVtYmVyc1xuICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuUkJveCgpO1xuICAgICAgICB9IC8vIGdldCB0aGUgZmlyc3QgcmJveCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgYmJveFxuXG5cbiAgICAgICAgdmFyIHJib3ggPSB0aGlzLm1lbWJlcnNbMF0ucmJveCh0aGlzLm1lbWJlcnNbMF0uZG9jKCkpO1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHVzZXIgcmJveCBmb3IgY29ycmVjdCBwb3NpdGlvbiBhbmQgdmlzdWFsIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgcmJveCA9IHJib3gubWVyZ2UodGhpcy5yYm94KHRoaXMuZG9jKCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYm94O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG1lbWJlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KG1lbWJlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5GWC5TZXQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzZXQpIHtcbiAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byBzZXRcbiAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgfSk7IC8vIEFsaWFzIG1ldGhvZHNcblxuICBTVkcuU2V0LmluaGVyaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG0sXG4gICAgICAgIG1ldGhvZHMgPSBbXTsgLy8gZ2F0aGVyIHNoYXBlIG1ldGhvZHNcblxuICAgIGZvciAodmFyIG0gaW4gU1ZHLlNoYXBlLnByb3RvdHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBTVkcuU2hhcGUucHJvdG90eXBlW21dID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0LnByb3RvdHlwZVttXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2gobSk7XG4gICAgICB9XG4gICAgfSAvLyBhcHBseSBzaGFwZSBhbGlhc3Nlc1xuXG5cbiAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgU1ZHLlNldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5tZW1iZXJzW2ldICYmIHR5cGVvZiB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldW21ldGhvZF0uYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2QgPT0gJ2FuaW1hdGUnID8gdGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlguU2V0KHRoaXMpKSA6IHRoaXM7XG4gICAgICB9O1xuICAgIH0pOyAvLyBjbGVhciBtZXRob2RzIGZvciB0aGUgbmV4dCByb3VuZFxuXG4gICAgbWV0aG9kcyA9IFtdOyAvLyBnYXRoZXIgZnggbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgbSBpbiBTVkcuRlgucHJvdG90eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIFNWRy5GWC5wcm90b3R5cGVbbV0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5GWC5TZXQucHJvdG90eXBlW21dICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9IC8vIGFwcGx5IGZ4IGFsaWFzc2VzXG5cblxuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBTVkcuRlguU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnNldC5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNldC5tZW1iZXJzW2ldLmZ4W21ldGhvZF0uYXBwbHkodGhpcy5zZXQubWVtYmVyc1tpXS5meCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gU3RvcmUgZGF0YSB2YWx1ZXMgb24gc3ZnIG5vZGVzXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YShhLCB2LCByKSB7XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2IGluIGEpIHtcbiAgICAgICAgICB0aGlzLmRhdGEodiwgYVt2XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2RhdGEtJyArIGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHIoJ2RhdGEtJyArIGEsIHYgPT09IG51bGwgPyBudWxsIDogciA9PT0gdHJ1ZSB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInID8gdiA6IEpTT04uc3RyaW5naWZ5KHYpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIFJlbWVtYmVyIGFyYml0cmFyeSBkYXRhXG4gICAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKGssIHYpIHtcbiAgICAgIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxuICAgICAgaWYgKF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgdiBpbiBrKSB7XG4gICAgICAgICAgdGhpcy5yZW1lbWJlcih2LCBrW3ZdKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9yeSgpW2tdO1xuICAgICAgICB9IC8vIHN0b3JlIG1lbW9yeVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVtb3J5KClba10gPSB2O1xuICAgICAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuICAgIGZvcmdldDogZnVuY3Rpb24gZm9yZ2V0KCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aGlzLl9tZW1vcnkgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5tZW1vcnkoKVthcmd1bWVudHNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gSW5pdGlhbGl6ZSBvciByZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuICAgIG1lbW9yeTogZnVuY3Rpb24gbWVtb3J5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lbW9yeSB8fCAodGhpcy5fbWVtb3J5ID0ge30pO1xuICAgIH1cbiAgfSk7IC8vIE1ldGhvZCBmb3IgZ2V0dGluZyBhbiBlbGVtZW50IGJ5IGlkXG5cbiAgU1ZHLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRGcm9tUmVmZXJlbmNlKGlkKSB8fCBpZCk7XG4gICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKTtcbiAgfTsgLy8gU2VsZWN0IGVsZW1lbnRzIGJ5IHF1ZXJ5IHN0cmluZ1xuXG5cbiAgU1ZHLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBTVkcuU2V0KFNWRy51dGlscy5tYXAoKHBhcmVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgIH0pKTtcbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgICAvLyBTY29wZWQgc2VsZWN0IG1ldGhvZFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gU1ZHLnNlbGVjdChxdWVyeSwgdGhpcy5ub2RlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHBhdGhSZWdSZXBsYWNlKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyArIGQucmVwbGFjZShTVkcucmVnZXguZG90cywgJyAuJyk7XG4gIH0gLy8gY3JlYXRlcyBkZWVwIGNsb25lIG9mIGFycmF5XG5cblxuICBmdW5jdGlvbiBhcnJheV9jbG9uZShhcnIpIHtcbiAgICB2YXIgY2xvbmUgPSBhcnIuc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gY2xvbmUubGVuZ3RoOyBpLS07KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjbG9uZVtpXSkpIHtcbiAgICAgICAgY2xvbmVbaV0gPSBhcnJheV9jbG9uZShjbG9uZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9IC8vIHRlc3RzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBpbnN0YW5jZSBvZiBhbiBvYmplY3RcblxuXG4gIGZ1bmN0aW9uIF9pcyhlbCwgb2JqKSB7XG4gICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygb2JqO1xuICB9IC8vIHRlc3RzIGlmIGEgZ2l2ZW4gc2VsZWN0b3IgbWF0Y2hlcyBhbiBlbGVtZW50XG5cblxuICBmdW5jdGlvbiBfbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB9IC8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuXG5cbiAgZnVuY3Rpb24gY2FtZWxDYXNlKHMpIHtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgICAgIHJldHVybiBnLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0gLy8gQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcblxuXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbiAgfSAvLyBFbnN1cmUgdG8gc2l4LWJhc2VkIGhleFxuXG5cbiAgZnVuY3Rpb24gZnVsbEhleChoZXgpIHtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSA0ID8gWycjJywgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygzLCA0KSwgaGV4LnN1YnN0cmluZygzLCA0KV0uam9pbignJykgOiBoZXg7XG4gIH0gLy8gQ29tcG9uZW50IHRvIGhleCB2YWx1ZVxuXG5cbiAgZnVuY3Rpb24gY29tcFRvSGV4KGNvbXApIHtcbiAgICB2YXIgaGV4ID0gY29tcC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgfSAvLyBDYWxjdWxhdGUgcHJvcG9ydGlvbmFsIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIHdoZW4gbmVjZXNzYXJ5XG5cblxuICBmdW5jdGlvbiBwcm9wb3J0aW9uYWxTaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPT0gbnVsbCB8fCBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgdmFyIGJveCA9IGVsZW1lbnQuYmJveCgpO1xuXG4gICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9IC8vIERlbHRhIHRyYW5zZm9ybSBwb2ludFxuXG5cbiAgZnVuY3Rpb24gZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAqIG1hdHJpeC5hICsgeSAqIG1hdHJpeC5jICsgMCxcbiAgICAgIHk6IHggKiBtYXRyaXguYiArIHkgKiBtYXRyaXguZCArIDBcbiAgICB9O1xuICB9IC8vIE1hcCBtYXRyaXggYXJyYXkgdG8gb2JqZWN0XG5cblxuICBmdW5jdGlvbiBhcnJheVRvTWF0cml4KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogYVswXSxcbiAgICAgIGI6IGFbMV0sXG4gICAgICBjOiBhWzJdLFxuICAgICAgZDogYVszXSxcbiAgICAgIGU6IGFbNF0sXG4gICAgICBmOiBhWzVdXG4gICAgfTtcbiAgfSAvLyBQYXJzZSBtYXRyaXggaWYgcmVxdWlyZWRcblxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF0cml4KG1hdHJpeCkge1xuICAgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIFNWRy5NYXRyaXgpKSB7XG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH0gLy8gQWRkIGNlbnRyZSBwb2ludCB0byB0cmFuc2Zvcm0gb2JqZWN0XG5cblxuICBmdW5jdGlvbiBlbnN1cmVDZW50cmUobywgdGFyZ2V0KSB7XG4gICAgby5jeCA9IG8uY3ggPT0gbnVsbCA/IHRhcmdldC5iYm94KCkuY3ggOiBvLmN4O1xuICAgIG8uY3kgPSBvLmN5ID09IG51bGwgPyB0YXJnZXQuYmJveCgpLmN5IDogby5jeTtcbiAgfSAvLyBQYXRoQXJyYXkgSGVscGVyc1xuXG5cbiAgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGgsIHMgPSAnJzsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHMgKz0gYVtpXVswXTtcblxuICAgICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xuICAgICAgICBzICs9IGFbaV1bMV07XG5cbiAgICAgICAgaWYgKGFbaV1bMl0gIT0gbnVsbCkge1xuICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgIHMgKz0gYVtpXVsyXTtcblxuICAgICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgICAgcyArPSBhW2ldWzNdO1xuICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICBzICs9IGFbaV1bNF07XG5cbiAgICAgICAgICAgIGlmIChhW2ldWzVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgIHMgKz0gYVtpXVs1XTtcbiAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgIHMgKz0gYVtpXVs2XTtcblxuICAgICAgICAgICAgICBpZiAoYVtpXVs3XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgICAgcyArPSBhW2ldWzddO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMgKyAnICc7XG4gIH0gLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxuXG5cbiAgZnVuY3Rpb24gYXNzaWduTmV3SWQobm9kZSkge1xuICAgIC8vIGRvIHRoZSBzYW1lIGZvciBTVkcgY2hpbGQgbm9kZXMgYXMgd2VsbFxuICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0gaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgICBhc3NpZ25OZXdJZChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTVkcuYWRvcHQobm9kZSkuaWQoU1ZHLmVpZChub2RlLm5vZGVOYW1lKSk7XG4gIH0gLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcblxuXG4gIGZ1bmN0aW9uIGZ1bGxCb3goYikge1xuICAgIGlmIChiLnggPT0gbnVsbCkge1xuICAgICAgYi54ID0gMDtcbiAgICAgIGIueSA9IDA7XG4gICAgICBiLndpZHRoID0gMDtcbiAgICAgIGIuaGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBiLncgPSBiLndpZHRoO1xuICAgIGIuaCA9IGIuaGVpZ2h0O1xuICAgIGIueDIgPSBiLnggKyBiLndpZHRoO1xuICAgIGIueTIgPSBiLnkgKyBiLmhlaWdodDtcbiAgICBiLmN4ID0gYi54ICsgYi53aWR0aCAvIDI7XG4gICAgYi5jeSA9IGIueSArIGIuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gYjtcbiAgfSAvLyBHZXQgaWQgZnJvbSByZWZlcmVuY2Ugc3RyaW5nXG5cblxuICBmdW5jdGlvbiBpZEZyb21SZWZlcmVuY2UodXJsKSB7XG4gICAgdmFyIG0gPSAodXJsIHx8ICcnKS50b1N0cmluZygpLm1hdGNoKFNWRy5yZWdleC5yZWZlcmVuY2UpO1xuICAgIGlmIChtKSByZXR1cm4gbVsxXTtcbiAgfSAvLyBJZiB2YWx1ZXMgbGlrZSAxZS04OCBhcmUgcGFzc2VkLCB0aGlzIGlzIG5vdCBhIHZhbGlkIDMyIGJpdCBmbG9hdCxcbiAgLy8gYnV0IGluIHRob3NlIGNhc2VzLCB3ZSBhcmUgc28gY2xvc2UgdG8gMCB0aGF0IDAgd29ya3Mgd2VsbCFcblxuXG4gIGZ1bmN0aW9uIGZsb2F0MzJTdHJpbmcodikge1xuICAgIHJldHVybiBNYXRoLmFicyh2KSA+IDFlLTM3ID8gdiA6IDA7XG4gIH0gLy8gQ3JlYXRlIG1hdHJpeCBhcnJheSBmb3IgbG9vcGluZ1xuXG5cbiAgdmFyIGFiY2RlZiA9ICdhYmNkZWYnLnNwbGl0KCcnKTsgLy8gQWRkIEN1c3RvbUV2ZW50IHRvIElFOSBhbmQgSUUxMFxuXG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ29kZSBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnRcbiAgICB2YXIgQ3VzdG9tRXZlbnRQb2x5ID0gZnVuY3Rpb24gQ3VzdG9tRXZlbnRQb2x5KGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZS5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIG9wdGlvbnMuYnViYmxlcywgb3B0aW9ucy5jYW5jZWxhYmxlLCBvcHRpb25zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgQ3VzdG9tRXZlbnRQb2x5LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgU1ZHLkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnRQb2x5O1xuICB9IGVsc2Uge1xuICAgIFNWRy5DdXN0b21FdmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcbiAgfSAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLyBjYW5jZWxBbmltYXRpb25GcmFtZSBQb2x5ZmlsbCB3aXRoIGZhbGxiYWNrIGJhc2VkIG9uIFBhdWwgSXJpc2hcblxuXG4gIChmdW5jdGlvbiAodykge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgdmFyIGlkID0gdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHcuY2xlYXJUaW1lb3V0O1xuICB9KSh3aW5kb3cpO1xuXG4gIHJldHVybiBTVkc7XG59KTtcblxuLyohIHN2Zy5maWx0ZXIuanMgLSB2Mi4wLjIgLSAyMDE2LTAyLTI0XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLmZpbHRlci5qc1xyXG4qIENvcHlyaWdodCAoYykgMjAxNiBXb3V0IEZpZXJlbnM7IExpY2Vuc2VkIE1JVCAqL1xyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gIC8vIE1haW4gZmlsdGVyIGNsYXNzXHJcbiAgU1ZHLkZpbHRlciA9IFNWRy5pbnZlbnQoe1xyXG4gICAgY3JlYXRlOiAnZmlsdGVyJyxcclxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXHJcbiAgICBleHRlbmQ6IHtcclxuICAgICAgLy8gU3RhdGljIHN0cmluZ3NcclxuICAgICAgc291cmNlOiAgICAgICAgICAgJ1NvdXJjZUdyYXBoaWMnLFxyXG4gICAgICBzb3VyY2VBbHBoYTogICAgICAnU291cmNlQWxwaGEnLFxyXG4gICAgICBiYWNrZ3JvdW5kOiAgICAgICAnQmFja2dyb3VuZEltYWdlJyxcclxuICAgICAgYmFja2dyb3VuZEFscGhhOiAgJ0JhY2tncm91bmRBbHBoYScsXHJcbiAgICAgIGZpbGw6ICAgICAgICAgICAgICdGaWxsUGFpbnQnLFxyXG4gICAgICBzdHJva2U6ICAgICAgICAgICAnU3Ryb2tlUGFpbnQnLFxyXG5cclxuICAgICAgYXV0b1NldEluOiB0cnVlLFxyXG4gICAgICAvLyBDdXN0b20gcHV0IG1ldGhvZCBmb3IgbGVhbmVyIGNvZGVcclxuICAgICAgcHV0OiBmdW5jdGlvbihlbGVtZW50LCBpKSB7XHJcbiAgICAgICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XHJcblxyXG4gICAgICAgIGlmKCFlbGVtZW50LmF0dHIoJ2luJykgJiYgdGhpcy5hdXRvU2V0SW4pe1xyXG4gICAgICAgICAgZWxlbWVudC5hdHRyKCdpbicsdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZighZWxlbWVudC5hdHRyKCdyZXN1bHQnKSl7XHJcbiAgICAgICAgICBlbGVtZW50LmF0dHIoJ3Jlc3VsdCcsZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZWxlbWVudFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBCbGVuZCBlZmZlY3RcclxuICAgICAgYmxlbmQ6IGZ1bmN0aW9uKGluMSwgaW4yLCBtb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQmxlbmRFZmZlY3QoaW4xLCBpbjIsIG1vZGUpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBDb2xvck1hdHJpeCBlZmZlY3RcclxuICAgICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNvbG9yTWF0cml4RWZmZWN0KHR5cGUsIHZhbHVlcykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIENvbnZvbHZlTWF0cml4IGVmZmVjdFxyXG4gICAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ29udm9sdmVNYXRyaXhFZmZlY3QobWF0cml4KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29tcG9uZW50VHJhbnNmZXIgZWZmZWN0XHJcbiAgICAgIGNvbXBvbmVudFRyYW5zZmVyOiBmdW5jdGlvbihjb21wb25lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ29tcG9uZW50VHJhbnNmZXJFZmZlY3QoY29tcG9uZW50cykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIENvbXBvc2l0ZSBlZmZlY3RcclxuICAgICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjEsIGluMiwgb3BlcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db21wb3NpdGVFZmZlY3QoaW4xLCBpbjIsIG9wZXJhdG9yKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gRmxvb2QgZWZmZWN0XHJcbiAgICAgIGZsb29kOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkZsb29kRWZmZWN0KGNvbG9yLCBvcGFjaXR5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gT2Zmc2V0IGVmZmVjdFxyXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5PZmZzZXRFZmZlY3QoeCx5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gSW1hZ2UgZWZmZWN0XHJcbiAgICAgIGltYWdlOiBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5JbWFnZUVmZmVjdChzcmMpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBNZXJnZSBlZmZlY3RcclxuICAgICAgbWVyZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vcGFzcyB0aGUgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHdlIGRvbnQga25vdyBpZiB0aGUgdXNlciBnYXZlIHVzIGFuIGFycmF5IGFzIHRoZSBmaXJzdCBhcmd1ZW1udCBvciB3ZXRoZXIgdGhleSBsaXN0ZWQgdGhlIGVmZmVjdHMgaW4gdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgIHZhciBhcmdzID0gW3VuZGVmaW5lZF07XHJcbiAgICAgICAgZm9yKHZhciBpIGluIGFyZ3VtZW50cykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyAoU1ZHLk1lcmdlRWZmZWN0LmJpbmQuYXBwbHkoU1ZHLk1lcmdlRWZmZWN0LGFyZ3MpKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gR2F1c3NpYW4gQmx1ciBlZmZlY3RcclxuICAgICAgZ2F1c3NpYW5CbHVyOiBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HYXVzc2lhbkJsdXJFZmZlY3QoeCx5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gTW9ycGhvbG9neSBlZmZlY3RcclxuICAgICAgbW9ycGhvbG9neTogZnVuY3Rpb24ob3BlcmF0b3IscmFkaXVzKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Nb3JwaG9sb2d5RWZmZWN0KG9wZXJhdG9yLHJhZGl1cykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIERpZmZ1c2VMaWdodGluZyBlZmZlY3RcclxuICAgICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkRpZmZ1c2VMaWdodGluZ0VmZmVjdChzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBEaXNwbGFjZW1lbnRNYXAgZWZmZWN0XHJcbiAgICAgIGRpc3BsYWNlbWVudE1hcDogZnVuY3Rpb24oaW4xLGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3Ipe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkRpc3BsYWNlbWVudE1hcEVmZmVjdChpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3RvcikpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIFNwZWN1bGFyTGlnaHRpbmcgZWZmZWN0XHJcbiAgICAgIHNwZWN1bGFyTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxrZXJuZWxVbml0TGVuZ3RoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TcGVjdWxhckxpZ2h0aW5nRWZmZWN0KHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxrZXJuZWxVbml0TGVuZ3RoKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gVGlsZSBlZmZlY3RcclxuICAgICAgdGlsZTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UaWxlRWZmZWN0KCkpO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyBUdXJidWxlbmNlIGVmZmVjdFxyXG4gICAgICB0dXJidWxlbmNlOiBmdW5jdGlvbihiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UdXJidWxlbmNlRWZmZWN0KGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBEZWZhdWx0IHN0cmluZyB2YWx1ZVxyXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmF0dHIoJ2lkJykgKyAnKSdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvL2FkZCAuZmlsdGVyIGZ1bmN0aW9uXHJcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xyXG4gICAgLy8gRGVmaW5lIGZpbHRlclxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5wdXQobmV3IFNWRy5GaWx0ZXIpO1xyXG5cclxuICAgICAgLyogaW52b2tlIHBhc3NlZCBibG9jayAqL1xyXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGJsb2NrLmNhbGwoZmlsdGVyLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGZpbHRlclxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFNWRy5leHRlbmQoU1ZHLkNvbnRhaW5lciwge1xyXG4gICAgLy8gRGVmaW5lIGZpbHRlciBvbiBkZWZzXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5maWx0ZXIoYmxvY2spXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkcsIFNWRy5OZXN0ZWQsIHtcclxuICAgIC8vIENyZWF0ZSBmaWx0ZXIgZWxlbWVudCBpbiBkZWZzIGFuZCBzdG9yZSByZWZlcmVuY2VcclxuICAgIGZpbHRlcjogZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgdGhpcy5maWx0ZXJlciA9IGJsb2NrIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQgP1xyXG4gICAgICAgIGJsb2NrIDogdGhpcy5kb2MoKS5maWx0ZXIoYmxvY2spO1xyXG5cclxuICAgICAgaWYodGhpcy5kb2MoKSAmJiB0aGlzLmZpbHRlcmVyLmRvYygpICE9PSB0aGlzLmRvYygpKXtcclxuICAgICAgICB0aGlzLmRvYygpLmRlZnMoKS5hZGQodGhpcy5maWx0ZXJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYXR0cignZmlsdGVyJywgdGhpcy5maWx0ZXJlcik7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJlclxyXG4gICAgfSxcclxuICAgIC8vIFJlbW92ZSBmaWx0ZXJcclxuICAgIHVuZmlsdGVyOiBmdW5jdGlvbihyZW1vdmUpIHtcclxuICAgICAgLyogYWxzbyByZW1vdmUgdGhlIGZpbHRlciBub2RlICovXHJcbiAgICAgIGlmICh0aGlzLmZpbHRlcmVyICYmIHJlbW92ZSA9PT0gdHJ1ZSlcclxuICAgICAgICB0aGlzLmZpbHRlcmVyLnJlbW92ZSgpO1xyXG5cclxuICAgICAgLyogZGVsZXRlIHJlZmVyZW5jZSB0byBmaWx0ZXJlciAqL1xyXG4gICAgICBkZWxldGUgdGhpcy5maWx0ZXJlcjtcclxuXHJcbiAgICAgIC8qIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICovXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZpbHRlcicsIG51bGwpXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIENyZWF0ZSBTVkcuRWZmZWN0IGNsYXNzXHJcbiAgU1ZHLkVmZmVjdCA9IFNWRy5pbnZlbnQoe1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXHJcbiAgICBleHRlbmQ6IHtcclxuICAgICAgLy8gU2V0IGluIGF0dHJpYnV0ZVxyXG4gICAgICBpbjogZnVuY3Rpb24oZWZmZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVmZmVjdCA9PSBudWxsPyB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc2VsZWN0KCdbcmVzdWx0PVwiJyt0aGlzLmF0dHIoJ2luJykrJ1wiXScpLmdldCgwKSB8fCB0aGlzLmF0dHIoJ2luJykgOiB0aGlzLmF0dHIoJ2luJywgZWZmZWN0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBOYW1lZCByZXN1bHRcclxuICAgICAgcmVzdWx0OiBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ID09IG51bGw/IHRoaXMuYXR0cigncmVzdWx0JykgOiB0aGlzLmF0dHIoJ3Jlc3VsdCcscmVzdWx0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBTdHJpbmdpZmljYXRpb25cclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gY3JlYXRlIGNsYXNzIGZvciBwYXJlbnQgZWZmZWN0cyBsaWtlIG1lcmdlXHJcbiAgLy8gSW5oZXJpdCBmcm9tIFNWRy5QYXJlbnRcclxuICBTVkcuUGFyZW50RWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBpbmhlcml0OiBTVkcuUGFyZW50LFxyXG4gICAgZXh0ZW5kOiB7XHJcbiAgICAgIC8vIFNldCBpbiBhdHRyaWJ1dGVcclxuICAgICAgaW46IGZ1bmN0aW9uKGVmZmVjdCkge1xyXG4gICAgICAgIHJldHVybiBlZmZlY3QgPT0gbnVsbD8gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNlbGVjdCgnW3Jlc3VsdD1cIicrdGhpcy5hdHRyKCdpbicpKydcIl0nKS5nZXQoMCkgfHwgdGhpcy5hdHRyKCdpbicpIDogdGhpcy5hdHRyKCdpbicsIGVmZmVjdClcclxuICAgICAgfSxcclxuICAgICAgLy8gTmFtZWQgcmVzdWx0XHJcbiAgICAgIHJlc3VsdDogZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsPyB0aGlzLmF0dHIoJ3Jlc3VsdCcpIDogdGhpcy5hdHRyKCdyZXN1bHQnLHJlc3VsdClcclxuICAgICAgfSxcclxuICAgICAgLy8gU3RyaW5naWZpY2F0aW9uXHJcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vY2hhaW5pbmdcclxuICB2YXIgY2hhaW5pbmdFZmZlY3RzID0ge1xyXG4gICAgLy8gQmxlbmQgZWZmZWN0XHJcbiAgICBibGVuZDogZnVuY3Rpb24oaW4yLCBtb2RlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYmxlbmQodGhpcywgaW4yLCBtb2RlKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBDb2xvck1hdHJpeCBlZmZlY3RcclxuICAgIGNvbG9yTWF0cml4OiBmdW5jdGlvbih0eXBlLCB2YWx1ZXMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb2xvck1hdHJpeCh0eXBlLCB2YWx1ZXMpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gQ29udm9sdmVNYXRyaXggZWZmZWN0XHJcbiAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY29udm9sdmVNYXRyaXgobWF0cml4KS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIENvbXBvbmVudFRyYW5zZmVyIGVmZmVjdFxyXG4gICAgY29tcG9uZW50VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbXBvbmVudHMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb21wb25lbnRUcmFuc2Zlcihjb21wb25lbnRzKS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIENvbXBvc2l0ZSBlZmZlY3RcclxuICAgIGNvbXBvc2l0ZTogZnVuY3Rpb24oaW4yLCBvcGVyYXRvcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbXBvc2l0ZSh0aGlzLCBpbjIsIG9wZXJhdG9yKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBGbG9vZCBlZmZlY3RcclxuICAgIGZsb29kOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmZsb29kKGNvbG9yLCBvcGFjaXR5KSAvL3RoaXMgZWZmZWN0IGRvbnQgaGF2ZSBpbnB1dHNcclxuICAgIH0sXHJcbiAgICAvLyBPZmZzZXQgZWZmZWN0XHJcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5vZmZzZXQoeCx5KS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIEltYWdlIGVmZmVjdFxyXG4gICAgaW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmltYWdlKHNyYykgLy90aGlzIGVmZmVjdCBkb250IGhhdmUgaW5wdXRzXHJcbiAgICB9LFxyXG4gICAgLy8gTWVyZ2UgZWZmZWN0XHJcbiAgICBtZXJnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkubWVyZ2UuYXBwbHkodGhpcy5wYXJlbnQoKSxbdGhpc10uY29uY2F0KGFyZ3VtZW50cykpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxyXG4gICAgfSxcclxuICAgIC8vIEdhdXNzaWFuIEJsdXIgZWZmZWN0XHJcbiAgICBnYXVzc2lhbkJsdXI6IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmdhdXNzaWFuQmx1cih4LHkpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gTW9ycGhvbG9neSBlZmZlY3RcclxuICAgIG1vcnBob2xvZ3k6IGZ1bmN0aW9uKG9wZXJhdG9yLHJhZGl1cyl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkubW9ycGhvbG9neShvcGVyYXRvcixyYWRpdXMpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gRGlmZnVzZUxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmRpZmZ1c2VMaWdodGluZyhzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gRGlzcGxhY2VtZW50TWFwIGVmZmVjdFxyXG4gICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5kaXNwbGFjZW1lbnRNYXAodGhpcyxpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBTcGVjdWxhckxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNwZWN1bGFyTGlnaHRpbmcoc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gVGlsZSBlZmZlY3RcclxuICAgIHRpbGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkudGlsZSgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gVHVyYnVsZW5jZSBlZmZlY3RcclxuICAgIHR1cmJ1bGVuY2U6IGZ1bmN0aW9uKGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnR1cmJ1bGVuY2UoYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSkuaW4odGhpcylcclxuICAgIH1cclxuICB9O1xyXG4gIFNWRy5leHRlbmQoU1ZHLkVmZmVjdCxjaGFpbmluZ0VmZmVjdHMpO1xyXG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudEVmZmVjdCxjaGFpbmluZ0VmZmVjdHMpO1xyXG5cclxuICAvL2NyZWEgY2xhc3MgZm9yIGNoaWxkIGVmZmVjdHMsIGxpa2UgTWVyZ2VOb2RlLCBGdW5jUiBhbmQgbGlnaHRzXHJcbiAgU1ZHLkNoaWxkRWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcclxuICAgIGV4dGVuZDoge1xyXG4gICAgaW46IGZ1bmN0aW9uKGVmZmVjdCl7XHJcbiAgICAgIHRoaXMuYXR0cignaW4nLGVmZmVjdCk7XHJcbiAgICB9XHJcbiAgICAvL2RvbnQgaW5jbHVkZSBhbnkgXCJyZXN1bHRcIiBmdW5jdGlvbnMgYmVjYXVzZSB0aGVzZSB0eXBlcyBvZiBub2RlcyBkb250IGhhdmUgdGhlbVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgYWxsIGRpZmZlcmVudCBlZmZlY3RzXHJcbiAgdmFyIGVmZmVjdHMgPSB7XHJcbiAgICBibGVuZDogZnVuY3Rpb24oaW4xLGluMixtb2RlKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBpbjogaW4xLFxyXG4gICAgICAgIGluMjogaW4yLFxyXG4gICAgICAgIG1vZGU6IG1vZGUgfHwgJ25vcm1hbCdcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsdmFsdWVzKXtcclxuICAgICAgaWYgKHR5cGUgPT0gJ21hdHJpeCcpXHJcbiAgICAgICAgdmFsdWVzID0gbm9ybWFsaXNlTWF0cml4KHZhbHVlcyk7XHJcblxyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHR5cGU6ICAgdHlwZVxyXG4gICAgICAsIHZhbHVlczogdHlwZW9mIHZhbHVlcyA9PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2YWx1ZXNcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29udm9sdmVNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCl7XHJcbiAgICAgIG1hdHJpeCA9IG5vcm1hbGlzZU1hdHJpeChtYXRyaXgpO1xyXG5cclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBvcmRlcjogICAgICAgIE1hdGguc3FydChtYXRyaXguc3BsaXQoJyAnKS5sZW5ndGgpXHJcbiAgICAgICwga2VybmVsTWF0cml4OiBtYXRyaXhcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjEsIGluMiwgb3BlcmF0b3Ipe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGluOiBpbjEsXHJcbiAgICAgICAgaW4yOiBpbjIsXHJcbiAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGZsb29kOiBmdW5jdGlvbihjb2xvcixvcGFjaXR5KXtcclxuICAgICAgdGhpcy5hdHRyKCdmbG9vZC1jb2xvcicsY29sb3IpO1xyXG4gICAgICBpZihvcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignZmxvb2Qtb3BhY2l0eScsb3BhY2l0eSk7XHJcbiAgICB9LFxyXG4gICAgb2Zmc2V0OiBmdW5jdGlvbih4LHkpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGR4OiB4LFxyXG4gICAgICAgIGR5OiB5XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGltYWdlOiBmdW5jdGlvbihzcmMpe1xyXG4gICAgICB0aGlzLmF0dHIoJ2hyZWYnLCBzcmMsIFNWRy54bGluayk7XHJcbiAgICB9LFxyXG4gICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3Rvcil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgaW46IGluMSxcclxuICAgICAgICBpbjI6IGluMixcclxuICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgeENoYW5uZWxTZWxlY3RvcjogeENoYW5uZWxTZWxlY3RvcixcclxuICAgICAgICB5Q2hhbm5lbFNlbGVjdG9yOiB5Q2hhbm5lbFNlbGVjdG9yXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGdhdXNzaWFuQmx1cjogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgaWYoeCAhPSBudWxsIHx8IHkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmF0dHIoJ3N0ZERldmlhdGlvbicsIGxpc3RTdHJpbmcoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5hdHRyKCdzdGREZXZpYXRpb24nLCAnMCAwJyk7XHJcbiAgICB9LFxyXG4gICAgbW9ycGhvbG9neTogZnVuY3Rpb24ob3BlcmF0b3IscmFkaXVzKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXNcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdGlsZTogZnVuY3Rpb24oKXtcclxuXHJcbiAgICB9LFxyXG4gICAgdHVyYnVsZW5jZTogZnVuY3Rpb24oYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSl7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgbnVtT2N0YXZlczogbnVtT2N0YXZlcyxcclxuICAgICAgICBzZWVkOiBzZWVkLFxyXG4gICAgICAgIHN0aXRjaFRpbGVzOiBzdGl0Y2hUaWxlcyxcclxuICAgICAgICBiYXNlRnJlcXVlbmN5OiBiYXNlRnJlcXVlbmN5LFxyXG4gICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGFsbCBwYXJlbnQgZWZmZWN0c1xyXG4gIHZhciBwYXJlbnRFZmZlY3RzID0ge1xyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBjaGlsZHJlbjtcclxuXHJcbiAgICAgIC8vdGVzdCB0byBzZWUgaWYgd2UgaGF2ZSBhIHNldFxyXG4gICAgICBpZihhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTVkcuU2V0KXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgYXJndW1lbnRzWzBdLmVhY2goZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSlcclxuICAgICAgICAgICAgdGhhdC5wdXQodGhpcyk7XHJcbiAgICAgICAgICBlbHNlIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuRWZmZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50RWZmZWN0KVxyXG4gICAgICAgICAgICB0aGF0LnB1dChuZXcgU1ZHLk1lcmdlTm9kZSh0aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICAvL2lmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSB1c2UgaXRcclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgIGlmKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMucHV0KGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgdGhpcy5wdXQobmV3IFNWRy5NZXJnZU5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRUcmFuc2ZlcjogZnVuY3Rpb24oY29tcG9udGVudHMpe1xyXG4gICAgICAvKiBjcmVhdGUgcmdiIHNldCAqL1xyXG4gICAgICB0aGlzLnJnYiA9IG5ldyBTVkcuU2V0XHJcblxyXG4gICAgICAvKiBjcmVhdGUgY29tcG9uZW50cyAqL1xyXG4gICAgICA7KFsncicsICdnJywgJ2InLCAnYSddKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAvKiBjcmVhdGUgY29tcG9uZW50ICovXHJcbiAgICAgICAgdGhpc1tjXSA9IG5ldyBTVkdbJ0Z1bmMnICsgYy50b1VwcGVyQ2FzZSgpXSgnaWRlbnRpdHknKTtcclxuXHJcbiAgICAgICAgLyogc3RvcmUgY29tcG9uZW50IGluIHNldCAqL1xyXG4gICAgICAgIHRoaXMucmdiLmFkZCh0aGlzW2NdKTtcclxuXHJcbiAgICAgICAgLyogYWRkIGNvbXBvbmVudCBub2RlICovXHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXNbY10ubm9kZSk7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7IC8vbG9zdCBjb250ZXh0IGluIGZvcmVhY2hcclxuXHJcbiAgICAgIC8qIHNldCBjb21wb25lbnRzICovXHJcbiAgICAgIGlmIChjb21wb250ZW50cykge1xyXG4gICAgICAgIGlmIChjb21wb250ZW50cy5yZ2IpIHtcclxuKFsncicsICdnJywgJ2InXSkuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgIHRoaXNbY10uYXR0cihjb21wb250ZW50cy5yZ2IpO1xyXG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICBkZWxldGUgY29tcG9udGVudHMucmdiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogc2V0IGluZGl2aWR1YWwgY29tcG9uZW50cyAqL1xyXG4gICAgICAgIGZvciAodmFyIGMgaW4gY29tcG9udGVudHMpXHJcbiAgICAgICAgICB0aGlzW2NdLmF0dHIoY29tcG9udGVudHNbY10pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHN1cmZhY2VTY2FsZTogc3VyZmFjZVNjYWxlLFxyXG4gICAgICAgIGRpZmZ1c2VDb25zdGFudDogZGlmZnVzZUNvbnN0YW50LFxyXG4gICAgICAgIGtlcm5lbFVuaXRMZW5ndGg6IGtlcm5lbFVuaXRMZW5ndGhcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHN1cmZhY2VTY2FsZTogc3VyZmFjZVNjYWxlLFxyXG4gICAgICAgIGRpZmZ1c2VDb25zdGFudDogZGlmZnVzZUNvbnN0YW50LFxyXG4gICAgICAgIHNwZWN1bGFyRXhwb25lbnQ6IHNwZWN1bGFyRXhwb25lbnQsXHJcbiAgICAgICAga2VybmVsVW5pdExlbmd0aDoga2VybmVsVW5pdExlbmd0aFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGNoaWxkIGVmZmVjdHMgbGlrZSBQb2ludExpZ2h0IGFuZCBNZXJnZU5vZGVcclxuICB2YXIgY2hpbGRFZmZlY3RzID0ge1xyXG4gICAgZGlzdGFudExpZ2h0OiBmdW5jdGlvbihhemltdXRoLCBlbGV2YXRpb24pe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGF6aW11dGg6IGF6aW11dGgsXHJcbiAgICAgICAgZWxldmF0aW9uOiBlbGV2YXRpb25cclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9pbnRMaWdodDogZnVuY3Rpb24oeCx5LHope1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB6OiB6XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHNwb3RMaWdodDogZnVuY3Rpb24oeCx5LHoscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFope1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB6OiB6LFxyXG4gICAgICAgIHBvaW50c0F0WDogcG9pbnRzQXRYLFxyXG4gICAgICAgIHBvaW50c0F0WTogcG9pbnRzQXRZLFxyXG4gICAgICAgIHBvaW50c0F0WjogcG9pbnRzQXRaXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmdlTm9kZTogZnVuY3Rpb24oaW4xKXtcclxuICAgICAgdGhpcy5hdHRyKCdpbicsaW4xKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBjb21wb250ZW50IGZ1bmN0aW9uc1xyXG4gIDsoWydyJywgJ2cnLCAnYicsICdhJ10pLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBjaGlsZEVmZmVjdHNbJ0Z1bmMnICsgYy50b1VwcGVyQ2FzZSgpXSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgdGhpcy5hdHRyKCd0eXBlJyx0eXBlKTtcclxuXHJcbiAgICAgIC8vIHRha2UgZGlmZmVudCBhcmd1bWVudHMgYmFzZWQgb24gdGhlIHR5cGVcclxuICAgICAgc3dpdGNoKHR5cGUpe1xyXG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcclxuICAgICAgICAgIHRoaXMuYXR0cigndGFibGVWYWx1ZXMnLGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ2xpbmVhcic6XHJcbiAgICAgICAgICB0aGlzLmF0dHIoJ3Nsb3BlJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyKCdpbnRlcmNlcHQnLGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ2dhbW1hJzpcclxuICAgICAgICAgIHRoaXMuYXR0cignYW1wbGl0dWRlJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyKCdleHBvbmVudCcsYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIHRoaXMuYXR0cignb2Zmc2V0Jyxhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy9jcmVhdGUgZWZmZWN0c1xyXG4gIGZvcmVhY2goZWZmZWN0cyxmdW5jdGlvbihlZmZlY3QsaSl7XHJcblxyXG4gICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgdmFyIHByb3RvID0ge307XHJcblxyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBTVkdbbmFtZSArICdFZmZlY3QnXSA9IFNWRy5pbnZlbnQoe1xyXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdmZScgKyBuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vY2FsbCBjb25zdHJ1Y3RvciBmb3IgdGhpcyBlZmZlY3RcclxuICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAvL3NldCB0aGUgcmVzdWx0XHJcbiAgICAgICAgdGhpcy5yZXN1bHQodGhpcy5hdHRyKCdpZCcpICsgJ091dCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmhlcml0OiBTVkcuRWZmZWN0LFxyXG4gICAgICBleHRlbmQ6IHByb3RvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy9jcmVhdGUgcGFyZW50IGVmZmVjdHNcclxuICBmb3JlYWNoKHBhcmVudEVmZmVjdHMsZnVuY3Rpb24oZWZmZWN0LGkpe1xyXG5cclxuICAgIC8qIGNhcGl0YWxpemUgbmFtZSAqL1xyXG4gICAgdmFyIG5hbWUgPSBpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaS5zbGljZSgxKTtcclxuICAgIHZhciBwcm90byA9IHt9O1xyXG5cclxuICAgIC8qIGNyZWF0ZSBjbGFzcyAqL1xyXG4gICAgU1ZHW25hbWUgKyAnRWZmZWN0J10gPSBTVkcuaW52ZW50KHtcclxuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2NhbGwgc3VwZXJcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnZmUnICsgbmFtZSkpO1xyXG5cclxuICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgZWZmZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgLy9zZXQgdGhlIHJlc3VsdFxyXG4gICAgICAgIHRoaXMucmVzdWx0KHRoaXMuYXR0cignaWQnKSArICdPdXQnKTtcclxuICAgICAgfSxcclxuICAgICAgaW5oZXJpdDogU1ZHLlBhcmVudEVmZmVjdCxcclxuICAgICAgZXh0ZW5kOiBwcm90b1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vY3JlYXRlIGNoaWxkIGVmZmVjdHNcclxuICBmb3JlYWNoKGNoaWxkRWZmZWN0cyxmdW5jdGlvbihlZmZlY3QsaSl7XHJcblxyXG4gICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgdmFyIHByb3RvID0ge307XHJcblxyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBTVkdbbmFtZV0gPSBTVkcuaW52ZW50KHtcclxuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2NhbGwgc3VwZXJcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnZmUnICsgbmFtZSkpO1xyXG5cclxuICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgZWZmZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcclxuICAgICAgfSxcclxuICAgICAgaW5oZXJpdDogU1ZHLkNoaWxkRWZmZWN0LFxyXG4gICAgICBleHRlbmQ6IHByb3RvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy8gRWZmZWN0LXNwZWNpZmljIGV4dGVuc2lvbnNcclxuICBTVkcuZXh0ZW5kKFNWRy5NZXJnZUVmZmVjdCx7XHJcbiAgICBpbjogZnVuY3Rpb24oZWZmZWN0KXtcclxuICAgICAgaWYoZWZmZWN0IGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSlcclxuICAgICAgICB0aGlzLmFkZChlZmZlY3QsMCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmFkZChuZXcgU1ZHLk1lcmdlTm9kZShlZmZlY3QpLDApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9KTtcclxuICBTVkcuZXh0ZW5kKFNWRy5Db21wb3NpdGVFZmZlY3QsU1ZHLkJsZW5kRWZmZWN0LFNWRy5EaXNwbGFjZW1lbnRNYXBFZmZlY3Qse1xyXG4gICAgaW4yOiBmdW5jdGlvbihlZmZlY3Qpe1xyXG4gICAgICAgIHJldHVybiBlZmZlY3QgPT0gbnVsbD8gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNlbGVjdCgnW3Jlc3VsdD1cIicrdGhpcy5hdHRyKCdpbjInKSsnXCJdJykuZ2V0KDApIHx8IHRoaXMuYXR0cignaW4yJykgOiB0aGlzLmF0dHIoJ2luMicsIGVmZmVjdClcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gUHJlc2V0c1xyXG4gIFNWRy5maWx0ZXIgPSB7XHJcbiAgICBzZXBpYXRvbmU6ICBbIC4zNDMsIC42NjksIC4xMTksIDAsIDBcclxuICAgICAgICAgICAgICAgICwgLjI0OSwgLjYyNiwgLjEzMCwgMCwgMFxyXG4gICAgICAgICAgICAgICAgLCAuMTcyLCAuMzM0LCAuMTExLCAwLCAwXHJcbiAgICAgICAgICAgICAgICAsIC4wMDAsIC4wMDAsIC4wMDAsIDEsIDAgXVxyXG4gIH07XHJcblxyXG4gIC8vIEhlbHBlcnNcclxuICBmdW5jdGlvbiBub3JtYWxpc2VNYXRyaXgobWF0cml4KSB7XHJcbiAgICAvKiBjb252ZXJ0IHBvc3NpYmxlIGFycmF5IHZhbHVlIHRvIHN0cmluZyAqL1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSlcclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5BcnJheShtYXRyaXgpO1xyXG5cclxuICAgIC8qIGVuc3VyZSB0aGVyZSBhcmUgbm8gbGVhZGluZywgdGFpbGluZyBvciBkb3VibGUgc3BhY2VzICovXHJcbiAgICByZXR1cm4gbWF0cml4LnRvU3RyaW5nKCkucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsaXN0U3RyaW5nKGxpc3QpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcclxuICAgICAgcmV0dXJuIGxpc3RcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoLCBzID0gW107IGkgPCBsOyBpKyspXHJcbiAgICAgIHMucHVzaChsaXN0W2ldKTtcclxuXHJcbiAgICByZXR1cm4gcy5qb2luKCcgJylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmVhY2goKXsgLy9sb29wcyB0aHJvdWdoIG11dGlwbGUgb2JqZWN0c1xyXG4gICAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xyXG4gICAgaWYodHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdID09ICdmdW5jdGlvbicpe1xyXG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO1xyXG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLGFyZ3VtZW50cy5sZW5ndGgtMSwxKTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgayBpbiBhcmd1bWVudHMpe1xyXG4gICAgICBmb3IodmFyIGkgaW4gYXJndW1lbnRzW2tdKXtcclxuICAgICAgICBmbihhcmd1bWVudHNba11baV0saSxhcmd1bWVudHNba10pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSkuY2FsbCh1bmRlZmluZWQpO1xuXG4oZnVuY3Rpb24oKSB7XHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5QYXRoQXJyYXksIHtcclxuICBtb3JwaDogZnVuY3Rpb24oYXJyYXkpIHtcclxuXHJcbiAgICB2YXIgc3RhcnRBcnIgPSB0aGlzLnZhbHVlXHJcbiAgICAgICwgIGRlc3RBcnIgPSB0aGlzLnBhcnNlKGFycmF5KTtcclxuXHJcbiAgICB2YXIgc3RhcnRPZmZzZXRNID0gMFxyXG4gICAgICAsICBkZXN0T2Zmc2V0TSA9IDA7XHJcblxyXG4gICAgdmFyIHN0YXJ0T2Zmc2V0TmV4dE0gPSBmYWxzZVxyXG4gICAgICAsICBkZXN0T2Zmc2V0TmV4dE0gPSBmYWxzZTtcclxuXHJcbiAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBNIGFueW1vcmVcclxuICAgICAgaWYoc3RhcnRPZmZzZXRNID09PSBmYWxzZSAmJiBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UpIGJyZWFrXHJcblxyXG4gICAgICAvLyBmaW5kIHRoZSBuZXh0IE0gaW4gcGF0aCBhcnJheVxyXG4gICAgICBzdGFydE9mZnNldE5leHRNID0gZmluZE5leHRNKHN0YXJ0QXJyLCBzdGFydE9mZnNldE0gPT09IGZhbHNlID8gZmFsc2UgOiBzdGFydE9mZnNldE0rMSk7XHJcbiAgICAgICBkZXN0T2Zmc2V0TmV4dE0gPSBmaW5kTmV4dE0oIGRlc3RBcnIsICBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UgPyBmYWxzZSA6ICBkZXN0T2Zmc2V0TSsxKTtcclxuXHJcbiAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIG9uZSBNIHRvIHRoZSBzdGFydEFycmF5XHJcbiAgICAgIGlmKHN0YXJ0T2Zmc2V0TSA9PT0gZmFsc2Upe1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFNWRy5QYXRoQXJyYXkocmVzdWx0LnN0YXJ0KS5iYm94KCk7XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdGhlIGxhc3QgYmxvY2sgaGFkIG5vIGJvdW5kaW5nIGJveCB3ZSBzaW1wbHkgdGFrZSB0aGUgZmlyc3QgTSB3ZSBnb3RcclxuICAgICAgICBpZihiYm94LmhlaWdodCA9PSAwIHx8IGJib3gud2lkdGggPT0gMCl7XHJcbiAgICAgICAgICBzdGFydE9mZnNldE0gPSAgc3RhcnRBcnIucHVzaChzdGFydEFyclswXSkgLSAxO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgLy8gd2UgdGFrZSB0aGUgbWlkZGxlIG9mIHRoZSBiYm94IGluc3RlYWQgd2hlbiB3ZSBnb3Qgb25lXHJcbiAgICAgICAgICBzdGFydE9mZnNldE0gPSBzdGFydEFyci5wdXNoKCBbJ00nLCBiYm94LnggKyBiYm94LndpZHRoLzIsIGJib3gueSArIGJib3guaGVpZ2h0LzIgXSApIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIG9uZSBNIHRvIHRoZSBkZXN0QXJyYXlcclxuICAgICAgaWYoIGRlc3RPZmZzZXRNID09PSBmYWxzZSl7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgU1ZHLlBhdGhBcnJheShyZXN1bHQuZGVzdCkuYmJveCgpO1xyXG5cclxuICAgICAgICBpZihiYm94LmhlaWdodCA9PSAwIHx8IGJib3gud2lkdGggPT0gMCl7XHJcbiAgICAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0QXJyLnB1c2goZGVzdEFyclswXSkgLSAxO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgZGVzdE9mZnNldE0gPSAgZGVzdEFyci5wdXNoKCBbJ00nLCBiYm94LnggKyBiYm94LndpZHRoLzIsIGJib3gueSArIGJib3guaGVpZ2h0LzIgXSApIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhhbmRsZSBibG9jayBmcm9tIE0gdG8gbmV4dCBNXHJcbiAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVCbG9jayhzdGFydEFyciwgc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNLCBkZXN0QXJyLCBkZXN0T2Zmc2V0TSwgZGVzdE9mZnNldE5leHRNKTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0aGUgYXJyYXlzIHRvIHRoZWlyIG5ldyB2YWx1ZXNcclxuICAgICAgc3RhcnRBcnIgPSBzdGFydEFyci5zbGljZSgwLCBzdGFydE9mZnNldE0pLmNvbmNhdChyZXN1bHQuc3RhcnQsIHN0YXJ0T2Zmc2V0TmV4dE0gPT09IGZhbHNlID8gW10gOiBzdGFydEFyci5zbGljZShzdGFydE9mZnNldE5leHRNKSk7XHJcbiAgICAgICBkZXN0QXJyID0gIGRlc3RBcnIuc2xpY2UoMCwgIGRlc3RPZmZzZXRNKS5jb25jYXQocmVzdWx0LmRlc3QgLCAgZGVzdE9mZnNldE5leHRNID09PSBmYWxzZSA/IFtdIDogIGRlc3RBcnIuc2xpY2UoIGRlc3RPZmZzZXROZXh0TSkpO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIG9mZnNldHNcclxuICAgICAgc3RhcnRPZmZzZXRNID0gc3RhcnRPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBmYWxzZSA6IHN0YXJ0T2Zmc2V0TSArIHJlc3VsdC5zdGFydC5sZW5ndGg7XHJcbiAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0T2Zmc2V0TmV4dE0gPT09IGZhbHNlID8gZmFsc2UgOiAgZGVzdE9mZnNldE0gKyByZXN1bHQuZGVzdC5sZW5ndGg7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvcHkgYmFjayBhcnJheXNcclxuICAgIHRoaXMudmFsdWUgPSBzdGFydEFycjtcclxuICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLlBhdGhBcnJheSgpO1xyXG4gICAgdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSA9IGRlc3RBcnI7XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG4vLyBzb3JyeSBmb3IgdGhlIGxvbmcgZGVjbGFyYXRpb25cclxuLy8gc2xpY2VzIG91dCBvbmUgYmxvY2sgKGZyb20gTSB0byBNKSBhbmQgc3luY3Jvbml6ZSBpdCBzbyB0aGUgdHlwZXMgYW5kIGxlbmd0aCBtYXRjaFxyXG5mdW5jdGlvbiBoYW5kbGVCbG9jayhzdGFydEFyciwgc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNLCBkZXN0QXJyLCBkZXN0T2Zmc2V0TSwgZGVzdE9mZnNldE5leHRNLCB1bmRlZmluZWQpe1xyXG5cclxuICAvLyBzbGljZSBvdXQgdGhlIGJsb2NrIHdlIG5lZWRcclxuICB2YXIgc3RhcnRBcnJUZW1wID0gc3RhcnRBcnIuc2xpY2Uoc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNIHx8IHVuZGVmaW5lZClcclxuICAgICwgIGRlc3RBcnJUZW1wID0gIGRlc3RBcnIuc2xpY2UoIGRlc3RPZmZzZXRNLCAgZGVzdE9mZnNldE5leHRNIHx8IHVuZGVmaW5lZCk7XHJcblxyXG4gIHZhciBpID0gMFxyXG4gICAgLCBwb3NTdGFydCA9IHtwb3M6WzAsMF0sIHN0YXJ0OlswLDBdfVxyXG4gICAgLCBwb3NEZXN0ICA9IHtwb3M6WzAsMF0sIHN0YXJ0OlswLDBdfTtcclxuXHJcbiAgZG97XHJcblxyXG4gICAgLy8gY29udmVydCBzaG9ydGhhbmQgdHlwZXMgdG8gbG9uZyBmb3JtXHJcbiAgICBzdGFydEFyclRlbXBbaV0gPSBzaW1wbHlmeS5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pO1xyXG4gICAgIGRlc3RBcnJUZW1wW2ldID0gc2ltcGx5ZnkuY2FsbChwb3NEZXN0ICwgIGRlc3RBcnJUZW1wW2ldKTtcclxuXHJcbiAgICAvLyBjaGVjayBpZiBib3RoIHNoYXBlIHR5cGVzIG1hdGNoXHJcbiAgICAvLyAyIGVsbGlwdGljYWwgYXJjIGN1cnZlIGNvbW1hbmRzICgnQScpLCBhcmUgY29uc2lkZXJlZCBkaWZmZXJlbnQgaWYgdGhlXHJcbiAgICAvLyBmbGFncyAobGFyZ2UtYXJjLWZsYWcsIHN3ZWVwLWZsYWcpIGRvbid0IG1hdGNoXHJcbiAgICBpZihzdGFydEFyclRlbXBbaV1bMF0gIT0gZGVzdEFyclRlbXBbaV1bMF0gfHwgc3RhcnRBcnJUZW1wW2ldWzBdID09ICdNJyB8fFxyXG4gICAgICAgIChzdGFydEFyclRlbXBbaV1bMF0gPT0gJ0EnICYmXHJcbiAgICAgICAgICAoc3RhcnRBcnJUZW1wW2ldWzRdICE9IGRlc3RBcnJUZW1wW2ldWzRdIHx8IHN0YXJ0QXJyVGVtcFtpXVs1XSAhPSBkZXN0QXJyVGVtcFtpXVs1XSlcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG5cclxuICAgICAgLy8gaWYgbm90LCBjb252ZXJ0IHNoYXBlcyB0byBiZXppZXJlXHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RhcnRBcnJUZW1wLCBbaSwgMV0uY29uY2F0KHRvQmV6aWVyZS5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pKSk7XHJcbiAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGRlc3RBcnJUZW1wLCBbaSwgMV0uY29uY2F0KHRvQmV6aWVyZS5jYWxsKHBvc0Rlc3QsIGRlc3RBcnJUZW1wW2ldKSkpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBwb3NpdGlvbnMgb3RoZXJ3aXNlXHJcbiAgICAgIHN0YXJ0QXJyVGVtcFtpXSA9IHNldFBvc0FuZFJlZmxlY3Rpb24uY2FsbChwb3NTdGFydCwgc3RhcnRBcnJUZW1wW2ldKTtcclxuICAgICAgIGRlc3RBcnJUZW1wW2ldID0gc2V0UG9zQW5kUmVmbGVjdGlvbi5jYWxsKHBvc0Rlc3QgLCAgZGVzdEFyclRlbXBbaV0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBhcmUgYXQgdGhlIGVuZCBhdCBib3RoIGFycmF5cy4gc3RvcCBoZXJlXHJcbiAgICBpZigrK2kgPT0gc3RhcnRBcnJUZW1wLmxlbmd0aCAmJiBpID09IGRlc3RBcnJUZW1wLmxlbmd0aCkgYnJlYWtcclxuXHJcbiAgICAvLyBkZXN0QXJyYXkgaXMgbG9uZ2VyLiBBZGQgb25lIGVsZW1lbnRcclxuICAgIGlmKGkgPT0gc3RhcnRBcnJUZW1wLmxlbmd0aCl7XHJcbiAgICAgIHN0YXJ0QXJyVGVtcC5wdXNoKFtcclxuICAgICAgICAnQycsXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzBdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1sxXSxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzFdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1swXSxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0QXJyIGlzIGxvbmdlci4gQWRkIG9uZSBlbGVtZW50XHJcbiAgICBpZihpID09IGRlc3RBcnJUZW1wLmxlbmd0aCl7XHJcbiAgICAgIGRlc3RBcnJUZW1wLnB1c2goW1xyXG4gICAgICAgICdDJyxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXVxyXG4gICAgICBdKTtcclxuICAgIH1cclxuXHJcblxyXG4gIH13aGlsZSh0cnVlKVxyXG5cclxuICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgYmxvY2tcclxuICByZXR1cm4ge3N0YXJ0OnN0YXJ0QXJyVGVtcCwgZGVzdDpkZXN0QXJyVGVtcH1cclxufVxyXG5cclxuLy8gY29udmVydHMgc2hvcnRoYW5kIHR5cGVzIHRvIGxvbmcgZm9ybVxyXG5mdW5jdGlvbiBzaW1wbHlmeSh2YWwpe1xyXG5cclxuICBzd2l0Y2godmFsWzBdKXtcclxuICAgIGNhc2UgJ3onOiAvLyBzaG9ydGhhbmQgbGluZSB0byBzdGFydFxyXG4gICAgY2FzZSAnWic6XHJcbiAgICAgIHZhbFswXSA9ICdMJztcclxuICAgICAgdmFsWzFdID0gdGhpcy5zdGFydFswXTtcclxuICAgICAgdmFsWzJdID0gdGhpcy5zdGFydFsxXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ0gnOiAvLyBzaG9ydGhhbmQgaG9yaXpvbnRhbCBsaW5lXHJcbiAgICAgIHZhbFswXSA9ICdMJztcclxuICAgICAgdmFsWzJdID0gdGhpcy5wb3NbMV07XHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdWJzogLy8gc2hvcnRoYW5kIHZlcnRpY2FsIGxpbmVcclxuICAgICAgdmFsWzBdID0gJ0wnO1xyXG4gICAgICB2YWxbMl0gPSB2YWxbMV07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucG9zWzBdO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnVCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWMgYmV6aWVyZVxyXG4gICAgICB2YWxbMF0gPSAnUSc7XHJcbiAgICAgIHZhbFszXSA9IHZhbFsxXTtcclxuICAgICAgdmFsWzRdID0gdmFsWzJdO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnJlZmxlY3Rpb25bMV07XHJcbiAgICAgIHZhbFsyXSA9IHRoaXMucmVmbGVjdGlvblswXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyZVxyXG4gICAgICB2YWxbMF0gPSAnQyc7XHJcbiAgICAgIHZhbFs2XSA9IHZhbFs0XTtcclxuICAgICAgdmFsWzVdID0gdmFsWzNdO1xyXG4gICAgICB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgIHZhbFszXSA9IHZhbFsxXTtcclxuICAgICAgdmFsWzJdID0gdGhpcy5yZWZsZWN0aW9uWzFdO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnJlZmxlY3Rpb25bMF07XHJcbiAgICAgIGJyZWFrXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsXHJcblxyXG59XHJcblxyXG4vLyB1cGRhdGVzIHJlZmxlY3Rpb24gcG9pbnQgYW5kIGN1cnJlbnQgcG9zaXRpb25cclxuZnVuY3Rpb24gc2V0UG9zQW5kUmVmbGVjdGlvbih2YWwpe1xyXG5cclxuICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcclxuXHJcbiAgdGhpcy5wb3MgPSBbIHZhbFtsZW4tMl0sIHZhbFtsZW4tMV0gXTtcclxuXHJcbiAgaWYoJ1NDUVQnLmluZGV4T2YodmFsWzBdKSAhPSAtMSlcclxuICAgIHRoaXMucmVmbGVjdGlvbiA9IFsgMiAqIHRoaXMucG9zWzBdIC0gdmFsW2xlbi00XSwgMiAqIHRoaXMucG9zWzFdIC0gdmFsW2xlbi0zXSBdO1xyXG5cclxuICByZXR1cm4gdmFsXHJcbn1cclxuXHJcbi8vIGNvbnZlcnRzIGFsbCB0eXBlcyB0byBjdWJpYyBiZXppZXJlXHJcbmZ1bmN0aW9uIHRvQmV6aWVyZSh2YWwpe1xyXG4gIHZhciByZXRWYWwgPSBbdmFsXTtcclxuXHJcbiAgc3dpdGNoKHZhbFswXSl7XHJcbiAgICBjYXNlICdNJzogLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgTVxyXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSBbdmFsWzFdLCB2YWxbMl1dO1xyXG4gICAgICByZXR1cm4gcmV0VmFsXHJcbiAgICBjYXNlICdMJzpcclxuICAgICAgdmFsWzVdID0gdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICB2YWxbNl0gPSB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucG9zWzBdO1xyXG4gICAgICB2YWxbMl0gPSB0aGlzLnBvc1sxXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ1EnOlxyXG4gICAgICB2YWxbNl0gPSB2YWxbNF07XHJcbiAgICAgIHZhbFs1XSA9IHZhbFszXTtcclxuICAgICAgdmFsWzRdID0gdmFsWzRdICogMS8zICsgdmFsWzJdICogMi8zO1xyXG4gICAgICB2YWxbM10gPSB2YWxbM10gKiAxLzMgKyB2YWxbMV0gKiAyLzM7XHJcbiAgICAgIHZhbFsyXSA9IHRoaXMucG9zWzFdICogMS8zICsgdmFsWzJdICogMi8zO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnBvc1swXSAqIDEvMyArIHZhbFsxXSAqIDIvMztcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ0EnOlxyXG4gICAgICByZXRWYWwgPSBhcmNUb0JlemllcmUodGhpcy5wb3MsIHZhbCk7XHJcbiAgICAgIHZhbCA9IHJldFZhbFswXTtcclxuICAgICAgYnJlYWtcclxuICB9XHJcblxyXG4gIHZhbFswXSA9ICdDJztcclxuICB0aGlzLnBvcyA9IFt2YWxbNV0sIHZhbFs2XV07XHJcbiAgdGhpcy5yZWZsZWN0aW9uID0gWzIgKiB2YWxbNV0gLSB2YWxbM10sIDIgKiB2YWxbNl0gLSB2YWxbNF1dO1xyXG5cclxuICByZXR1cm4gcmV0VmFsXHJcblxyXG59XHJcblxyXG4vLyBmaW5kcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiB0eXBlIE1cclxuZnVuY3Rpb24gZmluZE5leHRNKGFyciwgb2Zmc2V0KXtcclxuXHJcbiAgaWYob2Zmc2V0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXHJcblxyXG4gIGZvcih2YXIgaSA9IG9mZnNldCwgbGVuID0gYXJyLmxlbmd0aDtpIDwgbGVuOysraSl7XHJcblxyXG4gICAgaWYoYXJyW2ldWzBdID09ICdNJykgcmV0dXJuIGlcclxuXHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuXHJcblxyXG4vLyBDb252ZXJ0IGFuIGFyYyBzZWdtZW50IGludG8gZXF1aXZhbGVudCBjdWJpYyBCZXppZXIgY3VydmVzXHJcbi8vIERlcGVuZGluZyBvbiB0aGUgYXJjLCB1cCB0byA0IGN1cnZlcyBtaWdodCBiZSB1c2VkIHRvIHJlcHJlc2VudCBpdCBzaW5jZSBhXHJcbi8vIGN1cnZlIGdpdmVzIGEgZ29vZCBhcHByb3hpbWF0aW9uIGZvciBvbmx5IGEgcXVhcnRlciBvZiBhbiBlbGxpcHNlXHJcbi8vIFRoZSBjdXJ2ZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIFNWRyBjdXJ2ZSBjb21tYW5kczpcclxuLy8gWyBbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0gLi4uIF1cclxuZnVuY3Rpb24gYXJjVG9CZXppZXJlKHBvcywgdmFsKSB7XHJcbiAgICAvLyBQYXJhbWV0ZXJzIGV4dHJhY3Rpb24sIGhhbmRsZSBvdXQtb2YtcmFuZ2UgcGFyYW1ldGVycyBhcyBzcGVjaWZpZWQgaW4gdGhlIFNWRyBzcGVjXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY091dE9mUmFuZ2VQYXJhbWV0ZXJzXHJcbiAgICB2YXIgcnggPSBNYXRoLmFicyh2YWxbMV0pLCByeSA9IE1hdGguYWJzKHZhbFsyXSksIHhBeGlzUm90YXRpb24gPSB2YWxbM10gJSAzNjBcclxuICAgICAgLCBsYXJnZUFyY0ZsYWcgPSB2YWxbNF0sIHN3ZWVwRmxhZyA9IHZhbFs1XSwgeCA9IHZhbFs2XSwgeSA9IHZhbFs3XVxyXG4gICAgICAsIEEgPSBuZXcgU1ZHLlBvaW50KHBvcyksIEIgPSBuZXcgU1ZHLlBvaW50KHgsIHkpXHJcbiAgICAgICwgcHJpbWVkQ29vcmQsIGxhbWJkYSwgbWF0LCBrLCBjLCBjU3F1YXJlLCB0LCBPLCBPQSwgT0IsIHRldGFTdGFydCwgdGV0YUVuZFxyXG4gICAgICAsIGRlbHRhVGV0YSwgbmJTZWN0b3JzLCBmLCBhcmNTZWdQb2ludHMsIGFuZ2xlLCBzaW5BbmdsZSwgY29zQW5nbGUsIHB0LCBpLCBpbFxyXG4gICAgICAsIHJldFZhbCA9IFtdLCB4MSwgeTEsIHgyLCB5MjtcclxuXHJcbiAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIG5vbi16ZXJvXHJcbiAgICBpZihyeCA9PT0gMCB8fCByeSA9PT0gMCB8fCAoQS54ID09PSBCLnggJiYgQS55ID09PSBCLnkpKSB7XHJcbiAgICAgIC8vIHRyZWF0IHRoaXMgYXJjIGFzIGEgc3RyYWlnaHQgbGluZSBzZWdtZW50XHJcbiAgICAgIHJldHVybiBbWydDJywgQS54LCBBLnksIEIueCwgQi55LCBCLngsIEIueV1dXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5zdXJlIHJhZGlpIGFyZSBsYXJnZSBlbm91Z2ggdXNpbmcgdGhlIGFsZ29yaXRobSBwcm92aWRlZCBpbiB0aGUgU1ZHIHNwZWNcclxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjQ29ycmVjdGlvbk91dE9mUmFuZ2VSYWRpaVxyXG4gICAgcHJpbWVkQ29vcmQgPSBuZXcgU1ZHLlBvaW50KChBLngtQi54KS8yLCAoQS55LUIueSkvMikudHJhbnNmb3JtKG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pKTtcclxuICAgIGxhbWJkYSA9IChwcmltZWRDb29yZC54ICogcHJpbWVkQ29vcmQueCkgLyAocnggKiByeCkgKyAocHJpbWVkQ29vcmQueSAqIHByaW1lZENvb3JkLnkpIC8gKHJ5ICogcnkpO1xyXG4gICAgaWYobGFtYmRhID4gMSkge1xyXG4gICAgICBsYW1iZGEgPSBNYXRoLnNxcnQobGFtYmRhKTtcclxuICAgICAgcnggPSBsYW1iZGEqcng7XHJcbiAgICAgIHJ5ID0gbGFtYmRhKnJ5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvIHNpbXBsaWZ5IGNhbGN1bGF0aW9ucywgd2UgbWFrZSB0aGUgYXJjIHBhcnQgb2YgYSB1bml0IGNpcmNsZSAocmF5b24gaXMgMSkgaW5zdGVhZCBvZiBhbiBlbGxpcHNlXHJcbiAgICBtYXQgPSBuZXcgU1ZHLk1hdHJpeCgpLnJvdGF0ZSh4QXhpc1JvdGF0aW9uKS5zY2FsZSgxL3J4LCAxL3J5KS5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG4gICAgQSA9IEEudHJhbnNmb3JtKG1hdCk7XHJcbiAgICBCID0gQi50cmFuc2Zvcm0obWF0KTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIGZpbmFsIHBvaW50IG9mIHRoZSBhcmNcclxuICAgIGsgPSBbQi54LUEueCwgQi55LUEueV07XHJcblxyXG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoIG9mIHRoZSBjaG9yZCBmb3JtZWQgYnkgQSBhbmQgQlxyXG4gICAgY1NxdWFyZSA9IGtbMF0qa1swXSArIGtbMV0qa1sxXTtcclxuICAgIGMgPSBNYXRoLnNxcnQoY1NxdWFyZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByYXRpb3Mgb2YgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpc3RhbmNlIG9uIHRoZSBsZW5ndGggb2YgdGhlIGNob3JkXHJcbiAgICBrWzBdIC89IGM7XHJcbiAgICBrWzFdIC89IGM7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjaXJjbGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnRcclxuICAgIC8vIHVzaW5nIHRoaXMgZm9ybXVsYTogdCA9IHNxcnQocl4yIC0gY14yIC8gNClcclxuICAgIC8vIHdoZXJlIHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNpcmxlIGNlbnRlciBhbmQgdGhlIGNob3JkIG1pZHBvaW50LFxyXG4gICAgLy8gICAgICAgciBpcyB0aGUgcmF5b24gb2YgdGhlIGNpcmNsZSBhbmQgYyBpcyB0aGUgY2hvcmQgbGVuZ3RoXHJcbiAgICAvLyBGcm9tOiBodHRwOi8vd3d3LmFqZGVzaWduZXIuY29tL3BocGNpcmNsZS9jaXJjbGVfc2VnbWVudF9jaG9yZF90LnBocFxyXG4gICAgLy8gQmVjYXVzZSBvZiB0aGUgaW1wcmVjaXNpb24gb2YgZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgY1NxdWFyZSBtaWdodCBlbmRcclxuICAgIC8vIHVwIGJlaW5nIHNsaWdodGx5IGFib3ZlIDQgd2hpY2ggd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgcmFkaWNhbmRcclxuICAgIC8vIFRvIHByZXZlbnQgdGhhdCwgYSB0ZXN0IGlzIG1hZGUgYmVmb3JlIGNvbXB1dGluZyB0aGUgc3F1YXJlIHJvb3RcclxuICAgIHQgPSAoY1NxdWFyZSA8IDQpID8gTWF0aC5zcXJ0KDEgLSBjU3F1YXJlLzQpIDogMDtcclxuXHJcbiAgICAvLyBGb3IgbW9zdCBzaXR1YXRpb25zLCB0aGVyZSBhcmUgYWN0dWFsbHkgdHdvIGRpZmZlcmVudCBlbGxpcHNlcyB0aGF0XHJcbiAgICAvLyBzYXRpc2Z5IHRoZSBjb25zdHJhaW50cyBpbXBvc2VkIGJ5IHRoZSBwb2ludHMgQSBhbmQgQiwgdGhlIHJhZGlpIHJ4IGFuZCByeSxcclxuICAgIC8vIGFuZCB0aGUgeEF4aXNSb3RhdGlvblxyXG4gICAgLy8gV2hlbiB0aGUgZmxhZ3MgbGFyZ2VBcmNGbGFnIGFuZCBzd2VlcEZsYWcgYXJlIGVxdWFsLCBpdCBtZWFucyB0aGF0IHRoZVxyXG4gICAgLy8gc2Vjb25kIGVsbGlwc2UgaXMgdXNlZCBhcyBhIHNvbHV0aW9uXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YUVsbGlwdGljYWxBcmNDb21tYW5kc1xyXG4gICAgaWYobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcpIHtcclxuICAgICAgICB0ICo9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGZyb20gdGhlIG1pZHBvaW50IG9mIHRoZSBjaG9yZFxyXG4gICAgLy8gVGhpcyBpcyBkb25lIGJ5IG11bHRpcGx5aW5nIHRoZSByYXRpb3MgY2FsY3VsYXRlZCBwcmV2aW91c2x5IGJ5IHRoZSBkaXN0YW5jZSBiZXR3ZWVuXHJcbiAgICAvLyB0aGUgY2lyY2xlIGNlbnRlciBhbmQgdGhlIGNob3JkIG1pZHBvaW50IGFuZCB1c2luZyB0aGVzZSB2YWx1ZXMgdG8gZ28gZnJvbSB0aGUgbWlkcG9pbnRcclxuICAgIC8vIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgLy8gVGhlIG5lZ2F0aXZlIG9mIHRoZSB2ZXJ0aWNhbCBkaXN0YW5jZSByYXRpbyBpcyB1c2VkIHRvIG1vZGlmeSB0aGUgeCBjb29yZGluYXRlIHdoaWxlXHJcbiAgICAvLyB0aGUgaG9yaXpvbnRhbCBkaXN0YW5jZSByYXRpbyBpcyB1c2VkIHRvIG1vZGlmeSB0aGUgeSBjb29yZGluYXRlXHJcbiAgICAvLyBUaGF0IGlzIGJlY2F1c2UgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGNob3JkIGFuZCBwZXJwZW5kaWN1bGFyXHJcbiAgICAvLyBsaW5lcyBhcmUgbmVnYXRpdmUgcmVjaXByb2NhbHNcclxuICAgIE8gPSBuZXcgU1ZHLlBvaW50KChCLngrQS54KS8yICsgdCota1sxXSwgKEIueStBLnkpLzIgKyB0KmtbMF0pO1xyXG4gICAgLy8gTW92ZSB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXQgdGhlIG9yaWdpblxyXG4gICAgT0EgPSBuZXcgU1ZHLlBvaW50KEEueC1PLngsIEEueS1PLnkpO1xyXG4gICAgT0IgPSBuZXcgU1ZHLlBvaW50KEIueC1PLngsIEIueS1PLnkpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZVxyXG4gICAgdGV0YVN0YXJ0ID0gTWF0aC5hY29zKE9BLngvTWF0aC5zcXJ0KE9BLngqT0EueCArIE9BLnkqT0EueSkpO1xyXG4gICAgaWYgKE9BLnkgPCAwKSB7XHJcbiAgICAgIHRldGFTdGFydCAqPSAtMTtcclxuICAgIH1cclxuICAgIHRldGFFbmQgPSBNYXRoLmFjb3MoT0IueC9NYXRoLnNxcnQoT0IueCpPQi54ICsgT0IueSpPQi55KSk7XHJcbiAgICBpZiAoT0IueSA8IDApIHtcclxuICAgICAgdGV0YUVuZCAqPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBzd2VlcC1mbGFnIGlzICcxJywgdGhlbiB0aGUgYXJjIHdpbGwgYmUgZHJhd24gaW4gYSBcInBvc2l0aXZlLWFuZ2xlXCIgZGlyZWN0aW9uLFxyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGVuZCBhbmdsZSBpcyBhYm92ZSB0aGUgc3RhcnQgYW5nbGVcclxuICAgIGlmIChzd2VlcEZsYWcgJiYgdGV0YVN0YXJ0ID4gdGV0YUVuZCkge1xyXG4gICAgICB0ZXRhRW5kICs9IDIqTWF0aC5QSTtcclxuICAgIH1cclxuICAgIC8vIElmIHN3ZWVwLWZsYWcgaXMgJzAnLCB0aGVuIHRoZSBhcmMgd2lsbCBiZSBkcmF3biBpbiBhIFwibmVnYXRpdmUtYW5nbGVcIiBkaXJlY3Rpb24sXHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZW5kIGFuZ2xlIGlzIGJlbG93IHRoZSBzdGFydCBhbmdsZVxyXG4gICAgaWYgKCFzd2VlcEZsYWcgJiYgdGV0YVN0YXJ0IDwgdGV0YUVuZCkge1xyXG4gICAgICB0ZXRhRW5kIC09IDIqTWF0aC5QSTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHRoZSBudW1iZXIgb2YgQmV6aWVyIGN1cnZlcyB0aGF0IGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgdGhlIGFyY1xyXG4gICAgLy8gQSBjdWJpYyBCZXppZXIgY3VydmUgZ2l2ZXMgYSBnb29kIGVub3VnaCBhcHByb3hpbWF0aW9uIHdoZW4gcmVwcmVzZW50aW5nIGF0IG1vc3QgYSBxdWFydGVyIG9mIGEgY2lyY2xlXHJcbiAgICBuYlNlY3RvcnMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGV0YVN0YXJ0LXRldGFFbmQpICogMi9NYXRoLlBJKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludHMgb2YgYWxsIHRoZSBCZXppZXIgY3VydmVzIHJlcXVpcmVkIHRvIHJlcHJlc2VudCB0aGUgYXJjXHJcbiAgICAvLyBGb3IgYW4gaW4tZGVwdGggZXhwbGFuYXRpb24gb2YgdGhpcyBwYXJ0IHNlZTogaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNjaXJjbGVzX2N1YmljXHJcbiAgICBhcmNTZWdQb2ludHMgPSBbXTtcclxuICAgIGFuZ2xlID0gdGV0YVN0YXJ0O1xyXG4gICAgZGVsdGFUZXRhID0gKHRldGFFbmQtdGV0YVN0YXJ0KS9uYlNlY3RvcnM7XHJcbiAgICBmID0gNCpNYXRoLnRhbihkZWx0YVRldGEvNCkvMztcclxuICAgIGZvciAoaSA9IDA7IGkgPD0gbmJTZWN0b3JzOyBpKyspIHsgLy8gVGhlIDw9IGlzIGJlY2F1c2UgYSBCZXppZXIgY3VydmUgaGF2ZSBhIHN0YXJ0IGFuZCBhIGVuZHBvaW50XHJcbiAgICAgIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgIHB0ID0gbmV3IFNWRy5Qb2ludChPLngrY29zQW5nbGUsIE8ueStzaW5BbmdsZSk7XHJcbiAgICAgIGFyY1NlZ1BvaW50c1tpXSA9IFtuZXcgU1ZHLlBvaW50KHB0LngrZipzaW5BbmdsZSwgcHQueS1mKmNvc0FuZ2xlKSwgcHQsIG5ldyBTVkcuUG9pbnQocHQueC1mKnNpbkFuZ2xlLCBwdC55K2YqY29zQW5nbGUpXTtcclxuXHJcbiAgICAgIGFuZ2xlICs9IGRlbHRhVGV0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGZpcnN0IHNlZ21lbnQgcG9pbnQgYW5kIHJlbW92ZSB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb2YgdGhlIGxhc3Qgc2VnbWVudCBwb2ludFxyXG4gICAgLy8gVGhlc2UgdHdvIGNvbnRyb2wgcG9pbnRzIGFyZSBub3QgdXNlZCBpbiB0aGUgYXBwcm94aW1hdGlvbiBvZiB0aGUgYXJjLCB0aGF0IGlzIHdoeSB0aGV5IGFyZSByZW1vdmVkXHJcbiAgICBhcmNTZWdQb2ludHNbMF1bMF0gPSBhcmNTZWdQb2ludHNbMF1bMV0uY2xvbmUoKTtcclxuICAgIGFyY1NlZ1BvaW50c1thcmNTZWdQb2ludHMubGVuZ3RoLTFdWzJdID0gYXJjU2VnUG9pbnRzW2FyY1NlZ1BvaW50cy5sZW5ndGgtMV1bMV0uY2xvbmUoKTtcclxuXHJcbiAgICAvLyBSZXZlcnQgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgd2FzIGFwcGxpZWQgdG8gbWFrZSB0aGUgYXJjIHBhcnQgb2YgYSB1bml0IGNpcmNsZSBpbnN0ZWFkIG9mIGFuIGVsbGlwc2VcclxuICAgIG1hdCA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pLnNjYWxlKHJ4LCByeSkucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcclxuICAgIGZvciAoaSA9IDAsIGlsID0gYXJjU2VnUG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgYXJjU2VnUG9pbnRzW2ldWzBdID0gYXJjU2VnUG9pbnRzW2ldWzBdLnRyYW5zZm9ybShtYXQpO1xyXG4gICAgICBhcmNTZWdQb2ludHNbaV1bMV0gPSBhcmNTZWdQb2ludHNbaV1bMV0udHJhbnNmb3JtKG1hdCk7XHJcbiAgICAgIGFyY1NlZ1BvaW50c1tpXVsyXSA9IGFyY1NlZ1BvaW50c1tpXVsyXS50cmFuc2Zvcm0obWF0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgc2VnbWVudHMgcG9pbnRzIHRvIFNWRyBjdXJ2ZSBjb21tYW5kc1xyXG4gICAgZm9yIChpID0gMSwgaWwgPSBhcmNTZWdQb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICBwdCA9IGFyY1NlZ1BvaW50c1tpLTFdWzJdO1xyXG4gICAgICB4MSA9IHB0Lng7XHJcbiAgICAgIHkxID0gcHQueTtcclxuXHJcbiAgICAgIHB0ID0gYXJjU2VnUG9pbnRzW2ldWzBdO1xyXG4gICAgICB4MiA9IHB0Lng7XHJcbiAgICAgIHkyID0gcHQueTtcclxuXHJcbiAgICAgIHB0ID0gYXJjU2VnUG9pbnRzW2ldWzFdO1xyXG4gICAgICB4ID0gcHQueDtcclxuICAgICAgeSA9IHB0Lnk7XHJcblxyXG4gICAgICByZXRWYWwucHVzaChbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXRWYWxcclxufVxyXG59KCkpO1xuXG4vKiEgc3ZnLmRyYWdnYWJsZS5qcyAtIHYyLjIuMSAtIDIwMTYtMDgtMjVcclxuKiBodHRwczovL2dpdGh1Yi5jb20vd291dC9zdmcuZHJhZ2dhYmxlLmpzXHJcbiogQ29weXJpZ2h0IChjKSAyMDE2IFdvdXQgRmllcmVuczsgTGljZW5zZWQgTUlUICovXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgLy8gY3JlYXRlcyBoYW5kbGVyLCBzYXZlcyBpdFxyXG4gIGZ1bmN0aW9uIERyYWdIYW5kbGVyKGVsKXtcclxuICAgIGVsLnJlbWVtYmVyKCdfZHJhZ2dhYmxlJywgdGhpcyk7XHJcbiAgICB0aGlzLmVsID0gZWw7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gU2V0cyBuZXcgcGFyYW1ldGVyLCBzdGFydHMgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIHZhbCl7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdGhpcy5jb25zdHJhaW50ID0gY29uc3RyYWludDtcclxuICAgIHRoaXMudmFsdWUgPSB2YWw7XHJcbiAgICB0aGlzLmVsLm9uKCdtb3VzZWRvd24uZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5zdGFydChlKTsgfSk7XHJcbiAgICB0aGlzLmVsLm9uKCd0b3VjaHN0YXJ0LmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuc3RhcnQoZSk7IH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIHRyYW5zZm9ybXMgb25lIHBvaW50IGZyb20gc2NyZWVuIHRvIHVzZXIgY29vcmRzXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24oZXZlbnQsIG9mZnNldCl7XHJcbiAgICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIHx8IGV2ZW50O1xyXG4gICAgICB0aGlzLnAueCA9IHRvdWNoZXMucGFnZVggLSAob2Zmc2V0IHx8IDApO1xyXG4gICAgICB0aGlzLnAueSA9IHRvdWNoZXMucGFnZVk7XHJcbiAgICAgIHJldHVybiB0aGlzLnAubWF0cml4VHJhbnNmb3JtKHRoaXMubSlcclxuICB9O1xyXG4gIFxyXG4gIC8vIGdldHMgZWxlbWVudHMgYm91bmRpbmcgYm94IHdpdGggc3BlY2lhbCBoYW5kbGluZyBvZiBncm91cHMsIG5lc3RlZCBhbmQgdXNlXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICBpZih0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLk5lc3RlZCkgYm94ID0gdGhpcy5lbC5yYm94KCk7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLkcgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5Vc2UgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIHtcclxuICAgICAgYm94LnggPSB0aGlzLmVsLngoKTtcclxuICAgICAgYm94LnkgPSB0aGlzLmVsLnkoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm94XHJcbiAgfTtcclxuXHJcbiAgLy8gc3RhcnQgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAvLyBjaGVjayBmb3IgbGVmdCBidXR0b25cclxuICAgIGlmKGUudHlwZSA9PSAnY2xpY2snfHwgZS50eXBlID09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PSAnbW91c2Vtb3ZlJyl7XHJcbiAgICAgIGlmKChlLndoaWNoIHx8IGUuYnV0dG9ucykgIT0gMSl7XHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAvLyBmaXJlIGJlZm9yZWRyYWcgZXZlbnRcclxuICAgIHRoaXMuZWwuZmlyZSgnYmVmb3JlZHJhZycsIHsgZXZlbnQ6IGUsIGhhbmRsZXI6IHRoaXMgfSk7XHJcblxyXG4gICAgLy8gc2VhcmNoIGZvciBwYXJlbnQgb24gdGhlIGZseSB0byBtYWtlIHN1cmUgd2UgY2FuIGNhbGxcclxuICAgIC8vIGRyYWdnYWJsZSgpIGV2ZW4gd2hlbiBlbGVtZW50IGlzIG5vdCBpbiB0aGUgZG9tIGN1cnJlbnRseVxyXG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLmVsLnBhcmVudChTVkcuTmVzdGVkKSB8fCB0aGlzLmVsLnBhcmVudChTVkcuRG9jKTtcclxuICAgIHRoaXMucCA9IHRoaXMucGFyZW50Lm5vZGUuY3JlYXRlU1ZHUG9pbnQoKTtcclxuXHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICB0aGlzLm0gPSB0aGlzLmVsLm5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xyXG5cclxuICAgIHZhciBib3ggPSB0aGlzLmdldEJCb3goKTtcclxuICAgIFxyXG4gICAgdmFyIGFuY2hvck9mZnNldDtcclxuICAgIFxyXG4gICAgLy8gZml4IHRleHQtYW5jaG9yIGluIHRleHQtZWxlbWVudCAoIzM3KVxyXG4gICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5UZXh0KXtcclxuICAgICAgYW5jaG9yT2Zmc2V0ID0gdGhpcy5lbC5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIFxyXG4gICAgICBzd2l0Y2godGhpcy5lbC5hdHRyKCd0ZXh0LWFuY2hvcicpKXtcclxuICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0IC89IDI7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnN0YXJ0UG9pbnRzID0ge1xyXG4gICAgICAvLyBXZSB0YWtlIGFic29sdXRlIGNvb3JkaW5hdGVzIHNpbmNlIHdlIGFyZSBqdXN0IHVzaW5nIGEgZGVsdGEgaGVyZVxyXG4gICAgICBwb2ludDogdGhpcy50cmFuc2Zvcm1Qb2ludChlLCBhbmNob3JPZmZzZXQpLFxyXG4gICAgICBib3g6ICAgYm94LFxyXG4gICAgICB0cmFuc2Zvcm06IHRoaXMuZWwudHJhbnNmb3JtKClcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIGFkZCBkcmFnIGFuZCBlbmQgZXZlbnRzIHRvIHdpbmRvd1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNlbW92ZS5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmRyYWcoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNobW92ZS5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmRyYWcoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNldXAuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNoZW5kLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZW5kKGUpOyB9KTtcclxuXHJcbiAgICAvLyBmaXJlIGRyYWdzdGFydCBldmVudFxyXG4gICAgdGhpcy5lbC5maXJlKCdkcmFnc3RhcnQnLCB7ZXZlbnQ6IGUsIHA6IHRoaXMuc3RhcnRQb2ludHMucG9pbnQsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpc30pO1xyXG5cclxuICAgIC8vIHByZXZlbnQgYnJvd3NlciBkcmFnIGJlaGF2aW9yXHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gcHJldmVudCBwcm9wYWdhdGlvbiB0byBhIHBhcmVudCB0aGF0IG1pZ2h0IGFsc28gaGF2ZSBkcmFnZ2luZyBlbmFibGVkXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIC8vIHdoaWxlIGRyYWdnaW5nXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICB2YXIgYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgICAgLCBwICAgPSB0aGlzLnRyYW5zZm9ybVBvaW50KGUpXHJcbiAgICAgICwgeCAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueCArIHAueCAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueFxyXG4gICAgICAsIHkgICA9IHRoaXMuc3RhcnRQb2ludHMuYm94LnkgKyBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnlcclxuICAgICAgLCBjICAgPSB0aGlzLmNvbnN0cmFpbnRcclxuICAgICAgLCBneCAgPSBwLnggLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnhcclxuICAgICAgLCBneSAgPSBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50Lnk7XHJcbiAgICAgIFxyXG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdkcmFnbW92ZScsIHtcclxuICAgICAgICBkZXRhaWw6IHtcclxuICAgICAgICAgICAgZXZlbnQ6IGVcclxuICAgICAgICAgICwgcDogcFxyXG4gICAgICAgICAgLCBtOiB0aGlzLm1cclxuICAgICAgICAgICwgaGFuZGxlcjogdGhpc1xyXG4gICAgICAgIH1cclxuICAgICAgLCBjYW5jZWxhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgICAgXHJcbiAgICB0aGlzLmVsLmZpcmUoZXZlbnQpO1xyXG4gICAgXHJcbiAgICBpZihldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gcFxyXG5cclxuICAgIC8vIG1vdmUgdGhlIGVsZW1lbnQgdG8gaXRzIG5ldyBwb3NpdGlvbiwgaWYgcG9zc2libGUgYnkgY29uc3RyYWludFxyXG4gICAgaWYgKHR5cGVvZiBjID09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgIHZhciBjb29yZCA9IGMuY2FsbCh0aGlzLmVsLCB4LCB5LCB0aGlzLm0pO1xyXG5cclxuICAgICAgLy8gYm9vbCwganVzdCBzaG93IHVzIGlmIG1vdmVtZW50IGlzIGFsbG93ZWQgb3Igbm90XHJcbiAgICAgIGlmICh0eXBlb2YgY29vcmQgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgY29vcmQgPSB7XHJcbiAgICAgICAgICB4OiBjb29yZCxcclxuICAgICAgICAgIHk6IGNvb3JkXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgdHJ1ZSwgd2UganVzdCBtb3ZlLiBJZiAhZmFsc2UgaXRzIGEgbnVtYmVyIGFuZCB3ZSBtb3ZlIGl0IHRoZXJlXHJcbiAgICAgIGlmIChjb29yZC54ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5lbC54KHgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5lbC54KGNvb3JkLngpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29vcmQueSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuZWwueSh5KTtcclxuICAgICAgfSBlbHNlIGlmIChjb29yZC55ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuZWwueShjb29yZC55KTtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGMgPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICAgIGlmIChjLm1pblggIT0gbnVsbCAmJiB4IDwgYy5taW5YKVxyXG4gICAgICAgIHggPSBjLm1pblg7XHJcbiAgICAgIGVsc2UgaWYgKGMubWF4WCAhPSBudWxsICYmIHggPiBjLm1heFggLSBib3gud2lkdGgpe1xyXG4gICAgICAgIHggPSBjLm1heFggLSBib3gud2lkdGg7XHJcbiAgICAgIH1pZiAoYy5taW5ZICE9IG51bGwgJiYgeSA8IGMubWluWSlcclxuICAgICAgICB5ID0gYy5taW5ZO1xyXG4gICAgICBlbHNlIGlmIChjLm1heFkgIT0gbnVsbCAmJiB5ID4gYy5tYXhZIC0gYm94LmhlaWdodClcclxuICAgICAgICB5ID0gYy5tYXhZIC0gYm94LmhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5HKVxyXG4gICAgICAgIHRoaXMuZWwubWF0cml4KHRoaXMuc3RhcnRQb2ludHMudHJhbnNmb3JtKS50cmFuc2Zvcm0oe3g6Z3gsIHk6IGd5fSwgdHJ1ZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmVsLm1vdmUoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIHNvIHdlIGNhbiB1c2UgaXQgaW4gdGhlIGVuZC1tZXRob2QsIHRvb1xyXG4gICAgcmV0dXJuIHBcclxuICB9O1xyXG5cclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZSl7XHJcblxyXG4gICAgLy8gZmluYWwgZHJhZ1xyXG4gICAgdmFyIHAgPSB0aGlzLmRyYWcoZSk7XHJcblxyXG4gICAgLy8gZmlyZSBkcmFnZW5kIGV2ZW50XHJcbiAgICB0aGlzLmVsLmZpcmUoJ2RyYWdlbmQnLCB7IGV2ZW50OiBlLCBwOiBwLCBtOiB0aGlzLm0sIGhhbmRsZXI6IHRoaXMgfSk7XHJcblxyXG4gICAgLy8gdW5iaW5kIGV2ZW50c1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZW1vdmUuZHJhZycpO1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUuZHJhZycpO1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZXVwLmRyYWcnKTtcclxuICAgIFNWRy5vZmYod2luZG93LCAndG91Y2hlbmQuZHJhZycpO1xyXG5cclxuICB9O1xyXG5cclxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgICAvLyBNYWtlIGVsZW1lbnQgZHJhZ2dhYmxlXHJcbiAgICAvLyBDb25zdHJhaW50IG1pZ2h0IGJlIGFuIG9iamVjdCAoYXMgZGVzY3JpYmVkIGluIHJlYWRtZS5tZCkgb3IgYSBmdW5jdGlvbiBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uICh4LCB5KVwiIHRoYXQgZ2V0cyBjYWxsZWQgYmVmb3JlIGV2ZXJ5IG1vdmUuXHJcbiAgICAvLyBUaGUgZnVuY3Rpb24gY2FuIHJldHVybiBhIGJvb2xlYW4gb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIHt4LCB5fSwgdG8gd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBiZSBtb3ZlZC4gXCJGYWxzZVwiIHNraXBzIG1vdmluZywgdHJ1ZSBtb3ZlcyB0byByYXcgeCwgeS5cclxuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24odmFsdWUsIGNvbnN0cmFpbnQpIHtcclxuXHJcbiAgICAgIC8vIENoZWNrIHRoZSBwYXJhbWV0ZXJzIGFuZCByZWFzc2lnbiBpZiBuZWVkZWRcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0cmFpbnQgPSB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkcmFnSGFuZGxlciA9IHRoaXMucmVtZW1iZXIoJ19kcmFnZ2FibGUnKSB8fCBuZXcgRHJhZ0hhbmRsZXIodGhpcyk7XHJcblxyXG4gICAgICAvLyBXaGVuIG5vIHBhcmFtZXRlciBpcyBnaXZlbiwgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogdmFsdWU7XHJcblxyXG4gICAgICBpZih2YWx1ZSkgZHJhZ0hhbmRsZXIuaW5pdChjb25zdHJhaW50IHx8IHt9LCB2YWx1ZSk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24uZHJhZycpO1xyXG4gICAgICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0LmRyYWcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KS5jYWxsKHVuZGVmaW5lZCk7XG5cbihmdW5jdGlvbigpIHtcblxuZnVuY3Rpb24gU2VsZWN0SGFuZGxlcihlbCkge1xyXG5cclxuICAgIHRoaXMuZWwgPSBlbDtcclxuICAgIGVsLnJlbWVtYmVyKCdfc2VsZWN0SGFuZGxlcicsIHRoaXMpO1xyXG4gICAgdGhpcy5wb2ludFNlbGVjdGlvbiA9IHtpc1NlbGVjdGVkOiBmYWxzZX07XHJcbiAgICB0aGlzLnJlY3RTZWxlY3Rpb24gPSB7aXNTZWxlY3RlZDogZmFsc2V9O1xyXG5cclxufVxyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAvLyBNZXJnaW5nIHRoZSBkZWZhdWx0cyBhbmQgdGhlIG9wdGlvbnMtb2JqZWN0IHRvZ2V0aGVyXHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuZWwuc2VsZWN0aXplLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gdGhpcy5lbC5zZWxlY3RpemUuZGVmYXVsdHNbaV07XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMuZWwucGFyZW50KCk7XHJcbiAgICB0aGlzLm5lc3RlZCA9ICh0aGlzLm5lc3RlZCB8fCB0aGlzLnBhcmVudC5ncm91cCgpKTtcclxuICAgIHRoaXMubmVzdGVkLm1hdHJpeChuZXcgU1ZHLk1hdHJpeCh0aGlzLmVsKS50cmFuc2xhdGUoYmJveC54LCBiYm94LnkpKTtcclxuXHJcbiAgICAvLyBXaGVuIGRlZXBTZWxlY3QgaXMgZW5hYmxlZCBhbmQgdGhlIGVsZW1lbnQgaXMgYSBsaW5lL3BvbHlsaW5lL3BvbHlnb24sIGRyYXcgb25seSBwb2ludHMgZm9yIG1vdmluZ1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwU2VsZWN0ICYmIFsnbGluZScsICdwb2x5bGluZScsICdwb2x5Z29uJ10uaW5kZXhPZih0aGlzLmVsLnR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0UG9pbnRzKHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RSZWN0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9ic2VydmUoKTtcclxuICAgIHRoaXMuY2xlYW51cCgpO1xyXG5cclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdFBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIFdoZW4gc2V0IGlzIGFscmVhZHkgdGhlcmUgd2UgZG9udCBoYXZlIHRvIGNyZWF0ZSBvbmVcclxuICAgIGlmICh0aGlzLnBvaW50U2VsZWN0aW9uLnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBvdXIgc2V0IG9mIGVsZW1lbnRzXHJcbiAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldCA9IHRoaXMucGFyZW50LnNldCgpO1xyXG4gICAgLy8gZHJhdyB0aGUgY2lyY2xlcyBhbmQgbWFyayB0aGUgZWxlbWVudCBhcyBzZWxlY3RlZFxyXG4gICAgdGhpcy5kcmF3Q2lyY2xlcygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIGNyZWF0ZSB0aGUgcG9pbnQtYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIDIgcG9pbnRzIG9mIGEgbGluZSBvciBzaW1wbHkgdGhlIHBvaW50cy1hcnJheSBvZiBwb2x5bGluZS9wb2x5Z29uXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmdldFBvaW50QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVsLmFycmF5KCkudmFsdWVPZigpLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICByZXR1cm4gW2VsWzBdIC0gYmJveC54LCBlbFsxXSAtIGJib3gueV07XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8vIFRoZSBmdW5jdGlvbiB0byBkcmF3IHRoZSBjaXJjbGVzXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmRyYXdDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXMsIGFycmF5ID0gdGhpcy5nZXRQb2ludEFycmF5KCk7XHJcblxyXG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgb2YgcG9pbnRzXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHJcbiAgICAgICAgdmFyIGN1cnJpZWRFdmVudCA9IChmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lbC5maXJlKCdwb2ludCcsIHt4OiB4LCB5OiB5LCBpOiBrLCBldmVudDogZXZ9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KShpKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGV2ZXJ5IHBvaW50IHRvIHRoZSBzZXRcclxuICAgICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5hZGQoXHJcbiAgICAgICAgICAgIC8vIGEgY2lyY2xlIHdpdGggb3VyIGNzcy1jbGFzc2VzIGFuZCBhIHRvdWNoc3RhcnQtZXZlbnQgd2hpY2ggZmlyZXMgb3VyIGV2ZW50IGZvciBtb3ZpbmcgcG9pbnRzXHJcbiAgICAgICAgICAgIHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmNlbnRlcihhcnJheVtpXVswXSwgYXJyYXlbaV1bMV0pXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcG9pbnQnKVxyXG4gICAgICAgICAgICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgY3VycmllZEV2ZW50KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBjdXJyaWVkRXZlbnQpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBldmVyeSB0aW1lIGEgY2lyY2xlIGlzIG1vdmVkLCB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIG91ciBjaXJjbGVcclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUG9pbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmdldFBvaW50QXJyYXkoKTtcclxuXHJcbiAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3goKSA9PT0gYXJyYXlbaV1bMF0gJiYgdGhpcy5jeSgpID09PSBhcnJheVtpXVsxXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2VudGVyKGFycmF5W2ldWzBdLCBhcnJheVtpXVsxXSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVJlY3RTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDApLmF0dHIoe1xyXG4gICAgICAgIHdpZHRoOiBiYm94LndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNldC5nZXQoMSkgaXMgYWx3YXlzIGluIHRoZSB1cHBlciBsZWZ0IGNvcm5lci4gbm8gbmVlZCB0byBtb3ZlIGl0XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnBvaW50cykge1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDIpLmNlbnRlcihiYm94LndpZHRoLCAwKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgzKS5jZW50ZXIoYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDQpLmNlbnRlcigwLCBiYm94LmhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDUpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgMCk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNikuY2VudGVyKGJib3gud2lkdGgsIGJib3guaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNykuY2VudGVyKGJib3gud2lkdGggLyAyLCBiYm94LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoOCkuY2VudGVyKDAsIGJib3guaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGlvblBvaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoOSkuY2VudGVyKGJib3gud2lkdGggLyAyLCAyMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMSkuY2VudGVyKGJib3gud2lkdGggLyAyLCAyMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuc2VsZWN0UmVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXMsIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICB0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIHdoZW4gc2V0IGlzIGFscmVhZHkgcFxyXG4gICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldCA9IHRoaXMucmVjdFNlbGVjdGlvbi5zZXQgfHwgdGhpcy5wYXJlbnQuc2V0KCk7XHJcblxyXG4gICAgLy8gaGVscGVyRnVuY3Rpb24gdG8gY3JlYXRlIGEgbW91c2UtZG93biBmdW5jdGlvbiB3aGljaCB0cmlnZ2VycyB0aGUgZXZlbnQgc3BlY2lmaWVkIGluIGBldmVudE5hbWVgXHJcbiAgICBmdW5jdGlvbiBnZXRNb3NlRG93bkZ1bmMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogZXYucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZXYucGFnZVkgfHwgZXYudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuZmlyZShldmVudE5hbWUsIHt4OiB4LCB5OiB5LCBldmVudDogZXZ9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgc2VsZWN0aW9uLXJlY3RhbmdsZSBhbmQgYWRkIHRoZSBjc3MtY2xhc3NcclxuICAgIGlmICghdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMCkpIHtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5yZWN0KGJib3gud2lkdGgsIGJib3guaGVpZ2h0KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NSZWN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBQb2ludHMgYXQgdGhlIGVkZ2VzLCBpZiBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnBvaW50cyAmJiAhdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMSkpIHtcclxuICAgICAgICB2YXIgZW5hbWUgPVwidG91Y2hzdGFydFwiLCBtbmFtZSA9IFwibW91c2Vkb3duXCI7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcigwLCAwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfbHQnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsdCcpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsdCcpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoLCAwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcnQnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdydCcpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdydCcpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoLCBiYm94LmhlaWdodCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX3JiJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygncmInKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygncmInKSkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoMCwgYmJveC5oZWlnaHQpLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19sYicpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2xiJykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2xiJykpKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgMCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX3QnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCd0JykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3QnKSkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoYmJveC53aWR0aCwgYmJveC5oZWlnaHQgLyAyKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcicpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3InKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygncicpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgYmJveC5oZWlnaHQpLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19iJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygnYicpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdiJykpKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKDAsIGJib3guaGVpZ2h0IC8gMikuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX2wnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsJykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2wnKSkpO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKF90aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYXcgcm90YXRpb25QaW50LCBpZiBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uUG9pbnQgJiYgKCh0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg5KSkgfHwgKCF0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgxKSkpKSB7XHJcblxyXG4gICAgICAgIHZhciBjdXJyaWVkRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgZXYgPSBldiB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBldi5wYWdlWCB8fCBldi50b3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsLmZpcmUoJ3JvdCcsIHt4OiB4LCB5OiB5LCBldmVudDogZXZ9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIDIwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcm90JylcclxuICAgICAgICAgICAgLm9uKFwidG91Y2hzdGFydFwiLCBjdXJyaWVkRXZlbnQpLm9uKFwibW91c2Vkb3duXCIsIGN1cnJpZWRFdmVudCkpO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcbiAgICB0aGlzLm5lc3RlZC5tYXRyaXgobmV3IFNWRy5NYXRyaXgodGhpcy5lbCkudHJhbnNsYXRlKGJib3gueCwgYmJveC55KSk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZWN0U2VsZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnRTZWxlY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBpZiAoTXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCB8fCB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckluc3QgPSB0aGlzLm9ic2VydmVySW5zdCB8fCBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdC5vYnNlcnZlKHRoaXMuZWwubm9kZSwge2F0dHJpYnV0ZXM6IHRydWV9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlckluc3QuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJJbnN0O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdET01BdHRyTW9kaWZpZWQuc2VsZWN0Jyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCB8fCB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5vbignRE9NQXR0ck1vZGlmaWVkLnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvL3ZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0KSB7XHJcbiAgICAgICAgLy8gc3RvcCB3YXRjaGluZyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmNsZWFyKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQgJiYgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHBvaW50cywgY2xlYXIgdGhlIHNldCwgc3RvcCB3YXRjaGluZyB0aGUgZWxlbWVudFxyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5jbGVhcigpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBvaW50U2VsZWN0aW9uLnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiAhdGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLm5lc3RlZC5yZW1vdmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWQ7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgIC8vIFNlbGVjdCBlbGVtZW50IHdpdGggbW91c2VcclxuICAgIHNlbGVjdGl6ZTogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXJhbWV0ZXJzIGFuZCByZWFzc2lnbiBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzZWxlY3RIYW5kbGVyID0gdGhpcy5yZW1lbWJlcignX3NlbGVjdEhhbmRsZXInKSB8fCBuZXcgU2VsZWN0SGFuZGxlcih0aGlzKTtcclxuXHJcbiAgICAgICAgc2VsZWN0SGFuZGxlci5pbml0KHZhbHVlID09PSB1bmRlZmluZWQgPyB0cnVlIDogdmFsdWUsIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuU1ZHLkVsZW1lbnQucHJvdG90eXBlLnNlbGVjdGl6ZS5kZWZhdWx0cyA9IHtcclxuICAgIHBvaW50czogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgcG9pbnRzIGF0IHRoZSBlZGdlcyBhcmUgZHJhd24uIE5lZWRlZCBmb3IgcmVzaXplIVxyXG4gICAgY2xhc3NSZWN0OiAnc3ZnX3NlbGVjdF9ib3VuZGluZ1JlY3QnLCAgICAvLyBDc3MtY2xhc3MgYWRkZWQgdG8gdGhlIHJlY3RcclxuICAgIGNsYXNzUG9pbnRzOiAnc3ZnX3NlbGVjdF9wb2ludHMnLCAgICAgICAgLy8gQ3NzLWNsYXNzIGFkZGVkIHRvIHRoZSBwb2ludHNcclxuICAgIHJhZGl1czogNywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFkaXVzIG9mIHRoZSBwb2ludHNcclxuICAgIHJvdGF0aW9uUG9pbnQ6IHRydWUsICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgcm90YXRpb24gcG9pbnQgaXMgZHJhd24uIE5lZWRlZCBmb3Igcm90YXRpb24hXHJcbiAgICBkZWVwU2VsZWN0OiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRydWUsIG1vdmluZyBvZiBzaW5nbGUgcG9pbnRzIGlzIHBvc3NpYmxlIChvbmx5IGxpbmUsIHBvbHlsaW5lLCBwb2x5b24pXHJcbn07XG59KCkpO1xuXG4oZnVuY3Rpb24oKSB7XG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoZWwpIHtcclxuXHJcbiAgICAgICAgZWwucmVtZW1iZXIoJ19yZXNpemVIYW5kbGVyJywgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVDYWxsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnAgPSBlbC5kb2MoKS5ub2RlLmNyZWF0ZVNWR1BvaW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtKXtcclxuXHJcbiAgICAgICAgdGhpcy5wLnggPSB4IC0gKHRoaXMub2Zmc2V0LnggLSB3aW5kb3cucGFnZVhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMucC55ID0geSAtICh0aGlzLm9mZnNldC55IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucC5tYXRyaXhUcmFuc2Zvcm0obSB8fCB0aGlzLm0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuX2V4dHJhY3RQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gRXh0cmFjdCBhIHBvc2l0aW9uIGZyb20gYSBtb3VzZS90b3VjaCBldmVudC5cclxuICAgICAgICAvLyBSZXR1cm5zIHsgeDogLi4sIHk6IC4uIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYICE9IG51bGwgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxyXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZICE9IG51bGwgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSAnc3RvcCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcblxyXG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnMgYW5kIGRlZmF1bHRzXHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmVsLnJlc2l6ZS5kZWZhdWx0cykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSB0aGlzLmVsLnJlc2l6ZS5kZWZhdWx0c1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2UgbGlzdGVuIHRvIGFsbCB0aGVzZSBldmVudHMgd2hpY2ggYXJlIHNwZWNpZnlpbmcgZGlmZmVyZW50IGVkZ2VzXHJcbiAgICAgICAgdGhpcy5lbC5vbignbHQucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgLy8gTGVmdC1Ub3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdydC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBSaWdodC1Ub3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdyYi5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBSaWdodC1Cb3R0b21cclxuICAgICAgICB0aGlzLmVsLm9uKCdsYi5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBMZWZ0LUJvdHRvbVxyXG5cclxuICAgICAgICB0aGlzLmVsLm9uKCd0LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBUb3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdyLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBSaWdodFxyXG4gICAgICAgIHRoaXMuZWwub24oJ2IucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIEJvdHRvbVxyXG4gICAgICAgIHRoaXMuZWwub24oJ2wucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIExlZnRcclxuXHJcbiAgICAgICAgdGhpcy5lbC5vbigncm90LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgLy8gUm90YXRpb25cclxuXHJcbiAgICAgICAgdGhpcy5lbC5vbigncG9pbnQucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAvLyBQb2ludC1Nb3ZpbmdcclxuXHJcbiAgICAgICAgLy8gVGhpcyBjYWxsIGVuc3VyZXMsIHRoYXQgdGhlIHBsdWdpbiByZWFjdHMgdG8gYSBjaGFuZ2Ugb2Ygc25hcFRvR3JpZCBpbW1lZGlhdGVseVxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmVsLm9mZignbHQucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ3J0LnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdyYi5yZXNpemUnKTtcclxuICAgICAgICB0aGlzLmVsLm9mZignbGIucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwub2ZmKCd0LnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdyLnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdiLnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdsLnJlc2l6ZScpO1xyXG5cclxuICAgICAgICB0aGlzLmVsLm9mZigncm90LnJlc2l6ZScpO1xyXG5cclxuICAgICAgICB0aGlzLmVsLm9mZigncG9pbnQucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5tID0gdGhpcy5lbC5ub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfTtcclxuXHJcbiAgICAgICAgdmFyIHR4UHQgPSB0aGlzLl9leHRyYWN0UG9zaXRpb24oZXZlbnQuZGV0YWlsLmV2ZW50KTtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZWwudHlwZSwgLy8gdGhlIHR5cGUgb2YgZWxlbWVudFxyXG4gICAgICAgICAgICBwOiB0aGlzLnRyYW5zZm9ybVBvaW50KHR4UHQueCwgdHhQdC55KSxcclxuICAgICAgICAgICAgeDogZXZlbnQuZGV0YWlsLngsICAgICAgLy8geC1wb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2hlbiByZXNpemluZyBzdGFydGVkXHJcbiAgICAgICAgICAgIHk6IGV2ZW50LmRldGFpbC55LCAgICAgIC8vIHktcG9zaXRpb24gb2YgdGhlIG1vdXNlIHdoZW4gcmVzaXppbmcgc3RhcnRlZFxyXG4gICAgICAgICAgICBib3g6IHRoaXMuZWwuYmJveCgpLCAgICAvLyBUaGUgYm91bmRpbmctYm94IG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmVsLnRyYW5zZm9ybSgpLnJvdGF0aW9uICAvLyBUaGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGUgZWxlbWVudFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFkZCBmb250LXNpemUgcGFyYW1ldGVyIGlmIHRoZSBlbGVtZW50IHR5cGUgaXMgdGV4dFxyXG4gICAgICAgIGlmICh0aGlzLmVsLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSA9IHRoaXMuZWwuYXR0cigpW1wiZm9udC1zaXplXCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlIGktcGFyYW0gaW4gdGhlIGV2ZW50IGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgd2hpY2ggaXMgbW92ZWQsIHdoZW4gdXNpbmcgYGRlZXBTZWxlY3RgXHJcbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5pICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcG9pbnQgYXJyYXlcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5lbC5hcnJheSgpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGluZGV4IGFuZCB0aGUgcG9pbnQgd2hpY2ggaXMgbW92ZWRcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmkgPSBldmVudC5kZXRhaWwuaTtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzID0gW2FycmF5W2V2ZW50LmRldGFpbC5pXVswXSwgYXJyYXlbZXZlbnQuZGV0YWlsLmldWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExldHMgY2hlY2sgd2hpY2ggZWRnZSBvZiB0aGUgYm91bmRpbmctYm94IHdhcyBjbGlja2VkIGFuZCByZXNpemUgdGhlIHRoaXMuZWwgYWNjb3JkaW5nIHRvIHRoaXNcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIExlZnQtVG9wLUVkZ2VcclxuICAgICAgICAgICAgY2FzZSAnbHQnOlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgYnVpbGQgYSBjYWxjdWxhdGluZyBmdW5jdGlvbiBmb3IgZXZlcnkgY2FzZSB3aGljaCBnaXZlcyB1cyB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSB0aGlzLmVsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb2NlZHVyZSBpcyBhbHdheXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB3ZSBzbmFwIHRoZSBlZGdlIHRvIHRoZSBnaXZlbiBncmlkIChzbmFwcGluZyB0byAxcHggZ3JpZCBpcyBub3JtYWwgcmVzaXppbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGNoZWNrIGlmIHRoZSBuZXcgaGVpZ2h0IGFuZCB3aWR0aCBzdGlsbCB2YWxpZCAoPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pZiB2YWxpZCwgd2UgcmVzaXplIHRoZSB0aGlzLmVsICh3aGljaCBjYW4gaW5jbHVkZSBtb3ZpbmcgYmVjYXVzZSB0aGUgY29vcmQtc3lzdGVtIHN0YXJ0cyBhdCB0aGUgbGVmdC10b3AgYW5kIHRoaXMgZWRnZSBpcyBtb3Zpbmcgc29tZXRpbWVzIHdoZW4gcmVzaXplZClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dCBmaXJzdCBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyB0ZXh0IGJveCwgc28gd2UgY2FuIGNoYW5nZSB0aGUgZm9udCBzaXplIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgLSBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBzbmFwWzFdKS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0LVRvcFxyXG4gICAgICAgICAgICBjYXNlICdydCc6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxIDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgKyBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSArIHNuYXBbMV0pLnNpemUodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gUmlnaHQtQm90dG9tXHJcbiAgICAgICAgICAgIGNhc2UgJ3JiJzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgKyBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSkuc2l6ZSh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBMZWZ0LUJvdHRvbVxyXG4gICAgICAgICAgICBjYXNlICdsYic6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0gPiAwICYmIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0ICsgc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3gueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmF0dHIoXCJmb250LXNpemVcIiwgdGhpcy5wYXJhbWV0ZXJzLmZvbnRTaXplIC0gc25hcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXAgPSB0aGlzLmNoZWNrQXNwZWN0UmF0aW8oc25hcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFRvcFxyXG4gICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDEgPDwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgZm9udC1yZXNpemluZyBpZiBpdCBpcyBub3QgZnJvbSB0aGUgY29ybmVyIG9mIGJvdW5kaW5nLWJveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSArIHNuYXBbMV0pLmhlaWdodCh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSkud2lkdGgodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIEJvdHRvbVxyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5oZWlnaHQodGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBMZWZ0XHJcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLndpZHRoKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGlvblxyXG4gICAgICAgICAgICBjYXNlICdyb3QnOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB5ZXMgdGhpcyBpcyBraW5kYSBzdHVwaWQgYnV0IHdlIG5lZWQgdGhlIG1vdXNlIGNvb3JkcyBiYWNrLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB7eDogZGlmZlggKyB0aGlzLnBhcmFtZXRlcnMucC54LCB5OiBkaWZmWSArIHRoaXMucGFyYW1ldGVycy5wLnl9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBtaW51cyBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc0FuZ2xlID0gTWF0aC5hdGFuMigodGhpcy5wYXJhbWV0ZXJzLnAueSAtIHRoaXMucGFyYW1ldGVycy5ib3gueSAtIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC8gMiksICh0aGlzLnBhcmFtZXRlcnMucC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG1pbnVzIG1pZGRsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwQW5nbGUgPSBNYXRoLmF0YW4yKChjdXJyZW50LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAvIDIpLCAoY3VycmVudC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gKHBBbmdsZSAtIHNBbmdsZSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgYm94IGZpcnN0IGFuZCBjaGFuZ2UgdGhlIHJvdGF0aW9uIGFmdGVyd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHJvdGF0aW9uIGFsd2F5cyB3b3JrcyBhcm91bmQgYSByb3RhdGlvbi1jZW50ZXIsIHdoaWNoIGlzIGNoYW5nZWQgd2hlbiBtb3ZpbmcgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIHNldCB0aGUgbmV3IHJvdGF0aW9uIGNlbnRlciB0byB0aGUgY2VudGVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5jZW50ZXIodGhpcy5wYXJhbWV0ZXJzLmJveC5jeCwgdGhpcy5wYXJhbWV0ZXJzLmJveC5jeSkucm90YXRlKHRoaXMucGFyYW1ldGVycy5yb3RhdGlvbiArIGFuZ2xlIC0gYW5nbGUgJSB0aGlzLm9wdGlvbnMuc25hcFRvQW5nbGUsIHRoaXMucGFyYW1ldGVycy5ib3guY3gsIHRoaXMucGFyYW1ldGVycy5ib3guY3kpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gTW92aW5nIG9uZSBzaW5nbGUgUG9pbnQgKG5lZWRlZCB3aGVuIGFuIGVsZW1lbnQgaXMgZGVlcFNlbGVjdGVkIHdoaWNoIG1lYW5zIHlvdSBjYW4gbW92ZSBldmVyeSBzaW5nbGUgcG9pbnQgb2YgdGhlIG9iamVjdClcclxuICAgICAgICAgICAgY2FzZSAncG9pbnQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwcGluZyB0aGUgcG9pbnQgdG8gdGhlIGdyaWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1swXSwgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb2ludCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuZWwuYXJyYXkoKS52YWx1ZU9mKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBtb3ZlZCBwb2ludCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt0aGlzLnBhcmFtZXRlcnMuaV1bMF0gPSB0aGlzLnBhcmFtZXRlcnMucG9pbnRDb29yZHNbMF0gKyBzbmFwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3RoaXMucGFyYW1ldGVycy5pXVsxXSA9IHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1sxXSArIHNuYXBbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCBwbG90IHRoZSBuZXcgdGhpcy5lbFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwucGxvdChhcnJheSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemVzdGFydCcsIHtkeDogdGhpcy5wYXJhbWV0ZXJzLngsIGR5OiB0aGlzLnBhcmFtZXRlcnMueSwgZXZlbnQ6IGV2ZW50fSk7XHJcbiAgICAgICAgLy8gV2hlbiByZXNpemluZyBzdGFydGVkLCB3ZSBoYXZlIHRvIHJlZ2lzdGVyIGV2ZW50cyBmb3IuLi5cclxuICAgICAgICAvLyBUb3VjaGVzLlxyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICd0b3VjaG1vdmUucmVzaXplJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGUoZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICd0b3VjaGVuZC5yZXNpemUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgX3RoaXMuZG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1vdXNlLlxyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICdtb3VzZW1vdmUucmVzaXplJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlKGUgfHwgd2luZG93LmV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBTVkcub24od2luZG93LCAnbW91c2V1cC5yZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRvbmUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSB1cGRhdGUtZnVuY3Rpb24gcmVkcmF3cyB0aGUgZWxlbWVudCBldmVyeSB0aW1lIHRoZSBtb3VzZSBpcyBtb3ZpbmdcclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgICAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGModGhpcy5sYXN0VXBkYXRlQ2FsbFswXSwgdGhpcy5sYXN0VXBkYXRlQ2FsbFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1vdXNlcG9zaXRpb24gYXQgc3RhcnQgYW5kIG5vd1xyXG4gICAgICAgIHZhciB0eFB0ID0gdGhpcy5fZXh0cmFjdFBvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgICB2YXIgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQodHhQdC54LCB0eFB0LnkpO1xyXG5cclxuICAgICAgICB2YXIgZGlmZlggPSBwLnggLSB0aGlzLnBhcmFtZXRlcnMucC54LFxyXG4gICAgICAgICAgICBkaWZmWSA9IHAueSAtIHRoaXMucGFyYW1ldGVycy5wLnk7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUNhbGwgPSBbZGlmZlgsIGRpZmZZXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcG9zaXRpb24gYW5kIGhlaWdodCAvIHdpZHRoIG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgdGhpcy5jYWxjKGRpZmZYLCBkaWZmWSk7XHJcblxyXG4gICAgICAgLy8gRW1pdCBhbiBldmVudCB0byBzYXkgd2UgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgIHRoaXMuZWwuZmlyZSgncmVzaXppbmcnLCB7ZHg6IGRpZmZYLCBkeTogZGlmZlksIGV2ZW50OiBldmVudH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJcyBjYWxsZWQgb24gbW91c2V1cC5cclxuICAgIC8vIFJlbW92ZXMgdGhlIHVwZGF0ZS1mdW5jdGlvbiBmcm9tIHRoZSBtb3VzZW1vdmUgZXZlbnRcclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlQ2FsbCA9IG51bGw7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZW1vdmUucmVzaXplJyk7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZXVwLnJlc2l6ZScpO1xyXG4gICAgICAgIFNWRy5vZmYod2luZG93LCAndG91Y2htb3ZlLnJlc2l6ZScpO1xyXG4gICAgICAgIFNWRy5vZmYod2luZG93LCAndG91Y2hlbmQucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemVkb25lJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBmbGFnIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHJlc2l6aW5nIGlzIHVzZWQgd2l0aCBhIGxlZnQtUG9pbnQgKGZpcnN0IGJpdCkgYW5kIHRvcC1wb2ludCAoc2Vjb25kIGJpdClcclxuICAgIC8vIEluIHRoaXMgY2FzZXMgdGhlIHRlbXAtdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGRpZmZlcmVudGx5XHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9HcmlkID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZW1wO1xyXG5cclxuICAgICAgICAvLyBJZiBgcG9pbnRDb29yZHNZYCBpcyBnaXZlbiwgYSBzaW5nbGUgUG9pbnQgaGFzIHRvIGJlIHNuYXBwZWQgKGRlZXBTZWxlY3QpLiBUaGF0J3Mgd2h5IHdlIG5lZWQgYSBkaWZmZXJlbnQgdGVtcC12YWx1ZVxyXG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRDb29yZHNZICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgZmxhZyA9IHBvaW50Q29vcmRzWCBpbiB0aGlzIGNhc2VcclxuICAgICAgICAgICAgdGVtcCA9IFsoZmxhZyArIGRpZmZYKSAlIHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkLCAocG9pbnRDb29yZHNZICsgZGlmZlkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGlmIHRoZSBmbGFnIGlzIHNldCBhbmQgaWYgbm90IHdlIHNldCBhIGRlZmF1bHQtdmFsdWUgKGJvdGggYml0cyBzZXQgLSB3aGljaCBtZWFucyB1cHBlci1sZWZ0LWVkZ2UpXHJcbiAgICAgICAgICAgIGZsYWcgPSBmbGFnID09IG51bGwgPyAxIHwgMSA8PCAxIDogZmxhZztcclxuICAgICAgICAgICAgdGVtcCA9IFsodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgZGlmZlggKyAoZmxhZyAmIDEgPyAwIDogdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQsICh0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBkaWZmWSArIChmbGFnICYgKDEgPDwgMSkgPyAwIDogdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQpKSAlIHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBkaWZmWCAtPSAoTWF0aC5hYnModGVtcFswXSkgPCB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCAvIDIgP1xyXG4gICAgICAgICAgICAgICAgICB0ZW1wWzBdIDpcclxuICAgICAgICAgICAgICAgICAgdGVtcFswXSAtIChkaWZmWCA8IDAgPyAtdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQgOiB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCkpO1xyXG4gICAgICAgIGRpZmZZIC09IChNYXRoLmFicyh0ZW1wWzFdKSA8IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkIC8gMiA/XHJcbiAgICAgICAgICAgICAgICAgIHRlbXBbMV0gOlxyXG4gICAgICAgICAgICAgICAgICB0ZW1wWzFdIC0gKGRpZmZZIDwgMCA/IC10aGlzLm9wdGlvbnMuc25hcFRvR3JpZCA6IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRUb0JveChkaWZmWCwgZGlmZlksIGZsYWcsIHBvaW50Q29vcmRzWSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBrZWVwIGVsZW1lbnQgd2l0aGluIGNvbnN0cmFpbmVkIGJveFxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuY29uc3RyYWludFRvQm94ID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gW2RpZmZYLCBkaWZmWV1cclxuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW50IHx8IHt9O1xyXG4gICAgICAgIHZhciBvcmdYLCBvcmdZO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHBvaW50Q29vcmRzWSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIG9yZ1ggPSBmbGFnO1xyXG4gICAgICAgICAgb3JnWSA9IHBvaW50Q29vcmRzWTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3JnWCA9IHRoaXMucGFyYW1ldGVycy5ib3gueCArIChmbGFnICYgMSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoKTtcclxuICAgICAgICAgIG9yZ1kgPSB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyAoZmxhZyAmICgxPDwxKSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWluWCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYIDwgYy5taW5YKSB7XHJcbiAgICAgICAgICBkaWZmWCA9IGMubWluWCAtIG9yZ1g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWF4WCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYID4gYy5tYXhYKSB7XHJcbiAgICAgICAgICBkaWZmWCA9IGMubWF4WCAtIG9yZ1g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWluWSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZIDwgYy5taW5ZKSB7XHJcbiAgICAgICAgICBkaWZmWSA9IGMubWluWSAtIG9yZ1k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWF4WSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZID4gYy5tYXhZKSB7XHJcbiAgICAgICAgICBkaWZmWSA9IGMubWF4WSAtIG9yZ1k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW2RpZmZYLCBkaWZmWV07XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmNoZWNrQXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAoc25hcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNhdmVBc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICByZXR1cm4gc25hcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB1cGRhdGVkU25hcCA9IHNuYXAuc2xpY2UoKTtcclxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC8gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIG5ld1cgPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXTtcclxuICAgICAgICB2YXIgbmV3SCA9IHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXTtcclxuICAgICAgICB2YXIgbmV3QXNwZWN0UmF0aW8gPSBuZXdXIC8gbmV3SDtcclxuXHJcbiAgICAgICAgaWYgKG5ld0FzcGVjdFJhdGlvIDwgYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IGlzIHRvbyBiaWcuIEFkYXB0IGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZWRTbmFwWzFdID0gbmV3VyAvIGFzcGVjdFJhdGlvIC0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXdBc3BlY3RSYXRpbyA+IGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIC8vIFdpZHRoIGlzIHRvbyBiaWcuIEFkYXB0IGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZWRTbmFwWzBdID0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIG5ld0ggKiBhc3BlY3RSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1cGRhdGVkU25hcDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgICAgICAvLyBSZXNpemUgZWxlbWVudCB3aXRoIG1vdXNlXHJcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgKHRoaXMucmVtZW1iZXIoJ19yZXNpemVIYW5kbGVyJykgfHwgbmV3IFJlc2l6ZUhhbmRsZXIodGhpcykpLmluaXQob3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIFNWRy5FbGVtZW50LnByb3RvdHlwZS5yZXNpemUuZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgc25hcFRvQW5nbGU6IDAuMSwgICAgICAgLy8gU3BlY2lmaWVzIHRoZSBzcGVlZCB0aGUgcm90YXRpb24gaXMgaGFwcGVuaW5nIHdoZW4gbW92aW5nIHRoZSBtb3VzZVxyXG4gICAgICAgIHNuYXBUb0dyaWQ6IDEsICAgICAgICAgIC8vIFNuYXBzIHRvIGEgZ3JpZCBvZiBgc25hcFRvR3JpZGAgUGl4ZWxzXHJcbiAgICAgICAgY29uc3RyYWludDoge30sICAgICAgICAgLy8ga2VlcCBlbGVtZW50IHdpdGhpbiBjb25zdHJhaW5lZCBib3hcclxuICAgICAgICBzYXZlQXNwZWN0UmF0aW86IGZhbHNlICAvLyBTYXZlIGFzcGVjdCByYXRpbyB3aGVuIHJlc2l6aW5nIHVzaW5nIGx0LCBydCwgcmIgb3IgbGIgcG9pbnRzXHJcbiAgICB9O1xyXG5cclxufSkuY2FsbCh0aGlzKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzcyA9IFwiLmFwZXhjaGFydHMtY2FudmFzIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLyogY2Fubm90IGdpdmUgb3ZlcmZsb3c6IGhpZGRlbiBhcyBpdCB3aWxsIGNyb3AgdG9vbHRpcHMgd2hpY2ggb3ZlcmZsb3cgb3V0c2lkZSBjaGFydCBhcmVhICovXFxufVxcblxcbi8qIHNjcm9sbGJhciBpcyBub3QgdmlzaWJsZSBieSBkZWZhdWx0IGZvciBsZWdlbmQsIGhlbmNlIGZvcmNpbmcgdGhlIHZpc2liaWxpdHkgKi9cXG4uYXBleGNoYXJ0cy1jYW52YXMgOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICB3aWR0aDogNnB4O1xcbn1cXG4uYXBleGNoYXJ0cy1jYW52YXMgOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLC41KTtcXG4gIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSgyNTUsMjU1LDI1NSwuNSk7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSgyNTUsMjU1LDI1NSwuNSk7XFxufVxcbi5hcGV4Y2hhcnRzLWNhbnZhcy5kYXJrIHtcXG4gIGJhY2tncm91bmQ6ICMzNDNGNTc7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWlubmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLmxlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUge1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxuICBvcGFjaXR5OiAwLjIwO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWdyaWRsaW5lLCAuYXBleGNoYXJ0cy10ZXh0IHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwIHtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJveC1zaGFkb3c6IDJweCAycHggNnB4IC00cHggIzk5OTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxlZnQ6IDYycHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDIwcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHotaW5kZXg6IDEyO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAubGlnaHQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2UzZTNlMztcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45Nik7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuZGFyayB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMzAsMzAsMzAsIDAuOCk7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAgKiB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcCAuYXBleGNoYXJ0cy1tYXJrZXIsXFxuLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtYXJlYSxcXG4uYXBleGNoYXJ0cy1saW5lIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLmFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUge1xcbiAgcGFkZGluZzogNnB4O1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLmxpZ2h0IC5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUge1xcbiAgYmFja2dyb3VuZDogI0VDRUZGMTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLmRhcmsgLmFwZXhjaGFydHMtdG9vbHRpcC10aXRsZSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzMzMztcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXZhbHVlLFxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei1sYWJlbDplbXB0eSxcXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei12YWx1ZTplbXB0eSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtdmFsdWUsIFxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlIHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyIHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwIHtcXG4gIHBhZGRpbmc6IDAgMTBweDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAganVzdGlmeS1jb250ZW50OiBsZWZ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAuYWN0aXZlIC5hcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyIHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwLmFjdGl2ZSwgLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXA6bGFzdC1jaGlsZCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNHB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLXktZ3JvdXAge1xcbiAgcGFkZGluZzogNnB4IDAgNXB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLWNhbmRsZXN0aWNrIHtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtY2FuZGxlc3RpY2sgPiBkaXYge1xcbiAgbWFyZ2luOiA0cHggMDtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC1jYW5kbGVzdGljayBzcGFuLnZhbHVlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXJhbmdlYmFyIHtcXG4gIHBhZGRpbmc6IDVweCA4cHg7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtcmFuZ2ViYXIgLmNhdGVnb3J5IHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBjb2xvcjogIzc3NztcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1yYW5nZWJhciAuc2VyaWVzLW5hbWUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwIHtcXG4gIG9wYWNpdHk6IDA7XFxuICBwYWRkaW5nOiA5cHggMTBweDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgY29sb3I6ICMzNzNkM2Y7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMDtcXG5cXHRiYWNrZ3JvdW5kOiAjRUNFRkYxO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzkwQTRBRTtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAuZGFyayB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmFmdGVyLCAuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHRsZWZ0OiA1MCU7XFxuXFx0Ym9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG5cXHRjb250ZW50OiBcXFwiIFxcXCI7XFxuXFx0aGVpZ2h0OiAwO1xcblxcdHdpZHRoOiAwO1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmFmdGVyIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMjM2LCAyMzksIDI0MSwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA2cHg7XFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcDpiZWZvcmUge1xcblxcdGJvcmRlci1jb2xvcjogcmdiYSgxNDQsIDE2NCwgMTc0LCAwKTtcXG5cXHRib3JkZXItd2lkdGg6IDdweDtcXG5cXHRtYXJnaW4tbGVmdDogLTdweDtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTphZnRlciwgLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcbiAgYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmFmdGVyLCAuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmJlZm9yZSB7XFxuICB0b3A6IDEwMCU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b206YWZ0ZXIge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI0VDRUZGMTtcXG59XFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogIzkwQTRBRTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbS5kYXJrOmFmdGVyIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG59XFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbS5kYXJrOmJlZm9yZSB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YWZ0ZXIge1xcbiAgYm9yZGVyLXRvcC1jb2xvcjojRUNFRkYxXFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YmVmb3JlIHtcXG4gIGJvcmRlci10b3AtY29sb3I6ICM5MEE0QUU7XFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3AuZGFyazphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOnJnYmEoMCwgMCwgMCwgMC41KTtcXG59XFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcC5kYXJrOmJlZm9yZSB7XFxuICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC5hY3RpdmUge1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAge1xcbiAgb3BhY2l0eTogMDtcXG4gIHBhZGRpbmc6IDRweCAxMHB4O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBjb2xvcjogIzM3M2QzZjtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDEwO1xcblxcdGJhY2tncm91bmQ6ICNFQ0VGRjE7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOTBBNEFFO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAuZGFyayB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmFmdGVyLCAuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHR0b3A6IDUwJTtcXG5cXHRib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcblxcdGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG5cXHRoZWlnaHQ6IDA7XFxuXFx0d2lkdGg6IDA7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YWZ0ZXIge1xcblxcdGJvcmRlci1jb2xvcjogcmdiYSgyMzYsIDIzOSwgMjQxLCAwKTtcXG5cXHRib3JkZXItd2lkdGg6IDZweDtcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMTQ0LCAxNjQsIDE3NCwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA3cHg7XFxuXFx0bWFyZ2luLXRvcDogLTdweDtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YWZ0ZXIsIC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxuICBsZWZ0OiAxMDAlO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YWZ0ZXIsIC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcbiAgcmlnaHQ6IDEwMCU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0OmFmdGVyIHtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiAjRUNFRkYxO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdDpiZWZvcmUge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICM5MEE0QUU7XFxufVxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0LmRhcms6YWZ0ZXIge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQuZGFyazpiZWZvcmUge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0OmFmdGVyIHtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogI0VDRUZGMTtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxuICBib3JkZXItcmlnaHQtY29sb3I6ICM5MEE0QUU7XFxufVxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodC5kYXJrOmFmdGVyIHtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQuZGFyazpiZWZvcmUge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC5hY3RpdmUge1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGNyb3NzaGFpcnMsIC5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14Y3Jvc3NoYWlycy5hY3RpdmUsIC5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzLmFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy16b29tLXJlY3Qge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0IHtcXG4gIGN1cnNvcjogbW92ZTtcXG59XFxuXFxuLnN2Z19zZWxlY3RfcG9pbnRzLCAuc3ZnX3NlbGVjdF9wb2ludHNfcm90IHtcXG4gIG9wYWNpdHk6IDA7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcbi5zdmdfc2VsZWN0X3BvaW50c19sLCAuc3ZnX3NlbGVjdF9wb2ludHNfciB7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG4gIG9wYWNpdHk6IDE7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgZmlsbDogIzg4ODtcXG59XFxuLmFwZXhjaGFydHMtY2FudmFzLnpvb21hYmxlIC5ob3ZlcmluZy16b29tIHtcXG4gIGN1cnNvcjogY3Jvc3NoYWlyXFxufVxcbi5hcGV4Y2hhcnRzLWNhbnZhcy56b29tYWJsZSAuaG92ZXJpbmctcGFuIHtcXG4gIGN1cnNvcjogbW92ZVxcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpcyxcXG4uYXBleGNoYXJ0cy15YXhpcyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbS1pY29uLCBcXG4uYXBleGNoYXJ0cy16b29tLWluLWljb24sXFxuLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbixcXG4uYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24sIFxcbi5hcGV4Y2hhcnRzLXBhbi1pY29uLCBcXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24taWNvbixcXG4uYXBleGNoYXJ0cy1tZW51LWljb24sIFxcbi5hcGV4Y2hhcnRzLXRvb2xiYXItY3VzdG9tLWljb24ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogMjRweDtcXG4gIGNvbG9yOiAjNkU4MTkyO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5cXG4uYXBleGNoYXJ0cy16b29tLWljb24gc3ZnLCBcXG4uYXBleGNoYXJ0cy16b29tLWluLWljb24gc3ZnLFxcbi5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb24gc3ZnLFxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiBzdmcsXFxuLmFwZXhjaGFydHMtbWVudS1pY29uIHN2ZyB7XFxuICBmaWxsOiAjNkU4MTkyO1xcbn1cXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24taWNvbiBzdmcge1xcbiAgZmlsbDogIzQ0NDtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC43NilcXG59XFxuXFxuLmRhcmsgLmFwZXhjaGFydHMtem9vbS1pY29uIHN2ZywgXFxuLmRhcmsgLmFwZXhjaGFydHMtem9vbS1pbi1pY29uIHN2ZyxcXG4uZGFyayAuYXBleGNoYXJ0cy16b29tLW91dC1pY29uIHN2ZyxcXG4uZGFyayAuYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24gc3ZnLCBcXG4uZGFyayAuYXBleGNoYXJ0cy1wYW4taWNvbiBzdmcsIFxcbi5kYXJrIC5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uIHN2ZyxcXG4uZGFyayAuYXBleGNoYXJ0cy1tZW51LWljb24gc3ZnLCBcXG4uZGFyayAuYXBleGNoYXJ0cy10b29sYmFyLWN1c3RvbS1pY29uIHN2Z3tcXG4gIGZpbGw6ICNmM2Y0ZjU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWNhbnZhcyAuYXBleGNoYXJ0cy16b29tLWljb24uc2VsZWN0ZWQgc3ZnLCBcXG4uYXBleGNoYXJ0cy1jYW52YXMgLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24uc2VsZWN0ZWQgc3ZnLCBcXG4uYXBleGNoYXJ0cy1jYW52YXMgLmFwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uLnNlbGVjdGVkIHN2ZyB7XFxuICBmaWxsOiAjMDA4RkZCO1xcbn1cXG4ubGlnaHQgLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb246bm90KC5zZWxlY3RlZCk6aG92ZXIgc3ZnLFxcbi5saWdodCAuYXBleGNoYXJ0cy16b29tLWljb246bm90KC5zZWxlY3RlZCk6aG92ZXIgc3ZnLCBcXG4ubGlnaHQgLmFwZXhjaGFydHMtem9vbS1pbi1pY29uOmhvdmVyIHN2ZywgXFxuLmxpZ2h0IC5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb246aG92ZXIgc3ZnLCBcXG4ubGlnaHQgLmFwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uOmhvdmVyIHN2ZywgXFxuLmxpZ2h0IC5hcGV4Y2hhcnRzLW1lbnUtaWNvbjpob3ZlciBzdmcge1xcbiAgZmlsbDogIzMzMztcXG59XFxuXFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24sIC5hcGV4Y2hhcnRzLW1lbnUtaWNvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiB7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbn1cXG4uYXBleGNoYXJ0cy16b29tLWljb24sIC5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiwgLmFwZXhjaGFydHMtbWVudS1pY29uIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC44NSk7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20taW4taWNvbiwgLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbiB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuNylcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbiB7XFxuICBtYXJnaW4tcmlnaHQ6IDNweDtcXG59XFxuXFxuLmFwZXhjaGFydHMtcGFuLWljb24ge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjYyKTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDFweDtcXG4gIHRvcDogMHB4O1xcbn1cXG4uYXBleGNoYXJ0cy1wYW4taWNvbiBzdmcge1xcbiAgZmlsbDogI2ZmZjtcXG4gIHN0cm9rZTogIzZFODE5MjtcXG4gIHN0cm9rZS13aWR0aDogMjtcXG59XFxuLmFwZXhjaGFydHMtcGFuLWljb24uc2VsZWN0ZWQgc3ZnIHtcXG4gIHN0cm9rZTogIzAwOEZGQjtcXG59XFxuLmFwZXhjaGFydHMtcGFuLWljb246bm90KC5zZWxlY3RlZCk6aG92ZXIgc3ZnIHtcXG4gIHN0cm9rZTogIzMzMztcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbGJhciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMTtcXG4gIHRvcDogMHB4O1xcbiAgcmlnaHQ6IDNweDtcXG4gIG1heC13aWR0aDogMTc2cHg7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIHBhZGRpbmc6IDBweCA2cHggMnB4IDZweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyOyBcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbGJhciBzdmcge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTAwJTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAzcHg7XFxuICByaWdodDogMTBweDtcXG4gIG9wYWNpdHk6IDA7XFxuICBtaW4td2lkdGg6IDExMHB4O1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmFwZXhjaGFydHMtbWVudS5vcGVuIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUtaXRlbSB7XFxuICBwYWRkaW5nOiA2cHggN3B4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4ubGlnaHQgLmFwZXhjaGFydHMtbWVudS1pdGVtOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxufVxcbi5kYXJrIC5hcGV4Y2hhcnRzLW1lbnUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgY29sb3I6ICNmZmY7XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAuYXBleGNoYXJ0cy10b29sYmFyIHtcXG4gICAgLypvcGFjaXR5OiAwOyovXFxuICB9XFxuXFxuICAuYXBleGNoYXJ0cy1jYW52YXM6aG92ZXIgLmFwZXhjaGFydHMtdG9vbGJhciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9IFxcbn1cXG5cXG4uYXBleGNoYXJ0cy1kYXRhbGFiZWwuaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXBpZS1sYWJlbCxcXG4uYXBleGNoYXJ0cy1kYXRhbGFiZWwsIC5hcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCwgLmFwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1waWUtbGFiZWwtZGVsYXkge1xcbiAgb3BhY2l0eTogMDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBvcGFxdWU7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWNhbnZhcyAuaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWhpZGUgLmFwZXhjaGFydHMtc2VyaWVzLXBvaW50cyB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXIubm8tcG9pbnRlci1ldmVudHMsXFxuLmFwZXhjaGFydHMtbGluZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgLmFwZXhjaGFydHMtbWFya2VyLm5vLXBvaW50ZXItZXZlbnRzLCAuYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMgcGF0aCwgLmFwZXhjaGFydHMtcmFkYXItc2VyaWVzIHBvbHlnb24ge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi8qIG1hcmtlcnMgKi9cXG5cXG4uYXBleGNoYXJ0cy1tYXJrZXIge1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbkBrZXlmcmFtZXMgb3BhcXVlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbn1cIjtcbnN0eWxlSW5qZWN0KGNzcyk7XG5cbi8qXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqIDEuMi4yMDE3MTIxMFxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XG4gIC8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbiAgLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XG4gIGlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpKSkge1xuICAgIChmdW5jdGlvbiAodmlldykge1xuXG4gICAgICBpZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcblxuICAgICAgdmFyIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiLFxuICAgICAgICAgIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCIsXG4gICAgICAgICAgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF0sXG4gICAgICAgICAgb2JqQ3RyID0gT2JqZWN0LFxuICAgICAgICAgIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICB9LFxuICAgICAgICAgIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcbiAgICAgICxcbiAgICAgICAgICBET01FeCA9IGZ1bmN0aW9uIERPTUV4KHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdHlwZTtcbiAgICAgICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfSxcbiAgICAgICAgICBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiBjaGVja1Rva2VuQW5kR2V0SW5kZXgoY2xhc3NMaXN0LCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXCJTWU5UQVhfRVJSXCIsIFwiVGhlIHRva2VuIG11c3Qgbm90IGJlIGVtcHR5LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeChcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiLCBcIlRoZSB0b2tlbiBtdXN0IG5vdCBjb250YWluIHNwYWNlIGNoYXJhY3RlcnMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcbiAgICAgIH0sXG4gICAgICAgICAgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gQ2xhc3NMaXN0KGVsZW0pIHtcbiAgICAgICAgdmFyIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiksXG4gICAgICAgICAgICBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGNsYXNzZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgICAgICBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW10sXG4gICAgICAgICAgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gY2xhc3NMaXN0R2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcbiAgICAgIH07IC8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbiAgICAgIC8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuXG5cbiAgICAgIERPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xuXG4gICAgICBjbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB+Y2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuICsgXCJcIik7XG4gICAgICB9O1xuXG4gICAgICBjbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblxuICAgICAgICAgIGlmICghfmNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuXG4gICAgICAgICAgd2hpbGUgKH5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2kgPCBsKTtcblxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKSxcbiAgICAgICAgICAgIG1ldGhvZCA9IHJlc3VsdCA/IGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCIgOiBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIjtcblxuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgdGhpc1ttZXRob2RdKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiAodG9rZW4sIHJlcGxhY2VtZW50X3Rva2VuKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0b2tlbiArIFwiXCIpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSwgcmVwbGFjZW1lbnRfdG9rZW4pO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuICAgICAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG4gICAgICAgICAgLy8gYWRkaW5nIHVuZGVmaW5lZCB0byBmaWdodCB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9pc3N1ZXMvMzZcbiAgICAgICAgICAvLyBtb2Rlcm5pZSBJRTgtTVNXNyBtYWNoaW5lIGhhcyBJRTggOC4wLjYwMDEuMTg3MDIgYW5kIGlzIGFmZmVjdGVkXG4gICAgICAgICAgaWYgKGV4Lm51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuICAgICAgICBlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xuICAgICAgfVxuICAgIH0pKHNlbGYpO1xuICB9IC8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxuICAvLyB0byBub3JtYWxpemUgdGhlIGFkZC9yZW1vdmUgYW5kIHRvZ2dsZSBBUElzLlxuXG5cbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpOyAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAvMTEgYW5kIEZpcmVmb3ggPDI2LCB3aGVyZSBjbGFzc0xpc3QuYWRkIGFuZFxuICAgIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxuXG4gICAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xuICAgICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xuXG4gICAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XG4gICAgICBjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xuICAgIH1cblxuICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7IC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcbiAgICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cbiAgICBpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcbiAgICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG5cbiAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuICAgICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyByZXBsYWNlKCkgcG9seWZpbGxcblxuXG4gICAgaWYgKCEoXCJyZXBsYWNlXCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikuY2xhc3NMaXN0KSkge1xuICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRva2VuLCByZXBsYWNlbWVudF90b2tlbikge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICAgIGluZGV4ID0gdG9rZW5zLmluZGV4T2YodG9rZW4gKyBcIlwiKTtcblxuICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICB0aGlzLnJlbW92ZS5hcHBseSh0aGlzLCB0b2tlbnMpO1xuICAgICAgICAgIHRoaXMuYWRkKHJlcGxhY2VtZW50X3Rva2VuKTtcbiAgICAgICAgICB0aGlzLmFkZC5hcHBseSh0aGlzLCB0b2tlbnMuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRlc3RFbGVtZW50ID0gbnVsbDtcbiAgfSkoKTtcbn1cblxuLyoqXG4qIERldGVjdCBFbGVtZW50IFJlc2l6ZVxuKlxuKiBodHRwczovL2dpdGh1Yi5jb20vc2RlY2ltYS9qYXZhc2NyaXB0LWRldGVjdC1lbGVtZW50LXJlc2l6ZVxuKiBTZWJhc3RpYW4gRGVjaW1hXG4qXG4qIHZlcnNpb246IDAuNS4zXG4qKi9cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHlsZXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcmVzZXRUcmlnZ2VycyhlbGVtZW50KSB7XG4gICAgdmFyIHRyaWdnZXJzID0gZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18sXG4gICAgICAgIGV4cGFuZCA9IHRyaWdnZXJzLmZpcnN0RWxlbWVudENoaWxkLFxuICAgICAgICBjb250cmFjdCA9IHRyaWdnZXJzLmxhc3RFbGVtZW50Q2hpbGQsXG4gICAgICAgIGV4cGFuZENoaWxkID0gZXhwYW5kLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGNvbnRyYWN0LnNjcm9sbExlZnQgPSBjb250cmFjdC5zY3JvbGxXaWR0aDtcbiAgICBjb250cmFjdC5zY3JvbGxUb3AgPSBjb250cmFjdC5zY3JvbGxIZWlnaHQ7XG4gICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSBleHBhbmQub2Zmc2V0V2lkdGggKyAxICsgJ3B4JztcbiAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBleHBhbmQub2Zmc2V0SGVpZ2h0ICsgMSArICdweCc7XG4gICAgZXhwYW5kLnNjcm9sbExlZnQgPSBleHBhbmQuc2Nyb2xsV2lkdGg7XG4gICAgZXhwYW5kLnNjcm9sbFRvcCA9IGV4cGFuZC5zY3JvbGxIZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1RyaWdnZXJzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRXaWR0aCAhPSBlbGVtZW50Ll9fcmVzaXplTGFzdF9fLndpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICE9IGVsZW1lbnQuX19yZXNpemVMYXN0X18uaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIoZSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICByZXNldFRyaWdnZXJzKHRoaXMpO1xuICAgIGlmICh0aGlzLl9fcmVzaXplUkFGX18pIGNhbmNlbEZyYW1lKHRoaXMuX19yZXNpemVSQUZfXyk7XG4gICAgdGhpcy5fX3Jlc2l6ZVJBRl9fID0gcmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjaGVja1RyaWdnZXJzKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVMYXN0X18ud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBlbGVtZW50Ll9fcmVzaXplTGFzdF9fLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3R5bGVzKCkge1xuICAgIGlmICghc3R5bGVzQ3JlYXRlZCkge1xuICAgICAgLy8gb3BhY2l0eTowIHdvcmtzIGFyb3VuZCBhIGNocm9tZSBidWcgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI4NjM2MFxuICAgICAgdmFyIGNzcyA9IChhbmltYXRpb25LZXlmcmFtZXMgfHwgJycpICsgJy5yZXNpemUtdHJpZ2dlcnMgeyAnICsgKGFuaW1hdGlvblN0eWxlIHx8ICcnKSArICd2aXNpYmlsaXR5OiBoaWRkZW47IG9wYWNpdHk6IDA7IH0gJyArICcucmVzaXplLXRyaWdnZXJzLCAucmVzaXplLXRyaWdnZXJzID4gZGl2LCAuY29udHJhY3QtdHJpZ2dlcjpiZWZvcmUgeyBjb250ZW50OiBcXFwiIFxcXCI7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTsgb3ZlcmZsb3c6IGhpZGRlbjsgfSAucmVzaXplLXRyaWdnZXJzID4gZGl2IHsgYmFja2dyb3VuZDogI2VlZTsgb3ZlcmZsb3c6IGF1dG87IH0gLmNvbnRyYWN0LXRyaWdnZXI6YmVmb3JlIHsgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJTsgfScsXG4gICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcbiAgICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICB9XG5cbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgc3R5bGVzQ3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlcXVlc3RGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIDIwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIHJhZihmbik7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjYW5jZWxGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LmNsZWFyVGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gY2FuY2VsKGlkKTtcbiAgICB9O1xuICB9KCk7XG4gIC8qIERldGVjdCBDU1MgQW5pbWF0aW9ucyBzdXBwb3J0IHRvIGRldGVjdCBlbGVtZW50IGRpc3BsYXkvcmUtYXR0YWNoICovXG5cblxuICB2YXIgYW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICBrZXlmcmFtZXByZWZpeCA9ICcnLFxuICAgICAgYW5pbWF0aW9uc3RhcnRldmVudCA9ICdhbmltYXRpb25zdGFydCcsXG4gICAgICBkb21QcmVmaXhlcyA9ICdXZWJraXQgTW96IE8gbXMnLnNwbGl0KCcgJyksXG4gICAgICBzdGFydEV2ZW50cyA9ICd3ZWJraXRBbmltYXRpb25TdGFydCBhbmltYXRpb25zdGFydCBvQW5pbWF0aW9uU3RhcnQgTVNBbmltYXRpb25TdGFydCcuc3BsaXQoJyAnKSxcbiAgICAgIHBmeCA9ICcnO1xuICB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zha2VlbGVtZW50Jyk7XG5cbiAgICBpZiAoZWxtLnN0eWxlLmFuaW1hdGlvbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxtLnN0eWxlW2RvbVByZWZpeGVzW2ldICsgJ0FuaW1hdGlvbk5hbWUnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGZ4ID0gZG9tUHJlZml4ZXNbaV07XG4gICAgICAgICAga2V5ZnJhbWVwcmVmaXggPSAnLScgKyBwZngudG9Mb3dlckNhc2UoKSArICctJztcbiAgICAgICAgICBhbmltYXRpb25zdGFydGV2ZW50ID0gc3RhcnRFdmVudHNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGFuaW1hdGlvbk5hbWUgPSAncmVzaXplYW5pbSc7XG4gIHZhciBhbmltYXRpb25LZXlmcmFtZXMgPSAnQCcgKyBrZXlmcmFtZXByZWZpeCArICdrZXlmcmFtZXMgJyArIGFuaW1hdGlvbk5hbWUgKyAnIHsgZnJvbSB7IG9wYWNpdHk6IDA7IH0gdG8geyBvcGFjaXR5OiAwOyB9IH0gJztcbiAgdmFyIGFuaW1hdGlvblN0eWxlID0ga2V5ZnJhbWVwcmVmaXggKyAnYW5pbWF0aW9uOiAxbXMgJyArIGFuaW1hdGlvbk5hbWUgKyAnOyAnO1xuXG4gIHdpbmRvdy5hZGRSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBmbikge1xuICAgIGlmICghZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pIHtcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09ICdzdGF0aWMnKSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIGNyZWF0ZVN0eWxlcygpO1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxhc3RfXyA9IHt9O1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fID0gW107XG4gICAgICAoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkuY2xhc3NOYW1lID0gJ3Jlc2l6ZS10cmlnZ2Vycyc7XG4gICAgICBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXy5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImV4cGFuZC10cmlnZ2VyXCI+PGRpdj48L2Rpdj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjb250cmFjdC10cmlnZ2VyXCI+PC9kaXY+JztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pO1xuICAgICAgcmVzZXRUcmlnZ2VycyhlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsTGlzdGVuZXIsIHRydWUpO1xuICAgICAgLyogTGlzdGVuIGZvciBhIGNzcyBhbmltYXRpb24gdG8gZGV0ZWN0IGVsZW1lbnQgZGlzcGxheS9yZS1hdHRhY2ggKi9cblxuICAgICAgYW5pbWF0aW9uc3RhcnRldmVudCAmJiBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXy5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbnN0YXJ0ZXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmFuaW1hdGlvbk5hbWUgPT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgIHJlc2V0VHJpZ2dlcnMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5wdXNoKGZuKTtcbiAgfTtcblxuICB3aW5kb3cucmVtb3ZlUmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZm4pIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLnNwbGljZShlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18uaW5kZXhPZihmbiksIDEpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVUcmlnZ2Vyc19fID0gIWVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbndpbmRvdy5BcGV4ID0ge307XG4vKipcbiAqXG4gKiBAbW9kdWxlIEFwZXhDaGFydHNcbiAqKi9cblxudmFyIEFwZXhDaGFydHMkMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFwZXhDaGFydHMoZWwsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBleENoYXJ0cyk7XG5cbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY3R4ID0gdGhpczsgLy8gUGFzcyB0aGUgdXNlciBzdXBwbGllZCBvcHRpb25zIHRvIHRoZSBCYXNlIENsYXNzIHdoZXJlIHRoZXNlIG9wdGlvbnMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGZyb20gQmFzZSBDbGFzcyB3aWxsIGJlY29tZSB0aGUgY29uZmlnIG9iamVjdCBpbiB0aGUgZW50aXJlIGNvZGViYXNlLlxuXG4gICAgdGhpcy53ID0gbmV3IEJhc2Uob3B0cykuaW5pdCgpO1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLncuZ2xvYmFscy5jdWlkID0gKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpO1xuICAgIHRoaXMudy5nbG9iYWxzLmNoYXJ0SUQgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmlkID8gdGhpcy53LmNvbmZpZy5jaGFydC5pZCA6IHRoaXMudy5nbG9iYWxzLmN1aWQ7XG4gICAgdGhpcy5pbml0TW9kdWxlcygpO1xuICAgIHRoaXMuY3JlYXRlID0gVXRpbHMuYmluZCh0aGlzLmNyZWF0ZSwgdGhpcyk7XG4gICAgdGhpcy53aW5kb3dSZXNpemVIYW5kbGVyID0gdGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbWV0aG9kIHVzZXIgd2lsbCBjYWxsIHRvIHJlbmRlciB0aGUgY2hhcnQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFwZXhDaGFydHMsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBtYWluIG1ldGhvZFxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbmx5IGRyYXcgY2hhcnQsIGlmIGVsZW1lbnQgZm91bmRcbiAgICAgICAgaWYgKF90aGlzLmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBBcGV4Ll9jaGFydEluc3RhbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLncuY29uZmlnLmNoYXJ0LmlkKSB7XG4gICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IF90aGlzLncuZ2xvYmFscy5jaGFydElELFxuICAgICAgICAgICAgICBncm91cDogX3RoaXMudy5jb25maWcuY2hhcnQuZ3JvdXAsXG4gICAgICAgICAgICAgIGNoYXJ0OiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBzZXQgdGhlIGxvY2FsZSBoZXJlXG5cblxuICAgICAgICAgIF90aGlzLnNldExvY2FsZShfdGhpcy53LmNvbmZpZy5jaGFydC5kZWZhdWx0TG9jYWxlKTtcblxuICAgICAgICAgIHZhciBiZWZvcmVNb3VudCA9IF90aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5iZWZvcmVNb3VudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYmVmb3JlTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJlZm9yZU1vdW50KF90aGlzLCBfdGhpcy53KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5maXJlRXZlbnQoJ2JlZm9yZU1vdW50JywgW190aGlzLCBfdGhpcy53XSk7XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3RoaXMud2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgICAgICAgd2luZG93LmFkZFJlc2l6ZUxpc3RlbmVyKF90aGlzLmVsLnBhcmVudE5vZGUsIF90aGlzLnBhcmVudFJlc2l6ZUNhbGxiYWNrLmJpbmQoX3RoaXMpKTtcblxuICAgICAgICAgIHZhciBncmFwaERhdGEgPSBfdGhpcy5jcmVhdGUoX3RoaXMudy5jb25maWcuc2VyaWVzLCB7fSk7XG5cbiAgICAgICAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuIHJlc29sdmUoX3RoaXMpO1xuXG4gICAgICAgICAgX3RoaXMubW91bnQoZ3JhcGhEYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZ3JhcGhEYXRhKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubW91bnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubW91bnRlZChfdGhpcywgX3RoaXMudyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLmZpcmVFdmVudCgnbW91bnRlZCcsIFtfdGhpcywgX3RoaXMud10pO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7IC8vIGhhbmRsZSBlcnJvciBpbiBjYXNlIG5vIGRhdGEgb3IgZWxlbWVudCBub3QgZm91bmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb2R1bGVzKCkge1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcyk7XG4gICAgICB0aGlzLmFubm90YXRpb25zID0gbmV3IEFubm90YXRpb25zKHRoaXMpO1xuICAgICAgdGhpcy5jb3JlID0gbmV3IENvcmUodGhpcy5lbCwgdGhpcyk7XG4gICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZCh0aGlzKTtcbiAgICAgIHRoaXMuY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzKTtcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh7fSk7XG4gICAgICB0aGlzLmNyb3NzaGFpcnMgPSBuZXcgQ3Jvc3NoYWlycyh0aGlzKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICB0aGlzLnJlc3BvbnNpdmUgPSBuZXcgUmVzcG9uc2l2ZSh0aGlzKTtcbiAgICAgIHRoaXMuc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzKTtcbiAgICAgIHRoaXMudGhlbWUgPSBuZXcgVGhlbWUodGhpcyk7XG4gICAgICB0aGlzLmZvcm1hdHRlcnMgPSBuZXcgRm9ybWF0dGVycyh0aGlzKTtcbiAgICAgIHRoaXMudGl0bGVTdWJ0aXRsZSA9IG5ldyBUaXRsZVN1YnRpdGxlKHRoaXMpO1xuICAgICAgdGhpcy5sZWdlbmQgPSBuZXcgTGVnZW5kKHRoaXMpO1xuICAgICAgdGhpcy50b29sYmFyID0gbmV3IFRvb2xiYXIodGhpcyk7XG4gICAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzKTtcbiAgICAgIHRoaXMuem9vbVBhblNlbGVjdGlvbiA9IG5ldyBab29tUGFuU2VsZWN0aW9uKHRoaXMpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMudG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobmFtZSQkMSwgaGFuZGxlcikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0ucHVzaChoYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0gPSBbaGFuZGxlcl07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lJCQxLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gdy5nbG9iYWxzLmV2ZW50c1tuYW1lJCQxXS5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVFdmVudChuYW1lJCQxLCBhcmdzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhcmdzIHx8ICFhcmdzLmxlbmd0aCkge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBldnMgPSB3Lmdsb2JhbHMuZXZlbnRzW25hbWUkJDFdO1xuICAgICAgdmFyIGwgPSBldnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBldnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoc2VyLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMuaW5pdE1vZHVsZXMoKTtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgZ2wubm9EYXRhID0gZmFsc2U7XG4gICAgICBnbC5hbmltYXRpb25FbmRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXNwb25zaXZlLmNoZWNrUmVzcG9uc2l2ZUNvbmZpZyhvcHRzKTtcblxuICAgICAgaWYgKHRoaXMuZWwgPT09IG51bGwpIHtcbiAgICAgICAgZ2wuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlLnNldHVwRWxlbWVudHMoKTtcblxuICAgICAgaWYgKGdsLnN2Z1dpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiwgc2tpcCBkcmF3aW5nXG4gICAgICAgIGdsLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21ibyA9IENvcmVVdGlscy5jaGVja0NvbWJvU2VyaWVzKHNlcik7XG4gICAgICBnbC5jb21ib0NoYXJ0cyA9IGNvbWJvLmNvbWJvQ2hhcnRzO1xuICAgICAgZ2wuY29tYm9DaGFydHNIYXNCYXJzID0gY29tYm8uY29tYm9DaGFydHNIYXNCYXJzO1xuXG4gICAgICBpZiAoc2VyLmxlbmd0aCA9PT0gMCB8fCBzZXIubGVuZ3RoID09PSAxICYmIHNlclswXS5kYXRhICYmIHNlclswXS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcmllcy5oYW5kbGVOb0RhdGEoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMoKTsgLy8gSGFuZGxlIHRoZSBkYXRhIGlucHV0dGVkIGJ5IHVzZXIgYW5kIHNldCBzb21lIG9mIHRoZSBnbG9iYWwgdmFyaWFibGVzIChmb3IgZWcsIGlmIGRhdGEgaXMgZGF0ZXRpbWUgLyBudW1lcmljIC8gY2F0ZWdvcnkpLiBEb24ndCBjYWxjdWxhdGUgdGhlIHJhbmdlIC8gbWluIC8gbWF4IGF0IHRoaXMgdGltZVxuXG4gICAgICB0aGlzLmNvcmUucGFyc2VEYXRhKHNlcik7IC8vIHRoaXMgaXMgYSBnb29kIHRpbWUgdG8gc2V0IHRoZW1lIGNvbG9ycyBmaXJzdFxuXG4gICAgICB0aGlzLnRoZW1lLmluaXQoKTsgLy8gYXMgbWFya2VycyBhY2NlcHRzIGFycmF5LCB3ZSBuZWVkIHRvIHNldHVwIGdsb2JhbCBtYXJrZXJzIGZvciBlYXNpZXIgYWNjZXNzXG5cbiAgICAgIHZhciBtYXJrZXJzID0gbmV3IE1hcmtlcnModGhpcyk7XG4gICAgICBtYXJrZXJzLnNldEdsb2JhbE1hcmtlclNpemUoKTsgLy8gbGFiZWxGb3JtYXR0ZXJzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRpbWVuc2lvbnMgYXMgaW4gZGltZW5zaW9ucyB3ZSBuZWVkIHRleHQgbGFiZWxzIHdpZHRoXG5cbiAgICAgIHRoaXMuZm9ybWF0dGVycy5zZXRMYWJlbEZvcm1hdHRlcnMoKTtcbiAgICAgIHRoaXMudGl0bGVTdWJ0aXRsZS5kcmF3KCk7IC8vIGxlZ2VuZCBpcyBjYWxjdWxhdGVkIGhlcmUgYmVmb3JlIGNvcmVDYWxjdWxhdGlvbnMgYmVjYXVzZSBpdCBhZmZlY3RzIHRoZSBwbG90dGFibGUgYXJlYVxuXG4gICAgICB0aGlzLmxlZ2VuZC5pbml0KCk7IC8vIGNoZWNrIHdoZXRoZXIgaW4gbXVsdGlwbGUgc2VyaWVzLCBhbGwgc2VyaWVzIHNoYXJlIHRoZSBzYW1lIFhcblxuICAgICAgdGhpcy5zZXJpZXMuaGFzQWxsU2VyaWVzRXF1YWxYKCk7IC8vIGNvcmVDYWxjdWxhdGlvbnMgd2lsbCBnaXZlIHRoZSBtaW4vbWF4IHJhbmdlIGFuZCB5YXhpcy9heGlzIHZhbHVlcy4gSXQgc2hvdWxkIGJlIGNhbGxlZCBoZXJlIHRvIHNldCBzZXJpZXMgdmFyaWFibGUgZnJvbSBjb25maWcgdG8gZ2xvYmFsc1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICB0aGlzLmNvcmUuY29yZUNhbGN1bGF0aW9ucygpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlICE9PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgLy8gYXMgd2UgaGF2ZSBtaW5YIGFuZCBtYXhYIHZhbHVlcywgZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IERhdGVUaW1lRm9ybWF0IGZvciB0aW1lIHNlcmllc1xuICAgICAgICAgIHRoaXMuZm9ybWF0dGVycy5zZXRMYWJlbEZvcm1hdHRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHlheGlzIGZvciBoZWF0bWFwIHNlcGFyYXRlbHkgYXMgd2UgYXJlIG5vdCBzaG93aW5nIG51bWVyaWNzIHRoZXJlLCBidXQgc2VyaWVzTmFtZXMuIFRoZXJlIGFyZSBzb21lIHR3ZWFrcyB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIGhlYXRtYXAgdG8gYWxpZ24gbGFiZWxzIGNvcnJlY3RseSB3aGljaCBhcmUgZG9uZSBpbiBiZWxvdyBmdW5jdGlvblxuICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIGNhbGN1dGluZyBEaW1lbnRpb25zIHBsb3RDb29yZHMoKSBtZXRob2Qgb2YgRGltZW5zaW9uc1xuXG5cbiAgICAgIHRoaXMuZm9ybWF0dGVycy5oZWF0bWFwTGFiZWxGb3JtYXR0ZXJzKCk7IC8vIFdlIGdvdCBwbG90dGFibGUgYXJlYSBoZXJlLCBuZXh0IHRhc2sgd291bGQgYmUgdG8gY2FsY3VsYXRlIGF4aXMgYXJlYXNcblxuICAgICAgdGhpcy5kaW1lbnNpb25zLnBsb3RDb29yZHMoKTtcbiAgICAgIHZhciB4eVJhdGlvcyA9IHRoaXMuY29yZS54eVNldHRpbmdzKCk7XG4gICAgICB0aGlzLmdyaWQuY3JlYXRlR3JpZE1hc2soKTtcbiAgICAgIHZhciBlbEdyYXBoID0gdGhpcy5jb3JlLnBsb3RDaGFydFR5cGUoc2VyLCB4eVJhdGlvcyk7IC8vIGFmdGVyIGFsbCB0aGUgZHJhd2luZyBjYWxjdWxhdGlvbnMsIHNoaWZ0IHRoZSBncmFwaGljYWwgYXJlYSAoYWN0dWFsIGNoYXJ0cy9iYXJzKSBleGNsdWRpbmcgbGVnZW5kc1xuXG4gICAgICB0aGlzLmNvcmUuc2hpZnRHcmFwaFBvc2l0aW9uKCk7XG4gICAgICB2YXIgZGltID0ge1xuICAgICAgICBwbG90OiB7XG4gICAgICAgICAgbGVmdDogdy5nbG9iYWxzLnRyYW5zbGF0ZVgsXG4gICAgICAgICAgdG9wOiB3Lmdsb2JhbHMudHJhbnNsYXRlWSxcbiAgICAgICAgICB3aWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbEdyYXBoOiBlbEdyYXBoLFxuICAgICAgICB4eVJhdGlvczogeHlSYXRpb3MsXG4gICAgICAgIGVsSW5uZXI6IHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwsXG4gICAgICAgIGRpbWVuc2lvbnM6IGRpbVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgZ3JhcGhEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciB3ID0gbWUudztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gbm8gZGF0YSB0byBkaXNwbGF5XG4gICAgICAgIGlmIChtZS5lbCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOb3QgZW5vdWdoIGRhdGEgdG8gZGlzcGxheSBvciB0YXJnZXQgZWxlbWVudCBub3QgZm91bmQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JhcGhEYXRhID09PSBudWxsIHx8IHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICBtZS5zZXJpZXMuaGFuZGxlTm9EYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5jb3JlLmRyYXdBeGlzKHcuY29uZmlnLmNoYXJ0LnR5cGUsIGdyYXBoRGF0YS54eVJhdGlvcyk7XG4gICAgICAgIG1lLmdyaWQgPSBuZXcgR3JpZChtZSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgIG1lLmdyaWQuZHJhd0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgbWUuYW5ub3RhdGlvbnMuZHJhd0Fubm90YXRpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhcGhEYXRhLmVsR3JhcGggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgZ3JhcGhEYXRhLmVsR3JhcGgubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKGdyYXBoRGF0YS5lbEdyYXBoW2ddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoZ3JhcGhEYXRhLmVsR3JhcGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQucG9zaXRpb24gPT09ICdmcm9udCcpIHtcbiAgICAgICAgICBtZS5ncmlkLmRyYXdHcmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgIG1lLmNyb3NzaGFpcnMuZHJhd1hDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgIG1lLmNyb3NzaGFpcnMuZHJhd1lDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuYW5ub3RhdGlvbnMucG9zaXRpb24gPT09ICdmcm9udCcpIHtcbiAgICAgICAgICBtZS5hbm5vdGF0aW9ucy5kcmF3QW5ub3RhdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLm5vRGF0YSkge1xuICAgICAgICAgIC8vIGRyYXcgdG9vbHRpcHMgYXQgdGhlIGVuZFxuICAgICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmVuYWJsZWQgJiYgIXcuZ2xvYmFscy5ub0RhdGEpIHtcbiAgICAgICAgICAgIG1lLncuZ2xvYmFscy50b29sdGlwLmRyYXdUb29sdGlwKGdyYXBoRGF0YS54eVJhdGlvcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkIHx8IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbiAmJiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZW5hYmxlZCB8fCB3LmNvbmZpZy5jaGFydC5wYW4gJiYgdy5jb25maWcuY2hhcnQucGFuLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgbWUuem9vbVBhblNlbGVjdGlvbi5pbml0KHtcbiAgICAgICAgICAgICAgICB4eVJhdGlvczogZ3JhcGhEYXRhLnh5UmF0aW9zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG9vbHMgPSB3LmNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzO1xuICAgICAgICAgICAgdG9vbHMuem9vbSA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHMuem9vbWluID0gZmFsc2U7XG4gICAgICAgICAgICB0b29scy56b29tb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICB0b29scy5zZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xzLnBhbiA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHMucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudG9vbGJhci5zaG93ICYmICF3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS50b29sYmFyLmNyZWF0ZVRvb2xiYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZuLm1ldGhvZChmbi5wYXJhbXMsIGZhbHNlLCBmbi5jb250ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyUHJldmlvdXNQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclByZXZpb3VzUGF0aHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzID0gW107XG4gICAgICB3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzID0gW107XG4gICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNlcnMgdG8gdXBkYXRlIE9wdGlvbnMgYWZ0ZXIgdGhlIGNoYXJ0IGhhcyByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQSBuZXcgY29uZmlnIG9iamVjdCBjYW4gYmUgcGFzc2VkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZHJhdyAtIHNob3VsZCByZWRyYXcgZnJvbSBiZWdpbm5pbmcgb3Igc2hvdWxkIHVzZSBleGlzdGluZyBwYXRocyBhbmQgcmVkcmF3IGZyb20gdGhlcmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgLSBzaG91bGQgYW5pbWF0ZSBvciBub3Qgb24gdXBkYXRpbmcgT3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciByZWRyYXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbENvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAob3B0aW9ucyQkMS5zZXJpZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMkJDEuc2VyaWVzWzBdLmRhdGEpIHtcbiAgICAgICAgICBvcHRpb25zJCQxLnNlcmllcyA9IG9wdGlvbnMkJDEuc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHcuY29uZmlnLnNlcmllc1tpXSwge1xuICAgICAgICAgICAgICBuYW1lOiBzLm5hbWUgPyBzLm5hbWUgOiB3LmNvbmZpZy5zZXJpZXNbaV0gJiYgdy5jb25maWcuc2VyaWVzW2ldLm5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6IHMudHlwZSA/IHMudHlwZSA6IHcuY29uZmlnLnNlcmllc1tpXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0udHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogcy5kYXRhID8gcy5kYXRhIDogdy5jb25maWcuc2VyaWVzW2ldICYmIHcuY29uZmlnLnNlcmllc1tpXS5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyB1c2VyIHVwZGF0ZWQgdGhlIHNlcmllcyB2aWEgdXBkYXRlT3B0aW9ucygpIGZ1bmN0aW9uLlxuICAgICAgICAvLyBIZW5jZSwgd2UgbmVlZCB0byByZXNldCBheGlzIG1pbi9tYXggdG8gYXZvaWQgem9vbWluZyBpc3N1ZXNcblxuXG4gICAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIH0gLy8gdXNlciBoYXMgc2V0IHgtYXhpcyBtaW4vbWF4IGV4dGVybmFsbHkgLSBoZW5jZSB3ZSBuZWVkIHRvIGZvcmNlZnVsbHkgc2V0IHRoZSB4YXhpcyBtaW4vbWF4XG5cblxuICAgICAgaWYgKG9wdGlvbnMkJDEueGF4aXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMkJDEueGF4aXMubWluIHx8IG9wdGlvbnMkJDEueGF4aXMubWF4KSB7XG4gICAgICAgICAgdGhpcy5mb3JjZVhBeGlzVXBkYXRlKG9wdGlvbnMkJDEpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZpeGVzIGFwZXhjaGFydHMuanMjMzY5IGFuZCByZWFjdC1hcGV4Y2hhcnRzIzQ2ICovXG5cblxuICAgICAgICBpZiAob3B0aW9ucyQkMS54YXhpcy5jYXRlZ29yaWVzICYmIG9wdGlvbnMkJDEueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggJiYgdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgb3B0aW9ucyQkMSA9IERlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWMob3B0aW9ucyQkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jbGVhclByZXZpb3VzUGF0aHMoKTtcbiAgICAgIH1cbiAgICAgIC8qIHVwZGF0ZSB0aGVtZSBtb2RlIzQ1OSAqL1xuXG5cbiAgICAgIGlmIChvcHRpb25zJCQxLnRoZW1lKSB7XG4gICAgICAgIG9wdGlvbnMkJDEgPSB0aGlzLnRoZW1lLnVwZGF0ZVRoZW1lT3B0aW9ucyhvcHRpb25zJCQxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU9wdGlvbnMob3B0aW9ucyQkMSwgcmVkcmF3LCBhbmltYXRlLCBvdmVyd3JpdGVJbml0aWFsQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIE9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgbmV3IGNvbmZpZyBvYmplY3QgY2FuIGJlIHBhc3NlZCB3aGljaCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWRyYXcgLSBzaG91bGQgcmVkcmF3IGZyb20gYmVnaW5uaW5nIG9yIHNob3VsZCB1c2UgZXhpc3RpbmcgcGF0aHMgYW5kIHJlZHJhdyBmcm9tIHRoZXJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gc2hvdWxkIGFuaW1hdGUgb3Igbm90IG9uIHVwZGF0aW5nIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZUluaXRpYWxDb25maWcgLSBzaG91bGQgdXBkYXRlIHRoZSBpbml0aWFsIGNvbmZpZyBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVPcHRpb25zKG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciByZWRyYXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbENvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgY2hhcnRzID0gdGhpcy5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgIGNoYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgdyA9IGNoLnc7XG4gICAgICAgIHcuZ2xvYmFscy5zaG91bGRBbmltYXRlID0gYW5pbWF0ZTtcblxuICAgICAgICBpZiAoIXJlZHJhdykge1xuICAgICAgICAgIHcuZ2xvYmFscy5yZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIGNoLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMkJDEgJiYgX3R5cGVvZihvcHRpb25zJCQxKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaC5jb25maWcgPSBuZXcgQ29uZmlnKG9wdGlvbnMkJDEpO1xuICAgICAgICAgIG9wdGlvbnMkJDEgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhjaC5jb25maWcsIG9wdGlvbnMkJDEpO1xuICAgICAgICAgIHcuY29uZmlnID0gVXRpbHMuZXh0ZW5kKHcuY29uZmlnLCBvcHRpb25zJCQxKTtcblxuICAgICAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGZvcmdldCB0aGUgbGFzdFhBeGlzIGFuZCBsYXN0WUF4aXMgaXMgdXNlciBmb3JjZWZ1bGx5IG92ZXJ3cml0ZUluaXRpYWxDb25maWcuIElmIHdlIGRvIG5vdCBkbyB0aGlzLCBhbmQgbmV4dCB0aW1lIHdoZW4gdXNlciB6b29tcyB0aGUgY2hhcnQgYWZ0ZXIgc2V0dGluZyB5YXhpcy5taW4vbWF4IG9yIHhheGlzLm1pbi9tYXggLSB0aGUgc3RvcmVkIGxhc3RYQXhpcyB3aWxsIG5ldmVyIGFsbG93IHRoZSBjaGFydCB0byB1c2UgdGhlIHVwZGF0ZWQgbWluL21heCBieSB1c2VyLlxuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcyA9IFtdO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RZQXhpcyA9IFtdOyAvLyBBZnRlciBmb3JnZXR0aW5nIGxhc3RBeGVzLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIG5ldyBjb25maWcgaW4gaW5pdGlhbENvbmZpZy9pbml0aWFsU2VyaWVzXG5cbiAgICAgICAgICAgIHcuZ2xvYmFscy5pbml0aWFsQ29uZmlnID0gVXRpbHMuZXh0ZW5kKHt9LCB3LmNvbmZpZyk7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkody5jb25maWcuc2VyaWVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoLnVwZGF0ZShvcHRpb25zJCQxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNlcnMgdG8gdXBkYXRlIFNlcmllcyBhZnRlciB0aGUgY2hhcnQgaGFzIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gc2VyaWVzIC0gTmV3IHNlcmllcyB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlcmllcygpIHtcbiAgICAgIHZhciBuZXdTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbFNlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlLCBvdmVyd3JpdGVJbml0aWFsU2VyaWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzZXJzIHRvIGFwcGVuZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgdGhlIGNoYXJ0IGhhcyByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld1NlcmllIC0gTmV3IHNlcmllIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGV4aXN0aW5nIHNlcmllc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFNlcmllcyhuZXdTZXJpZSkge1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgbmV3U2VyaWVzID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcbiAgICAgIG5ld1Nlcmllcy5wdXNoKG5ld1NlcmllKTtcbiAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIFNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHNlcmllcyAtIE5ldyBzZXJpZXMgd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgZXhpc3RpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVNlcmllcyhuZXdTZXJpZXMsIGFuaW1hdGUpIHtcbiAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy53Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlOyAvLyBpZiB1c2VyIGhhcyBjb2xsYXBzZWQgc29tZSBzZXJpZXMgd2l0aCBsZWdlbmQsIHdlIG5lZWQgdG8gY2xlYXIgdGhvc2VcblxuICAgICAgaWYgKHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleGlzdGluZ1NlcmllczsgLy8gYXhpcyBjaGFydHNcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIGV4aXN0aW5nU2VyaWVzID0gbmV3U2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCB3LmNvbmZpZy5zZXJpZXNbaV0sIHtcbiAgICAgICAgICAgIG5hbWU6IHMubmFtZSA/IHMubmFtZSA6IHcuY29uZmlnLnNlcmllc1tpXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHMudHlwZSA/IHMudHlwZSA6IHcuY29uZmlnLnNlcmllc1tpXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0udHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHMuZGF0YSA/IHMuZGF0YSA6IHcuY29uZmlnLnNlcmllc1tpXSAmJiB3LmNvbmZpZy5zZXJpZXNbaV0uZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXhpc3RpbmdTZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhpc3RpbmdTZXJpZXMgPSBbe1xuICAgICAgICAgICAgZGF0YTogW11cbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuY29uZmlnLnNlcmllcyA9IGV4aXN0aW5nU2VyaWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWF4aXMgY2hhcnQgKHBpZS9yYWRpYWxiYXIpXG4gICAgICAgIHcuY29uZmlnLnNlcmllcyA9IG5ld1Nlcmllcy5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcndyaXRlSW5pdGlhbFNlcmllcykge1xuICAgICAgICB3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZy5zZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHcuY29uZmlnLnNlcmllcykpO1xuICAgICAgICB3Lmdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkody5jb25maWcuc2VyaWVzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGNoYXJ0cyBpbiB0aGUgc2FtZSBcImdyb3VwXCIgKGluY2x1ZGluZyB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgY2FsbGVkIHVwb24pIHRvIHN5bmMgdGhlbSB3aGVuIHVzZXIgem9vbXMgaW4vb3V0IG9yIHBhbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFN5bmNlZENoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTeW5jZWRDaGFydHMoKSB7XG4gICAgICB2YXIgY2hhcnRHcm91cHMgPSB0aGlzLmdldEdyb3VwZWRDaGFydHMoKTtcbiAgICAgIHZhciBhbGxDaGFydHMgPSBbdGhpc107XG5cbiAgICAgIGlmIChjaGFydEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgYWxsQ2hhcnRzID0gW107XG4gICAgICAgIGNoYXJ0R3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgYWxsQ2hhcnRzLnB1c2goY2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbENoYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNoYXJ0cyBpbiB0aGUgc2FtZSBcImdyb3VwXCIgKGV4Y2x1ZGluZyB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgY2FsbGVkIHVwb24pIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGUgb3RoZXIgY2hhcnRzIG9mIHRoZSBzYW1lIGdyb3VwIChlZy4sIHRvb2x0aXAgaG92ZXJpbmcpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcm91cGVkQ2hhcnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyb3VwZWRDaGFydHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIEFwZXguX2NoYXJ0SW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgaWYgKGNoLmdyb3VwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi53LmNvbmZpZy5jaGFydC5ncm91cCA9PT0gY2guZ3JvdXAgPyBjaC5jaGFydCA6IF90aGlzMjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNlcnMgdG8gYXBwZW5kIERhdGEgdG8gc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gbmV3RGF0YSAtIE5ldyBkYXRhIGluIHRoZSBzYW1lIGZvcm1hdCBhcyBzZXJpZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kRGF0YShuZXdEYXRhKSB7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbFNlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBtZS53Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgbWUuc2VyaWVzLmdldFByZXZpb3VzUGF0aHMoKTtcbiAgICAgIHZhciBuZXdTZXJpZXMgPSBtZS53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdEYXRhW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RGF0YVtpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBuZXdTZXJpZXNbaV0uZGF0YS5wdXNoKG5ld0RhdGFbaV0uZGF0YVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lLncuY29uZmlnLnNlcmllcyA9IG5ld1NlcmllcztcblxuICAgICAgaWYgKG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpIHtcbiAgICAgICAgbWUudy5nbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lLncuY29uZmlnLnNlcmllcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zJCQxKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpczMuY2xlYXIoKTtcblxuICAgICAgICB2YXIgZ3JhcGhEYXRhID0gX3RoaXMzLmNyZWF0ZShfdGhpczMudy5jb25maWcuc2VyaWVzLCBvcHRpb25zJCQxKTtcblxuICAgICAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuIHJlc29sdmUoX3RoaXMzKTtcblxuICAgICAgICBfdGhpczMubW91bnQoZ3JhcGhEYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIF90aGlzMy53LmNvbmZpZy5jaGFydC5ldmVudHMudXBkYXRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX3RoaXMzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy51cGRhdGVkKF90aGlzMywgX3RoaXMzLncpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ3VwZGF0ZWQnLCBbX3RoaXMzLCBfdGhpczMud10pO1xuXG4gICAgICAgICAgX3RoaXMzLncuZ2xvYmFscy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKF90aGlzMyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZVhBeGlzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmNlWEF4aXNVcGRhdGUob3B0aW9ucyQkMSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyQkMS54YXhpcy5taW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHcuY29uZmlnLnhheGlzLm1pbiA9IG9wdGlvbnMkJDEueGF4aXMubWluO1xuICAgICAgICB3Lmdsb2JhbHMubGFzdFhBeGlzLm1pbiA9IG9wdGlvbnMkJDEueGF4aXMubWluO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMkJDEueGF4aXMubWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3LmNvbmZpZy54YXhpcy5tYXggPSBvcHRpb25zJCQxLnhheGlzLm1heDtcbiAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcy5tYXggPSBvcHRpb25zJCQxLnhheGlzLm1heDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXZlcnRzIHRoZSB5YXhpcyBhbmQgeGF4aXMgbWluL21heCB2YWx1ZXMgdG8gd2hhdCBpdCB3YXMgd2hlbiB0aGUgY2hhcnQgd2FzIGRlZmluZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBmaXhlcyBhbiBpbXBvcnRhbnQgYnVnIHdoZXJlIGEgdXNlciBtaWdodCBsb2FkIGEgbmV3IHNlcmllcyBhZnRlciB6b29taW5nIGluL291dCBvZiBwcmV2aW91cyBzZXJpZXMgd2hpY2ggcmVzdWx0ZWQgaW4gd3JvbmcgbWluL21heFxuICAgICAqIEFsc28sIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBpbnRlcm5hbGx5IG9uIHpvb20vcGFuIC0gdGhlIHJlc2V0IHNob3VsZCBvbmx5IGhhcHBlbiB3aGVuIHVzZXIgY2FsbHMgdGhlIHVwZGF0ZVNlcmllcygpIGZ1bmN0aW9uIGV4dGVybmFsbHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJldmVydERlZmF1bHRBeGlzTWluTWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydERlZmF1bHRBeGlzTWluTWF4KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3LmNvbmZpZy54YXhpcy5taW4gPSB3Lmdsb2JhbHMubGFzdFhBeGlzLm1pbjtcbiAgICAgIHcuY29uZmlnLnhheGlzLm1heCA9IHcuZ2xvYmFscy5sYXN0WEF4aXMubWF4O1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21lZCkge1xuICAgICAgICAgIC8vIGlmIHVzZXIgaGFzIHpvb21lZCwgYW5kIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGdldCB0aGUgbGFzdEF4aXMgbWluIGFuZCBtYXhcbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5sYXN0WUF4aXNbaW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgeWF4ZS5taW4gPSB3Lmdsb2JhbHMubGFzdFlBeGlzW2luZGV4XS5taW47XG4gICAgICAgICAgICB5YXhlLm1heCA9IHcuZ2xvYmFscy5sYXN0WUF4aXNbaW5kZXhdLm1heDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGlmICh0aGlzLnpvb21QYW5TZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy56b29tUGFuU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG9vbGJhcikge1xuICAgICAgICB0aGlzLnRvb2xiYXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNvcmUgPSBudWxsO1xuICAgICAgdGhpcy5ncmlkID0gbnVsbDtcbiAgICAgIHRoaXMuc2VyaWVzID0gbnVsbDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IG51bGw7XG4gICAgICB0aGlzLnRoZW1lID0gbnVsbDtcbiAgICAgIHRoaXMuZm9ybWF0dGVycyA9IG51bGw7XG4gICAgICB0aGlzLnRpdGxlU3VidGl0bGUgPSBudWxsO1xuICAgICAgdGhpcy5sZWdlbmQgPSBudWxsO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gbnVsbDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNyb3NzaGFpcnMgPSBudWxsO1xuICAgICAgdGhpcy56b29tUGFuU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMudG9vbGJhciA9IG51bGw7XG4gICAgICB0aGlzLncuZ2xvYmFscy50b29sdGlwID0gbnVsbDtcbiAgICAgIHRoaXMuY2xlYXJEb21FbGVtZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJraWxsU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGxTVkcoZHJhdykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkcmF3LmVhY2goZnVuY3Rpb24gKGksIGNoaWxkcmVuKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygnKicpO1xuICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBkcmF3LnVuZ3JvdXAoKTtcbiAgICAgICAgZHJhdy5jbGVhcigpO1xuICAgICAgICByZXNvbHZlKCdkb25lJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJEb21FbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckRvbUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGRvbUVscyA9IHRoaXMudy5nbG9iYWxzLmRvbTtcblxuICAgICAgaWYgKHRoaXMuZWwgIT09IG51bGwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHJlc2V0dGluZyB0aGUgd2hvbGUgY2hhcnRcbiAgICAgICAgd2hpbGUgKHRoaXMuZWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQ2hpbGQodGhpcy5lbC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmtpbGxTVkcoZG9tRWxzLlBhcGVyKTtcbiAgICAgIGRvbUVscy5QYXBlci5yZW1vdmUoKTtcbiAgICAgIGRvbUVscy5lbFdyYXAgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JhcGhpY2FsID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbExlZ2VuZFdyYXAgPSBudWxsO1xuICAgICAgZG9tRWxzLmJhc2VFbCA9IG51bGw7XG4gICAgICBkb21FbHMuZWxHcmlkUmVjdCA9IG51bGw7XG4gICAgICBkb21FbHMuZWxHcmlkUmVjdE1hc2sgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JpZFJlY3RNYXJrZXJNYXNrID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbERlZnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBjaGFydCBpbnN0YW5jZSBieSByZW1vdmluZyBhbGwgZWxlbWVudHMgd2hpY2ggYWxzbyBjbGVhbiB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhvc2UgZWxlbWVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7IC8vIHJlbW92ZSB0aGUgY2hhcnQncyBpbnN0YW5jZSBmcm9tIHRoZSBnbG9iYWwgQXBleC5fY2hhcnRJbnN0YW5jZXNcblxuICAgICAgdmFyIGNoYXJ0SUQgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmlkO1xuXG4gICAgICBpZiAoY2hhcnRJRCkge1xuICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgaWYgKGMuaWQgPT09IGNoYXJ0SUQpIHtcbiAgICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy53aW5kb3dSZXNpemVIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVSZXNpemVMaXN0ZW5lcih0aGlzLmVsLnBhcmVudE5vZGUsIHRoaXMucGFyZW50UmVzaXplQ2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBwcm92aWRlIGRhdGEgYXR0cnMgaW4gdGhlIGVsZW1lbnQgYW5kIHRoZSBjaGFydCB3aWxsIHJlbmRlciBhdXRvbWF0aWNhbGx5IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGVsZW1lbnRzIGNvbnRhaW5pbmcgJ2RhdGEtYXBleGNoYXJ0cycgYXR0cmlidXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlU2VyaWVzKHNlcmllc05hbWUpIHtcbiAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5zZXJpZXMuZ2V0U2VyaWVzQnlOYW1lKHNlcmllc05hbWUpO1xuICAgICAgdmFyIHNlcmllc0NudCA9IHBhcnNlSW50KHRhcmdldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgIHZhciBpc0hpZGRlbiA9IHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQnKTtcbiAgICAgIHRoaXMubGVnZW5kLnRvZ2dsZURhdGFTZXJpZXMoc2VyaWVzQ250LCBpc0hpZGRlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0VG9nZ2xlU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VG9nZ2xlU2VyaWVzKCkge1xuICAgICAgdGhpcy5sZWdlbmQucmVzZXRUb2dnbGVEYXRhU2VyaWVzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwRXZlbnRIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgY2xpY2thYmxlQXJlYSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3Iody5nbG9iYWxzLmNoYXJ0Q2xhc3MpO1xuICAgICAgdmFyIGV2ZW50TGlzdCA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICdtb3VzZXVwJywgJ3RvdWNoZW5kJ107XG4gICAgICBldmVudExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY2xpY2thYmxlQXJlYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGUud2hpY2ggPT09IDEpIDsgZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2V1cCcgJiYgZS53aGljaCA9PT0gMSB8fCBlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5jbGljayhlLCBtZSwgdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmVFdmVudCgnY2xpY2snLCBbZSwgbWUsIHddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBldmVudExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgICAgICB3Lmdsb2JhbHMuY2xpZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WSA6IGUuY2xpZW50WTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29yZS5zZXR1cEJydXNoSGFuZGxlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRYYXhpc0Fubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWGF4aXNBbm5vdGF0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5hZGRYYXhpc0Fubm90YXRpb25FeHRlcm5hbChvcHRzLCBwdXNoVG9NZW1vcnksIG1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWWF4aXNBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFlheGlzQW5ub3RhdGlvbihvcHRzKSB7XG4gICAgICB2YXIgcHVzaFRvTWVtb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgbWUuYW5ub3RhdGlvbnMuYWRkWWF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwob3B0cywgcHVzaFRvTWVtb3J5LCBtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFBvaW50QW5ub3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQb2ludEFubm90YXRpb24ob3B0cykge1xuICAgICAgdmFyIHB1c2hUb01lbW9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIG1lLmFubm90YXRpb25zLmFkZFBvaW50QW5ub3RhdGlvbkV4dGVybmFsKG9wdHMsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbnMoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5jbGVhckFubm90YXRpb25zKG1lKTtcbiAgICB9IC8vIFRoaXMgbWV0aG9kIGlzIG5ldmVyIHVzZWQgaW50ZXJuYWxseSBhbmQgd2lsbCBiZSBvbmx5IGNhbGxlZCBleHRlcm5hbGx5IG9uIHRoZSBjaGFydCBpbnN0YW5jZS5cbiAgICAvLyBIZW5jZSwgd2UgbmVlZCB0byBrZWVwIGFsbCB0aGVzZSBlbGVtZW50cyBpbiBtZW1vcnkgd2hlbiB0aGUgY2hhcnQgZ2V0cyB1cGRhdGVkIGFuZCByZWRyYXcgYWdhaW5cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGV4dChvcHRpb25zJCQxKSB7XG4gICAgICB2YXIgcHVzaFRvTWVtb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgbWUuYW5ub3RhdGlvbnMuYWRkVGV4dChvcHRpb25zJCQxLCBwdXNoVG9NZW1vcnksIG1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hhcnRBcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYXJ0QXJlYSgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtaW5uZXInKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VyaWVzVG90YWxYUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxYUmFuZ2UobWluWCwgbWF4WCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29yZVV0aWxzLmdldFNlcmllc1RvdGFsc1hSYW5nZShtaW5YLCBtYXhYKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGlnaGVzdFZhbHVlSW5TZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGlnaGVzdFZhbHVlSW5TZXJpZXMoKSB7XG4gICAgICB2YXIgc2VyaWVzSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UkMSh0aGlzLmN0eCk7XG4gICAgICB2YXIgbWluWW1heFkgPSByYW5nZS5nZXRNaW5ZTWF4WShzZXJpZXNJbmRleCk7XG4gICAgICByZXR1cm4gbWluWW1heFkuaGlnaGVzdFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExvd2VzdFZhbHVlSW5TZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG93ZXN0VmFsdWVJblNlcmllcygpIHtcbiAgICAgIHZhciBzZXJpZXNJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSQxKHRoaXMuY3R4KTtcbiAgICAgIHZhciBtaW5ZbWF4WSA9IHJhbmdlLmdldE1pbllNYXhZKHNlcmllc0luZGV4KTtcbiAgICAgIHJldHVybiBtaW5ZbWF4WS5sb3dlc3RZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5zZXJpZXNUb3RhbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExvY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2NhbGUobG9jYWxlTmFtZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50TG9jYWxlVmFsdWVzKGxvY2FsZU5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJyZW50TG9jYWxlVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRMb2NhbGVWYWx1ZXMobG9jYWxlTmFtZSkge1xuICAgICAgdmFyIGxvY2FsZXMgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmxvY2FsZXM7IC8vIGNoZWNrIGlmIHVzZXIgaGFzIHNwZWNpZmllZCBsb2NhbGVzIGluIGdsb2JhbCBBcGV4IHZhcmlhYmxlXG4gICAgICAvLyBpZiB5ZXMgLSB0aGVuIGV4dGVuZCB0aG9zZSB3aXRoIGxvY2FsIGNoYXJ0J3MgbG9jYWxlXG5cbiAgICAgIGlmICh3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC5sb2NhbGVzICYmIHdpbmRvdy5BcGV4LmNoYXJ0LmxvY2FsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2NhbGVzID0gdGhpcy53LmNvbmZpZy5jaGFydC5sb2NhbGVzLmNvbmNhdCh3aW5kb3cuQXBleC5jaGFydC5sb2NhbGVzKTtcbiAgICAgIH0gLy8gZmluZCB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5IG9mIGxvY2FsZXMgd2hpY2ggdXNlciBoYXMgc2V0IChlaXRoZXIgYnkgY2hhcnQuZGVmYXVsdExvY2FsZSBvciBieSBjYWxsaW5nIHNldExvY2FsZSgpIG1ldGhvZC4pXG5cblxuICAgICAgdmFyIHNlbGVjdGVkTG9jYWxlID0gbG9jYWxlcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMubmFtZSA9PT0gbG9jYWxlTmFtZTtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgY29tcGxldGUgbG9jYWxlIG9iamVjdCBieSBleHRlbmRpbmcgZGVmYXVsdHMgc28geW91IGRvbid0IGdldCB1bmRlZmluZWQgZXJyb3JzLlxuICAgICAgICB2YXIgcmV0ID0gVXRpbHMuZXh0ZW5kKGVuLCBzZWxlY3RlZExvY2FsZSk7IC8vIHN0b3JlIHRoZXNlIGxvY2FsZSBvcHRpb25zIGluIGdsb2JhbCB2YXIgZm9yIGVhc2UgYWNjZXNzXG5cbiAgICAgICAgdGhpcy53Lmdsb2JhbHMubG9jYWxlID0gcmV0Lm9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGxvY2FsZSBuYW1lIHByb3ZpZGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBzZXQgdGhlIGNvcnJlY3QgbG9jYWxlIG5hbWUgaW4gb3B0aW9ucycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhVVJJXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFVUkkoKSB7XG4gICAgICB2YXIgZXhwID0gbmV3IEV4cG9ydHModGhpcy5jdHgpO1xuICAgICAgcmV0dXJuIGV4cC5kYXRhVVJJKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5QYXBlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyZW50UmVzaXplQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyZW50UmVzaXplQ2FsbGJhY2soKSB7XG4gICAgICBpZiAodGhpcy53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQpIHtcbiAgICAgICAgdGhpcy53aW5kb3dSZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHdpbmRvdyByZXNpemUgYW5kIHJlLWRyYXcgdGhlIHdob2xlIGNoYXJ0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2luZG93UmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53Lmdsb2JhbHMucmVzaXplVGltZXIpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMucmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC53Lmdsb2JhbHMucmVzaXplZCA9IHRydWU7XG4gICAgICAgIF90aGlzNC53Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSBmYWxzZTsgLy8gd2UgbmVlZCB0byByZWRyYXcgdGhlIHdob2xlIGNoYXJ0IG9uIHdpbmRvdyByZXNpemUgKHdpdGggYSBzbWFsbCBkZWxheSkuXG5cbiAgICAgICAgX3RoaXM0LnVwZGF0ZSgpO1xuICAgICAgfSwgMTUwKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpbml0T25Mb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRPbkxvYWQoKSB7XG4gICAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYXBleGNoYXJ0c10nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gZWxzW2ldO1xuICAgICAgICB2YXIgb3B0aW9ucyQkMSA9IEpTT04ucGFyc2UoZWxzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1vcHRpb25zJykpO1xuICAgICAgICB2YXIgYXBleENoYXJ0ID0gbmV3IEFwZXhDaGFydHMoZWwsIG9wdGlvbnMkJDEpO1xuICAgICAgICBhcGV4Q2hhcnQucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCBhbGxvd3MgdXNlcnMgdG8gY2FsbCBjaGFydCBtZXRob2RzIHdpdGhvdXQgbmVjZXNzYXJpbHkgZnJvbSB0aGVcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgY2hhcnQgaW4gY2FzZSB1c2VyIGhhcyBhc3NpZ25lZCBjaGFydElEIHRvIHRoZSB0YXJnZXR0ZWQgY2hhcnQuXG4gICAgICogVGhlIGNoYXJ0SUQgaXMgdXNlZCBmb3IgbWFwcGluZyB0aGUgaW5zdGFuY2Ugc3RvcmVkIGluIEFwZXguX2NoYXJ0SW5zdGFuY2VzIGdsb2JhbCB2YXJpYWJsZVxuICAgICAqXG4gICAgICogVGhpcyBpcyBoZWxwZnVsIGluIGNhc2VzIHdoZW4geW91IGRvbid0IGhhdmUgcmVmZXJlbmNlIG9mIHRoZSBjaGFydCBpbnN0YW5jZVxuICAgICAqIGVhc2lseSBhbmQgbmVlZCB0byBjYWxsIHRoZSBtZXRob2QgZnJvbSBhbnl3aGVyZS5cbiAgICAgKiBGb3IgZWcsIGluIFJlYWN0L1Z1ZSBhcHBsaWNhdGlvbnMgd2hlbiB5b3UgaGF2ZSBtYW55IHBhcmVudC9jaGlsZCBjb21wb25lbnRzLFxuICAgICAqIGFuZCBuZWVkIGVhc3kgcmVmZXJlbmNlIHRvIG90aGVyIGNoYXJ0cyBmb3IgcGVyZm9ybWluZyBkeW5hbWljIG9wZXJhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydElEIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjYWxsIG1ldGhvZHNcbiAgICAgKiBvbiB0aGF0IGNoYXJ0IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgbWV0aG9kIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIHBhcmFtZXRlcnMgd2hpY2ggYXJlIGFjY2VwdGVkIGluIHRoZSBvcmlnaW5hbCBtZXRob2Qgd2lsbCBiZSBwYXNzZWQgaGVyZSBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4ZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhlYyhjaGFydElELCBmbikge1xuICAgICAgdmFyIGNoYXJ0ID0gdGhpcy5nZXRDaGFydEJ5SUQoY2hhcnRJRCk7XG4gICAgICBpZiAoIWNoYXJ0KSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgb3B0c1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZm4pIHtcbiAgICAgICAgY2FzZSAndXBkYXRlT3B0aW9ucyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LnVwZGF0ZU9wdGlvbnMuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd1cGRhdGVTZXJpZXMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC51cGRhdGVTZXJpZXMuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhcHBlbmREYXRhJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuYXBwZW5kRGF0YS5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2FwcGVuZFNlcmllcyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmFwcGVuZFNlcmllcy5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RvZ2dsZVNlcmllcyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LnRvZ2dsZVNlcmllcy5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RhdGFVUkknOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5kYXRhVVJJLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYWRkWGF4aXNBbm5vdGF0aW9uJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuYWRkWGF4aXNBbm5vdGF0aW9uLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYWRkWWF4aXNBbm5vdGF0aW9uJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuYWRkWWF4aXNBbm5vdGF0aW9uLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYWRkUG9pbnRBbm5vdGF0aW9uJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuYWRkUG9pbnRBbm5vdGF0aW9uLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYWRkVGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmFkZFRleHQuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjbGVhckFubm90YXRpb25zJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuY2xlYXJBbm5vdGF0aW9ucy5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BhcGVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQucGFwZXIuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGFydEJ5SURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhcnRCeUlEKGNoYXJ0SUQpIHtcbiAgICAgIHZhciBjID0gQXBleC5fY2hhcnRJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gY2guaWQgPT09IGNoYXJ0SUQ7XG4gICAgICB9KVswXTtcblxuICAgICAgcmV0dXJuIGMuY2hhcnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFwZXhDaGFydHM7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwZXhDaGFydHMkMTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apexcharts/dist/apexcharts.esm.js\n");

/***/ }),

/***/ "./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * clipboard.js v2.0.4\n * https://zenorocha.github.io/clipboard.js\n * \n * Licensed MIT © Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _clipboardAction = __webpack_require__(1);\n\nvar _clipboardAction2 = _interopRequireDefault(_clipboardAction);\n\nvar _tinyEmitter = __webpack_require__(3);\n\nvar _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);\n\nvar _goodListener = __webpack_require__(4);\n\nvar _goodListener2 = _interopRequireDefault(_goodListener);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.\n */\nvar Clipboard = function (_Emitter) {\n    _inherits(Clipboard, _Emitter);\n\n    /**\n     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n     * @param {Object} options\n     */\n    function Clipboard(trigger, options) {\n        _classCallCheck(this, Clipboard);\n\n        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\n\n        _this.resolveOptions(options);\n        _this.listenClick(trigger);\n        return _this;\n    }\n\n    /**\n     * Defines if attributes would be resolved using internal setter functions\n     * or custom functions that were passed in the constructor.\n     * @param {Object} options\n     */\n\n\n    _createClass(Clipboard, [{\n        key: 'resolveOptions',\n        value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n            this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n            this.container = _typeof(options.container) === 'object' ? options.container : document.body;\n        }\n\n        /**\n         * Adds a click event listener to the passed trigger.\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         */\n\n    }, {\n        key: 'listenClick',\n        value: function listenClick(trigger) {\n            var _this2 = this;\n\n            this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {\n                return _this2.onClick(e);\n            });\n        }\n\n        /**\n         * Defines a new `ClipboardAction` on each click event.\n         * @param {Event} e\n         */\n\n    }, {\n        key: 'onClick',\n        value: function onClick(e) {\n            var trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n                this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new _clipboardAction2.default({\n                action: this.action(trigger),\n                target: this.target(trigger),\n                text: this.text(trigger),\n                container: this.container,\n                trigger: trigger,\n                emitter: this\n            });\n        }\n\n        /**\n         * Default `action` lookup function.\n         * @param {Element} trigger\n         */\n\n    }, {\n        key: 'defaultAction',\n        value: function defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n        }\n\n        /**\n         * Default `target` lookup function.\n         * @param {Element} trigger\n         */\n\n    }, {\n        key: 'defaultTarget',\n        value: function defaultTarget(trigger) {\n            var selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n                return document.querySelector(selector);\n            }\n        }\n\n        /**\n         * Returns the support of the given action, or all actions if no action is\n         * given.\n         * @param {String} [action]\n         */\n\n    }, {\n        key: 'defaultText',\n\n\n        /**\n         * Default `text` lookup function.\n         * @param {Element} trigger\n         */\n        value: function defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n        }\n\n        /**\n         * Destroy lifecycle.\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n                this.clipboardAction.destroy();\n                this.clipboardAction = null;\n            }\n        }\n    }], [{\n        key: 'isSupported',\n        value: function isSupported() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n\n            var actions = typeof action === 'string' ? [action] : action;\n            var support = !!document.queryCommandSupported;\n\n            actions.forEach(function (action) {\n                support = support && !!document.queryCommandSupported(action);\n            });\n\n            return support;\n        }\n    }]);\n\n    return Clipboard;\n}(_tinyEmitter2.default);\n\n/**\n * Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element\n */\n\n\nfunction getAttributeValue(suffix, element) {\n    var attribute = 'data-clipboard-' + suffix;\n\n    if (!element.hasAttribute(attribute)) {\n        return;\n    }\n\n    return element.getAttribute(attribute);\n}\n\nmodule.exports = Clipboard;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _select = __webpack_require__(2);\n\nvar _select2 = _interopRequireDefault(_select);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Inner class which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n */\nvar ClipboardAction = function () {\n    /**\n     * @param {Object} options\n     */\n    function ClipboardAction(options) {\n        _classCallCheck(this, ClipboardAction);\n\n        this.resolveOptions(options);\n        this.initSelection();\n    }\n\n    /**\n     * Defines base properties passed from constructor.\n     * @param {Object} options\n     */\n\n\n    _createClass(ClipboardAction, [{\n        key: 'resolveOptions',\n        value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.action = options.action;\n            this.container = options.container;\n            this.emitter = options.emitter;\n            this.target = options.target;\n            this.text = options.text;\n            this.trigger = options.trigger;\n\n            this.selectedText = '';\n        }\n\n        /**\n         * Decides which selection strategy is going to be applied based\n         * on the existence of `text` and `target` properties.\n         */\n\n    }, {\n        key: 'initSelection',\n        value: function initSelection() {\n            if (this.text) {\n                this.selectFake();\n            } else if (this.target) {\n                this.selectTarget();\n            }\n        }\n\n        /**\n         * Creates a fake textarea element, sets its value from `text` property,\n         * and makes a selection on it.\n         */\n\n    }, {\n        key: 'selectFake',\n        value: function selectFake() {\n            var _this = this;\n\n            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n\n            this.removeFake();\n\n            this.fakeHandlerCallback = function () {\n                return _this.removeFake();\n            };\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n\n            this.fakeElem = document.createElement('textarea');\n            // Prevent zooming on iOS\n            this.fakeElem.style.fontSize = '12pt';\n            // Reset box model\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0';\n            // Move element out of screen horizontally\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';\n            // Move element to the same position vertically\n            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = yPosition + 'px';\n\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n\n            this.container.appendChild(this.fakeElem);\n\n            this.selectedText = (0, _select2.default)(this.fakeElem);\n            this.copyText();\n        }\n\n        /**\n         * Only removes the fake element after another click event, that way\n         * a user can hit `Ctrl+C` to copy because selection still exists.\n         */\n\n    }, {\n        key: 'removeFake',\n        value: function removeFake() {\n            if (this.fakeHandler) {\n                this.container.removeEventListener('click', this.fakeHandlerCallback);\n                this.fakeHandler = null;\n                this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n                this.container.removeChild(this.fakeElem);\n                this.fakeElem = null;\n            }\n        }\n\n        /**\n         * Selects the content from element passed on `target` property.\n         */\n\n    }, {\n        key: 'selectTarget',\n        value: function selectTarget() {\n            this.selectedText = (0, _select2.default)(this.target);\n            this.copyText();\n        }\n\n        /**\n         * Executes the copy operation based on the current selection.\n         */\n\n    }, {\n        key: 'copyText',\n        value: function copyText() {\n            var succeeded = void 0;\n\n            try {\n                succeeded = document.execCommand(this.action);\n            } catch (err) {\n                succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n        }\n\n        /**\n         * Fires an event based on the copy operation result.\n         * @param {Boolean} succeeded\n         */\n\n    }, {\n        key: 'handleResult',\n        value: function handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n                action: this.action,\n                text: this.selectedText,\n                trigger: this.trigger,\n                clearSelection: this.clearSelection.bind(this)\n            });\n        }\n\n        /**\n         * Moves focus away from `target` and back to the trigger, removes current selection.\n         */\n\n    }, {\n        key: 'clearSelection',\n        value: function clearSelection() {\n            if (this.trigger) {\n                this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n        }\n\n        /**\n         * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n         * @param {String} action\n         */\n\n    }, {\n        key: 'destroy',\n\n\n        /**\n         * Destroy lifecycle.\n         */\n        value: function destroy() {\n            this.removeFake();\n        }\n    }, {\n        key: 'action',\n        set: function set() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n                throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n        }\n\n        /**\n         * Gets the `action` property.\n         * @return {String}\n         */\n        ,\n        get: function get() {\n            return this._action;\n        }\n\n        /**\n         * Sets the `target` property using an element\n         * that will be have its content copied.\n         * @param {Element} target\n         */\n\n    }, {\n        key: 'target',\n        set: function set(target) {\n            if (target !== undefined) {\n                if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {\n                    if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                        throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                    }\n\n                    if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                        throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                    }\n\n                    this._target = target;\n                } else {\n                    throw new Error('Invalid \"target\" value, use a valid Element');\n                }\n            }\n        }\n\n        /**\n         * Gets the `target` property.\n         * @return {String|HTMLElement}\n         */\n        ,\n        get: function get() {\n            return this._target;\n        }\n    }]);\n\n    return ClipboardAction;\n}();\n\nmodule.exports = ClipboardAction;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nfunction select(element) {\n    var selectedText;\n\n    if (element.nodeName === 'SELECT') {\n        element.focus();\n\n        selectedText = element.value;\n    }\n    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n        var isReadOnly = element.hasAttribute('readonly');\n\n        if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n        }\n\n        element.select();\n        element.setSelectionRange(0, element.value.length);\n\n        if (!isReadOnly) {\n            element.removeAttribute('readonly');\n        }\n\n        selectedText = element.value;\n    }\n    else {\n        if (element.hasAttribute('contenteditable')) {\n            element.focus();\n        }\n\n        var selection = window.getSelection();\n        var range = document.createRange();\n\n        range.selectNodeContents(element);\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        selectedText = selection.toString();\n    }\n\n    return selectedText;\n}\n\nmodule.exports = select;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nfunction E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar is = __webpack_require__(5);\nvar delegate = __webpack_require__(6);\n\n/**\n * Validates all params and calls the right\n * listener function based on its target type.\n *\n * @param {String|HTMLElement|HTMLCollection|NodeList} target\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listen(target, type, callback) {\n    if (!target && !type && !callback) {\n        throw new Error('Missing required arguments');\n    }\n\n    if (!is.string(type)) {\n        throw new TypeError('Second argument must be a String');\n    }\n\n    if (!is.fn(callback)) {\n        throw new TypeError('Third argument must be a Function');\n    }\n\n    if (is.node(target)) {\n        return listenNode(target, type, callback);\n    }\n    else if (is.nodeList(target)) {\n        return listenNodeList(target, type, callback);\n    }\n    else if (is.string(target)) {\n        return listenSelector(target, type, callback);\n    }\n    else {\n        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n    }\n}\n\n/**\n * Adds an event listener to a HTML element\n * and returns a remove listener function.\n *\n * @param {HTMLElement} node\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNode(node, type, callback) {\n    node.addEventListener(type, callback);\n\n    return {\n        destroy: function() {\n            node.removeEventListener(type, callback);\n        }\n    }\n}\n\n/**\n * Add an event listener to a list of HTML elements\n * and returns a remove listener function.\n *\n * @param {NodeList|HTMLCollection} nodeList\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNodeList(nodeList, type, callback) {\n    Array.prototype.forEach.call(nodeList, function(node) {\n        node.addEventListener(type, callback);\n    });\n\n    return {\n        destroy: function() {\n            Array.prototype.forEach.call(nodeList, function(node) {\n                node.removeEventListener(type, callback);\n            });\n        }\n    }\n}\n\n/**\n * Add an event listener to a selector\n * and returns a remove listener function.\n *\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenSelector(selector, type, callback) {\n    return delegate(document.body, selector, type, callback);\n}\n\nmodule.exports = listen;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n/**\n * Check if argument is a HTML element.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.node = function(value) {\n    return value !== undefined\n        && value instanceof HTMLElement\n        && value.nodeType === 1;\n};\n\n/**\n * Check if argument is a list of HTML elements.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.nodeList = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return value !== undefined\n        && (type === '[object NodeList]' || type === '[object HTMLCollection]')\n        && ('length' in value)\n        && (value.length === 0 || exports.node(value[0]));\n};\n\n/**\n * Check if argument is a string.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.string = function(value) {\n    return typeof value === 'string'\n        || value instanceof String;\n};\n\n/**\n * Check if argument is a function.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.fn = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return type === '[object Function]';\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar closest = __webpack_require__(7);\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction _delegate(element, selector, type, callback, useCapture) {\n    var listenerFn = listener.apply(this, arguments);\n\n    element.addEventListener(type, listenerFn, useCapture);\n\n    return {\n        destroy: function() {\n            element.removeEventListener(type, listenerFn, useCapture);\n        }\n    }\n}\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element|String|Array} [elements]\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction delegate(elements, selector, type, callback, useCapture) {\n    // Handle the regular Element usage\n    if (typeof elements.addEventListener === 'function') {\n        return _delegate.apply(null, arguments);\n    }\n\n    // Handle Element-less usage, it defaults to global delegation\n    if (typeof type === 'function') {\n        // Use `document` as the first parameter, then apply arguments\n        // This is a short way to .unshift `arguments` without running into deoptimizations\n        return _delegate.bind(null, document).apply(null, arguments);\n    }\n\n    // Handle Selector-based usage\n    if (typeof elements === 'string') {\n        elements = document.querySelectorAll(elements);\n    }\n\n    // Handle Array-like based usage\n    return Array.prototype.map.call(elements, function (element) {\n        return _delegate(element, selector, type, callback, useCapture);\n    });\n}\n\n/**\n * Finds closest match and invokes callback.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Function}\n */\nfunction listener(element, selector, type, callback) {\n    return function(e) {\n        e.delegateTarget = closest(e.target, selector);\n\n        if (e.delegateTarget) {\n            callback.call(element, e);\n        }\n    }\n}\n\nmodule.exports = delegate;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar DOCUMENT_NODE_TYPE = 9;\n\n/**\n * A polyfill for Element.matches()\n */\nif (typeof Element !== 'undefined' && !Element.prototype.matches) {\n    var proto = Element.prototype;\n\n    proto.matches = proto.matchesSelector ||\n                    proto.mozMatchesSelector ||\n                    proto.msMatchesSelector ||\n                    proto.oMatchesSelector ||\n                    proto.webkitMatchesSelector;\n}\n\n/**\n * Finds the closest parent that matches a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @return {Function}\n */\nfunction closest (element, selector) {\n    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n        if (typeof element.matches === 'function' &&\n            element.matches(selector)) {\n          return element;\n        }\n        element = element.parentNode;\n    }\n}\n\nmodule.exports = closest;\n\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2Rpc3QvY2xpcGJvYXJkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC9kaXN0L2NsaXBib2FyZC5qcz9iMzExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2xpcGJvYXJkLmpzIHYyLjAuNFxuICogaHR0cHM6Ly96ZW5vcm9jaGEuZ2l0aHViLmlvL2NsaXBib2FyZC5qc1xuICogXG4gKiBMaWNlbnNlZCBNSVQgwqkgWmVubyBSb2NoYVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJDbGlwYm9hcmRKU1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDbGlwYm9hcmRKU1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jbGlwYm9hcmRBY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2NsaXBib2FyZEFjdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGlwYm9hcmRBY3Rpb24pO1xuXG52YXIgX3RpbnlFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF90aW55RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW55RW1pdHRlcik7XG5cbnZhciBfZ29vZExpc3RlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9nb29kTGlzdGVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ29vZExpc3RlbmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEJhc2UgY2xhc3Mgd2hpY2ggdGFrZXMgb25lIG9yIG1vcmUgZWxlbWVudHMsIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZW0sXG4gKiBhbmQgaW5zdGFudGlhdGVzIGEgbmV3IGBDbGlwYm9hcmRBY3Rpb25gIG9uIGVhY2ggY2xpY2suXG4gKi9cbnZhciBDbGlwYm9hcmQgPSBmdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoQ2xpcGJvYXJkLCBfRW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdHJpZ2dlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xpcGJvYXJkKHRyaWdnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBib2FyZCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENsaXBib2FyZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENsaXBib2FyZCkpLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLnJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5saXN0ZW5DbGljayh0cmlnZ2VyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgYXR0cmlidXRlcyB3b3VsZCBiZSByZXNvbHZlZCB1c2luZyBpbnRlcm5hbCBzZXR0ZXIgZnVuY3Rpb25zXG4gICAgICogb3IgY3VzdG9tIGZ1bmN0aW9ucyB0aGF0IHdlcmUgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2xpcGJvYXJkLCBbe1xuICAgICAgICBrZXk6ICdyZXNvbHZlT3B0aW9ucycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSB0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmFjdGlvbiA6IHRoaXMuZGVmYXVsdEFjdGlvbjtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50YXJnZXQgOiB0aGlzLmRlZmF1bHRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0eXBlb2Ygb3B0aW9ucy50ZXh0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50ZXh0IDogdGhpcy5kZWZhdWx0VGV4dDtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gX3R5cGVvZihvcHRpb25zLmNvbnRhaW5lcikgPT09ICdvYmplY3QnID8gb3B0aW9ucy5jb250YWluZXIgOiBkb2N1bWVudC5ib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjbGljayBldmVudCBsaXN0ZW5lciB0byB0aGUgcGFzc2VkIHRyaWdnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0fSB0cmlnZ2VyXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsaXN0ZW5DbGljaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5DbGljayh0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lciA9ICgwLCBfZ29vZExpc3RlbmVyMi5kZWZhdWx0KSh0cmlnZ2VyLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub25DbGljayhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgYSBuZXcgYENsaXBib2FyZEFjdGlvbmAgb24gZWFjaCBjbGljayBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25DbGljaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyID0gZS5kZWxlZ2F0ZVRhcmdldCB8fCBlLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBib2FyZEFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGlwYm9hcmRBY3Rpb24gPSBuZXcgX2NsaXBib2FyZEFjdGlvbjIuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbih0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0KHRyaWdnZXIpLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCh0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRyaWdnZXIsXG4gICAgICAgICAgICAgICAgZW1pdHRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBgYWN0aW9uYCBsb29rdXAgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVmYXVsdEFjdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0QWN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgnYWN0aW9uJywgdHJpZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBgdGFyZ2V0YCBsb29rdXAgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVmYXVsdFRhcmdldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VGFyZ2V0KHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGdldEF0dHJpYnV0ZVZhbHVlKCd0YXJnZXQnLCB0cmlnZ2VyKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHN1cHBvcnQgb2YgdGhlIGdpdmVuIGFjdGlvbiwgb3IgYWxsIGFjdGlvbnMgaWYgbm8gYWN0aW9uIGlzXG4gICAgICAgICAqIGdpdmVuLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjdGlvbl1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlZmF1bHRUZXh0JyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGB0ZXh0YCBsb29rdXAgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRUZXh0KHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgndGV4dCcsIHRyaWdnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgbGlmZWN5Y2xlLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBib2FyZEFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbJ2NvcHknLCAnY3V0J107XG5cbiAgICAgICAgICAgIHZhciBhY3Rpb25zID0gdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBbYWN0aW9uXSA6IGFjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ID0gISFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQ7XG5cbiAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydCA9IHN1cHBvcnQgJiYgISFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoYWN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDbGlwYm9hcmQ7XG59KF90aW55RW1pdHRlcjIuZGVmYXVsdCk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHJpZXZlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdWZmaXhcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoc3VmZml4LCBlbGVtZW50KSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9ICdkYXRhLWNsaXBib2FyZC0nICsgc3VmZml4O1xuXG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGlwYm9hcmQ7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9zZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2VsZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBJbm5lciBjbGFzcyB3aGljaCBwZXJmb3JtcyBzZWxlY3Rpb24gZnJvbSBlaXRoZXIgYHRleHRgIG9yIGB0YXJnZXRgXG4gKiBwcm9wZXJ0aWVzIGFuZCB0aGVuIGV4ZWN1dGVzIGNvcHkgb3IgY3V0IG9wZXJhdGlvbnMuXG4gKi9cbnZhciBDbGlwYm9hcmRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGlwYm9hcmRBY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpcGJvYXJkQWN0aW9uKTtcblxuICAgICAgICB0aGlzLnJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmluaXRTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGJhc2UgcHJvcGVydGllcyBwYXNzZWQgZnJvbSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2xpcGJvYXJkQWN0aW9uLCBbe1xuICAgICAgICBrZXk6ICdyZXNvbHZlT3B0aW9ucycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBvcHRpb25zLmVtaXR0ZXI7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyID0gb3B0aW9ucy50cmlnZ2VyO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2lkZXMgd2hpY2ggc2VsZWN0aW9uIHN0cmF0ZWd5IGlzIGdvaW5nIHRvIGJlIGFwcGxpZWQgYmFzZWRcbiAgICAgICAgICogb24gdGhlIGV4aXN0ZW5jZSBvZiBgdGV4dGAgYW5kIGB0YXJnZXRgIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbml0U2VsZWN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGYWtlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RUYXJnZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZmFrZSB0ZXh0YXJlYSBlbGVtZW50LCBzZXRzIGl0cyB2YWx1ZSBmcm9tIGB0ZXh0YCBwcm9wZXJ0eSxcbiAgICAgICAgICogYW5kIG1ha2VzIGEgc2VsZWN0aW9uIG9uIGl0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2VsZWN0RmFrZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RGYWtlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGlzUlRMID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlyJykgPT0gJ3J0bCc7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRmFrZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmZha2VIYW5kbGVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUZha2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZha2VIYW5kbGVyID0gdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmZha2VIYW5kbGVyQ2FsbGJhY2spIHx8IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgLy8gUHJldmVudCB6b29taW5nIG9uIGlPU1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5mb250U2l6ZSA9ICcxMnB0JztcbiAgICAgICAgICAgIC8vIFJlc2V0IGJveCBtb2RlbFxuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5ib3JkZXIgPSAnMCc7XG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtLnN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICAgICAgICAgIC8vIE1vdmUgZWxlbWVudCBvdXQgb2Ygc2NyZWVuIGhvcml6b250YWxseVxuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtLnN0eWxlW2lzUlRMID8gJ3JpZ2h0JyA6ICdsZWZ0J10gPSAnLTk5OTlweCc7XG4gICAgICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gdGhlIHNhbWUgcG9zaXRpb24gdmVydGljYWxseVxuICAgICAgICAgICAgdmFyIHlQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS50b3AgPSB5UG9zaXRpb24gKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtLnZhbHVlID0gdGhpcy50ZXh0O1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZha2VFbGVtKTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy5mYWtlRWxlbSk7XG4gICAgICAgICAgICB0aGlzLmNvcHlUZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSByZW1vdmVzIHRoZSBmYWtlIGVsZW1lbnQgYWZ0ZXIgYW5vdGhlciBjbGljayBldmVudCwgdGhhdCB3YXlcbiAgICAgICAgICogYSB1c2VyIGNhbiBoaXQgYEN0cmwrQ2AgdG8gY29weSBiZWNhdXNlIHNlbGVjdGlvbiBzdGlsbCBleGlzdHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVGYWtlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZha2UoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mYWtlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VIYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5mYWtlRWxlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZmFrZUVsZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdHMgdGhlIGNvbnRlbnQgZnJvbSBlbGVtZW50IHBhc3NlZCBvbiBgdGFyZ2V0YCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlbGVjdFRhcmdldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RUYXJnZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dCA9ICgwLCBfc2VsZWN0Mi5kZWZhdWx0KSh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmNvcHlUZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIGNvcHkgb3BlcmF0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvcHlUZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlUZXh0KCkge1xuICAgICAgICAgICAgdmFyIHN1Y2NlZWRlZCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXN1bHQoc3VjY2VlZGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhbiBldmVudCBiYXNlZCBvbiB0aGUgY29weSBvcGVyYXRpb24gcmVzdWx0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1Y2NlZWRlZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlUmVzdWx0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHN1Y2NlZWRlZCA/ICdzdWNjZXNzJyA6ICdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuYWN0aW9uLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc2VsZWN0ZWRUZXh0LFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMudHJpZ2dlcixcbiAgICAgICAgICAgICAgICBjbGVhclNlbGVjdGlvbjogdGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3ZlcyBmb2N1cyBhd2F5IGZyb20gYHRhcmdldGAgYW5kIGJhY2sgdG8gdGhlIHRyaWdnZXIsIHJlbW92ZXMgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbGVhclNlbGVjdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGBhY3Rpb25gIHRvIGJlIHBlcmZvcm1lZCB3aGljaCBjYW4gYmUgZWl0aGVyICdjb3B5JyBvciAnY3V0Jy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBsaWZlY3ljbGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRmFrZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhY3Rpb24nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdjb3B5JztcblxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uICE9PSAnY29weScgJiYgdGhpcy5fYWN0aW9uICE9PSAnY3V0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcImFjdGlvblwiIHZhbHVlLCB1c2UgZWl0aGVyIFwiY29weVwiIG9yIFwiY3V0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBgYWN0aW9uYCBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYHRhcmdldGAgcHJvcGVydHkgdXNpbmcgYW4gZWxlbWVudFxuICAgICAgICAgKiB0aGF0IHdpbGwgYmUgaGF2ZSBpdHMgY29udGVudCBjb3BpZWQuXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0YXJnZXQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRhcmdldCkpID09PSAnb2JqZWN0JyAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uID09PSAnY29weScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgYXR0cmlidXRlLiBQbGVhc2UgdXNlIFwicmVhZG9ubHlcIiBpbnN0ZWFkIG9mIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbiA9PT0gJ2N1dCcgJiYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIGF0dHJpYnV0ZS4gWW91IGNhblxcJ3QgY3V0IHRleHQgZnJvbSBlbGVtZW50cyB3aXRoIFwicmVhZG9ubHlcIiBvciBcImRpc2FibGVkXCIgYXR0cmlidXRlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIHZhbHVlLCB1c2UgYSB2YWxpZCBFbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGB0YXJnZXRgIHByb3BlcnR5LlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDbGlwYm9hcmRBY3Rpb247XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcGJvYXJkQWN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gc2VsZWN0KGVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZWN0ZWRUZXh0O1xuXG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgdmFyIGlzUmVhZE9ubHkgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKTtcblxuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KCk7XG4gICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgZWxlbWVudC52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGVjdDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gRSAoKSB7XG4gIC8vIEtlZXAgdGhpcyBlbXB0eSBzbyBpdCdzIGVhc2llciB0byBpbmhlcml0IGZyb21cbiAgLy8gKHZpYSBodHRwczovL2dpdGh1Yi5jb20vbGlwc21hY2sgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2lzc3Vlcy8zKVxufVxuXG5FLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcblxuICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIGN0eDogY3R4XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBsaXN0ZW5lciAoKSB7XG4gICAgICBzZWxmLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBjYWxsYmFjay5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFja1xuICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIGxpc3RlbmVyLCBjdHgpO1xuICB9LFxuXG4gIGVtaXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGRhdGEgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGV2dEFyciA9ICgodGhpcy5lIHx8ICh0aGlzLmUgPSB7fSkpW25hbWVdIHx8IFtdKS5zbGljZSgpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZXZ0QXJyLmxlbmd0aDtcblxuICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBldnRBcnJbaV0uZm4uYXBwbHkoZXZ0QXJyW2ldLmN0eCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb2ZmOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuICAgIHZhciBldnRzID0gZVtuYW1lXTtcbiAgICB2YXIgbGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgaWYgKGV2dHMgJiYgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChldnRzW2ldLmZuICE9PSBjYWxsYmFjayAmJiBldnRzW2ldLmZuLl8gIT09IGNhbGxiYWNrKVxuICAgICAgICAgIGxpdmVFdmVudHMucHVzaChldnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXZlbnQgZnJvbSBxdWV1ZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgLy8gU3VnZ2VzdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9sYXpkXG4gICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2NvbW1pdC9jNmViZmFhOWJjOTczYjMzZDExMGE4NGEzMDc3NDJiN2NmOTRjOTUzI2NvbW1pdGNvbW1lbnQtNTAyNDkxMFxuXG4gICAgKGxpdmVFdmVudHMubGVuZ3RoKVxuICAgICAgPyBlW25hbWVdID0gbGl2ZUV2ZW50c1xuICAgICAgOiBkZWxldGUgZVtuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEU7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGVsZWdhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhbGwgcGFyYW1zIGFuZCBjYWxscyB0aGUgcmlnaHRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9uIGJhc2VkIG9uIGl0cyB0YXJnZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRhcmdldCAmJiAhdHlwZSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGlmICghaXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpcy5mbihjYWxsYmFjaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzLm5vZGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuTm9kZSh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXMubm9kZUxpc3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuTm9kZUxpc3QodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLnN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5TZWxlY3Rvcih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBTdHJpbmcsIEhUTUxFbGVtZW50LCBIVE1MQ29sbGVjdGlvbiwgb3IgTm9kZUxpc3QnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhIEhUTUwgZWxlbWVudFxuICogYW5kIHJldHVybnMgYSByZW1vdmUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbk5vZGUobm9kZSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIGxpc3Qgb2YgSFRNTCBlbGVtZW50c1xuICogYW5kIHJldHVybnMgYSByZW1vdmUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbn0gbm9kZUxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlTGlzdChub2RlTGlzdCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobm9kZUxpc3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgc2VsZWN0b3JcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3RlblNlbGVjdG9yKHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkZWxlZ2F0ZShkb2N1bWVudC5ib2R5LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RlbjtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMubm9kZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICAgICAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBsaXN0IG9mIEhUTUwgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGVMaXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAodHlwZSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKVxuICAgICAgICAmJiAoJ2xlbmd0aCcgaW4gdmFsdWUpXG4gICAgICAgICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgZXhwb3J0cy5ub2RlKHZhbHVlWzBdKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5zdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5mbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbi8qKlxuICogRGVsZWdhdGVzIGV2ZW50IHRvIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSB1c2VDYXB0dXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9kZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgbGlzdGVuZXJGbiA9IGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lckZuLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgZXZlbnQgdG8gYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfEFycmF5fSBbZWxlbWVudHNdXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSB1c2VDYXB0dXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlKGVsZW1lbnRzLCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAvLyBIYW5kbGUgdGhlIHJlZ3VsYXIgRWxlbWVudCB1c2FnZVxuICAgIGlmICh0eXBlb2YgZWxlbWVudHMuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gX2RlbGVnYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIEVsZW1lbnQtbGVzcyB1c2FnZSwgaXQgZGVmYXVsdHMgdG8gZ2xvYmFsIGRlbGVnYXRpb25cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIGBkb2N1bWVudGAgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgdGhlbiBhcHBseSBhcmd1bWVudHNcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNob3J0IHdheSB0byAudW5zaGlmdCBgYXJndW1lbnRzYCB3aXRob3V0IHJ1bm5pbmcgaW50byBkZW9wdGltaXphdGlvbnNcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZS5iaW5kKG51bGwsIGRvY3VtZW50KS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTZWxlY3Rvci1iYXNlZCB1c2FnZVxuICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIEFycmF5LWxpa2UgYmFzZWQgdXNhZ2VcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX2RlbGVnYXRlKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogRmluZHMgY2xvc2VzdCBtYXRjaCBhbmQgaW52b2tlcyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXIoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5kZWxlZ2F0ZVRhcmdldCA9IGNsb3Nlc3QoZS50YXJnZXQsIHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoZS5kZWxlZ2F0ZVRhcmdldCkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtZW50LCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWxlZ2F0ZTtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIERPQ1VNRU5UX05PREVfVFlQRSA9IDk7XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgRWxlbWVudC5tYXRjaGVzKClcbiAqL1xuaWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIHZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ubWF0Y2hlcyA9IHByb3RvLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IHRoYXQgbWF0Y2hlcyBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdCAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSBET0NVTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm1hdGNoZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9zZXN0O1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/clipboard/dist/clipboard.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzYwMTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzUxMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzPzgyYjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/harmony-module.js\n");

/***/ })

}]);