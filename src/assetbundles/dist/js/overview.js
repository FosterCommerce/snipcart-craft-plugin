/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/assetbundles/src/js/overview.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/apexcharts/dist/apexcharts.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/apexcharts/dist/apexcharts.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate, module) {/*!\n * ApexCharts v3.6.2\n * (c) 2018-2019 Juned Chhipa\n * Released under the MIT License.\n */\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/*\n ** Generic functions which are not dependent on ApexCharts\n */\nvar Utils =\n/*#__PURE__*/\nfunction () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, [{\n    key: \"shadeRGBColor\",\n    value: function shadeRGBColor(percent, color) {\n      var f = color.split(','),\n          t = percent < 0 ? 0 : 255,\n          p = percent < 0 ? percent * -1 : percent,\n          R = parseInt(f[0].slice(4)),\n          G = parseInt(f[1]),\n          B = parseInt(f[2]);\n      return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';\n    }\n  }, {\n    key: \"shadeHexColor\",\n    value: function shadeHexColor(percent, color) {\n      var f = parseInt(color.slice(1), 16),\n          t = percent < 0 ? 0 : 255,\n          p = percent < 0 ? percent * -1 : percent,\n          R = f >> 16,\n          G = f >> 8 & 0x00ff,\n          B = f & 0x0000ff;\n      return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);\n    } // beautiful color shading blending code\n    // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n\n  }, {\n    key: \"shadeColor\",\n    value: function shadeColor(p, color) {\n      if (color.length > 7) return this.shadeRGBColor(p, color);else return this.shadeHexColor(p, color);\n    }\n  }], [{\n    key: \"bind\",\n    value: function bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    }\n  }, {\n    key: \"isObject\",\n    value: function isObject(item) {\n      return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;\n    } // to extend defaults with user options\n    // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873\n\n  }, {\n    key: \"extend\",\n    value: function extend(target, source) {\n      var _this = this;\n\n      if (typeof Object.assign !== 'function') {\n\n        (function () {\n          Object.assign = function (target) {\n\n            if (target === undefined || target === null) {\n              throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n\n            for (var index = 1; index < arguments.length; index++) {\n              var _source = arguments[index];\n\n              if (_source !== undefined && _source !== null) {\n                for (var nextKey in _source) {\n                  if (_source.hasOwnProperty(nextKey)) {\n                    output[nextKey] = _source[nextKey];\n                  }\n                }\n              }\n            }\n\n            return output;\n          };\n        })();\n      }\n\n      var output = Object.assign({}, target);\n\n      if (this.isObject(target) && this.isObject(source)) {\n        Object.keys(source).forEach(function (key) {\n          if (_this.isObject(source[key])) {\n            if (!(key in target)) {\n              Object.assign(output, _defineProperty({}, key, source[key]));\n            } else {\n              output[key] = _this.extend(target[key], source[key]);\n            }\n          } else {\n            Object.assign(output, _defineProperty({}, key, source[key]));\n          }\n        });\n      }\n\n      return output;\n    }\n  }, {\n    key: \"extendArray\",\n    value: function extendArray(arrToExtend, resultArr) {\n      var extendedArr = [];\n      arrToExtend.map(function (item) {\n        extendedArr.push(Utils.extend(resultArr, item));\n      });\n      arrToExtend = extendedArr;\n      return arrToExtend;\n    } // If month counter exceeds 12, it starts again from 1\n\n  }, {\n    key: \"monthMod\",\n    value: function monthMod(month) {\n      return month % 12;\n    }\n  }, {\n    key: \"addProps\",\n    value: function addProps(obj, arr, val) {\n      if (typeof arr === 'string') {\n        arr = arr.split('.');\n      }\n\n      obj[arr[0]] = obj[arr[0]] || {};\n      var tmpObj = obj[arr[0]];\n\n      if (arr.length > 1) {\n        arr.shift();\n        this.addProps(tmpObj, arr, val);\n      } else {\n        obj[arr[0]] = val;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(source) {\n      if (Object.prototype.toString.call(source) === '[object Array]') {\n        var cloneResult = [];\n\n        for (var i = 0; i < source.length; i++) {\n          cloneResult[i] = this.clone(source[i]);\n        }\n\n        return cloneResult;\n      } else if (_typeof(source) === 'object') {\n        var _cloneResult = {};\n\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            _cloneResult[prop] = this.clone(source[prop]);\n          }\n        }\n\n        return _cloneResult;\n      } else {\n        return source;\n      }\n    }\n  }, {\n    key: \"log10\",\n    value: function log10(x) {\n      return Math.log(x) / Math.LN10;\n    }\n  }, {\n    key: \"roundToBase10\",\n    value: function roundToBase10(x) {\n      return Math.pow(10, Math.floor(Math.log10(x)));\n    }\n  }, {\n    key: \"roundToBase\",\n    value: function roundToBase(x, base) {\n      return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));\n    }\n  }, {\n    key: \"parseNumber\",\n    value: function parseNumber(val) {\n      if (val === null) return val;\n      return parseFloat(val);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions(el) {\n      var computedStyle = getComputedStyle(el);\n      var ret = [];\n      var elementHeight = el.clientHeight;\n      var elementWidth = el.clientWidth;\n      elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n      elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n      ret.push(elementWidth);\n      ret.push(elementHeight);\n      return ret;\n    }\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect(element) {\n      var rect = element.getBoundingClientRect();\n      return {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n        x: rect.x,\n        y: rect.y\n      };\n    } // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275\n\n  }, {\n    key: \"hexToRgba\",\n    value: function hexToRgba() {\n      var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';\n      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;\n\n      if (hex.substring(0, 1) !== '#') {\n        hex = '#999999';\n      }\n\n      var h = hex.replace('#', '');\n      h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));\n\n      for (var i = 0; i < h.length; i++) {\n        h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);\n      }\n\n      if (typeof opacity !== 'undefined') h.push(opacity);\n      return 'rgba(' + h.join(',') + ')';\n    }\n  }, {\n    key: \"getOpacityFromRGBA\",\n    value: function getOpacityFromRGBA(rgba) {\n      rgba = rgba.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n      return rgba[3];\n    }\n  }, {\n    key: \"rgb2hex\",\n    value: function rgb2hex(rgb) {\n      rgb = rgb.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n      return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';\n    }\n  }, {\n    key: \"isColorHex\",\n    value: function isColorHex(color) {\n      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);\n    }\n  }, {\n    key: \"polarToCartesian\",\n    value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n      return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians)\n      };\n    }\n  }, {\n    key: \"escapeString\",\n    value: function escapeString(str) {\n      var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n      var newStr = str.toString().slice();\n      newStr = newStr.replace(/[` ~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, escapeWith);\n      return newStr;\n    }\n  }, {\n    key: \"negToZero\",\n    value: function negToZero(val) {\n      return val < 0 ? 0 : val;\n    }\n  }, {\n    key: \"moveIndexInArray\",\n    value: function moveIndexInArray(arr, old_index, new_index) {\n      if (new_index >= arr.length) {\n        var k = new_index - arr.length + 1;\n\n        while (k--) {\n          arr.push(undefined);\n        }\n      }\n\n      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\n      return arr;\n    }\n  }, {\n    key: \"extractNumber\",\n    value: function extractNumber(s) {\n      return parseFloat(s.replace(/[^\\d\\.]*/g, ''));\n    }\n  }, {\n    key: \"randomString\",\n    value: function randomString(len) {\n      var text = '';\n      var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n      for (var i = 0; i < len; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n      }\n\n      return text;\n    }\n  }, {\n    key: \"findAncestor\",\n    value: function findAncestor(el, cls) {\n      while ((el = el.parentElement) && !el.classList.contains(cls)) {\n      }\n\n      return el;\n    }\n  }, {\n    key: \"setELstyles\",\n    value: function setELstyles(el, styles) {\n      for (var key in styles) {\n        if (styles.hasOwnProperty(key)) {\n          el.style.key = styles[key];\n        }\n      }\n    }\n  }, {\n    key: \"isNumber\",\n    value: function isNumber(value) {\n      return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));\n    }\n  }, {\n    key: \"isFloat\",\n    value: function isFloat(n) {\n      return Number(n) === n && n % 1 !== 0;\n    }\n  }, {\n    key: \"isSafari\",\n    value: function isSafari() {\n      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    }\n  }, {\n    key: \"isFirefox\",\n    value: function isFirefox() {\n      return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n    }\n  }, {\n    key: \"isIE11\",\n    value: function isIE11() {\n      if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) {\n        return true;\n      }\n    }\n  }, {\n    key: \"isIE\",\n    value: function isIE() {\n      var ua = window.navigator.userAgent;\n      var msie = ua.indexOf('MSIE ');\n\n      if (msie > 0) {\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n      }\n\n      var trident = ua.indexOf('Trident/');\n\n      if (trident > 0) {\n        // IE 11 => return version number\n        var rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n      }\n\n      var edge = ua.indexOf('Edge/');\n\n      if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n      } // other browser\n\n\n      return false;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/**\n * ApexCharts Filters Class for setting hover/active states on the paths.\n *\n * @module Formatters\n **/\n\nvar Filters =\n/*#__PURE__*/\nfunction () {\n  function Filters(ctx) {\n    _classCallCheck(this, Filters);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // create a re-usable filter which can be appended other filter effects and applied to multiple elements\n\n\n  _createClass(Filters, [{\n    key: \"getDefaultFilter\",\n    value: function getDefaultFilter(el) {\n      var w = this.w;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n\n      if (w.config.states.normal.filter !== 'none') {\n        this.applyFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);\n      } else {\n        if (w.config.chart.dropShadow.enabled) {\n          this.dropShadow(el, w.config.chart.dropShadow);\n        }\n      }\n    }\n  }, {\n    key: \"addNormalFilter\",\n    value: function addNormalFilter(el) {\n      var w = this.w;\n\n      if (w.config.chart.dropShadow.enabled) {\n        this.dropShadow(el, w.config.chart.dropShadow);\n      }\n    }\n  }, {\n    key: \"addDesaturateFilter\",\n    value: function addDesaturateFilter(el) {\n      var _this = this;\n\n      var w = this.w;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.colorMatrix('matrix', [0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 1.0, 0]).colorMatrix('saturate', 0);\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addLightenFilter\",\n    value: function addLightenFilter(el, attrs) {\n      var _this2 = this;\n\n      var w = this.w;\n      var intensity = attrs.intensity;\n\n      if (Utils.isFirefox()) {\n        return;\n      }\n\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this2.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.componentTransfer({\n          rgb: {\n            type: 'linear',\n            slope: 1.5,\n            intercept: intensity\n          }\n        });\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addDarkenFilter\",\n    value: function addDarkenFilter(el, attrs) {\n      var _this3 = this;\n\n      var w = this.w;\n      var intensity = attrs.intensity;\n\n      if (Utils.isFirefox()) {\n        return;\n      }\n\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowAttr = w.config.chart.dropShadow;\n\n        if (shadowAttr.enabled) {\n          filter = _this3.addShadow(add, shadowAttr);\n        } else {\n          filter = add;\n        }\n\n        filter.componentTransfer({\n          rgb: {\n            type: 'linear',\n            slope: intensity\n          }\n        });\n      });\n      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n    }\n  }, {\n    key: \"applyFilter\",\n    value: function applyFilter(el, filter) {\n      var intensity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n\n      switch (filter) {\n        case 'none':\n          {\n            this.addNormalFilter(el);\n            break;\n          }\n\n        case 'lighten':\n          {\n            this.addLightenFilter(el, {\n              intensity: intensity\n            });\n            break;\n          }\n\n        case 'darken':\n          {\n            this.addDarkenFilter(el, {\n              intensity: intensity\n            });\n            break;\n          }\n\n        case 'desaturate':\n          {\n            this.addDesaturateFilter(el);\n            break;\n          }\n\n        default:\n          // do nothing\n          break;\n      }\n    } // appends dropShadow to the filter object which can be chained with other filter effects\n\n  }, {\n    key: \"addShadow\",\n    value: function addShadow(add, attrs) {\n      var blur = attrs.blur,\n          top = attrs.top,\n          left = attrs.left,\n          color = attrs.color,\n          opacity = attrs.opacity;\n      var shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n      return add.blend(add.source, shadowBlur);\n    } // directly adds dropShadow to the element and returns the same element.\n    // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow\n\n  }, {\n    key: \"dropShadow\",\n    value: function dropShadow(el, attrs) {\n      var top = attrs.top,\n          left = attrs.left,\n          blur = attrs.blur,\n          color = attrs.color,\n          opacity = attrs.opacity,\n          noUserSpaceOnUse = attrs.noUserSpaceOnUse;\n      el.unfilter(true);\n      var filter = new window.SVG.Filter();\n      filter.size('120%', '180%', '-5%', '-40%');\n      el.filter(function (add) {\n        var shadowBlur = null;\n\n        if (Utils.isSafari() || Utils.isFirefox() || Utils.isIE()) {\n          // safari/firefox has some alternative way to use this filter\n          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur);\n        } else {\n          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);\n        }\n\n        add.blend(add.source, shadowBlur);\n      });\n\n      if (!noUserSpaceOnUse) {\n        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');\n      }\n\n      return el;\n    }\n  }, {\n    key: \"setSelectionFilter\",\n    value: function setSelectionFilter(el, realIndex, dataPointIndex) {\n      var w = this.w;\n\n      if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {\n        if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {\n          el.node.setAttribute('selected', true);\n          var activeFilter = w.config.states.active.filter;\n\n          if (activeFilter !== 'none') {\n            this.applyFilter(el, activeFilter.type, activeFilter.value);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Filters;\n}();\n\n/**\n * ApexCharts Animation Class.\n *\n * @module Animations\n **/\n\nvar Animations =\n/*#__PURE__*/\nfunction () {\n  function Animations(ctx) {\n    _classCallCheck(this, Animations);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.setEasingFunctions();\n  }\n\n  _createClass(Animations, [{\n    key: \"setEasingFunctions\",\n    value: function setEasingFunctions() {\n      var easing;\n      var userDefinedEasing = this.w.config.chart.animations.easing;\n\n      switch (userDefinedEasing) {\n        case 'linear':\n          {\n            easing = '-';\n            break;\n          }\n\n        case 'easein':\n          {\n            easing = '<';\n            break;\n          }\n\n        case 'easeout':\n          {\n            easing = '>';\n            break;\n          }\n\n        case 'easeinout':\n          {\n            easing = '<>';\n            break;\n          }\n\n        case 'swing':\n          {\n            easing = function easing(pos) {\n              var s = 1.70158;\n              return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;\n            };\n\n            break;\n          }\n\n        case 'bounce':\n          {\n            easing = function easing(pos) {\n              if (pos < 1 / 2.75) {\n                return 7.5625 * pos * pos;\n              } else if (pos < 2 / 2.75) {\n                return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;\n              } else if (pos < 2.5 / 2.75) {\n                return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;\n              } else {\n                return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;\n              }\n            };\n\n            break;\n          }\n\n        case 'elastic':\n          {\n            easing = function easing(pos) {\n              if (pos === !!pos) return pos;\n              return Math.pow(2, -10 * pos) * Math.sin((pos - 0.075) * (2 * Math.PI) / 0.3) + 1;\n            };\n\n            break;\n          }\n\n        default:\n          {\n            easing = '<>';\n          }\n      }\n\n      this.w.globals.easing = easing;\n    }\n  }, {\n    key: \"animateLine\",\n    value: function animateLine(el, from, to, speed) {\n      el.attr(from).animate(speed).attr(to);\n    }\n    /*\n     ** Animate radius of a circle element\n     */\n\n  }, {\n    key: \"animateCircleRadius\",\n    value: function animateCircleRadius(el, from, to, speed, easing) {\n      if (!from) from = 0;\n      el.attr({\n        r: from\n      }).animate(speed, easing).attr({\n        r: to\n      });\n    }\n    /*\n     ** Animate radius and position of a circle element\n     */\n\n  }, {\n    key: \"animateCircle\",\n    value: function animateCircle(el, from, to, speed, easing) {\n      el.attr({\n        r: from.r,\n        cx: from.cx,\n        cy: from.cy\n      }).animate(speed, easing).attr({\n        r: to.r,\n        cx: to.cx,\n        cy: to.cy\n      });\n    }\n    /*\n     ** Animate rect properties\n     */\n\n  }, {\n    key: \"animateRect\",\n    value: function animateRect(el, from, to, speed, fn) {\n      el.attr(from).animate(speed).attr(to).afterAll(function () {\n        fn();\n      });\n    }\n  }, {\n    key: \"animatePathsGradually\",\n    value: function animatePathsGradually(params) {\n      var el = params.el,\n          j = params.j,\n          pathFrom = params.pathFrom,\n          pathTo = params.pathTo,\n          speed = params.speed,\n          delay = params.delay,\n          strokeWidth = params.strokeWidth;\n      var me = this;\n      var w = this.w;\n      var delayFactor = 0;\n\n      if (w.config.chart.animations.animateGradually.enabled) {\n        delayFactor = w.config.chart.animations.animateGradually.delay;\n      }\n\n      if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged) {\n        delayFactor = 0;\n      }\n\n      me.morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay * delayFactor);\n    }\n  }, {\n    key: \"showDelayedElements\",\n    value: function showDelayedElements() {\n      this.w.globals.delayedElements.forEach(function (d) {\n        var ele = d.el;\n        ele.classList.remove('hidden');\n      });\n    } // SVG.js animation for morphing one path to another\n\n  }, {\n    key: \"morphSVG\",\n    value: function morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay) {\n      var _this = this;\n\n      var w = this.w;\n\n      if (!pathFrom) {\n        pathFrom = el.attr('pathFrom');\n      }\n\n      if (!pathTo) {\n        pathTo = el.attr('pathTo');\n      }\n\n      if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {\n        pathFrom = \"M 0 \".concat(w.globals.gridHeight);\n        speed = 1;\n      }\n\n      if (pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {\n        pathTo = \"M 0 \".concat(w.globals.gridHeight);\n        speed = 1;\n      }\n\n      if (!w.globals.shouldAnimate) {\n        speed = 1;\n      }\n\n      el.plot(pathFrom).animate(1, w.globals.easing, delay).plot(pathFrom).animate(speed, w.globals.easing, delay).plot(pathTo).afterAll(function () {\n        // a flag to indicate that the original mount function can return true now as animation finished here\n        if (Utils.isNumber(j)) {\n          if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {\n            w.globals.animationEnded = true;\n          }\n        } else if (w.globals.shouldAnimate) {\n          w.globals.animationEnded = true;\n\n          if (typeof w.config.chart.events.animationEnd === 'function') {\n            w.config.chart.events.animationEnd(_this.ctx, w);\n          }\n        }\n\n        _this.showDelayedElements();\n      });\n    }\n  }]);\n\n  return Animations;\n}();\n\n/**\n * ApexCharts Graphics Class for all drawing operations.\n *\n * @module Graphics\n **/\n\nvar Graphics =\n/*#__PURE__*/\nfunction () {\n  function Graphics(ctx) {\n    _classCallCheck(this, Graphics);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Graphics, [{\n    key: \"drawLine\",\n    value: function drawLine(x1, y1, x2, y2) {\n      var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';\n      var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n      var w = this.w;\n      var line = w.globals.dom.Paper.line().attr({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        stroke: lineColor,\n        'stroke-dasharray': dashArray,\n        'stroke-width': strokeWidth\n      });\n      return line;\n    }\n  }, {\n    key: \"drawRect\",\n    value: function drawRect() {\n      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';\n      var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n      var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n      var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n      var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n      var w = this.w;\n      var rect = w.globals.dom.Paper.rect();\n      rect.attr({\n        x: x1,\n        y: y1,\n        width: x2 > 0 ? x2 : 0,\n        height: y2 > 0 ? y2 : 0,\n        rx: radius,\n        ry: radius,\n        fill: color,\n        opacity: opacity,\n        'stroke-width': strokeWidth !== null ? strokeWidth : 0,\n        stroke: strokeColor !== null ? strokeColor : 'none',\n        'stroke-dasharray': strokeDashArray\n      });\n      return rect;\n    }\n  }, {\n    key: \"drawPolygon\",\n    value: function drawPolygon(polygonString) {\n      var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';\n      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n      var w = this.w;\n      var polygon = w.globals.dom.Paper.polygon(polygonString).attr({\n        fill: fill,\n        stroke: stroke\n      });\n      return polygon;\n    }\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(radius) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var w = this.w;\n      var c = w.globals.dom.Paper.circle(radius * 2);\n\n      if (attrs !== null) {\n        c.attr(attrs);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(_ref) {\n      var _ref$d = _ref.d,\n          d = _ref$d === void 0 ? '' : _ref$d,\n          _ref$stroke = _ref.stroke,\n          stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,\n          _ref$strokeWidth = _ref.strokeWidth,\n          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,\n          fill = _ref.fill,\n          _ref$fillOpacity = _ref.fillOpacity,\n          fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,\n          _ref$strokeOpacity = _ref.strokeOpacity,\n          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,\n          classes = _ref.classes,\n          _ref$strokeLinecap = _ref.strokeLinecap,\n          strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,\n          _ref$strokeDashArray = _ref.strokeDashArray,\n          strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;\n      var w = this.w;\n\n      if (strokeLinecap === null) {\n        strokeLinecap = w.config.stroke.lineCap;\n      }\n\n      if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {\n        d = \"M 0 \".concat(w.globals.gridHeight);\n      }\n\n      var p = w.globals.dom.Paper.path(d).attr({\n        fill: fill,\n        'fill-opacity': fillOpacity,\n        stroke: stroke,\n        'stroke-opacity': strokeOpacity,\n        'stroke-linecap': strokeLinecap,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': strokeDashArray,\n        class: classes\n      });\n      return p;\n    }\n  }, {\n    key: \"group\",\n    value: function group() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var w = this.w;\n      var g = w.globals.dom.Paper.group();\n\n      if (attrs !== null) {\n        g.attr(attrs);\n      }\n\n      return g;\n    }\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      var move = ['M', x, y].join(' ');\n      return move;\n    }\n  }, {\n    key: \"line\",\n    value: function line(x, y) {\n      var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var line = null;\n\n      if (hORv === null) {\n        line = ['L', x, y].join(' ');\n      } else if (hORv === 'H') {\n        line = ['H', x].join(' ');\n      } else if (hORv === 'V') {\n        line = ['V', y].join(' ');\n      }\n\n      return line;\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(x1, y1, x2, y2, x, y) {\n      var curve = ['C', x1, y1, x2, y2, x, y].join(' ');\n      return curve;\n    }\n  }, {\n    key: \"quadraticCurve\",\n    value: function quadraticCurve(x1, y1, x, y) {\n      var curve = ['Q', x1, y1, x, y].join(' ');\n      return curve;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {\n      var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      var coord = 'A';\n      if (relative) coord = 'a';\n      var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');\n      return arc;\n    }\n    /**\n     * @memberof Graphics\n     * @param {object}\n     *  i = series's index\n     *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating \"i\" may change in loops, but realIndex doesn't\n     *  pathFrom = existing pathFrom to animateTo\n     *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo\n     *  stroke = line Color\n     *  strokeWidth = width of path Line\n     *  fill = it can be gradient, single color, pattern or image\n     *  animationDelay = how much to delay when starting animation (in milliseconds)\n     *  dataChangeSpeed = for dynamic animations, when data changes\n     *  className = class attribute to add\n     * @return {object} svg.js path object\n     **/\n\n  }, {\n    key: \"renderPaths\",\n    value: function renderPaths(_ref2) {\n      var i = _ref2.i,\n          j = _ref2.j,\n          realIndex = _ref2.realIndex,\n          pathFrom = _ref2.pathFrom,\n          pathTo = _ref2.pathTo,\n          stroke = _ref2.stroke,\n          strokeWidth = _ref2.strokeWidth,\n          strokeLinecap = _ref2.strokeLinecap,\n          fill = _ref2.fill,\n          animationDelay = _ref2.animationDelay,\n          initialSpeed = _ref2.initialSpeed,\n          dataChangeSpeed = _ref2.dataChangeSpeed,\n          className = _ref2.className,\n          id = _ref2.id,\n          _ref2$shouldClipToGri = _ref2.shouldClipToGrid,\n          shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,\n          _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,\n          bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat;\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var anim = new Animations(this.ctx);\n      var initialAnim = this.w.config.chart.animations.enabled;\n      var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n      var d;\n      var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);\n\n      if (shouldAnimate) {\n        d = pathFrom;\n      } else {\n        d = pathTo;\n        this.w.globals.animationEnded = true;\n      }\n\n      var strokeDashArrayOpt = w.config.stroke.dashArray;\n      var strokeDashArray = 0;\n\n      if (Array.isArray(strokeDashArrayOpt)) {\n        strokeDashArray = strokeDashArrayOpt[realIndex];\n      } else {\n        strokeDashArray = w.config.stroke.dashArray;\n      }\n\n      var el = this.drawPath({\n        d: d,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        fill: fill,\n        fillOpacity: 1,\n        classes: className,\n        strokeLinecap: strokeLinecap,\n        strokeDashArray: strokeDashArray\n      });\n      el.attr('id', \"\".concat(id, \"-\").concat(i));\n      el.attr('index', realIndex);\n\n      if (shouldClipToGrid) {\n        el.attr({\n          'clip-path': \"url(#gridRectMask\".concat(w.globals.cuid, \")\")\n        });\n      } // const defaultFilter = el.filterer\n\n\n      if (w.config.states.normal.filter.type !== 'none') {\n        filters.getDefaultFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);\n      } else {\n        if (w.config.chart.dropShadow.enabled) {\n          if (!w.config.chart.dropShadow.enabledSeries || w.config.chart.dropShadow.enabledSeries && w.config.chart.dropShadow.enabledSeries.indexOf(realIndex) !== -1) {\n            var shadow = w.config.chart.dropShadow;\n            filters.dropShadow(el, shadow);\n          }\n        }\n      }\n\n      if (bindEventsOnPaths) {\n        el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));\n        el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));\n        el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));\n      }\n\n      el.attr({\n        pathTo: pathTo,\n        pathFrom: pathFrom\n      });\n      var defaultAnimateOpts = {\n        el: el,\n        j: j,\n        pathFrom: pathFrom,\n        pathTo: pathTo,\n        strokeWidth: strokeWidth\n      };\n\n      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {\n          speed: initialSpeed,\n          delay: animationDelay\n        }));\n      } else {\n        if (w.globals.resized || !w.globals.dataChanged) {\n          anim.showDelayedElements();\n        }\n      }\n\n      if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {\n        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {\n          speed: dataChangeSpeed\n        }));\n      }\n\n      return el;\n    }\n  }, {\n    key: \"drawPattern\",\n    value: function drawPattern(style, width, height) {\n      var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';\n      var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var w = this.w;\n      var p = w.globals.dom.Paper.pattern(width, height, function (add) {\n        if (style === 'horizontalLines') {\n          add.line(0, 0, height, 0).stroke({\n            color: stroke,\n            width: strokeWidth + 1\n          });\n        } else if (style === 'verticalLines') {\n          add.line(0, 0, 0, width).stroke({\n            color: stroke,\n            width: strokeWidth + 1\n          });\n        } else if (style === 'slantedLines') {\n          add.line(0, 0, width, height).stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        } else if (style === 'squares') {\n          add.rect(width, height).fill('none').stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        } else if (style === 'circles') {\n          add.circle(width).fill('none').stroke({\n            color: stroke,\n            width: strokeWidth\n          });\n        }\n      });\n      return p;\n    }\n  }, {\n    key: \"drawGradient\",\n    value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {\n      var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n      var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n      var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n      var w = this.w;\n      var g;\n      gfrom = Utils.hexToRgba(gfrom, opacityFrom);\n      gto = Utils.hexToRgba(gto, opacityTo);\n      var stop1 = 0;\n      var stop2 = 1;\n      var stop3 = 1;\n      var stop4 = null;\n\n      if (stops !== null) {\n        stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;\n        stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;\n        stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;\n        stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;\n      }\n\n      var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'bubble');\n\n      if (colorStops === null || colorStops.length === 0) {\n        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n          stop.at(stop1, gfrom, opacityFrom);\n          stop.at(stop2, gto, opacityTo);\n          stop.at(stop3, gto, opacityTo);\n\n          if (stop4 !== null) {\n            stop.at(stop4, gfrom, opacityFrom);\n          }\n        });\n      } else {\n        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {\n          var stops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;\n          stops.forEach(function (s) {\n            stop.at(s.offset / 100, s.color, s.opacity);\n          });\n        });\n      }\n\n      if (!radial) {\n        if (style === 'vertical') {\n          g.from(0, 0).to(0, 1);\n        } else if (style === 'diagonal') {\n          g.from(0, 0).to(1, 1);\n        } else if (style === 'horizontal') {\n          g.from(0, 1).to(1, 1);\n        } else if (style === 'diagonal2') {\n          g.from(0, 1).to(2, 2);\n        }\n      } else {\n        var offx = w.globals.gridWidth / 2;\n        var offy = w.globals.gridHeight / 2;\n\n        if (w.config.chart.type !== 'bubble') {\n          g.attr({\n            gradientUnits: 'userSpaceOnUse',\n            cx: offx,\n            cy: offy,\n            r: size\n          });\n        } else {\n          g.attr({\n            cx: 0.5,\n            cy: 0.5,\n            r: 0.8,\n            fx: 0.2,\n            fy: 0.2\n          });\n        }\n      }\n\n      return g;\n    }\n  }, {\n    key: \"drawText\",\n    value: function drawText(opts) {\n      var w = this.w;\n      var x = opts.x,\n          y = opts.y,\n          text = opts.text,\n          textAnchor = opts.textAnchor,\n          fontSize = opts.fontSize,\n          fontFamily = opts.fontFamily,\n          foreColor = opts.foreColor,\n          opacity = opts.opacity;\n\n      if (!textAnchor) {\n        textAnchor = 'start';\n      }\n\n      if (!foreColor) {\n        foreColor = w.config.chart.foreColor;\n      }\n\n      fontFamily = fontFamily || w.config.chart.fontFamily;\n      var elText;\n\n      if (Array.isArray(text)) {\n        elText = w.globals.dom.Paper.text(function (add) {\n          for (var i = 0; i < text.length; i++) {\n            add.tspan(text[i]);\n          }\n        });\n      } else {\n        elText = w.globals.dom.Paper.plain(text);\n      }\n\n      elText.attr({\n        x: x,\n        y: y,\n        'text-anchor': textAnchor,\n        'dominant-baseline': 'central',\n        'font-size': fontSize,\n        'font-family': fontFamily,\n        fill: foreColor,\n        class:  true ? opts.cssClass : undefined\n      });\n      elText.node.style.fontFamily = fontFamily;\n      elText.node.style.opacity = opacity;\n      return elText;\n    }\n  }, {\n    key: \"addTspan\",\n    value: function addTspan(textEl, text, fontFamily) {\n      var tspan = textEl.tspan(text);\n\n      if (!fontFamily) {\n        fontFamily = this.w.config.chart.fontFamily;\n      }\n\n      tspan.node.style.fontFamily = fontFamily;\n    }\n  }, {\n    key: \"drawMarker\",\n    value: function drawMarker(x, y, opts) {\n      x = x || 0;\n      var size = opts.pSize || 0;\n      var elPoint = null;\n\n      if (opts.shape === 'square') {\n        var radius = opts.pRadius === undefined ? size / 2 : opts.pRadius;\n\n        if (y === null) {\n          size = 0;\n          radius = 0;\n        }\n\n        var nSize = size * 1.2 + radius;\n        var p = this.drawRect(nSize, nSize, nSize, nSize, radius);\n        p.attr({\n          x: x - nSize / 2,\n          y: y - nSize / 2,\n          cx: x,\n          cy: y,\n          class: opts.class ? opts.class : '',\n          fill: opts.pointFillColor,\n          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n          stroke: opts.pointStrokeColor,\n          'stroke-width': opts.pWidth ? opts.pWidth : 0,\n          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n        });\n        elPoint = p;\n      } else if (opts.shape === 'circle') {\n        if (!Utils.isNumber(y)) {\n          size = 0;\n          y = 0;\n        } // let nSize = size - opts.pRadius / 2 < 0 ? 0 : size - opts.pRadius / 2\n\n\n        elPoint = this.drawCircle(size, {\n          cx: x,\n          cy: y,\n          class: opts.class ? opts.class : '',\n          stroke: opts.pointStrokeColor,\n          fill: opts.pointFillColor,\n          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,\n          'stroke-width': opts.pWidth ? opts.pWidth : 0,\n          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1\n        });\n      }\n\n      return elPoint;\n    }\n  }, {\n    key: \"pathMouseEnter\",\n    value: function pathMouseEnter(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n\n      if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {\n        w.config.chart.events.dataPointMouseEnter(e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointMouseEnter', [e, this.ctx, {\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]);\n\n      if (w.config.states.active.filter.type !== 'none') {\n        if (path.node.getAttribute('selected') === 'true') {\n          return;\n        }\n      }\n\n      if (w.config.states.hover.filter.type !== 'none') {\n        if (w.config.states.active.filter.type !== 'none' && !w.globals.isTouchDevice) {\n          var hoverFilter = w.config.states.hover.filter;\n          filters.applyFilter(path, hoverFilter.type, hoverFilter.value);\n        }\n      }\n    }\n  }, {\n    key: \"pathMouseLeave\",\n    value: function pathMouseLeave(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n\n      if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {\n        w.config.chart.events.dataPointMouseLeave(e, this.ctx, {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointMouseLeave', [e, this.ctx, {\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]);\n\n      if (w.config.states.active.filter.type !== 'none') {\n        if (path.node.getAttribute('selected') === 'true') {\n          return;\n        }\n      }\n\n      if (w.config.states.hover.filter.type !== 'none') {\n        filters.getDefaultFilter(path);\n      }\n    }\n  }, {\n    key: \"pathMouseDown\",\n    value: function pathMouseDown(path, e) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var i = parseInt(path.node.getAttribute('index'));\n      var j = parseInt(path.node.getAttribute('j'));\n      var selected = 'false';\n\n      if (path.node.getAttribute('selected') === 'true') {\n        path.node.setAttribute('selected', 'false');\n\n        if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {\n          var index = w.globals.selectedDataPoints[i].indexOf(j);\n          w.globals.selectedDataPoints[i].splice(index, 1);\n        }\n      } else {\n        if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {\n          w.globals.selectedDataPoints = [];\n          var elPaths = w.globals.dom.Paper.select('.apexcharts-series path').members;\n          var elCircles = w.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members;\n          elPaths.forEach(function (elPath) {\n            elPath.node.setAttribute('selected', 'false');\n            filters.getDefaultFilter(elPath);\n          });\n          elCircles.forEach(function (circle) {\n            circle.node.setAttribute('selected', 'false');\n            filters.getDefaultFilter(circle);\n          });\n        }\n\n        path.node.setAttribute('selected', 'true');\n        selected = 'true';\n\n        if (typeof w.globals.selectedDataPoints[i] === 'undefined') {\n          w.globals.selectedDataPoints[i] = [];\n        }\n\n        w.globals.selectedDataPoints[i].push(j);\n      }\n\n      if (selected === 'true') {\n        var activeFilter = w.config.states.active.filter;\n\n        if (activeFilter !== 'none') {\n          filters.applyFilter(path, activeFilter.type, activeFilter.value);\n        }\n      } else {\n        if (w.config.states.active.filter.type !== 'none') {\n          filters.getDefaultFilter(path);\n        }\n      }\n\n      if (typeof w.config.chart.events.dataPointSelection === 'function') {\n        w.config.chart.events.dataPointSelection(e, this.ctx, {\n          selectedDataPoints: w.globals.selectedDataPoints,\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n      }\n\n      this.ctx.fireEvent('dataPointSelection', [e, this.ctx, {\n        selectedDataPoints: w.globals.selectedDataPoints,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      }]); // if (this.w.config.chart.selection.selectedPoints !== undefined) {\n      //   this.w.config.chart.selection.selectedPoints(w.globals.selectedDataPoints)\n      // }\n    }\n  }, {\n    key: \"rotateAroundCenter\",\n    value: function rotateAroundCenter(el) {\n      var coord = el.getBBox();\n      var x = coord.x + coord.width / 2;\n      var y = coord.y + coord.height / 2;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"getTextRects\",\n    value: function getTextRects(text, fontSize, fontFamily, transform) {\n      var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var w = this.w;\n      var virtualText = this.drawText({\n        x: -200,\n        y: -200,\n        text: text,\n        textAnchor: 'start',\n        fontSize: fontSize,\n        fontFamily: fontFamily,\n        foreColor: '#fff',\n        opacity: 0\n      });\n\n      if (transform) {\n        virtualText.attr('transform', transform);\n      }\n\n      w.globals.dom.Paper.add(virtualText);\n      var rect = virtualText.bbox();\n\n      if (!useBBox) {\n        rect = virtualText.node.getBoundingClientRect();\n      }\n\n      virtualText.remove();\n      return {\n        width: rect.width,\n        height: rect.height\n      };\n    }\n    /**\n     * append ... to long text\n     * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg\n     * @memberof Graphics\n     **/\n\n  }, {\n    key: \"placeTextWithEllipsis\",\n    value: function placeTextWithEllipsis(textObj, textString, width) {\n      textObj.textContent = textString;\n\n      if (textString.length > 0) {\n        // ellipsis is needed\n        if (textObj.getSubStringLength(0, textString.length) >= width) {\n          for (var x = textString.length - 3; x > 0; x -= 3) {\n            if (textObj.getSubStringLength(0, x) <= width) {\n              textObj.textContent = textString.substring(0, x) + '...';\n              return;\n            }\n          }\n\n          textObj.textContent = '...'; // can't place at all\n        }\n      }\n    }\n  }], [{\n    key: \"setAttrs\",\n    value: function setAttrs(el, attrs) {\n      for (var key in attrs) {\n        if (attrs.hasOwnProperty(key)) {\n          el.setAttribute(key, attrs[key]);\n        }\n      }\n    }\n  }]);\n\n  return Graphics;\n}();\n\nconst name = \"en\";\nconst options = {\n\tmonths: [\n\t\t\"January\",\n\t\t\"February\",\n\t\t\"March\",\n\t\t\"April\",\n\t\t\"May\",\n\t\t\"June\",\n\t\t\"July\",\n\t\t\"August\",\n\t\t\"September\",\n\t\t\"October\",\n\t\t\"November\",\n\t\t\"December\"\n\t],\n\tshortMonths: [\n\t\t\"Jan\",\n\t\t\"Feb\",\n\t\t\"Mar\",\n\t\t\"Apr\",\n\t\t\"May\",\n\t\t\"Jun\",\n\t\t\"Jul\",\n\t\t\"Aug\",\n\t\t\"Sep\",\n\t\t\"Oct\",\n\t\t\"Nov\",\n\t\t\"Dec\"\n\t],\n\tdays: [\n\t\t\"Sunday\",\n\t\t\"Monday\",\n\t\t\"Tuesday\",\n\t\t\"Wednesday\",\n\t\t\"Thursday\",\n\t\t\"Friday\",\n\t\t\"Saturday\"\n\t],\n\tshortDays: [\n\t\t\"Sun\",\n\t\t\"Mon\",\n\t\t\"Tue\",\n\t\t\"Wed\",\n\t\t\"Thu\",\n\t\t\"Fri\",\n\t\t\"Sat\"\n\t],\n\ttoolbar: {\n\t\texportToSVG: \"Download SVG\",\n\t\texportToPNG: \"Download PNG\",\n\t\tmenu: \"Menu\",\n\t\tselection: \"Selection\",\n\t\tselectionZoom: \"Selection Zoom\",\n\t\tzoomIn: \"Zoom In\",\n\t\tzoomOut: \"Zoom Out\",\n\t\tpan: \"Panning\",\n\t\treset: \"Reset Zoom\"\n\t}\n};\nvar en = {\n\tname: name,\n\toptions: options\n};\n\nvar Options =\n/*#__PURE__*/\nfunction () {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    this.yAxis = {\n      show: true,\n      showAlways: false,\n      seriesName: undefined,\n      opposite: false,\n      reversed: false,\n      logarithmic: false,\n      tickAmount: undefined,\n      forceNiceScale: false,\n      max: undefined,\n      min: undefined,\n      floating: false,\n      decimalsInFloat: 2,\n      labels: {\n        show: true,\n        minWidth: 0,\n        maxWidth: 160,\n        offsetX: 0,\n        offsetY: 0,\n        rotate: 0,\n        padding: 20,\n        style: {\n          colors: [],\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: ''\n        },\n        formatter: undefined\n      },\n      axisBorder: {\n        show: false,\n        color: '#78909C',\n        offsetX: 0,\n        offsetY: 0\n      },\n      axisTicks: {\n        show: false,\n        color: '#78909C',\n        width: 6,\n        offsetX: 0,\n        offsetY: 0\n      },\n      title: {\n        text: undefined,\n        rotate: 90,\n        offsetY: 0,\n        offsetX: 0,\n        style: {\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: ''\n        }\n      },\n      tooltip: {\n        enabled: false,\n        offsetX: 0\n      },\n      crosshairs: {\n        show: true,\n        position: 'front',\n        stroke: {\n          color: '#b6b6b6',\n          width: 1,\n          dashArray: 0\n        }\n      }\n    };\n    this.xAxisAnnotation = {\n      x: 0,\n      x2: null,\n      strokeDashArray: 1,\n      fillColor: '#c2c2c2',\n      borderColor: '#c2c2c2',\n      opacity: 0.3,\n      offsetX: 0,\n      offsetY: 0,\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'middle',\n        orientation: 'vertical',\n        position: 'top',\n        offsetX: 0,\n        offsetY: 0,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 2,\n            bottom: 2\n          }\n        }\n      }\n    };\n    this.yAxisAnnotation = {\n      y: 0,\n      y2: null,\n      strokeDashArray: 1,\n      fillColor: '#c2c2c2',\n      borderColor: '#c2c2c2',\n      opacity: 0.3,\n      offsetX: 0,\n      offsetY: 0,\n      yAxisIndex: 0,\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'end',\n        position: 'right',\n        offsetX: 0,\n        offsetY: -3,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 0,\n            bottom: 2\n          }\n        }\n      }\n    };\n    this.pointAnnotation = {\n      x: 0,\n      y: null,\n      yAxisIndex: 0,\n      seriesIndex: 0,\n      marker: {\n        size: 0,\n        fillColor: '#fff',\n        strokeWidth: 2,\n        strokeColor: '#333',\n        shape: 'circle',\n        offsetX: 0,\n        offsetY: 0,\n        radius: 2,\n        cssClass: ''\n      },\n      label: {\n        borderColor: '#c2c2c2',\n        borderWidth: 1,\n        text: undefined,\n        textAnchor: 'middle',\n        offsetX: 0,\n        offsetY: -15,\n        style: {\n          background: '#fff',\n          color: undefined,\n          fontSize: '11px',\n          fontFamily: undefined,\n          cssClass: '',\n          padding: {\n            left: 5,\n            right: 5,\n            top: 0,\n            bottom: 2\n          }\n        }\n      },\n      customSVG: {\n        SVG: undefined,\n        cssClass: undefined,\n        offsetX: 0,\n        offsetY: 0\n      }\n    };\n  }\n\n  _createClass(Options, [{\n    key: \"init\",\n    value: function init() {\n      return {\n        annotations: {\n          position: 'front',\n          yaxis: [this.yAxisAnnotation],\n          xaxis: [this.xAxisAnnotation],\n          points: [this.pointAnnotation]\n        },\n        chart: {\n          animations: {\n            enabled: true,\n            easing: 'easeinout',\n            // linear, easeout, easein, easeinout, swing, bounce, elastic\n            speed: 800,\n            animateGradually: {\n              delay: 150,\n              enabled: true\n            },\n            dynamicAnimation: {\n              enabled: true,\n              speed: 350\n            }\n          },\n          background: 'transparent',\n          locales: [en],\n          defaultLocale: 'en',\n          dropShadow: {\n            enabled: false,\n            enabledSeries: undefined,\n            top: 2,\n            left: 2,\n            blur: 4,\n            color: '#000',\n            opacity: 0.35\n          },\n          events: {\n            animationEnd: undefined,\n            beforeMount: undefined,\n            mounted: undefined,\n            updated: undefined,\n            click: undefined,\n            legendClick: undefined,\n            selection: undefined,\n            dataPointSelection: undefined,\n            dataPointMouseEnter: undefined,\n            dataPointMouseLeave: undefined,\n            beforeZoom: undefined,\n            zoomed: undefined,\n            scrolled: undefined\n          },\n          foreColor: '#373d3f',\n          fontFamily: 'Helvetica, Arial, sans-serif',\n          height: 'auto',\n          id: undefined,\n          group: undefined,\n          offsetX: 0,\n          offsetY: 0,\n          selection: {\n            enabled: false,\n            type: 'x',\n            // selectedPoints: undefined, // default datapoints that should be selected automatically\n            fill: {\n              color: '#24292e',\n              opacity: 0.1\n            },\n            stroke: {\n              width: 1,\n              color: '#24292e',\n              opacity: 0.4,\n              dashArray: 3\n            },\n            xaxis: {\n              min: undefined,\n              max: undefined\n            },\n            yaxis: {\n              min: undefined,\n              max: undefined\n            }\n          },\n          sparkline: {\n            enabled: false\n          },\n          brush: {\n            enabled: false,\n            autoScaleYaxis: false,\n            target: undefined\n          },\n          stacked: false,\n          stackType: 'normal',\n          toolbar: {\n            show: true,\n            tools: {\n              download: true,\n              selection: true,\n              zoom: true,\n              zoomin: true,\n              zoomout: true,\n              pan: true,\n              reset: true,\n              customIcons: []\n            },\n            autoSelected: 'zoom' // accepts -> zoom, pan, selection\n\n          },\n          type: 'line',\n          width: '100%',\n          zoom: {\n            enabled: true,\n            type: 'x',\n            // autoScaleYaxis: false, // TODO: rewrite the autoScaleY function\n            zoomedArea: {\n              fill: {\n                color: '#90CAF9',\n                opacity: 0.4\n              },\n              stroke: {\n                color: '#0D47A1',\n                opacity: 0.4,\n                width: 1\n              }\n            }\n          }\n        },\n        plotOptions: {\n          bar: {\n            horizontal: false,\n            endingShape: 'flat',\n            // TODO: deprecate in 4.0\n            columnWidth: '70%',\n            // should be in percent 0 - 100\n            barHeight: '70%',\n            // should be in percent 0 - 100\n            distributed: false,\n            colors: {\n              ranges: [],\n              backgroundBarColors: [],\n              backgroundBarOpacity: 1\n            },\n            dataLabels: {\n              position: 'top' // top, center, bottom\n              // TODO: provide stackedLabels for stacked charts which gives additions of values\n\n            }\n          },\n          candlestick: {\n            colors: {\n              upward: '#00B746',\n              downward: '#EF403C'\n            },\n            wick: {\n              useFillColor: true\n            }\n          },\n          heatmap: {\n            radius: 2,\n            enableShades: true,\n            shadeIntensity: 0.5,\n            distributed: false,\n            colorScale: {\n              inverse: false,\n              ranges: [],\n              min: undefined,\n              max: undefined\n            }\n          },\n          radialBar: {\n            size: undefined,\n            inverseOrder: false,\n            startAngle: 0,\n            endAngle: 360,\n            offsetX: 0,\n            offsetY: 0,\n            hollow: {\n              margin: 5,\n              size: '50%',\n              background: 'transparent',\n              image: undefined,\n              imageWidth: 150,\n              imageHeight: 150,\n              imageOffsetX: 0,\n              imageOffsetY: 0,\n              imageClipped: true,\n              position: 'front',\n              dropShadow: {\n                enabled: false,\n                top: 0,\n                left: 0,\n                blur: 3,\n                color: '#000',\n                opacity: 0.5\n              }\n            },\n            track: {\n              show: true,\n              startAngle: undefined,\n              endAngle: undefined,\n              background: '#f2f2f2',\n              strokeWidth: '97%',\n              opacity: 1,\n              margin: 5,\n              // margin is in pixels\n              dropShadow: {\n                enabled: false,\n                top: 0,\n                left: 0,\n                blur: 3,\n                color: '#000',\n                opacity: 0.5\n              }\n            },\n            dataLabels: {\n              show: true,\n              name: {\n                show: true,\n                fontSize: '16px',\n                fontFamily: undefined,\n                color: undefined,\n                offsetY: 0\n              },\n              value: {\n                show: true,\n                fontSize: '14px',\n                fontFamily: undefined,\n                color: undefined,\n                offsetY: 16,\n                formatter: function formatter(val) {\n                  return val + '%';\n                }\n              },\n              total: {\n                show: false,\n                label: 'Total',\n                color: '#373d3f',\n                formatter: function formatter(w) {\n                  return w.globals.seriesTotals.reduce(function (a, b) {\n                    return a + b;\n                  }, 0) / w.globals.series.length + '%';\n                }\n              }\n            }\n          },\n          pie: {\n            size: undefined,\n            customScale: 1,\n            offsetX: 0,\n            offsetY: 0,\n            expandOnClick: true,\n            dataLabels: {\n              // These are the percentage values which are displayed on slice\n              offset: 0 // offset by which labels will move outside\n\n            },\n            donut: {\n              size: '65%',\n              background: 'transparent',\n              labels: {\n                // These are the inner labels appearing inside donut\n                show: false,\n                name: {\n                  show: true,\n                  fontSize: '16px',\n                  fontFamily: undefined,\n                  color: undefined,\n                  offsetY: -10\n                },\n                value: {\n                  show: true,\n                  fontSize: '20px',\n                  fontFamily: undefined,\n                  color: undefined,\n                  offsetY: 10,\n                  formatter: function formatter(val) {\n                    return val;\n                  }\n                },\n                total: {\n                  show: false,\n                  label: 'Total',\n                  color: '#373d3f',\n                  formatter: function formatter(w) {\n                    return w.globals.seriesTotals.reduce(function (a, b) {\n                      return a + b;\n                    }, 0);\n                  }\n                }\n              }\n            }\n          },\n          radar: {\n            size: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            polygons: {\n              // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2\n              strokeColors: '#e8e8e8',\n              connectorColors: '#e8e8e8',\n              fill: {\n                colors: undefined\n              }\n            }\n          }\n        },\n        colors: undefined,\n        dataLabels: {\n          enabled: true,\n          enabledOnSeries: undefined,\n          formatter: function formatter(val) {\n            return val;\n          },\n          textAnchor: 'middle',\n          offsetX: 0,\n          offsetY: 0,\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined,\n            colors: undefined\n          },\n          dropShadow: {\n            enabled: false,\n            top: 1,\n            left: 1,\n            blur: 1,\n            color: '#000',\n            opacity: 0.45\n          }\n        },\n        fill: {\n          type: 'solid',\n          colors: undefined,\n          // array of colors\n          opacity: 0.85,\n          gradient: {\n            shade: 'dark',\n            type: 'horizontal',\n            shadeIntensity: 0.5,\n            gradientToColors: undefined,\n            inverseColors: true,\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [0, 50, 100],\n            colorStops: []\n          },\n          image: {\n            src: [],\n            width: undefined,\n            // optional\n            height: undefined // optional\n\n          },\n          pattern: {\n            style: 'sqaures',\n            // String | Array of Strings\n            width: 6,\n            height: 6,\n            strokeWidth: 2\n          }\n        },\n        grid: {\n          show: true,\n          borderColor: '#e0e0e0',\n          strokeDashArray: 0,\n          position: 'back',\n          xaxis: {\n            lines: {\n              show: false,\n              animate: false\n            }\n          },\n          yaxis: {\n            lines: {\n              show: true,\n              animate: true\n            }\n          },\n          row: {\n            colors: undefined,\n            // takes as array which will be repeated on rows\n            opacity: 0.5\n          },\n          column: {\n            colors: undefined,\n            // takes an array which will be repeated on columns\n            opacity: 0.5\n          },\n          padding: {\n            top: 0,\n            right: 10,\n            bottom: 0,\n            left: 12\n          }\n        },\n        labels: [],\n        legend: {\n          show: true,\n          showForSingleSeries: false,\n          showForNullSeries: true,\n          showForZeroSeries: true,\n          floating: false,\n          position: 'bottom',\n          // whether to position legends in 1 of 4\n          // direction - top, bottom, left, right\n          horizontalAlign: 'center',\n          // when position top/bottom, you can specify whether to align legends left, right or center\n          fontSize: '12px',\n          fontFamily: undefined,\n          width: undefined,\n          height: undefined,\n          formatter: undefined,\n          offsetX: -20,\n          offsetY: 0,\n          labels: {\n            colors: undefined,\n            useSeriesColors: false\n          },\n          markers: {\n            width: 12,\n            height: 12,\n            strokeWidth: 0,\n            strokeColor: '#fff',\n            radius: 12,\n            customHTML: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            onClick: undefined\n          },\n          itemMargin: {\n            horizontal: 0,\n            vertical: 5\n          },\n          onItemClick: {\n            toggleDataSeries: true\n          },\n          onItemHover: {\n            highlightDataSeries: true\n          }\n        },\n        markers: {\n          discrete: [],\n          size: 0,\n          colors: undefined,\n          //strokeColor: '#fff', // TODO: deprecate in major version 4.0\n          strokeColors: '#fff',\n          strokeWidth: 2,\n          strokeOpacity: 0.9,\n          fillOpacity: 1,\n          shape: 'circle',\n          radius: 2,\n          offsetX: 0,\n          offsetY: 0,\n          hover: {\n            size: undefined,\n            sizeOffset: 3\n          }\n        },\n        noData: {\n          text: undefined,\n          align: 'center',\n          verticalAlign: 'middle',\n          offsetX: 0,\n          offsetY: 0,\n          style: {\n            color: undefined,\n            fontSize: '14px',\n            fontFamily: undefined\n          }\n        },\n        responsive: [],\n        // breakpoints should follow ascending order 400, then 700, then 1000\n        series: undefined,\n        states: {\n          normal: {\n            filter: {\n              type: 'none',\n              value: 0\n            }\n          },\n          hover: {\n            filter: {\n              type: 'lighten',\n              value: 0.15\n            }\n          },\n          active: {\n            allowMultipleDataPointsSelection: false,\n            filter: {\n              type: 'darken',\n              value: 0.65\n            }\n          }\n        },\n        title: {\n          text: undefined,\n          align: 'left',\n          margin: 10,\n          offsetX: 0,\n          offsetY: 0,\n          floating: false,\n          style: {\n            fontSize: '14px',\n            fontFamily: undefined,\n            color: undefined\n          }\n        },\n        subtitle: {\n          text: undefined,\n          align: 'left',\n          margin: 10,\n          offsetX: 0,\n          offsetY: 30,\n          floating: false,\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined,\n            color: undefined\n          }\n        },\n        stroke: {\n          show: true,\n          curve: 'smooth',\n          // \"smooth\" / \"straight\" / \"stepline\"\n          lineCap: 'butt',\n          // round, butt , square\n          width: 2,\n          colors: undefined,\n          // array of colors\n          dashArray: 0 // single value or array of values\n\n        },\n        tooltip: {\n          enabled: true,\n          shared: true,\n          followCursor: false,\n          // when disabled, the tooltip will show on top of the series instead of mouse position\n          intersect: false,\n          // when enabled, tooltip will only show when user directly hovers over point\n          inverseOrder: false,\n          custom: undefined,\n          fillSeriesColor: false,\n          theme: 'light',\n          style: {\n            fontSize: '12px',\n            fontFamily: undefined\n          },\n          onDatasetHover: {\n            highlightDataSeries: false\n          },\n          x: {\n            // x value\n            show: true,\n            format: 'dd MMM',\n            // dd/MM, dd MMM yy, dd MMM yyyy\n            formatter: undefined // a custom user supplied formatter function\n\n          },\n          y: {\n            formatter: undefined,\n            title: {\n              formatter: function formatter(seriesName) {\n                return seriesName;\n              }\n            }\n          },\n          z: {\n            formatter: undefined,\n            title: 'Size: '\n          },\n          marker: {\n            show: true\n          },\n          items: {\n            display: 'flex'\n          },\n          fixed: {\n            enabled: false,\n            position: 'topRight',\n            // topRight, topLeft, bottomRight, bottomLeft\n            offsetX: 0,\n            offsetY: 0\n          }\n        },\n        xaxis: {\n          type: 'category',\n          categories: [],\n          offsetX: 0,\n          offsetY: 0,\n          labels: {\n            show: true,\n            rotate: -45,\n            rotateAlways: false,\n            hideOverlappingLabels: true,\n            trim: true,\n            minHeight: undefined,\n            maxHeight: 120,\n            showDuplicates: true,\n            style: {\n              colors: [],\n              fontSize: '12px',\n              fontFamily: undefined,\n              cssClass: ''\n            },\n            offsetX: 0,\n            offsetY: 0,\n            format: undefined,\n            formatter: undefined,\n            // custom formatter function which will override format\n            datetimeFormatter: {\n              year: 'yyyy',\n              month: \"MMM 'yy\",\n              day: 'dd MMM',\n              hour: 'HH:mm',\n              minute: 'HH:mm:ss'\n            }\n          },\n          axisBorder: {\n            show: true,\n            color: '#78909C',\n            width: '100%',\n            height: 1,\n            offsetX: 0,\n            offsetY: 0\n          },\n          axisTicks: {\n            show: true,\n            color: '#78909C',\n            height: 6,\n            offsetX: 0,\n            offsetY: 0\n          },\n          tickAmount: undefined,\n          tickPlacement: 'on',\n          min: undefined,\n          max: undefined,\n          range: undefined,\n          floating: false,\n          position: 'bottom',\n          title: {\n            text: undefined,\n            offsetX: 0,\n            offsetY: 0,\n            style: {\n              color: undefined,\n              fontSize: '12px',\n              fontFamily: undefined,\n              cssClass: ''\n            }\n          },\n          crosshairs: {\n            show: true,\n            width: 1,\n            // tickWidth/barWidth or an integer\n            position: 'back',\n            opacity: 0.9,\n            stroke: {\n              color: '#b6b6b6',\n              width: 1,\n              dashArray: 3\n            },\n            fill: {\n              type: 'solid',\n              // solid, gradient\n              color: '#B1B9C4',\n              gradient: {\n                colorFrom: '#D8E3F0',\n                colorTo: '#BED1E6',\n                stops: [0, 100],\n                opacityFrom: 0.4,\n                opacityTo: 0.5\n              }\n            },\n            dropShadow: {\n              enabled: false,\n              left: 0,\n              top: 0,\n              blur: 1,\n              opacity: 0.4\n            }\n          },\n          tooltip: {\n            enabled: true,\n            offsetY: 0,\n            formatter: undefined,\n            style: {\n              fontSize: '12px',\n              fontFamily: undefined\n            }\n          }\n        },\n        yaxis: this.yAxis,\n        theme: {\n          palette: 'palette1',\n          // If defined, it will overwrite globals.colors variable\n          monochrome: {\n            // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)\n            enabled: false,\n            color: '#008FFB',\n            shadeTo: 'light',\n            shadeIntensity: 0.65\n          }\n        }\n      };\n    }\n  }]);\n\n  return Options;\n}();\n\n/**\n * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.\n *\n * @module Annotations\n **/\n\nvar Annotations =\n/*#__PURE__*/\nfunction () {\n  function Annotations(ctx) {\n    _classCallCheck(this, Annotations);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.graphics = new Graphics(this.ctx);\n\n    if (this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal) {\n      this.invertAxis = true;\n    }\n\n    this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;\n  }\n\n  _createClass(Annotations, [{\n    key: \"drawAnnotations\",\n    value: function drawAnnotations() {\n      var w = this.w;\n\n      if (w.globals.axisCharts) {\n        var yAnnotations = this.drawYAxisAnnotations();\n        var xAnnotations = this.drawXAxisAnnotations();\n        var pointAnnotations = this.drawPointAnnotations();\n        var initialAnim = w.config.chart.animations.enabled;\n        var annoArray = [yAnnotations, xAnnotations, pointAnnotations];\n        var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];\n\n        for (var i = 0; i < 3; i++) {\n          w.globals.dom.elGraphical.add(annoArray[i]);\n\n          if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n            annoElArray[i].classList.add('hidden');\n          }\n\n          w.globals.delayedElements.push({\n            el: annoElArray[i],\n            index: 0\n          });\n        } // after placing the annotations on svg, set any vertically placed annotations\n\n\n        this.setOrientations(w.config.annotations.xaxis); // background sizes needs to be calculated after text is drawn, so calling them last\n\n        this.annotationsBackground();\n      }\n    }\n  }, {\n    key: \"addXaxisAnnotation\",\n    value: function addXaxisAnnotation(anno, parent, index) {\n      var w = this.w;\n      var min = this.invertAxis ? w.globals.minY : w.globals.minX;\n      var range = this.invertAxis ? w.globals.yRange[0] : w.globals.xRange;\n      var x1 = (anno.x - min) / (range / w.globals.gridWidth);\n\n      if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {\n        var catIndex = w.globals.labels.indexOf(anno.x);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n        x1 = parseFloat(xLabel.getAttribute('x'));\n      }\n\n      var strokeDashArray = anno.strokeDashArray;\n      if (x1 < 0 || x1 > w.globals.gridWidth) return;\n\n      if (anno.x2 === null) {\n        var line = this.graphics.drawLine(x1 + anno.offsetX, // x1\n        0 + anno.offsetY, // y1\n        x1 + anno.offsetX, // x2\n        w.globals.gridHeight + anno.offsetY, // y2\n        anno.borderColor, // lineColor\n        strokeDashArray //dashArray\n        );\n        parent.appendChild(line.node);\n      } else {\n        var x2 = (anno.x2 - min) / (range / w.globals.gridWidth);\n\n        if (x2 < x1) {\n          var temp = x1;\n          x1 = x2;\n          x2 = temp;\n        }\n\n        var rect = this.graphics.drawRect(x1 + anno.offsetX, // x1\n        0 + anno.offsetY, // y1\n        x2 - x1, // x2\n        w.globals.gridHeight + anno.offsetY, // y2\n        0, // radius\n        anno.fillColor, // color\n        anno.opacity, // opacity,\n        1, // strokeWidth\n        anno.borderColor, // strokeColor\n        strokeDashArray // stokeDashArray\n        );\n        parent.appendChild(rect.node);\n      }\n\n      var textY = anno.label.position === 'top' ? -3 : w.globals.gridHeight;\n      var text = anno.label.text ? anno.label.text : '';\n      var elText = this.graphics.drawText({\n        x: x1 + anno.label.offsetX,\n        y: textY + anno.label.offsetY,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-xaxis-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n    }\n  }, {\n    key: \"drawXAxisAnnotations\",\n    value: function drawXAxisAnnotations() {\n      var _this = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-xaxis-annotations'\n      });\n      w.config.annotations.xaxis.map(function (anno, index) {\n        _this.addXaxisAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"addYaxisAnnotation\",\n    value: function addYaxisAnnotation(anno, parent, index) {\n      var w = this.w;\n      var strokeDashArray = anno.strokeDashArray;\n      var y1;\n      var y2;\n\n      if (this.invertAxis) {\n        var catIndex = w.globals.labels.indexOf(anno.y);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n        y1 = parseFloat(xLabel.getAttribute('y'));\n      } else {\n        y1 = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex].reversed) {\n          y1 = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      }\n\n      var text = anno.label.text ? anno.label.text : '';\n\n      if (anno.y2 === null) {\n        var line = this.graphics.drawLine(0 + anno.offsetX, // x1\n        y1 + anno.offsetY, // y1\n        w.globals.gridWidth + anno.offsetX, // x2\n        y1 + anno.offsetY, // y2\n        anno.borderColor, // lineColor\n        strokeDashArray // dashArray\n        );\n        parent.appendChild(line.node);\n      } else {\n        if (this.invertAxis) {\n          var _catIndex = w.globals.labels.indexOf(anno.y2);\n\n          var _xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (_catIndex + 1) + ')');\n\n          y2 = parseFloat(_xLabel.getAttribute('y'));\n        } else {\n          y2 = w.globals.gridHeight - (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n          if (w.config.yaxis[anno.yAxisIndex].reversed) {\n            y2 = (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n          }\n        }\n\n        if (y2 > y1) {\n          var temp = y1;\n          y1 = y2;\n          y2 = temp;\n        }\n\n        var rect = this.graphics.drawRect(0 + anno.offsetX, // x1\n        y2 + anno.offsetY, // y1\n        w.globals.gridWidth + anno.offsetX, // x2\n        y1 - y2, // y2\n        0, // radius\n        anno.fillColor, // color\n        anno.opacity, // opacity,\n        1, // strokeWidth\n        anno.borderColor, // strokeColor\n        strokeDashArray // stokeDashArray\n        );\n        parent.appendChild(rect.node);\n      }\n\n      var textX = anno.label.position === 'right' ? w.globals.gridWidth : 0;\n      var elText = this.graphics.drawText({\n        x: textX + anno.label.offsetX,\n        y: (y2 || y1) + anno.label.offsetY - 3,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-yaxis-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n    }\n  }, {\n    key: \"drawYAxisAnnotations\",\n    value: function drawYAxisAnnotations() {\n      var _this2 = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-yaxis-annotations'\n      });\n      w.config.annotations.yaxis.map(function (anno, index) {\n        _this2.addYaxisAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"clearAnnotations\",\n    value: function clearAnnotations(ctx) {\n      var w = ctx.w;\n      var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations');\n      annos.forEach(function (a) {\n        while (a.firstChild) {\n          a.removeChild(a.firstChild);\n        }\n      });\n    }\n  }, {\n    key: \"addPointAnnotation\",\n    value: function addPointAnnotation(anno, parent, index) {\n      var w = this.w;\n      var x = 0;\n      var y = 0;\n      var pointY = 0;\n\n      if (this.invertAxis) {\n        console.warn('Point annotation is not supported in horizontal bar charts.');\n      }\n\n      if (typeof anno.x === 'string') {\n        var catIndex = w.globals.labels.indexOf(anno.x);\n        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');\n        var xPos = parseFloat(xLabel.getAttribute('x'));\n        x = xPos;\n        var annoY = anno.y;\n\n        if (anno.y === null) {\n          annoY = w.globals.series[anno.seriesIndex][catIndex];\n        }\n\n        y = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n        pointY = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex].reversed) {\n          y = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) + parseInt(anno.label.style.fontSize) + anno.marker.size;\n          pointY = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      } else {\n        x = (anno.x - w.globals.minX) / (w.globals.xRange / w.globals.gridWidth);\n        y = w.globals.gridHeight - (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n        pointY = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n\n        if (w.config.yaxis[anno.yAxisIndex].reversed) {\n          y = (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;\n          pointY = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);\n        }\n      }\n\n      if (x < 0 || x > w.globals.gridWidth) return;\n      var optsPoints = {\n        pSize: anno.marker.size,\n        pWidth: anno.marker.strokeWidth,\n        pointFillColor: anno.marker.fillColor,\n        pointStrokeColor: anno.marker.strokeColor,\n        shape: anno.marker.shape,\n        radius: anno.marker.radius,\n        class: 'apexcharts-point-annotation-marker ' + anno.marker.cssClass\n      };\n      var point = this.graphics.drawMarker(x + anno.marker.offsetX, pointY + anno.marker.offsetY, optsPoints);\n      parent.appendChild(point.node);\n      var text = anno.label.text ? anno.label.text : '';\n      var elText = this.graphics.drawText({\n        x: x + anno.label.offsetX,\n        y: y + anno.label.offsetY,\n        text: text,\n        textAnchor: anno.label.textAnchor,\n        fontSize: anno.label.style.fontSize,\n        fontFamily: anno.label.style.fontFamily,\n        foreColor: anno.label.style.color,\n        cssClass: 'apexcharts-point-annotation-label ' + anno.label.style.cssClass\n      });\n      elText.attr({\n        rel: index\n      });\n      parent.appendChild(elText.node);\n\n      if (anno.customSVG.SVG) {\n        var g = this.graphics.group({\n          class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass\n        });\n        g.attr({\n          transform: \"translate(\".concat(x + anno.customSVG.offsetX, \", \").concat(y + anno.customSVG.offsetY, \")\")\n        });\n        g.node.innerHTML = anno.customSVG.SVG;\n        parent.appendChild(g.node);\n      }\n    }\n  }, {\n    key: \"drawPointAnnotations\",\n    value: function drawPointAnnotations() {\n      var _this3 = this;\n\n      var w = this.w;\n      var elg = this.graphics.group({\n        class: 'apexcharts-point-annotations'\n      });\n      w.config.annotations.points.map(function (anno, index) {\n        _this3.addPointAnnotation(anno, elg.node, index);\n      });\n      return elg;\n    }\n  }, {\n    key: \"setOrientations\",\n    value: function setOrientations(annos) {\n      var _this4 = this;\n\n      var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var w = this.w;\n      annos.map(function (anno, index) {\n        if (anno.label.orientation === 'vertical') {\n          var i = annoIndex !== null ? annoIndex : index;\n          var xAnno = w.globals.dom.baseEl.querySelector(\".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='\".concat(i, \"']\"));\n\n          if (xAnno !== null) {\n            var xAnnoCoord = xAnno.getBoundingClientRect();\n            xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);\n\n            if (anno.label.position === 'top') {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + xAnnoCoord.width);\n            } else {\n              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) - xAnnoCoord.width);\n            }\n\n            var annoRotatingCenter = _this4.graphics.rotateAroundCenter(xAnno);\n\n            var x = annoRotatingCenter.x;\n            var y = annoRotatingCenter.y;\n            xAnno.setAttribute('transform', \"rotate(-90 \".concat(x, \" \").concat(y, \")\"));\n          }\n        }\n      });\n    }\n  }, {\n    key: \"addBackgroundToAnno\",\n    value: function addBackgroundToAnno(annoEl, anno) {\n      var w = this.w;\n      var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();\n      var coords = annoEl.getBoundingClientRect();\n      var pleft = anno.label.style.padding.left;\n      var pright = anno.label.style.padding.right;\n      var ptop = anno.label.style.padding.top;\n      var pbottom = anno.label.style.padding.bottom;\n\n      if (anno.label.orientation === 'vertical') {\n        ptop = anno.label.style.padding.left;\n        pbottom = anno.label.style.padding.right;\n        pleft = anno.label.style.padding.top;\n        pright = anno.label.style.padding.bottom;\n      }\n\n      var x1 = coords.left - elGridRect.left - pleft;\n      var y1 = coords.top - elGridRect.top - ptop;\n      var elRect = this.graphics.drawRect(x1, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, 0, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);\n      return elRect;\n    }\n  }, {\n    key: \"annotationsBackground\",\n    value: function annotationsBackground() {\n      var _this5 = this;\n\n      var w = this.w;\n\n      var add = function add(anno, i, type) {\n        var annoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(i, \"']\"));\n\n        if (annoLabel) {\n          var parent = annoLabel.parentNode;\n\n          var elRect = _this5.addBackgroundToAnno(annoLabel, anno);\n\n          parent.insertBefore(elRect.node, annoLabel);\n        }\n      };\n\n      w.config.annotations.xaxis.map(function (anno, i) {\n        add(anno, i, 'xaxis');\n      });\n      w.config.annotations.yaxis.map(function (anno, i) {\n        add(anno, i, 'yaxis');\n      });\n      w.config.annotations.points.map(function (anno, i) {\n        add(anno, i, 'point');\n      });\n    }\n  }, {\n    key: \"addText\",\n    value: function addText(params, pushToMemory, context) {\n      var x = params.x,\n          y = params.y,\n          text = params.text,\n          textAnchor = params.textAnchor,\n          _params$appendTo = params.appendTo,\n          appendTo = _params$appendTo === void 0 ? '.apexcharts-inner' : _params$appendTo,\n          foreColor = params.foreColor,\n          fontSize = params.fontSize,\n          fontFamily = params.fontFamily,\n          cssClass = params.cssClass,\n          backgroundColor = params.backgroundColor,\n          borderWidth = params.borderWidth,\n          strokeDashArray = params.strokeDashArray,\n          radius = params.radius,\n          borderColor = params.borderColor,\n          _params$paddingLeft = params.paddingLeft,\n          paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,\n          _params$paddingRight = params.paddingRight,\n          paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,\n          _params$paddingBottom = params.paddingBottom,\n          paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,\n          _params$paddingTop = params.paddingTop,\n          paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;\n      var me = context;\n      var w = me.w;\n      var parentNode = w.globals.dom.baseEl.querySelector(appendTo);\n      var elText = this.graphics.drawText({\n        x: x,\n        y: y,\n        text: text,\n        textAnchor: textAnchor || 'start',\n        fontSize: fontSize || '12px',\n        fontFamily: fontFamily || w.config.chart.fontFamily,\n        foreColor: foreColor || w.config.chart.foreColor,\n        cssClass:  true ? cssClass : undefined\n      });\n      parentNode.appendChild(elText.node);\n      var textRect = elText.bbox();\n      var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, radius, backgroundColor, 1, borderWidth, borderColor, strokeDashArray);\n      elText.before(elRect);\n\n      if (pushToMemory) {\n        w.globals.memory.methodsToExec.push({\n          context: me,\n          method: me.addText,\n          params: {\n            x: x,\n            y: y,\n            text: text,\n            textAnchor: textAnchor,\n            appendTo: appendTo,\n            foreColor: foreColor,\n            fontSize: fontSize,\n            cssClass: cssClass,\n            backgroundColor: backgroundColor,\n            borderWidth: borderWidth,\n            strokeDashArray: strokeDashArray,\n            radius: radius,\n            borderColor: borderColor,\n            paddingLeft: paddingLeft,\n            paddingRight: paddingRight,\n            paddingBottom: paddingBottom,\n            paddingTop: paddingTop\n          }\n        });\n      }\n\n      return context;\n    }\n  }, {\n    key: \"addPointAnnotationExternal\",\n    value: function addPointAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'point',\n        contextMethod: context.addPointAnnotation\n      });\n      return context;\n    }\n  }, {\n    key: \"addYaxisAnnotationExternal\",\n    value: function addYaxisAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'yaxis',\n        contextMethod: context.addYaxisAnnotation\n      });\n      return context;\n    } // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method\n\n  }, {\n    key: \"addXaxisAnnotationExternal\",\n    value: function addXaxisAnnotationExternal(params, pushToMemory, context) {\n      this.addAnnotationExternal({\n        params: params,\n        pushToMemory: pushToMemory,\n        context: context,\n        type: 'xaxis',\n        contextMethod: context.addXaxisAnnotation\n      });\n      return context;\n    }\n  }, {\n    key: \"addAnnotationExternal\",\n    value: function addAnnotationExternal(_ref) {\n      var params = _ref.params,\n          pushToMemory = _ref.pushToMemory,\n          context = _ref.context,\n          type = _ref.type,\n          contextMethod = _ref.contextMethod;\n      var me = context;\n      var w = me.w;\n      var parent = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations\"));\n      var index = parent.childNodes.length + 1;\n      var opt = new Options();\n      var axesAnno = Object.assign({}, type === 'xaxis' ? opt.xAxisAnnotation : type === 'yaxis' ? opt.yAxisAnnotation : opt.pointAnnotation);\n      var anno = Utils.extend(axesAnno, params);\n\n      switch (type) {\n        case 'xaxis':\n          this.addXaxisAnnotation(anno, parent, index);\n          break;\n\n        case 'yaxis':\n          this.addYaxisAnnotation(anno, parent, index);\n          break;\n\n        case 'point':\n          this.addPointAnnotation(anno, parent, index);\n          break;\n      } // add background\n\n\n      var axesAnnoLabel = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-annotations .apexcharts-\").concat(type, \"-annotation-label[rel='\").concat(index, \"']\"));\n      var elRect = this.addBackgroundToAnno(axesAnnoLabel, anno);\n      parent.insertBefore(elRect.node, axesAnnoLabel);\n\n      if (pushToMemory) {\n        w.globals.memory.methodsToExec.push({\n          context: me,\n          method: contextMethod,\n          params: params\n        });\n      }\n\n      return context;\n    }\n  }]);\n\n  return Annotations;\n}();\n\n/**\n * ApexCharts Default Class for setting default options for all chart types.\n *\n * @module Defaults\n **/\n\nvar Defaults =\n/*#__PURE__*/\nfunction () {\n  function Defaults(opts) {\n    _classCallCheck(this, Defaults);\n\n    this.opts = opts;\n  }\n\n  _createClass(Defaults, [{\n    key: \"line\",\n    value: function line() {\n      return {\n        chart: {\n          animations: {\n            easing: 'swing'\n          }\n        },\n        dataLabels: {\n          enabled: false\n        },\n        stroke: {\n          width: 5,\n          curve: 'straight'\n        },\n        markers: {\n          size: 0,\n          hover: {\n            sizeOffset: 6\n          }\n        },\n        xaxis: {\n          crosshairs: {\n            width: 1\n          }\n        }\n      };\n    }\n  }, {\n    key: \"sparkline\",\n    value: function sparkline(defaults) {\n      this.opts.yaxis[0].labels.show = false;\n      this.opts.yaxis[0].floating = true;\n      var ret = {\n        grid: {\n          show: false,\n          padding: {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n          }\n        },\n        legend: {\n          show: false\n        },\n        xaxis: {\n          labels: {\n            show: false\n          },\n          tooltip: {\n            enabled: false\n          },\n          axisBorder: {\n            show: false\n          }\n        },\n        chart: {\n          toolbar: {\n            show: false\n          },\n          zoom: {\n            enabled: false\n          }\n        },\n        dataLabels: {\n          enabled: false\n        }\n      };\n      return Utils.extend(defaults, ret);\n    }\n  }, {\n    key: \"bar\",\n    value: function bar() {\n      return {\n        chart: {\n          stacked: false,\n          animations: {\n            easing: 'swing'\n          }\n        },\n        plotOptions: {\n          bar: {\n            dataLabels: {\n              position: 'center'\n            }\n          }\n        },\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        stroke: {\n          width: 0\n        },\n        fill: {\n          opacity: 0.85\n        },\n        legend: {\n          markers: {\n            shape: 'square',\n            radius: 2,\n            size: 8\n          }\n        },\n        tooltip: {\n          shared: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          },\n          crosshairs: {\n            width: 'barWidth',\n            position: 'back',\n            fill: {\n              type: 'gradient'\n            },\n            dropShadow: {\n              enabled: false\n            },\n            stroke: {\n              width: 0\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"candlestick\",\n    value: function candlestick() {\n      return {\n        stroke: {\n          width: 1,\n          colors: ['#333']\n        },\n        dataLabels: {\n          enabled: false\n        },\n        tooltip: {\n          shared: true,\n          custom: function custom(_ref) {\n            var seriesIndex = _ref.seriesIndex,\n                dataPointIndex = _ref.dataPointIndex,\n                w = _ref.w;\n            var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];\n            var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];\n            var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];\n            var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];\n            return '<div class=\"apexcharts-tooltip-candlestick\">' + '<div>Open: <span class=\"value\">' + o + '</span></div>' + '<div>High: <span class=\"value\">' + h + '</span></div>' + '<div>Low: <span class=\"value\">' + l + '</span></div>' + '<div>Close: <span class=\"value\">' + c + '</span></div>' + '</div>';\n          }\n        },\n        states: {\n          active: {\n            filter: {\n              type: 'none'\n            }\n          }\n        },\n        xaxis: {\n          crosshairs: {\n            width: 1\n          }\n        }\n      };\n    }\n  }, {\n    key: \"area\",\n    value: function area() {\n      return {\n        stroke: {\n          width: 4\n        },\n        fill: {\n          type: 'gradient',\n          gradient: {\n            inverseColors: false,\n            shade: 'light',\n            type: 'vertical',\n            opacityFrom: 0.65,\n            opacityTo: 0.5,\n            stops: [0, 100, 100]\n          }\n        },\n        markers: {\n          size: 0,\n          hover: {\n            sizeOffset: 6\n          }\n        },\n        tooltip: {\n          followCursor: false\n        }\n      };\n    }\n  }, {\n    key: \"brush\",\n    value: function brush(defaults) {\n      var ret = {\n        chart: {\n          toolbar: {\n            autoSelected: 'selection',\n            show: false\n          },\n          zoom: {\n            enabled: false\n          }\n        },\n        dataLabels: {\n          enabled: false\n        },\n        stroke: {\n          width: 1\n        },\n        tooltip: {\n          enabled: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          }\n        }\n      };\n      return Utils.extend(defaults, ret);\n    }\n  }, {\n    key: \"stacked100\",\n    value: function stacked100() {\n      var _this = this;\n\n      this.opts.dataLabels = this.opts.dataLabels || {};\n      this.opts.dataLabels.formatter = this.opts.dataLabels.formatter || undefined;\n      var existingDataLabelFormatter = this.opts.dataLabels.formatter;\n      this.opts.yaxis.forEach(function (yaxe, index) {\n        _this.opts.yaxis[index].min = 0;\n        _this.opts.yaxis[index].max = 100;\n      });\n      var isBar = this.opts.chart.type === 'bar';\n\n      if (isBar) {\n        this.opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {\n          if (typeof val === 'number') {\n            return val ? val.toFixed(0) + '%' : val;\n          }\n\n          return val;\n        };\n      }\n    } // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area\n\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      return {\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        tooltip: {\n          shared: false,\n          intersect: true\n        },\n        xaxis: {\n          crosshairs: {\n            width: 0\n          }\n        },\n        fill: {\n          type: 'solid',\n          gradient: {\n            shade: 'light',\n            inverse: true,\n            shadeIntensity: 0.55,\n            opacityFrom: 0.4,\n            opacityTo: 0.8\n          }\n        }\n      };\n    }\n  }, {\n    key: \"scatter\",\n    value: function scatter() {\n      return {\n        dataLabels: {\n          enabled: false\n        },\n        tooltip: {\n          shared: false,\n          intersect: true\n        },\n        markers: {\n          size: 6,\n          strokeWidth: 2,\n          hover: {\n            sizeOffset: 2\n          }\n        }\n      };\n    }\n  }, {\n    key: \"heatmap\",\n    value: function heatmap() {\n      return {\n        chart: {\n          stacked: false,\n          zoom: {\n            enabled: false\n          }\n        },\n        fill: {\n          opacity: 1\n        },\n        dataLabels: {\n          style: {\n            colors: ['#fff']\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        tooltip: {\n          followCursor: true,\n          marker: {\n            show: false\n          },\n          x: {\n            show: false\n          }\n        },\n        legend: {\n          position: 'top',\n          markers: {\n            shape: 'square',\n            size: 10,\n            offsetY: 2\n          }\n        },\n        grid: {\n          padding: {\n            right: 20\n          }\n        }\n      };\n    }\n  }, {\n    key: \"pie\",\n    value: function pie() {\n      return {\n        chart: {\n          toolbar: {\n            show: false\n          }\n        },\n        plotOptions: {\n          pie: {\n            donut: {\n              labels: {\n                show: false\n              }\n            }\n          }\n        },\n        dataLabels: {\n          formatter: function formatter(val) {\n            return val.toFixed(1) + '%';\n          },\n          style: {\n            colors: ['#fff']\n          },\n          dropShadow: {\n            enabled: true\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        fill: {\n          opacity: 1,\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.35,\n            inverseColors: false,\n            stops: [0, 100, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        tooltip: {\n          theme: 'dark',\n          fillSeriesColor: true\n        },\n        legend: {\n          position: 'right'\n        }\n      };\n    }\n  }, {\n    key: \"donut\",\n    value: function donut() {\n      return {\n        chart: {\n          toolbar: {\n            show: false\n          }\n        },\n        dataLabels: {\n          formatter: function formatter(val) {\n            return val.toFixed(1) + '%';\n          },\n          style: {\n            colors: ['#fff']\n          },\n          dropShadow: {\n            enabled: true\n          }\n        },\n        stroke: {\n          colors: ['#fff']\n        },\n        fill: {\n          opacity: 1,\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.4,\n            inverseColors: false,\n            type: 'vertical',\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [70, 98, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        tooltip: {\n          theme: 'dark',\n          fillSeriesColor: true\n        },\n        legend: {\n          position: 'right'\n        }\n      };\n    }\n  }, {\n    key: \"radar\",\n    value: function radar() {\n      this.opts.yaxis[0].labels.style.fontSize = '13px';\n      this.opts.yaxis[0].labels.offsetY = 6;\n      return {\n        dataLabels: {\n          enabled: true,\n          style: {\n            colors: ['#a8a8a8'],\n            fontSize: '11px'\n          }\n        },\n        stroke: {\n          width: 2\n        },\n        markers: {\n          size: 3,\n          strokeWidth: 1,\n          strokeOpacity: 1\n        },\n        fill: {\n          opacity: 0.2\n        },\n        tooltip: {\n          shared: false,\n          intersect: true,\n          followCursor: true\n        },\n        grid: {\n          show: false\n        },\n        xaxis: {\n          tooltip: {\n            enabled: false\n          },\n          crosshairs: {\n            show: false\n          }\n        }\n      };\n    }\n  }, {\n    key: \"radialBar\",\n    value: function radialBar() {\n      return {\n        chart: {\n          animations: {\n            dynamicAnimation: {\n              enabled: true,\n              speed: 800\n            }\n          },\n          toolbar: {\n            show: false\n          }\n        },\n        fill: {\n          gradient: {\n            shade: 'dark',\n            shadeIntensity: 0.4,\n            inverseColors: false,\n            type: 'diagonal2',\n            opacityFrom: 1,\n            opacityTo: 1,\n            stops: [70, 98, 100]\n          }\n        },\n        padding: {\n          right: 0,\n          left: 0\n        },\n        legend: {\n          show: false,\n          position: 'right'\n        },\n        tooltip: {\n          enabled: false,\n          fillSeriesColor: true\n        }\n      };\n    }\n  }], [{\n    key: \"convertCatToNumeric\",\n    value: function convertCatToNumeric(opts) {\n      opts.xaxis.type = 'numeric';\n      opts.xaxis.convertedCatToNumeric = true;\n      opts.xaxis.labels = opts.xaxis.labels || {};\n\n      opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {\n        return val;\n      };\n\n      opts.chart = opts.chart || {};\n      opts.chart.zoom = opts.chart.zoom || window.Apex.chart && window.Apex.chart.zoom || {};\n      var defaultFormatter = opts.xaxis.labels.formatter;\n      var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;\n\n      if (labels && labels.length) {\n        opts.xaxis.labels.formatter = function (val) {\n          return defaultFormatter(labels[val - 1]);\n        };\n      }\n\n      opts.xaxis.categories = [];\n      opts.labels = [];\n      opts.chart.zoom.enabled = false;\n      return opts;\n    }\n  }]);\n\n  return Defaults;\n}();\n\n/*\n ** Util functions which are dependent on ApexCharts instance\n */\nvar CoreUtils =\n/*#__PURE__*/\nfunction () {\n  function CoreUtils(ctx) {\n    _classCallCheck(this, CoreUtils);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(CoreUtils, [{\n    key: \"getStackedSeriesTotals\",\n\n    /**\n     * @memberof CoreUtils\n     * returns the sum of all individual values in a multiple stacked series\n     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n     *  @return [34,36,48,13]\n     **/\n    value: function getStackedSeriesTotals() {\n      var w = this.w;\n      var total = [];\n\n      for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {\n        var t = 0;\n\n        for (var j = 0; j < w.globals.series.length; j++) {\n          t += w.globals.series[j][i];\n        }\n\n        total.push(t);\n      }\n\n      w.globals.stackedSeriesTotals = total;\n      return total;\n    } // get total of the all values inside all series\n\n  }, {\n    key: \"getSeriesTotalByIndex\",\n    value: function getSeriesTotalByIndex() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (index === null) {\n        // non-plot chart types - pie / donut / circle\n        return this.w.config.series.reduce(function (acc, cur) {\n          return acc + cur;\n        }, 0);\n      } else {\n        // axis charts - supporting multiple series\n        return this.w.globals.series[index].reduce(function (acc, cur) {\n          return acc + cur;\n        }, 0);\n      }\n    }\n  }, {\n    key: \"isSeriesNull\",\n    value: function isSeriesNull() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var r = [];\n\n      if (index === null) {\n        // non-plot chart types - pie / donut / circle\n        r = this.w.config.series.filter(function (d) {\n          return d !== null;\n        });\n      } else {\n        // axis charts - supporting multiple series\n        r = this.w.globals.series[index].filter(function (d) {\n          return d !== null;\n        });\n      }\n\n      return r.length === 0;\n    }\n  }, {\n    key: \"seriesHaveSameValues\",\n    value: function seriesHaveSameValues(index) {\n      return this.w.globals.series[index].every(function (val, i, arr) {\n        return val === arr[0];\n      });\n    } // maxValsInArrayIndex is the index of series[] which has the largest number of items\n\n  }, {\n    key: \"getLargestSeries\",\n    value: function getLargestSeries() {\n      var w = this.w;\n      w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {\n        return a.length;\n      }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {\n        return a.length;\n      })));\n    }\n  }, {\n    key: \"getLargestMarkerSize\",\n    value: function getLargestMarkerSize() {\n      var w = this.w;\n      var size = 0;\n      w.globals.markers.size.forEach(function (m) {\n        size = Math.max(size, m);\n      });\n      w.globals.markers.largestSize = size;\n      return size;\n    }\n    /**\n     * @memberof Core\n     * returns the sum of all values in a series\n     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]\n     *  @return [120, 11]\n     **/\n\n  }, {\n    key: \"getSeriesTotals\",\n    value: function getSeriesTotals() {\n      var w = this.w;\n      w.globals.seriesTotals = w.globals.series.map(function (ser, index) {\n        var total = 0;\n\n        if (Array.isArray(ser)) {\n          for (var j = 0; j < ser.length; j++) {\n            total += ser[j];\n          }\n        } else {\n          // for pie/donuts/gauges\n          total += ser;\n        }\n\n        return total;\n      });\n    }\n  }, {\n    key: \"getSeriesTotalsXRange\",\n    value: function getSeriesTotalsXRange(minX, maxX) {\n      var w = this.w;\n      var seriesTotalsXRange = w.globals.series.map(function (ser, index) {\n        var total = 0;\n\n        for (var j = 0; j < ser.length; j++) {\n          if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {\n            total += ser[j];\n          }\n        }\n\n        return total;\n      });\n      return seriesTotalsXRange;\n    }\n    /**\n     * @memberof CoreUtils\n     * returns the percentage value of all individual values which can be used in a 100% stacked series\n     * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]\n     *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]\n     **/\n\n  }, {\n    key: \"getPercentSeries\",\n    value: function getPercentSeries() {\n      var w = this.w;\n      w.globals.seriesPercent = w.globals.series.map(function (ser, index) {\n        var seriesPercent = [];\n\n        if (Array.isArray(ser)) {\n          for (var j = 0; j < ser.length; j++) {\n            var total = w.globals.stackedSeriesTotals[j];\n            var percent = 100 * ser[j] / total;\n            seriesPercent.push(percent);\n          }\n        } else {\n          var _total = w.globals.seriesTotals.reduce(function (acc, val) {\n            return acc + val;\n          }, 0);\n\n          var _percent = 100 * ser / _total;\n\n          seriesPercent.push(_percent);\n        }\n\n        return seriesPercent;\n      });\n    }\n  }, {\n    key: \"getCalculatedRatios\",\n    value: function getCalculatedRatios() {\n      var gl = this.w.globals;\n      var yRatio = [];\n      var invertedYRatio = 0;\n      var xRatio = 0;\n      var initialXRatio = 0;\n      var invertedXRatio = 0;\n      var zRatio = 0;\n      var baseLineY = [];\n      var baseLineInvertedY = 0.1;\n      var baseLineX = 0;\n      gl.yRange = [];\n\n      if (gl.isMultipleYAxis) {\n        for (var i = 0; i < gl.minYArr.length; i++) {\n          gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));\n          baseLineY.push(0);\n        }\n      } else {\n        gl.yRange.push(Math.abs(gl.minY - gl.maxY));\n      }\n\n      gl.xRange = Math.abs(gl.maxX - gl.minX);\n      gl.zRange = Math.abs(gl.maxZ - gl.minZ); // multiple y axis\n\n      for (var _i = 0; _i < gl.yRange.length; _i++) {\n        yRatio.push(gl.yRange[_i] / gl.gridHeight);\n      }\n\n      xRatio = gl.xRange / gl.gridWidth;\n      initialXRatio = Math.abs(gl.initialmaxX - gl.initialminX) / gl.gridWidth;\n      invertedYRatio = gl.yRange / gl.gridWidth;\n      invertedXRatio = gl.xRange / gl.gridHeight;\n      zRatio = gl.zRange / gl.gridHeight * 16;\n\n      if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {\n        // Negative numbers present in series\n        gl.hasNegs = true;\n        baseLineY = []; // baseline variables is the 0 of the yaxis which will be needed when there are negatives\n\n        if (gl.isMultipleYAxis) {\n          for (var _i2 = 0; _i2 < yRatio.length; _i2++) {\n            baseLineY.push(-gl.minYArr[_i2] / yRatio[_i2]);\n          }\n        } else {\n          baseLineY.push(-gl.minY / yRatio[0]);\n        }\n\n        baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart\n\n        baseLineX = gl.minX / xRatio;\n      } else {\n        baseLineY.push(0);\n      }\n\n      return {\n        yRatio: yRatio,\n        invertedYRatio: invertedYRatio,\n        zRatio: zRatio,\n        xRatio: xRatio,\n        initialXRatio: initialXRatio,\n        invertedXRatio: invertedXRatio,\n        baseLineInvertedY: baseLineInvertedY,\n        baseLineY: baseLineY,\n        baseLineX: baseLineX\n      };\n    }\n  }, {\n    key: \"getLogSeries\",\n    value: function getLogSeries(series) {\n      var w = this.w;\n      w.globals.seriesLog = series.map(function (s, i) {\n        if (w.config.yaxis[i] && w.config.yaxis[i].logarithmic) {\n          return s.map(function (d) {\n            if (d === null) return null;\n            var logVal = (Math.log(d) - Math.log(w.globals.minYArr[i])) / (Math.log(w.globals.maxYArr[i]) - Math.log(w.globals.minYArr[i]));\n            return logVal;\n          });\n        } else {\n          return s;\n        }\n      });\n      return w.globals.seriesLog;\n    }\n  }, {\n    key: \"getLogYRatios\",\n    value: function getLogYRatios(yRatio) {\n      var _this = this;\n\n      var w = this.w;\n      var gl = this.w.globals;\n      gl.yLogRatio = yRatio.slice();\n      gl.logYRange = gl.yRange.map(function (yRange, i) {\n        if (w.config.yaxis[i] && _this.w.config.yaxis[i].logarithmic) {\n          var maxY = -Number.MAX_VALUE;\n          var minY = Number.MIN_VALUE;\n          var range = 1;\n          gl.seriesLog.forEach(function (s, si) {\n            s.forEach(function (v) {\n              if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {\n                maxY = Math.max(v, maxY);\n                minY = Math.min(v, minY);\n              }\n            });\n          });\n          range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);\n          gl.yLogRatio[i] = range / gl.gridHeight;\n          return range;\n        }\n      });\n      return gl.yLogRatio;\n    } // Some config objects can be array - and we need to extend them correctly\n\n  }], [{\n    key: \"checkComboSeries\",\n    value: function checkComboSeries(series) {\n      var comboCharts = false;\n      var comboChartsHasBars = false; // if user specified a type in series too, turn on comboCharts flag\n\n      if (series.length && typeof series[0].type !== 'undefined') {\n        comboCharts = true;\n        series.forEach(function (s) {\n          if (s.type === 'bar' || s.type === 'column') {\n            comboChartsHasBars = true;\n          }\n        });\n      }\n\n      return {\n        comboCharts: comboCharts,\n        comboChartsHasBars: comboChartsHasBars\n      };\n    }\n  }, {\n    key: \"extendArrayProps\",\n    value: function extendArrayProps(configInstance, options) {\n      if (options.yaxis) {\n        options = configInstance.extendYAxis(options);\n      }\n\n      if (options.annotations) {\n        if (options.annotations.yaxis) {\n          options = configInstance.extendYAxisAnnotations(options);\n        }\n\n        if (options.annotations.xaxis) {\n          options = configInstance.extendXAxisAnnotations(options);\n        }\n\n        if (options.annotations.points) {\n          options = configInstance.extendPointAnnotations(options);\n        }\n      }\n\n      return options;\n    }\n  }]);\n\n  return CoreUtils;\n}();\n\n/**\n * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.\n *\n * @module Config\n **/\n\nvar Config =\n/*#__PURE__*/\nfunction () {\n  function Config(opts) {\n    _classCallCheck(this, Config);\n\n    this.opts = opts;\n  }\n\n  _createClass(Config, [{\n    key: \"init\",\n    value: function init() {\n      var opts = this.opts;\n      var options = new Options();\n      var defaults = new Defaults(opts);\n      this.chartType = opts.chart.type;\n\n      if (this.chartType === 'histogram') {\n        // technically, a histogram can be drawn by a column chart with no spaces in between\n        opts.chart.type = 'bar';\n        opts = Utils.extend({\n          plotOptions: {\n            bar: {\n              columnWidth: '99.99%'\n            }\n          }\n        }, opts);\n      }\n\n      opts.series = this.checkEmptySeries(opts.series);\n      opts = this.extendYAxis(opts);\n      opts = this.extendAnnotations(opts);\n      var config = options.init();\n      var newDefaults = {};\n\n      if (opts && _typeof(opts) === 'object') {\n        var chartDefaults = {};\n\n        switch (this.chartType) {\n          case 'line':\n            chartDefaults = defaults.line();\n            break;\n\n          case 'area':\n            chartDefaults = defaults.area();\n            break;\n\n          case 'bar':\n            chartDefaults = defaults.bar();\n            break;\n\n          case 'candlestick':\n            chartDefaults = defaults.candlestick();\n            break;\n\n          case 'histogram':\n            chartDefaults = defaults.bar();\n            break;\n\n          case 'bubble':\n            chartDefaults = defaults.bubble();\n            break;\n\n          case 'scatter':\n            chartDefaults = defaults.scatter();\n            break;\n\n          case 'heatmap':\n            chartDefaults = defaults.heatmap();\n            break;\n\n          case 'pie':\n            chartDefaults = defaults.pie();\n            break;\n\n          case 'donut':\n            chartDefaults = defaults.donut();\n            break;\n\n          case 'radar':\n            chartDefaults = defaults.radar();\n            break;\n\n          case 'radialBar':\n            chartDefaults = defaults.radialBar();\n            break;\n\n          default:\n            chartDefaults = defaults.line();\n        }\n\n        if (opts.chart.brush && opts.chart.brush.enabled) {\n          chartDefaults = defaults.brush(chartDefaults);\n        }\n\n        if (opts.chart.stacked && opts.chart.stackType === '100%') {\n          defaults.stacked100();\n        }\n\n        opts.xaxis = opts.xaxis || window.Apex.xaxis || {};\n        var combo = CoreUtils.checkComboSeries(opts.series);\n\n        if ((opts.chart.type === 'line' || opts.chart.type === 'area' || opts.chart.type === 'scatter') && !combo.comboChartsHasBars && opts.xaxis.type !== 'datetime' && opts.xaxis.tickPlacement !== 'between') {\n          opts = Defaults.convertCatToNumeric(opts);\n        }\n\n        if (opts.chart.sparkline && opts.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) {\n          chartDefaults = defaults.sparkline(chartDefaults);\n        }\n\n        newDefaults = Utils.extend(config, chartDefaults);\n      } // config should cascade in this fashion\n      // default-config < global-apex-variable-config < user-defined-config\n      // get GLOBALLY defined options and merge with the default config\n\n\n      var mergedWithDefaultConfig = Utils.extend(newDefaults, window.Apex); // get the merged config and extend with user defined config\n\n      config = Utils.extend(mergedWithDefaultConfig, opts); // some features are not supported. those mismatches should be handled\n\n      config = this.handleUserInputErrors(config);\n      return config;\n    }\n  }, {\n    key: \"extendYAxis\",\n    value: function extendYAxis(opts) {\n      var options = new Options();\n\n      if (typeof opts.yaxis === 'undefined') {\n        opts.yaxis = {};\n      } // extend global yaxis config (only if object is provided / not an array)\n\n\n      if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {\n        opts.yaxis = Utils.extend(opts.yaxis, window.Apex.yaxis);\n      } // as we can't extend nested object's array with extend, we need to do it first\n      // user can provide either an array or object in yaxis config\n\n\n      if (opts.yaxis.constructor !== Array) {\n        // convert the yaxis to array if user supplied object\n        opts.yaxis = [Utils.extend(options.yAxis, opts.yaxis)];\n      } else {\n        opts.yaxis = Utils.extendArray(opts.yaxis, options.yAxis);\n      }\n\n      return opts;\n    } // annotations also accepts array, so we need to extend them manually\n\n  }, {\n    key: \"extendAnnotations\",\n    value: function extendAnnotations(opts) {\n      if (typeof opts.annotations === 'undefined') {\n        opts.annotations = {};\n        opts.annotations.yaxis = [];\n        opts.annotations.xaxis = [];\n        opts.annotations.points = [];\n      }\n\n      opts = this.extendYAxisAnnotations(opts);\n      opts = this.extendXAxisAnnotations(opts);\n      opts = this.extendPointAnnotations(opts);\n      return opts;\n    }\n  }, {\n    key: \"extendYAxisAnnotations\",\n    value: function extendYAxisAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.yaxis = Utils.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"extendXAxisAnnotations\",\n    value: function extendXAxisAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.xaxis = Utils.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"extendPointAnnotations\",\n    value: function extendPointAnnotations(opts) {\n      var options = new Options();\n      opts.annotations.points = Utils.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);\n      return opts;\n    }\n  }, {\n    key: \"checkEmptySeries\",\n    value: function checkEmptySeries(ser) {\n      if (ser.length === 0) {\n        return [{\n          data: []\n        }];\n      }\n\n      return ser;\n    }\n  }, {\n    key: \"handleUserInputErrors\",\n    value: function handleUserInputErrors(opts) {\n      var config = opts; // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it\n\n      if (config.tooltip.shared && config.tooltip.intersect) {\n        throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');\n      }\n\n      if (config.chart.scroller) {\n        console.warn('Scroller has been deprecated since v2.0.0. Please remove the configuration for chart.scroller');\n      }\n\n      if (config.chart.type === 'bar' && config.plotOptions.bar.horizontal) {\n        // No time series for horizontal bars\n        if (config.xaxis.type === 'datetime') {\n          throw new Error('Timelines on bars are not supported yet. Switch to column chart by setting plotOptions.bar.horizontal=false');\n        } // No multiple yaxis for bars\n\n\n        if (config.yaxis.length > 1) {\n          throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');\n        }\n\n        if (config.yaxis[0].reversed) {\n          config.yaxis[0].opposite = true;\n        }\n\n        config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n        config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar\n\n        config.chart.zoom.enabled = false; // no zooming for horz bars\n      }\n\n      if (config.chart.type === 'bar') {\n        if (config.tooltip.shared) {\n          if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {\n            console.warn('crosshairs.width = \"barWidth\" is only supported in single series, not in a multi-series barChart.');\n            config.xaxis.crosshairs.width = 'tickWidth';\n          }\n\n          if (config.plotOptions.bar.horizontal) {\n            config.states.hover.type = 'none';\n          }\n\n          if (!config.tooltip.followCursor) {\n            console.warn('followCursor option in shared columns cannot be turned off.');\n            config.tooltip.followCursor = true;\n          }\n        }\n      }\n\n      if (config.chart.type === 'candlestick') {\n        if (config.yaxis[0].reversed) {\n          console.warn('Reversed y-axis in candlestick chart is not supported.');\n          config.yaxis[0].reversed = false;\n        }\n      }\n\n      if (config.chart.group && config.yaxis[0].labels.minWidth === 0) {\n        console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.');\n      } // if user supplied array for stroke width, it will only be applicable to line/area charts, for any other charts, revert back to Number\n\n\n      if (Array.isArray(config.stroke.width)) {\n        if (config.chart.type !== 'line' && config.chart.type !== 'area') {\n          console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number');\n          config.stroke.width = config.stroke.width[0];\n        }\n      }\n\n      return config;\n    }\n  }]);\n\n  return Config;\n}();\n\nvar Globals =\n/*#__PURE__*/\nfunction () {\n  function Globals() {\n    _classCallCheck(this, Globals);\n  }\n\n  _createClass(Globals, [{\n    key: \"globalVars\",\n    value: function globalVars(config) {\n      return {\n        chartID: null,\n        // chart ID - apexcharts-cuid\n        cuid: null,\n        // chart ID - random numbers excluding \"apexcharts\" part\n        events: {\n          beforeMount: [],\n          mounted: [],\n          updated: [],\n          clicked: [],\n          selection: [],\n          dataPointSelection: [],\n          zoomed: [],\n          scrolled: []\n        },\n        colors: [],\n        fill: {\n          colors: []\n        },\n        stroke: {\n          colors: []\n        },\n        dataLabels: {\n          style: {\n            colors: []\n          }\n        },\n        radarPolygons: {\n          fill: {\n            colors: []\n          }\n        },\n        markers: {\n          colors: [],\n          size: config.markers.size,\n          largestSize: 0\n        },\n        animationEnded: false,\n        isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,\n        isDirty: false,\n        // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update\n        initialConfig: null,\n        // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it\n        lastXAxis: [],\n        lastYAxis: [],\n        series: [],\n        // the MAIN series array (y values)\n        seriesPercent: [],\n        // the percentage values of the given series\n        seriesTotals: [],\n        stackedSeriesTotals: [],\n        seriesX: [],\n        // store the numeric x values in this array (x values)\n        seriesZ: [],\n        // The 3rd \"Z\" dimension for bubbles chart (z values)\n        labels: [],\n        // store the text to draw on x axis\n        // Don't mutate the labels, many things including tooltips depends on it!\n        timelineLabels: [],\n        // store the timeline Labels in another variable\n        seriesNames: [],\n        // same as labels, used in non axis charts\n        noLabelsProvided: false,\n        // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...\n        allSeriesCollapsed: false,\n        collapsedSeries: [],\n        // when user collapses a series, it goes into this array\n        collapsedSeriesIndices: [],\n        // this stores the index of the collapsedSeries instead of whole object for quick access\n        ancillaryCollapsedSeries: [],\n        // when user collapses an \"alwaysVisible\" series, it goes into this array\n        ancillaryCollapsedSeriesIndices: [],\n        // this stores the index of the collapsedSeries whose y-axis is always visible\n        risingSeries: [],\n        // when user re-opens a collapsed series, it goes here\n        selectedDataPoints: [],\n        ignoreYAxisIndexes: [],\n        // when series are being collapsed in multiple y axes, ignore certain index\n        padHorizontal: 0,\n        maxValsInArrayIndex: 0,\n        zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,\n        panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,\n        selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,\n        yaxis: null,\n        minY: Number.MIN_VALUE,\n        //  is 5e-324, i.e. the smallest positive number\n        // NOTE: If there are multiple y axis, the first yaxis array element will be considered for all y values calculations. Rest all will be calculated based on that\n        maxY: -Number.MAX_VALUE,\n        // is -1.7976931348623157e+308\n        // NOTE: The above note for minY applies here as well\n        minYArr: [],\n        maxYArr: [],\n        maxX: -Number.MAX_VALUE,\n        // is -1.7976931348623157e+308\n        initialmaxX: -Number.MAX_VALUE,\n        minX: Number.MIN_VALUE,\n        //  is 5e-324, i.e. the smallest positive number\n        initialminX: Number.MIN_VALUE,\n        minZ: Number.MIN_VALUE,\n        // Max Z value in charts with Z axis\n        maxZ: -Number.MAX_VALUE,\n        // Max Z value in charts with Z axis\n        mousedown: false,\n        lastClientPosition: {},\n        // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning\n        visibleXRange: undefined,\n        yRange: [],\n        // this property is the absolute sum of positive and negative values [eg (-100 + 200 = 300)] - yAxis\n        zRange: 0,\n        // zAxis Range (for bubble charts)\n        xRange: 0,\n        // xAxis range\n        yValueDecimal: 0,\n        // are there floating numbers in the series. If yes, this represent the len of the decimals\n        total: 0,\n        SVGNS: 'http://www.w3.org/2000/svg',\n        // svg namespace\n        svgWidth: 0,\n        // the whole svg width\n        svgHeight: 0,\n        // the whole svg height\n        noData: false,\n        // whether there is any data to display or not\n        locale: {},\n        // the current locale values will be preserved here for global access\n        dom: {},\n        // for storing all dom nodes in this particular property\n        // elWrap: null, // the element that wraps everything\n        // elGraphical: null, // this contains lines/areas/bars/pies\n        // elGridRect: null, // paths going outside this area will be clipped\n        // elGridRectMask: null, // clipping will happen with this mask\n        // elGridRectMarkerMask: null, // clipping will happen with this mask\n        // elLegendWrap: null, // the whole legend area\n        // elDefs: null, // [defs] element\n        memory: {\n          methodsToExec: []\n        },\n        shouldAnimate: true,\n        delayedElements: [],\n        // element which appear after animation has finished\n        axisCharts: true,\n        // chart type = line or area or bar\n        // (refer them also as plot charts in the code)\n        isXNumeric: false,\n        // bool: data was provided in a {[x,y], [x,y]} pattern\n        isDataXYZ: false,\n        // bool: data was provided in a {[x,y,z]} pattern\n        resized: false,\n        // bool: user has resized\n        resizeTimer: null,\n        // timeout function to make a small delay before\n        // drawing when user resized\n        comboCharts: false,\n        // bool: whether it's a combination of line/column\n        comboChartsHasBars: false,\n        // bool: whether it's a combination of line/column\n        dataChanged: false,\n        // bool: has data changed dynamically\n        previousPaths: [],\n        // array: when data is changed, it will animate from\n        // previous paths\n        seriesXvalues: [],\n        // we will need this in tooltip (it's x position)\n        // when we will have unequal x values, we will need\n        // some way to get x value depending on mouse pointer\n        seriesYvalues: [],\n        // we will need this when deciding which series\n        // user hovered on\n        seriesCandleO: [],\n        // candle stick open values\n        seriesCandleH: [],\n        // candle stick high values\n        seriesCandleL: [],\n        // candle stick low values\n        seriesCandleC: [],\n        // candle stick close values\n        allSeriesHasEqualX: true,\n        dataPoints: 0,\n        // the longest series length\n        pointsArray: [],\n        // store the points positions here to draw later on hover\n        // format is - [[x,y],[x,y]... [x,y]]\n        dataLabelsRects: [],\n        // store the positions of datalabels to prevent collision\n        lastDrawnDataLabelsIndexes: [],\n        hasNullValues: false,\n        // bool: whether series contains null values\n        easing: null,\n        // function: animation effect to apply\n        zoomed: false,\n        // whether user has zoomed or not\n        gridWidth: 0,\n        // drawable width of actual graphs (series paths)\n        gridHeight: 0,\n        // drawable height of actual graphs (series paths)\n        yAxisScale: [],\n        xAxisScale: null,\n        xAxisTicksPositions: [],\n        timescaleTicks: [],\n        rotateXLabels: false,\n        defaultLabels: false,\n        xLabelFormatter: undefined,\n        // formatter for x axis labels\n        yLabelFormatters: [],\n        xaxisTooltipFormatter: undefined,\n        // formatter for x axis tooltip\n        ttKeyFormatter: undefined,\n        ttVal: undefined,\n        ttZFormatter: undefined,\n        LINE_HEIGHT_RATIO: 1.618,\n        xAxisLabelsHeight: 0,\n        yAxisLabelsWidth: 0,\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0,\n        translateYAxisX: [],\n        yLabelsCoords: [],\n        yTitleCoords: [],\n        yAxisWidths: [],\n        translateXAxisY: 0,\n        translateXAxisX: 0,\n        tooltip: null,\n        tooltipOpts: null\n      };\n    }\n  }, {\n    key: \"init\",\n    value: function init(config) {\n      var globals = this.globalVars(config);\n      globals.initialConfig = Utils.extend({}, config);\n      globals.initialSeries = JSON.parse(JSON.stringify(globals.initialConfig.series));\n      globals.lastXAxis = JSON.parse(JSON.stringify(globals.initialConfig.xaxis));\n      globals.lastYAxis = JSON.parse(JSON.stringify(globals.initialConfig.yaxis));\n      return globals;\n    }\n  }]);\n\n  return Globals;\n}();\n\n/**\n * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.\n *\n * @module Base\n **/\n\nvar Base =\n/*#__PURE__*/\nfunction () {\n  function Base(opts) {\n    _classCallCheck(this, Base);\n\n    this.opts = opts;\n  }\n\n  _createClass(Base, [{\n    key: \"init\",\n    value: function init() {\n      var config = new Config(this.opts).init();\n      var globals = new Globals().init(config);\n      var w = {\n        config: config,\n        globals: globals\n      };\n      return w;\n    }\n  }]);\n\n  return Base;\n}();\n\n/**\n * ApexCharts Fill Class for setting fill options of the paths.\n *\n * @module Fill\n **/\n\nvar Fill =\n/*#__PURE__*/\nfunction () {\n  function Fill(ctx) {\n    _classCallCheck(this, Fill);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.opts = null;\n    this.seriesIndex = 0;\n  }\n\n  _createClass(Fill, [{\n    key: \"clippedImgArea\",\n    value: function clippedImgArea(params) {\n      var w = this.w;\n      var cnf = w.config;\n      var svgW = parseInt(w.globals.gridWidth);\n      var svgH = parseInt(w.globals.gridHeight);\n      var size = svgW > svgH ? svgW : svgH;\n      var fillImg = params.image;\n      var imgWidth = 0;\n      var imgHeight = 0;\n\n      if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {\n        if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {\n          imgWidth = cnf.fill.image.width + 1;\n          imgHeight = cnf.fill.image.height;\n        } else {\n          imgWidth = size + 1;\n          imgHeight = size;\n        }\n      } else {\n        imgWidth = params.width;\n        imgHeight = params.height;\n      }\n\n      var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');\n      Graphics.setAttrs(elPattern, {\n        id: params.patternID,\n        patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',\n        width: imgWidth + 'px',\n        height: imgHeight + 'px'\n      });\n      var elImage = document.createElementNS(w.globals.SVGNS, 'image');\n      elPattern.appendChild(elImage);\n      elImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', fillImg);\n      Graphics.setAttrs(elImage, {\n        x: 0,\n        y: 0,\n        preserveAspectRatio: 'none',\n        width: imgWidth + 'px',\n        height: imgHeight + 'px'\n      });\n      elImage.style.opacity = params.opacity;\n      w.globals.dom.elDefs.node.appendChild(elPattern);\n    }\n  }, {\n    key: \"getSeriesIndex\",\n    value: function getSeriesIndex(opts) {\n      var w = this.w;\n\n      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap') {\n        this.seriesIndex = opts.seriesNumber;\n      } else {\n        this.seriesIndex = opts.seriesNumber % w.globals.series.length;\n      }\n\n      return this.seriesIndex;\n    }\n  }, {\n    key: \"fillPath\",\n    value: function fillPath(opts) {\n      var w = this.w;\n      this.opts = opts;\n      var cnf = this.w.config;\n      var pathFill;\n      var patternFill, gradientFill;\n      this.seriesIndex = this.getSeriesIndex(opts);\n      var fillColors = this.getFillColors();\n      var fillColor = fillColors[this.seriesIndex];\n      var fillType = this.getFillType(this.seriesIndex);\n      var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;\n      var defaultColor = fillColor;\n\n      if (opts.color) {\n        fillColor = opts.color;\n      }\n\n      if (fillColor.indexOf('rgb') === -1) {\n        defaultColor = Utils.hexToRgba(fillColor, fillOpacity);\n      } else {\n        if (fillColor.indexOf('rgba') > -1) {\n          fillOpacity = 0 + '.' + Utils.getOpacityFromRGBA(fillColors[this.seriesIndex]);\n        }\n      }\n\n      if (fillType === 'pattern') {\n        patternFill = this.handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor);\n      }\n\n      if (fillType === 'gradient') {\n        gradientFill = this.handleGradientFill(gradientFill, fillColor, fillOpacity, this.seriesIndex);\n      }\n\n      if (cnf.fill.image.src.length > 0 && fillType === 'image') {\n        if (opts.seriesNumber < cnf.fill.image.src.length) {\n          this.clippedImgArea({\n            opacity: fillOpacity,\n            image: cnf.fill.image.src[opts.seriesNumber],\n            patternUnits: opts.patternUnits,\n            patternID: \"pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1)\n          });\n          pathFill = \"url(#pattern\".concat(w.globals.cuid).concat(opts.seriesNumber + 1, \")\");\n        } else {\n          pathFill = defaultColor;\n        }\n      } else if (fillType === 'gradient') {\n        pathFill = gradientFill;\n      } else if (fillType === 'pattern') {\n        pathFill = patternFill;\n      } else {\n        pathFill = defaultColor;\n      } // override pattern/gradient if opts.solid is true\n\n\n      if (opts.solid) {\n        pathFill = defaultColor;\n      }\n\n      return pathFill;\n    }\n  }, {\n    key: \"getFillType\",\n    value: function getFillType(seriesIndex) {\n      var w = this.w;\n\n      if (Array.isArray(w.config.fill.type)) {\n        return w.config.fill.type[seriesIndex];\n      } else {\n        return w.config.fill.type;\n      }\n    }\n  }, {\n    key: \"getFillColors\",\n    value: function getFillColors() {\n      var w = this.w;\n      var cnf = w.config;\n      var opts = this.opts;\n      var fillColors = [];\n\n      if (w.globals.comboCharts) {\n        if (w.config.series[this.seriesIndex].type === 'line') {\n          if (w.globals.stroke.colors instanceof Array) {\n            fillColors = w.globals.stroke.colors;\n          } else {\n            fillColors.push(w.globals.stroke.colors);\n          }\n        } else {\n          if (w.globals.fill.colors instanceof Array) {\n            fillColors = w.globals.fill.colors;\n          } else {\n            fillColors.push(w.globals.fill.colors);\n          }\n        }\n      } else {\n        if (cnf.chart.type === 'line') {\n          if (w.globals.stroke.colors instanceof Array) {\n            fillColors = w.globals.stroke.colors;\n          } else {\n            fillColors.push(w.globals.stroke.colors);\n          }\n        } else {\n          if (w.globals.fill.colors instanceof Array) {\n            fillColors = w.globals.fill.colors;\n          } else {\n            fillColors.push(w.globals.fill.colors);\n          }\n        }\n      } // colors passed in arguments\n\n\n      if (typeof opts.fillColors !== 'undefined') {\n        fillColors = [];\n\n        if (opts.fillColors instanceof Array) {\n          fillColors = opts.fillColors.slice();\n        } else {\n          fillColors.push(opts.fillColors);\n        }\n      }\n\n      return fillColors;\n    }\n  }, {\n    key: \"handlePatternFill\",\n    value: function handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor) {\n      var cnf = this.w.config;\n      var opts = this.opts;\n      var graphics = new Graphics(this.ctx);\n      var patternStrokeWidth = cnf.fill.pattern.strokeWidth === undefined ? Array.isArray(cnf.stroke.width) ? cnf.stroke.width[this.seriesIndex] : cnf.stroke.width : Array.isArray(cnf.fill.pattern.strokeWidth) ? cnf.fill.pattern.strokeWidth[this.seriesIndex] : cnf.fill.pattern.strokeWidth;\n      var patternLineColor = fillColor;\n\n      if (cnf.fill.pattern.style instanceof Array) {\n        if (typeof cnf.fill.pattern.style[opts.seriesNumber] !== 'undefined') {\n          var pf = graphics.drawPattern(cnf.fill.pattern.style[opts.seriesNumber], cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n          patternFill = pf;\n        } else {\n          patternFill = defaultColor;\n        }\n      } else {\n        patternFill = graphics.drawPattern(cnf.fill.pattern.style, cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);\n      }\n\n      return patternFill;\n    }\n  }, {\n    key: \"handleGradientFill\",\n    value: function handleGradientFill(gradientFill, fillColor, fillOpacity, i) {\n      var cnf = this.w.config;\n      var opts = this.opts;\n      var graphics = new Graphics(this.ctx);\n      var utils = new Utils();\n      var type = cnf.fill.gradient.type;\n      var gradientFrom, gradientTo;\n      var opacityFrom = cnf.fill.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityFrom) ? cnf.fill.gradient.opacityFrom[i] : cnf.fill.gradient.opacityFrom;\n      var opacityTo = cnf.fill.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityTo) ? cnf.fill.gradient.opacityTo[i] : cnf.fill.gradient.opacityTo;\n      gradientFrom = fillColor;\n\n      if (cnf.fill.gradient.gradientToColors === undefined || cnf.fill.gradient.gradientToColors.length === 0) {\n        if (cnf.fill.gradient.shade === 'dark') {\n          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity) * -1, fillColor);\n        } else {\n          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity), fillColor);\n        }\n      } else {\n        gradientTo = cnf.fill.gradient.gradientToColors[opts.seriesNumber];\n      }\n\n      if (cnf.fill.gradient.inverseColors) {\n        var t = gradientFrom;\n        gradientFrom = gradientTo;\n        gradientTo = t;\n      }\n\n      gradientFill = graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, cnf.fill.gradient.stops, cnf.fill.gradient.colorStops, i);\n      return gradientFill;\n    }\n  }]);\n\n  return Fill;\n}();\n\n/**\n * ApexCharts Markers Class for drawing points on y values in axes charts.\n *\n * @module Markers\n **/\n\nvar Markers =\n/*#__PURE__*/\nfunction () {\n  function Markers(ctx, opts) {\n    _classCallCheck(this, Markers);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Markers, [{\n    key: \"setGlobalMarkerSize\",\n    value: function setGlobalMarkerSize() {\n      var w = this.w;\n      w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];\n\n      if (w.globals.markers.size.length > 0) {\n        if (w.globals.markers.size.length < w.globals.series.length + 1) {\n          for (var i = 0; i <= w.globals.series.length; i++) {\n            if (typeof w.globals.markers.size[i] === 'undefined') {\n              w.globals.markers.size.push(w.globals.markers.size[0]);\n            }\n          }\n        }\n      } else {\n        w.globals.markers.size = w.config.series.map(function (s) {\n          return w.config.markers.size;\n        });\n      }\n    }\n  }, {\n    key: \"plotChartMarkers\",\n    value: function plotChartMarkers(pointsPos, seriesIndex, j) {\n      var _this = this;\n\n      var w = this.w;\n      var p = pointsPos;\n      var elPointsWrap = null;\n      var graphics = new Graphics(this.ctx);\n      var point;\n\n      if (w.globals.markers.size[seriesIndex] > 0) {\n        elPointsWrap = graphics.group({\n          class: 'apexcharts-series-markers'\n        });\n        elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n      }\n\n      if (p.x instanceof Array) {\n        var _loop = function _loop(q) {\n          var dataPointIndex = j; // a small hack as we have 2 points for the first val to connect it\n\n          if (j === 1 && q === 0) dataPointIndex = 0;\n          if (j === 1 && q === 1) dataPointIndex = 1;\n          var PointClasses = 'apexcharts-marker';\n\n          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n            PointClasses += ' no-pointer-events';\n          }\n\n          var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;\n\n          if (shouldMarkerDraw) {\n            if (Utils.isNumber(p.y[q])) {\n              PointClasses += \" w\".concat((Math.random() + 1).toString(36).substring(4));\n            } else {\n              PointClasses = 'apexcharts-nullpoint';\n            }\n\n            var opts = _this.getMarkerConfig(PointClasses, seriesIndex); // discrete markers is an option where user can specify a particular marker with different size and color\n\n\n            w.config.markers.discrete.map(function (marker) {\n              if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {\n                opts.pointStrokeColor = marker.strokeColor;\n                opts.pointFillColor = marker.fillColor;\n                opts.pSize = marker.size;\n              }\n            });\n            point = graphics.drawMarker(p.x[q], p.y[q], opts);\n            point.attr('rel', dataPointIndex);\n            point.attr('j', dataPointIndex);\n            point.attr('index', seriesIndex);\n            point.node.setAttribute('default-marker-size', opts.pSize);\n            var filters = new Filters(_this.ctx);\n            filters.setSelectionFilter(point, seriesIndex, dataPointIndex);\n\n            _this.addEvents(point);\n\n            if (elPointsWrap) {\n              elPointsWrap.add(point);\n            }\n          } else {\n            // dynamic array creation - multidimensional\n            if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];\n            w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);\n          }\n        };\n\n        for (var q = 0; q < p.x.length; q++) {\n          _loop(q);\n        }\n      }\n\n      return elPointsWrap;\n    }\n  }, {\n    key: \"getMarkerConfig\",\n    value: function getMarkerConfig(cssClass, seriesIndex) {\n      var w = this.w;\n      var pStyle = this.getMarkerStyle(seriesIndex);\n      var pSize = w.globals.markers.size[seriesIndex];\n      return {\n        pSize: pSize,\n        pRadius: w.config.markers.radius,\n        pWidth: w.config.markers.strokeWidth,\n        pointStrokeColor: pStyle.pointStrokeColor,\n        pointFillColor: pStyle.pointFillColor,\n        shape: w.config.markers.shape instanceof Array ? w.config.markers.shape[seriesIndex] : w.config.markers.shape,\n        class: cssClass,\n        pointStrokeOpacity: w.config.markers.strokeOpacity,\n        pointFillOpacity: w.config.markers.fillOpacity,\n        seriesIndex: seriesIndex\n      };\n    }\n  }, {\n    key: \"addEvents\",\n    value: function addEvents(circle) {\n      var graphics = new Graphics(this.ctx);\n      circle.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, circle));\n      circle.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, circle));\n      circle.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, circle));\n      circle.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, circle), {\n        passive: true\n      });\n    }\n  }, {\n    key: \"getMarkerStyle\",\n    value: function getMarkerStyle(seriesIndex) {\n      var w = this.w;\n      var colors = w.globals.markers.colors;\n      var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;\n      var pointStrokeColor = strokeColors instanceof Array ? strokeColors[seriesIndex] : strokeColors;\n      var pointFillColor = colors instanceof Array ? colors[seriesIndex] : colors;\n      return {\n        pointStrokeColor: pointStrokeColor,\n        pointFillColor: pointFillColor\n      };\n    }\n  }]);\n\n  return Markers;\n}();\n\n/**\n * ApexCharts Scatter Class.\n * This Class also handles bubbles chart as currently there is no major difference in drawing them,\n * @module Scatter\n **/\n\nvar Scatter =\n/*#__PURE__*/\nfunction () {\n  function Scatter(ctx) {\n    _classCallCheck(this, Scatter);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; // this array will help in centering the label in bubbles\n\n    this.radiusSizes = [];\n  }\n\n  _createClass(Scatter, [{\n    key: \"draw\",\n    value: function draw(elSeries, j, opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var realIndex = opts.realIndex;\n      var pointsPos = opts.pointsPos;\n      var zRatio = opts.zRatio;\n      var elPointsMain = opts.elParent;\n      var elPointsWrap = graphics.group({\n        class: \"apexcharts-series-markers apexcharts-series-\".concat(w.config.chart.type)\n      });\n      elPointsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n\n      if (pointsPos.x instanceof Array) {\n        for (var q = 0; q < pointsPos.x.length; q++) {\n          var dataPointIndex = j + 1;\n          var shouldDraw = true; // a small hack as we have 2 points for the first val to connect it\n\n          if (j === 0 && q === 0) dataPointIndex = 0;\n          if (j === 0 && q === 1) dataPointIndex = 1;\n          var radius = 0;\n          var finishRadius = w.globals.markers.size[realIndex];\n\n          if (zRatio !== Infinity) {\n            // means we have a bubble\n            finishRadius = w.globals.seriesZ[realIndex][dataPointIndex] / zRatio;\n\n            if (typeof this.radiusSizes[realIndex] === 'undefined') {\n              this.radiusSizes.push([]);\n            }\n\n            this.radiusSizes[realIndex].push(finishRadius);\n          }\n\n          if (!w.config.chart.animations.enabled) {\n            radius = finishRadius;\n          }\n\n          var x = pointsPos.x[q];\n          var y = pointsPos.y[q];\n          radius = radius || 0;\n\n          if (x === 0 && y === 0 || y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {\n            shouldDraw = false;\n          }\n\n          if (shouldDraw) {\n            var circle = this.drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j);\n            elPointsWrap.add(circle);\n          }\n\n          elPointsMain.add(elPointsWrap);\n        }\n      }\n    }\n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j) {\n      var w = this.w;\n      var anim = new Animations(this.ctx);\n      var filters = new Filters(this.ctx);\n      var fill = new Fill(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var pathFillCircle = fill.fillPath({\n        seriesNumber: realIndex,\n        patternUnits: 'objectBoundingBox'\n      });\n      var circle = graphics.drawCircle(radius);\n      circle.attr({\n        cx: x,\n        cy: y,\n        fill: pathFillCircle\n      });\n\n      if (w.config.chart.dropShadow.enabled) {\n        filters.dropShadow(circle, {\n          top: w.config.chart.dropShadow.top,\n          left: w.config.chart.dropShadow.left,\n          blur: w.config.chart.dropShadow.blur,\n          color: w.config.chart.dropShadow.color,\n          opacity: w.config.chart.dropShadow.opacity\n        });\n      }\n\n      if (this.initialAnim && !w.globals.dataChanged) {\n        var speed = 1;\n\n        if (!w.globals.resized) {\n          speed = w.config.chart.animations.speed;\n        }\n\n        anim.animateCircleRadius(circle, 0, finishRadius, speed, w.globals.easing);\n      }\n\n      if (w.globals.dataChanged) {\n        if (this.dynamicAnim) {\n          var _speed = w.config.chart.animations.dynamicAnimation.speed;\n          var prevX, prevY, prevR;\n          var prevPathJ = null;\n          prevPathJ = w.globals.previousPaths[realIndex] && w.globals.previousPaths[realIndex][j];\n\n          if (typeof prevPathJ !== 'undefined' && prevPathJ !== null) {\n            // series containing less elements will ignore these values and revert to 0\n            prevX = prevPathJ.x;\n            prevY = prevPathJ.y;\n            prevR = typeof prevPathJ.r !== 'undefined' ? prevPathJ.r : finishRadius;\n          }\n\n          for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {\n            if (w.globals.collapsedSeries[cs].index === realIndex) {\n              _speed = 1;\n              finishRadius = 0;\n            }\n          }\n\n          if (x === 0 && y === 0) finishRadius = 0;\n          anim.animateCircle(circle, {\n            cx: prevX,\n            cy: prevY,\n            r: prevR\n          }, {\n            cx: x,\n            cy: y,\n            r: finishRadius\n          }, _speed, w.globals.easing);\n        } else {\n          circle.attr({\n            r: finishRadius\n          });\n        }\n      }\n\n      circle.attr({\n        rel: dataPointIndex,\n        j: dataPointIndex,\n        index: realIndex,\n        'default-marker-size': finishRadius\n      });\n      var markers = new Markers(this.ctx);\n      filters.setSelectionFilter(circle, realIndex, dataPointIndex);\n      markers.addEvents(circle);\n      circle.node.classList.add('apexcharts-marker');\n      return circle;\n    }\n  }, {\n    key: \"centerTextInBubble\",\n    value: function centerTextInBubble(y) {\n      var w = this.w;\n      y = y + parseInt(w.config.dataLabels.style.fontSize) / 4;\n      return {\n        y: y\n      };\n    }\n  }]);\n\n  return Scatter;\n}();\n\n/**\n * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.\n *\n * @module DataLabels\n **/\n\nvar DataLabels =\n/*#__PURE__*/\nfunction () {\n  function DataLabels(ctx) {\n    _classCallCheck(this, DataLabels);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that\n  // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again\n\n\n  _createClass(DataLabels, [{\n    key: \"dataLabelsCorrection\",\n    value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var drawnextLabel = false; //\n\n      var textRects = graphics.getTextRects(val, fontSize);\n      var width = textRects.width;\n      var height = textRects.height; // first value in series, so push an empty array\n\n      if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = []; // then start pushing actual rects in that sub-array\n\n      w.globals.dataLabelsRects[i].push({\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n      var len = w.globals.dataLabelsRects[i].length - 2;\n      var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;\n\n      if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {\n        var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];\n\n        if ( // next label forward and x not intersecting\n        x > lastDataLabelRect.x + lastDataLabelRect.width + 2 || y > lastDataLabelRect.y + lastDataLabelRect.height + 2 || x + width < lastDataLabelRect.x // next label is going to be drawn backwards\n        ) {\n            // the 2 indexes don't override, so OK to draw next label\n            drawnextLabel = true;\n          }\n      }\n\n      if (dataPointIndex === 0 || alwaysDrawDataLabel) {\n        drawnextLabel = true;\n      }\n\n      return {\n        x: x,\n        y: y,\n        drawnextLabel: drawnextLabel\n      };\n    }\n  }, {\n    key: \"drawDataLabel\",\n    value: function drawDataLabel(pos, i, j) {\n      // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions\n      // all other charts like bars / heatmaps will define their own drawDataLabel routine\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var dataLabelsConfig = w.config.dataLabels;\n      var x = 0;\n      var y = 0;\n      var dataPointIndex = j;\n      var elDataLabelsWrap = null;\n\n      if (!dataLabelsConfig.enabled || pos.x instanceof Array !== true) {\n        return elDataLabelsWrap;\n      }\n\n      elDataLabelsWrap = graphics.group({\n        class: 'apexcharts-data-labels'\n      });\n      elDataLabelsWrap.attr('clip-path', \"url(#gridRectMarkerMask\".concat(w.globals.cuid, \")\"));\n\n      for (var q = 0; q < pos.x.length; q++) {\n        x = pos.x[q] + dataLabelsConfig.offsetX;\n        y = pos.y[q] + dataLabelsConfig.offsetY - w.globals.markers.size[i] - 5;\n\n        if (!isNaN(x)) {\n          // a small hack as we have 2 points for the first val to connect it\n          if (j === 1 && q === 0) dataPointIndex = 0;\n          if (j === 1 && q === 1) dataPointIndex = 1;\n          var val = w.globals.series[i][dataPointIndex];\n          var text = '';\n\n          if (w.config.chart.type === 'bubble') {\n            text = w.globals.seriesZ[i][dataPointIndex];\n            y = pos.y[q] + w.config.dataLabels.offsetY;\n            var scatter = new Scatter(this.ctx);\n            var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);\n            y = centerTextInBubbleCoords.y;\n          } else {\n            if (typeof val !== 'undefined') {\n              text = w.config.dataLabels.formatter(val, {\n                seriesIndex: i,\n                dataPointIndex: dataPointIndex,\n                w: w\n              });\n            }\n          }\n\n          this.plotDataLabelsText({\n            x: x,\n            y: y,\n            text: text,\n            i: i,\n            j: dataPointIndex,\n            parent: elDataLabelsWrap,\n            offsetCorrection: true,\n            dataLabelsConfig: w.config.dataLabels\n          });\n        }\n      }\n\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"plotDataLabelsText\",\n    value: function plotDataLabelsText(opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var x = opts.x,\n          y = opts.y,\n          i = opts.i,\n          j = opts.j,\n          text = opts.text,\n          textAnchor = opts.textAnchor,\n          parent = opts.parent,\n          dataLabelsConfig = opts.dataLabelsConfig,\n          alwaysDrawDataLabel = opts.alwaysDrawDataLabel,\n          offsetCorrection = opts.offsetCorrection;\n\n      if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {\n        if (w.config.dataLabels.enabledOnSeries.indexOf(i) > -1) {\n          return;\n        }\n      }\n\n      var correctedLabels = {\n        x: x,\n        y: y,\n        drawnextLabel: true\n      };\n\n      if (offsetCorrection) {\n        correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize));\n      } // when zoomed, we don't need to correct labels offsets,\n      // but if normally, labels get cropped, correct them\n\n\n      if (!w.globals.zoomed) {\n        x = correctedLabels.x;\n        y = correctedLabels.y;\n      }\n\n      if (correctedLabels.drawnextLabel) {\n        var dataLabelText = graphics.drawText({\n          width: 100,\n          height: parseInt(dataLabelsConfig.style.fontSize),\n          x: x,\n          y: y,\n          foreColor: w.globals.dataLabels.style.colors[i],\n          textAnchor: textAnchor || dataLabelsConfig.textAnchor,\n          text: text,\n          fontSize: dataLabelsConfig.style.fontSize,\n          fontFamily: dataLabelsConfig.style.fontFamily\n        });\n        dataLabelText.attr({\n          class: 'apexcharts-datalabel',\n          cx: x,\n          cy: y\n        });\n\n        if (dataLabelsConfig.dropShadow.enabled) {\n          var textShadow = dataLabelsConfig.dropShadow;\n          var filters = new Filters(this.ctx);\n          filters.dropShadow(dataLabelText, textShadow);\n        }\n\n        parent.add(dataLabelText);\n\n        if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {\n          w.globals.lastDrawnDataLabelsIndexes[i] = [];\n        }\n\n        w.globals.lastDrawnDataLabelsIndexes[i].push(j);\n      }\n    }\n  }]);\n\n  return DataLabels;\n}();\n\n/**\n * ApexCharts Bar Class responsible for drawing both Columns and Bars.\n *\n * @module Bar\n **/\n\nvar DATA_LABELS_WARNING_THRESHOLD = 50;\n\nvar Bar =\n/*#__PURE__*/\nfunction () {\n  function Bar(ctx, xyRatios) {\n    _classCallCheck(this, Bar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.barOptions = w.config.plotOptions.bar;\n    this.isHorizontal = this.barOptions.horizontal;\n    this.strokeWidth = w.config.stroke.width;\n    this.isNullValue = false;\n    this.xyRatios = xyRatios;\n\n    if (this.xyRatios !== null) {\n      this.xRatio = xyRatios.xRatio;\n      this.yRatio = xyRatios.yRatio;\n      this.invertedXRatio = xyRatios.invertedXRatio;\n      this.invertedYRatio = xyRatios.invertedYRatio;\n      this.baseLineY = xyRatios.baseLineY;\n      this.baseLineInvertedY = xyRatios.baseLineInvertedY;\n    }\n\n    this.minXDiff = Number.MAX_VALUE;\n    this.yaxisIndex = 0;\n    this.seriesLen = 0;\n  }\n  /** primary draw method which is called on bar object\n   * @memberof Bar\n   * @param {array} series - user supplied series values\n   * @param {int} seriesIndex - the index by which series will be drawn on the svg\n   * @return {node} element which is supplied to parent chart draw method for appending\n   **/\n\n\n  _createClass(Bar, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var _this = this;\n\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var coreUtils = new CoreUtils(this.ctx, w);\n      this.series = coreUtils.getLogSeries(series);\n      series = this.series;\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.initVariables(series);\n      var ret = graphics.group({\n        class: 'apexcharts-bar-series apexcharts-plot-series'\n      });\n      ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n\n      if (w.config.dataLabels.enabled) {\n        if (this.totalItems > DATA_LABELS_WARNING_THRESHOLD) {\n          console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.');\n        }\n      }\n\n      var _loop = function _loop(i, bc) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var x = void 0,\n            y = void 0,\n            xDivision = void 0,\n            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n        yDivision = void 0,\n            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n        zeroH = void 0,\n            // zeroH is the baseline where 0 meets y axis\n        zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n\n        _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n\n        if (series[i].length > 0) {\n          _this.visibleI = _this.visibleI + 1;\n        }\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        if (_this.yRatio.length > 1) {\n          _this.yaxisIndex = realIndex;\n        }\n\n        _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed;\n\n        var initPositions = _this.initialPositions();\n\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        yDivision = initPositions.yDivision;\n        zeroW = initPositions.zeroW;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n\n        if (!_this.horizontal) {\n          xArrj.push(x + barWidth / 2);\n        } // eldatalabels\n\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        var _loop2 = function _loop2(j, tj) {\n          if (typeof _this.series[i][j] === 'undefined' || series[i][j] === null) {\n            _this.isNullValue = true;\n          } else {\n            _this.isNullValue = false;\n          }\n\n          if (w.config.stroke.show) {\n            if (_this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(_this.strokeWidth) ? _this.strokeWidth[realIndex] : _this.strokeWidth;\n            }\n          }\n\n          var paths = null;\n\n          if (_this.isHorizontal) {\n            paths = _this.drawBarPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              barHeight: barHeight,\n              strokeWidth: strokeWidth,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              zeroW: zeroW,\n              x: x,\n              y: y,\n              yDivision: yDivision,\n              elSeries: elSeries\n            });\n          } else {\n            paths = _this.drawColumnPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              xDivision: xDivision,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              barWidth: barWidth,\n              zeroH: zeroH,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            });\n          }\n\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x; // push current X\n\n          if (j > 0) {\n            xArrj.push(x + barWidth / 2);\n          }\n\n          yArrj.push(y);\n          var seriesNumber = _this.barOptions.distributed ? j : i;\n          var fillColor = null;\n\n          if (_this.barOptions.colors.ranges.length > 0) {\n            var colorRange = _this.barOptions.colors.ranges;\n            colorRange.map(function (range) {\n              if (series[i][j] >= range.from && series[i][j] <= range.to) {\n                fillColor = range.color;\n              }\n            });\n          }\n\n          var pathFill = fill.fillPath({\n            seriesNumber: _this.barOptions.distributed ? seriesNumber : realIndex,\n            color: fillColor\n          });\n          elSeries = _this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            visibleSeries: _this.visibleI,\n            type: 'bar'\n          });\n        };\n\n        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {\n          _loop2(j, tj);\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj;\n        ret.add(elSeries);\n      };\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        _loop(i, bc);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"renderSeries\",\n    value: function renderSeries(_ref) {\n      var realIndex = _ref.realIndex,\n          pathFill = _ref.pathFill,\n          lineFill = _ref.lineFill,\n          j = _ref.j,\n          i = _ref.i,\n          pathFrom = _ref.pathFrom,\n          pathTo = _ref.pathTo,\n          strokeWidth = _ref.strokeWidth,\n          elSeries = _ref.elSeries,\n          x = _ref.x,\n          y = _ref.y,\n          series = _ref.series,\n          barHeight = _ref.barHeight,\n          barWidth = _ref.barWidth,\n          elDataLabelsWrap = _ref.elDataLabelsWrap,\n          visibleSeries = _ref.visibleSeries,\n          type = _ref.type;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n\n      if (!lineFill) {\n        /* fix apexcharts#341 */\n        lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : w.globals.stroke.colors[realIndex];\n      }\n\n      if (this.isNullValue) {\n        pathFill = 'none';\n      }\n\n      var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;\n      var renderedPath = graphics.renderPaths({\n        i: i,\n        j: j,\n        realIndex: realIndex,\n        pathFrom: pathFrom,\n        pathTo: pathTo,\n        stroke: lineFill,\n        strokeWidth: strokeWidth,\n        strokeLineCap: w.config.stroke.lineCap,\n        fill: pathFill,\n        animationDelay: delay,\n        initialSpeed: w.config.chart.animations.speed,\n        dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n        className: \"apexcharts-\".concat(type, \"-area\"),\n        id: \"apexcharts-\".concat(type, \"-area\")\n      });\n      var filters = new Filters(this.ctx);\n      filters.setSelectionFilter(renderedPath, realIndex, j);\n      elSeries.add(renderedPath);\n      var dataLabels = this.calculateDataLabelsPos({\n        x: x,\n        y: y,\n        i: i,\n        j: j,\n        series: series,\n        realIndex: realIndex,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        renderedPath: renderedPath,\n        visibleSeries: visibleSeries\n      });\n\n      if (dataLabels !== null) {\n        elDataLabelsWrap.add(dataLabels);\n      }\n\n      elSeries.add(elDataLabelsWrap);\n      return elSeries;\n    }\n  }, {\n    key: \"initVariables\",\n    value: function initVariables(series) {\n      var _this2 = this;\n\n      var w = this.w;\n      this.series = series;\n      this.totalItems = 0;\n      this.seriesLen = 0;\n      this.visibleI = -1;\n      this.visibleItems = 1; // number of visible bars after user zoomed in/out\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length > 0) {\n          this.seriesLen = this.seriesLen + 1;\n          this.totalItems += series[sl].length;\n        }\n\n        if (w.globals.isXNumeric) {\n          // get the least x diff if numeric x axis is present\n          w.globals.seriesX.forEach(function (sX, i) {\n            sX.forEach(function (s, j) {\n              if (j > 0) {\n                var xDiff = s - w.globals.seriesX[i][j - 1];\n                _this2.minXDiff = Math.min(xDiff, _this2.minXDiff);\n              }\n            });\n          }); // get max visible items\n\n          for (var j = 0; j < series[sl].length; j++) {\n            if (w.globals.seriesX[sl][j] > w.globals.minX && w.globals.seriesX[sl][j] < w.globals.maxX) {\n              this.visibleItems++;\n            }\n          }\n        } else {\n          this.visibleItems = w.globals.dataPoints;\n        }\n      }\n\n      if (this.seriesLen === 0) {\n        // A small adjustment when combo charts are used\n        this.seriesLen = 1;\n      }\n    }\n  }, {\n    key: \"initialPositions\",\n    value: function initialPositions() {\n      var w = this.w;\n      var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;\n\n      if (this.isHorizontal) {\n        // height divided into equal parts\n        yDivision = w.globals.gridHeight / w.globals.dataPoints;\n        barHeight = yDivision / this.seriesLen;\n\n        if (w.globals.isXNumeric) {\n          yDivision = w.globals.gridHeight / this.totalItems;\n          barHeight = yDivision / this.seriesLen;\n        }\n\n        barHeight = barHeight * parseInt(this.barOptions.barHeight) / 100;\n        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0);\n        y = (yDivision - barHeight * this.seriesLen) / 2;\n      } else {\n        // width divided into equal parts\n        xDivision = w.globals.gridWidth / this.visibleItems;\n        barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;\n\n        if (w.globals.isXNumeric) {\n          // max barwidth should be equal to minXDiff to avoid overlap\n          if (this.minXDiff === Number.MAX_VALUE) {\n            // possibly a single dataPoint (fixes react-apexcharts/issue#34)\n            var len = w.globals.labels.length;\n\n            if (w.globals.timelineLabels.length > 0) {\n              len = w.globals.timelineLabels.length;\n            }\n\n            if (len < 3) {\n              len = 3;\n            }\n\n            this.minXDiff = (w.globals.maxX - w.globals.minX) / len;\n          }\n\n          xDivision = this.minXDiff / this.xRatio;\n          barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;\n        }\n\n        zeroH = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0);\n        x = w.globals.padHorizontal + (xDivision - barWidth * this.seriesLen) / 2;\n      }\n\n      return {\n        x: x,\n        y: y,\n        yDivision: yDivision,\n        xDivision: xDivision,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        zeroH: zeroH,\n        zeroW: zeroW\n      };\n    }\n  }, {\n    key: \"drawBarPaths\",\n    value: function drawBarPaths(_ref2) {\n      var indexes = _ref2.indexes,\n          barHeight = _ref2.barHeight,\n          strokeWidth = _ref2.strokeWidth,\n          pathTo = _ref2.pathTo,\n          pathFrom = _ref2.pathFrom,\n          zeroW = _ref2.zeroW,\n          x = _ref2.x,\n          y = _ref2.y,\n          yDivision = _ref2.yDivision,\n          elSeries = _ref2.elSeries;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;\n      }\n\n      var barYPosition = y + barHeight * this.visibleI;\n      pathTo = graphics.move(zeroW, barYPosition);\n      pathFrom = graphics.move(zeroW, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        x = zeroW;\n      } else {\n        x = zeroW + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;\n      }\n\n      pathTo = pathTo + graphics.line(x, barYPosition) + graphics.line(x, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);\n      pathFrom = pathFrom + graphics.line(zeroW, barYPosition) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);\n\n      if (!w.globals.isXNumeric) {\n        y = y + yDivision;\n      }\n\n      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= this.barOptions.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = this.barOptions.colors.backgroundBarColors[bc];\n        var rect = graphics.drawRect(0, barYPosition - barHeight * this.visibleI, w.globals.gridWidth, barHeight * this.seriesLen, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y,\n        barYPosition: barYPosition\n      };\n    }\n  }, {\n    key: \"drawColumnPaths\",\n    value: function drawColumnPaths(_ref3) {\n      var indexes = _ref3.indexes,\n          x = _ref3.x,\n          y = _ref3.y,\n          xDivision = _ref3.xDivision,\n          pathTo = _ref3.pathTo,\n          pathFrom = _ref3.pathFrom,\n          barWidth = _ref3.barWidth,\n          zeroH = _ref3.zeroH,\n          strokeWidth = _ref3.strokeWidth,\n          elSeries = _ref3.elSeries;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x + barWidth * this.visibleI;\n      pathTo = graphics.move(barXPosition, zeroH);\n      pathFrom = graphics.move(barXPosition, zeroH);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        y = zeroH;\n      } else {\n        y = zeroH - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;\n      }\n\n      pathTo = pathTo + graphics.line(barXPosition, y) + graphics.line(barXPosition + barWidth - strokeWidth, y) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition, zeroH);\n      pathFrom = pathFrom + graphics.line(barXPosition, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition, zeroH);\n\n      if (!w.globals.isXNumeric) {\n        x = x + xDivision;\n      }\n\n      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= this.barOptions.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = this.barOptions.colors.backgroundBarColors[bc];\n        var rect = graphics.drawRect(barXPosition - barWidth * this.visibleI, 0, barWidth * this.seriesLen, w.globals.gridHeight, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y,\n        barXPosition: barXPosition\n      };\n    }\n    /** getPathFrom is a common function for bars/columns which is used to get previous paths when data changes.\n     * @memberof Bar\n     * @param {int} realIndex - current iterating i\n     * @param {int} j - current iterating series's j index\n     * @return {string} pathFrom is the string which will be appended in animations\n     **/\n\n  }, {\n    key: \"getPathFrom\",\n    value: function getPathFrom(realIndex, j) {\n      var w = this.w;\n      var pathFrom;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {\n            pathFrom = w.globals.previousPaths[pp].paths[j].d;\n          }\n        }\n      }\n\n      return pathFrom;\n    }\n    /** calculateBarDataLabels is used to calculate the positions for the data-labels\n     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()\n     * @memberof Bar\n     * @param {object} {barProps} most of the bar properties used throughout the bar\n     * drawing function\n     * @return {object} dataLabels node-element which you can append later\n     **/\n\n  }, {\n    key: \"calculateDataLabelsPos\",\n    value: function calculateDataLabelsPos(_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          i = _ref4.i,\n          j = _ref4.j,\n          realIndex = _ref4.realIndex,\n          series = _ref4.series,\n          barHeight = _ref4.barHeight,\n          barWidth = _ref4.barWidth,\n          visibleSeries = _ref4.visibleSeries,\n          renderedPath = _ref4.renderedPath;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n      var bcx = x + parseFloat(barWidth * visibleSeries);\n      var bcy = y + parseFloat(barHeight * visibleSeries);\n\n      if (w.globals.isXNumeric) {\n        bcx = x + parseFloat(barWidth * (visibleSeries + 1)) - strokeWidth;\n        bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;\n      }\n\n      var dataLabels = null;\n      var dataLabelsX = x;\n      var dataLabelsY = y;\n      var dataLabelsPos = {};\n      var dataLabelsConfig = w.config.dataLabels;\n      var barDataLabelsConfig = this.barOptions.dataLabels;\n      var offX = dataLabelsConfig.offsetX;\n      var offY = dataLabelsConfig.offsetY;\n      var textRects = {\n        width: 0,\n        height: 0\n      };\n\n      if (w.config.dataLabels.enabled) {\n        textRects = graphics.getTextRects(w.globals.yLabelFormatters[0](w.globals.maxY), parseInt(dataLabelsConfig.style.fontSize));\n      }\n\n      if (this.isHorizontal) {\n        dataLabelsPos = this.calculateBarsDataLabelsPosition({\n          x: x,\n          y: y,\n          i: i,\n          j: j,\n          renderedPath: renderedPath,\n          bcy: bcy,\n          barHeight: barHeight,\n          textRects: textRects,\n          strokeWidth: strokeWidth,\n          dataLabelsX: dataLabelsX,\n          dataLabelsY: dataLabelsY,\n          barDataLabelsConfig: barDataLabelsConfig,\n          offX: offX,\n          offY: offY\n        });\n      } else {\n        dataLabelsPos = this.calculateColumnsDataLabelsPosition({\n          x: x,\n          y: y,\n          i: i,\n          j: j,\n          renderedPath: renderedPath,\n          realIndex: realIndex,\n          bcx: bcx,\n          bcy: bcy,\n          barHeight: barHeight,\n          barWidth: barWidth,\n          textRects: textRects,\n          strokeWidth: strokeWidth,\n          dataLabelsY: dataLabelsY,\n          barDataLabelsConfig: barDataLabelsConfig,\n          offX: offX,\n          offY: offY\n        });\n      }\n\n      renderedPath.attr({\n        cy: dataLabelsPos.bcy,\n        cx: dataLabelsPos.bcx,\n        j: j,\n        val: series[i][j],\n        barHeight: barHeight,\n        barWidth: barWidth\n      });\n      dataLabels = this.drawCalculatedDataLabels({\n        x: dataLabelsPos.dataLabelsX,\n        y: dataLabelsPos.dataLabelsY,\n        val: series[i][j],\n        i: realIndex,\n        j: j,\n        dataLabelsConfig: dataLabelsConfig\n      });\n      return dataLabels;\n    }\n  }, {\n    key: \"calculateColumnsDataLabelsPosition\",\n    value: function calculateColumnsDataLabelsPosition(opts) {\n      var w = this.w;\n      var i = opts.i,\n          j = opts.j,\n          realIndex = opts.realIndex,\n          y = opts.y,\n          bcx = opts.bcx,\n          barWidth = opts.barWidth,\n          textRects = opts.textRects,\n          dataLabelsY = opts.dataLabelsY,\n          barDataLabelsConfig = opts.barDataLabelsConfig,\n          strokeWidth = opts.strokeWidth,\n          offX = opts.offX,\n          offY = opts.offY;\n      var dataLabelsX;\n      var barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];\n      var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n      bcx = bcx - strokeWidth / 2;\n\n      if (w.globals.isXNumeric) {\n        dataLabelsX = bcx - barWidth / 2 + offX;\n      } else {\n        dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;\n      }\n\n      var valIsNegative = this.series[i][j] <= 0;\n\n      if (w.config.yaxis[this.yaxisIndex].reversed) {\n        y = y - barHeight;\n      }\n\n      switch (barDataLabelsConfig.position) {\n        case 'center':\n          if (valIsNegative) {\n            dataLabelsY = y + barHeight / 2 + textRects.height / 2 + offY;\n          } else {\n            dataLabelsY = y + barHeight / 2 + textRects.height / 2 - offY;\n          }\n\n          break;\n\n        case 'bottom':\n          if (valIsNegative) {\n            dataLabelsY = y + barHeight + textRects.height + strokeWidth + offY;\n          } else {\n            dataLabelsY = y + barHeight - textRects.height / 2 + strokeWidth - offY;\n          }\n\n          break;\n\n        case 'top':\n          if (valIsNegative) {\n            dataLabelsY = y - textRects.height / 2 - offY;\n          } else {\n            dataLabelsY = y + textRects.height + offY;\n          }\n\n          break;\n      }\n\n      return {\n        bcx: bcx,\n        bcy: y,\n        dataLabelsX: dataLabelsX,\n        dataLabelsY: dataLabelsY\n      };\n    }\n  }, {\n    key: \"calculateBarsDataLabelsPosition\",\n    value: function calculateBarsDataLabelsPosition(opts) {\n      var w = this.w;\n      var x = opts.x,\n          i = opts.i,\n          j = opts.j,\n          bcy = opts.bcy,\n          barHeight = opts.barHeight,\n          textRects = opts.textRects,\n          dataLabelsX = opts.dataLabelsX,\n          strokeWidth = opts.strokeWidth,\n          barDataLabelsConfig = opts.barDataLabelsConfig,\n          offX = opts.offX,\n          offY = opts.offY;\n      var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n      var dataLabelsY = bcy - dataPointsDividedHeight + barHeight / 2 + textRects.height / 2 + offY - 3;\n      var barWidth = this.series[i][j] / this.invertedYRatio;\n      var valIsNegative = this.series[i][j] <= 0;\n\n      if (w.config.yaxis[this.yaxisIndex].reversed) {\n        x = x + barWidth;\n      }\n\n      switch (barDataLabelsConfig.position) {\n        case 'center':\n          if (valIsNegative) {\n            dataLabelsX = x - barWidth / 2 - offX;\n          } else {\n            dataLabelsX = x - barWidth / 2 + offX;\n          }\n\n          break;\n\n        case 'bottom':\n          if (valIsNegative) {\n            dataLabelsX = x - barWidth - strokeWidth - Math.round(textRects.width / 2) - offX;\n          } else {\n            dataLabelsX = x - barWidth + strokeWidth + Math.round(textRects.width / 2) + offX;\n          }\n\n          break;\n\n        case 'top':\n          if (valIsNegative) {\n            dataLabelsX = x - strokeWidth + Math.round(textRects.width / 2) - offX;\n          } else {\n            dataLabelsX = x - strokeWidth - Math.round(textRects.width / 2) + offX;\n          }\n\n          break;\n      }\n\n      if (dataLabelsX < 0) {\n        dataLabelsX = textRects.width + strokeWidth;\n      } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {\n        dataLabelsX = dataLabelsX - textRects.width - strokeWidth;\n      }\n\n      return {\n        bcx: x,\n        bcy: bcy,\n        dataLabelsX: dataLabelsX,\n        dataLabelsY: dataLabelsY\n      };\n    }\n  }, {\n    key: \"drawCalculatedDataLabels\",\n    value: function drawCalculatedDataLabels(_ref5) {\n      var x = _ref5.x,\n          y = _ref5.y,\n          val = _ref5.val,\n          i = _ref5.i,\n          j = _ref5.j,\n          dataLabelsConfig = _ref5.dataLabelsConfig;\n      var w = this.w;\n      var dataLabels = new DataLabels(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var formatter = dataLabelsConfig.formatter;\n      var elDataLabelsWrap = null;\n      var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;\n\n      if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {\n        elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-data-labels'\n        });\n        var text = '';\n\n        if (typeof val !== 'undefined' && val !== null) {\n          text = formatter(val, {\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        }\n\n        dataLabels.plotDataLabelsText({\n          x: x,\n          y: y,\n          text: text,\n          i: i,\n          j: j,\n          parent: elDataLabelsWrap,\n          dataLabelsConfig: dataLabelsConfig,\n          alwaysDrawDataLabel: true,\n          offsetCorrection: true\n        });\n      }\n\n      return elDataLabelsWrap;\n    }\n  }]);\n\n  return Bar;\n}();\n\n/**\n * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.\n *\n * @module BarStacked\n * The whole calculation for stacked bar/column is different from normal bar/column,\n * hence it makes sense to derive a new class for it extending most of the props of Parent Bar\n **/\n\nvar BarStacked =\n/*#__PURE__*/\nfunction (_Bar) {\n  _inherits(BarStacked, _Bar);\n\n  function BarStacked() {\n    _classCallCheck(this, BarStacked);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BarStacked).apply(this, arguments));\n  }\n\n  _createClass(BarStacked, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var _this = this;\n\n      var w = this.w;\n      this.graphics = new Graphics(this.ctx);\n      this.fill = new Fill(this.ctx);\n      this.bar = new Bar(this.ctx, this.xyRatios);\n      var coreUtils = new CoreUtils(this.ctx, w);\n      this.series = coreUtils.getLogSeries(series);\n      series = this.series;\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.series = series;\n      this.initVariables(series);\n\n      if (w.config.chart.stackType === '100%') {\n        this.series = w.globals.seriesPercent.slice();\n        series = this.series;\n      }\n\n      this.totalItems = 0;\n      this.prevY = []; // y position on chart\n\n      this.prevX = []; // x position on chart\n\n      this.prevYF = []; // y position including shapes on chart\n\n      this.prevXF = []; // x position including shapes on chart\n\n      this.prevYVal = []; // y values (series[i][j]) in columns\n\n      this.prevXVal = []; // x values (series[i][j]) in bars\n\n      this.xArrj = []; // xj indicates x position on graph in bars\n\n      this.xArrjF = []; // xjF indicates bar's x position + endingshape's positions in bars\n\n      this.xArrjVal = []; // x val means the actual series's y values in horizontal/bars\n\n      this.yArrj = []; // yj indicates y position on graph in columns\n\n      this.yArrjF = []; // yjF indicates bar's y position + endingshape's positions in columns\n\n      this.yArrjVal = []; // y val means the actual series's y values in columns\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length > 0) {\n          this.totalItems += series[sl].length;\n        }\n      }\n\n      var ret = this.graphics.group({\n        class: 'apexcharts-bar-series apexcharts-plot-series'\n      });\n      ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n      var x = 0;\n      var y = 0;\n\n      var _loop = function _loop(i, bc) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n\n        var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)\n\n        var zeroH = void 0; // zeroH is the baseline where 0 meets y axis\n\n        var zeroW = void 0; // zeroW is the baseline where 0 meets x axis\n\n        var xArrValues = [];\n        var yArrValues = [];\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n        if (_this.yRatio.length > 1) {\n          _this.yaxisIndex = realIndex;\n        }\n\n        _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed; // el to which series will be drawn\n\n        var elSeries = _this.graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        }); // eldatalabels\n\n\n        var elDataLabelsWrap = _this.graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        var initPositions = _this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW);\n\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        yDivision = initPositions.yDivision;\n        zeroW = initPositions.zeroW;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n        _this.yArrj = [];\n        _this.yArrjF = [];\n        _this.yArrjVal = [];\n        _this.xArrj = [];\n        _this.xArrjF = [];\n        _this.xArrjVal = []; // if (!this.horizontal) {\n        // this.xArrj.push(x + barWidth / 2)\n        // }\n\n        var _loop2 = function _loop2(j) {\n          if (w.config.stroke.show) {\n            if (_this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(_this.strokeWidth) ? _this.strokeWidth[realIndex] : _this.strokeWidth;\n            }\n          }\n\n          var paths = null;\n\n          if (_this.isHorizontal) {\n            paths = _this.drawBarPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              barHeight: barHeight,\n              strokeWidth: strokeWidth,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              zeroW: zeroW,\n              x: x,\n              y: y,\n              yDivision: yDivision,\n              elSeries: elSeries\n            });\n          } else {\n            paths = _this.drawColumnPaths({\n              indexes: {\n                i: i,\n                j: j,\n                realIndex: realIndex,\n                bc: bc\n              },\n              x: x,\n              y: y,\n              xDivision: xDivision,\n              pathTo: pathTo,\n              pathFrom: pathFrom,\n              barWidth: barWidth,\n              zeroH: zeroH,\n              strokeWidth: strokeWidth,\n              elSeries: elSeries\n            });\n          }\n\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x;\n          xArrValues.push(x);\n          yArrValues.push(y);\n          var seriesNumber = w.config.plotOptions.bar.distributed ? j : i;\n          var fillColor = null;\n\n          if (_this.barOptions.colors.ranges.length > 0) {\n            var colorRange = _this.barOptions.colors.ranges;\n            colorRange.map(function (range, index) {\n              if (series[i][j] >= range.from && series[i][j] <= range.to) {\n                fillColor = range.color;\n              }\n            });\n          }\n\n          var pathFill = _this.fill.fillPath({\n            seriesNumber: _this.barOptions.distributed ? seriesNumber : realIndex,\n            color: fillColor\n          });\n\n          elSeries = _this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            type: 'bar',\n            visibleSeries: 0\n          });\n        };\n\n        for (var j = 0; j < w.globals.dataPoints; j++) {\n          _loop2(j);\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrValues;\n        w.globals.seriesYvalues[realIndex] = yArrValues; // push all current y values array to main PrevY Array\n\n        _this.prevY.push(_this.yArrj);\n\n        _this.prevYF.push(_this.yArrjF);\n\n        _this.prevYVal.push(_this.yArrjVal);\n\n        _this.prevX.push(_this.xArrj);\n\n        _this.prevXF.push(_this.xArrjF);\n\n        _this.prevXVal.push(_this.xArrjVal);\n\n        ret.add(elSeries);\n      };\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        _loop(i, bc);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"initialPositions\",\n    value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW) {\n      var w = this.w;\n      var barHeight, barWidth;\n\n      if (this.isHorizontal) {\n        // height divided into equal parts\n        yDivision = w.globals.gridHeight / w.globals.dataPoints;\n        barHeight = yDivision;\n        barHeight = barHeight * parseInt(w.config.plotOptions.bar.barHeight) / 100;\n        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0); // initial y position is half of barHeight * half of number of Bars\n\n        y = (yDivision - barHeight) / 2;\n      } else {\n        // width divided into equal parts\n        xDivision = w.globals.gridWidth / w.globals.dataPoints;\n        barWidth = xDivision;\n\n        if (w.globals.isXNumeric) {\n          // max barwidth should be equal to minXDiff to avoid overlap\n          xDivision = this.minXDiff / this.xRatio;\n          barWidth = xDivision * parseInt(this.barOptions.columnWidth) / 100;\n        } else {\n          barWidth = barWidth * parseInt(w.config.plotOptions.bar.columnWidth) / 100;\n        }\n\n        zeroH = this.baseLineY[this.yaxisIndex] + (this.isReversed ? w.globals.gridHeight : 0) - (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0); // initial x position is one third of barWidth\n\n        x = w.globals.padHorizontal + (xDivision - barWidth) / 2;\n      }\n\n      return {\n        x: x,\n        y: y,\n        yDivision: yDivision,\n        xDivision: xDivision,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        zeroH: zeroH,\n        zeroW: zeroW\n      };\n    }\n  }, {\n    key: \"drawBarPaths\",\n    value: function drawBarPaths(_ref) {\n      var indexes = _ref.indexes,\n          barHeight = _ref.barHeight,\n          strokeWidth = _ref.strokeWidth,\n          pathTo = _ref.pathTo,\n          pathFrom = _ref.pathFrom,\n          zeroW = _ref.zeroW,\n          x = _ref.x,\n          y = _ref.y,\n          yDivision = _ref.yDivision,\n          elSeries = _ref.elSeries;\n      var w = this.w;\n      var barYPosition = y;\n      var barXPosition;\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n      var prevBarW = 0;\n\n      for (var k = 0; k < this.prevXF.length; k++) {\n        prevBarW = prevBarW + this.prevXF[k][j];\n      }\n\n      if (i > 0) {\n        var bXP = zeroW;\n\n        if (this.prevXVal[i - 1][j] < 0) {\n          if (this.series[i][j] >= 0) {\n            bXP = this.prevX[i - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2;\n          } else {\n            bXP = this.prevX[i - 1][j];\n          }\n        } else if (this.prevXVal[i - 1][j] >= 0) {\n          if (this.series[i][j] >= 0) {\n            bXP = this.prevX[i - 1][j];\n          } else {\n            bXP = this.prevX[i - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;\n          }\n        }\n\n        barXPosition = bXP;\n      } else {\n        // the first series will not have prevX values\n        barXPosition = zeroW;\n      }\n\n      if (this.series[i][j] === null) {\n        x = barXPosition;\n      } else {\n        x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;\n      }\n\n      this.xArrj.push(x);\n      this.xArrjF.push(Math.abs(barXPosition - x));\n      this.xArrjVal.push(this.series[i][j]);\n      pathTo = this.graphics.move(barXPosition, barYPosition);\n      pathFrom = this.graphics.move(barXPosition, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.bar.getPathFrom(realIndex, j, false);\n      }\n\n      pathTo = pathTo + this.graphics.line(x, barYPosition) + this.graphics.line(x, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);\n      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);\n\n      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];\n        var rect = this.graphics.drawRect(0, barYPosition, w.globals.gridWidth, barHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      y = y + yDivision;\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"drawColumnPaths\",\n    value: function drawColumnPaths(_ref2) {\n      var indexes = _ref2.indexes,\n          x = _ref2.x,\n          y = _ref2.y,\n          xDivision = _ref2.xDivision,\n          pathTo = _ref2.pathTo,\n          pathFrom = _ref2.pathFrom,\n          barWidth = _ref2.barWidth,\n          zeroH = _ref2.zeroH,\n          strokeWidth = _ref2.strokeWidth,\n          elSeries = _ref2.elSeries;\n      var w = this.w;\n      var i = indexes.i;\n      var j = indexes.j;\n      var realIndex = indexes.realIndex;\n      var bc = indexes.bc;\n\n      if (w.globals.isXNumeric) {\n        var seriesVal = w.globals.seriesX[i][j];\n        if (!seriesVal) seriesVal = 0;\n        x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x;\n      var barYPosition;\n      var prevBarH = 0;\n\n      for (var k = 0; k < this.prevYF.length; k++) {\n        prevBarH = prevBarH + this.prevYF[k][j];\n      }\n\n      if (i > 0 && !w.globals.isXNumeric || i > 0 && w.globals.isXNumeric && w.globals.seriesX[i - 1][j] === w.globals.seriesX[i][j]) {\n        var bYP;\n        var prevYValue = this.prevY[i - 1][j];\n\n        if (this.prevYVal[i - 1][j] < 0) {\n          if (this.series[i][j] >= 0) {\n            bYP = prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2;\n          } else {\n            bYP = prevYValue;\n          }\n        } else {\n          if (this.series[i][j] >= 0) {\n            bYP = prevYValue;\n          } else {\n            bYP = prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2;\n          }\n        }\n\n        barYPosition = bYP;\n      } else {\n        // the first series will not have prevY values, also if the prev index's series X doesn't matches the current index's series X, then start from zero\n        barYPosition = w.globals.gridHeight - zeroH;\n      }\n\n      y = barYPosition - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;\n      this.yArrj.push(y);\n      this.yArrjF.push(Math.abs(barYPosition - y));\n      this.yArrjVal.push(this.series[i][j]);\n      pathTo = this.graphics.move(barXPosition, barYPosition);\n      pathFrom = this.graphics.move(barXPosition, barYPosition);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.bar.getPathFrom(realIndex, j, false);\n      }\n\n      pathTo = pathTo + this.graphics.line(barXPosition, y) + this.graphics.line(barXPosition + barWidth - strokeWidth, y) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition, barYPosition);\n      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition, barYPosition);\n\n      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {\n        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {\n          bc = 0;\n        }\n\n        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];\n        var rect = this.graphics.drawRect(barXPosition, 0, barWidth, w.globals.gridHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);\n        elSeries.add(rect);\n        rect.node.classList.add('apexcharts-backgroundBar');\n      }\n\n      x = x + xDivision;\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: w.globals.isXNumeric ? x - xDivision : x,\n        y: y\n      };\n    }\n  }]);\n\n  return BarStacked;\n}(Bar);\n\n/**\n * ApexCharts CandleStick Class responsible for drawing both Stacked Columns and Bars.\n *\n * @module CandleStick\n * The whole calculation for stacked bar/column is different from normal bar/column,\n * hence it makes sense to derive a new class for it extending most of the props of Parent Bar\n **/\n\nvar CandleStick =\n/*#__PURE__*/\nfunction (_Bar) {\n  _inherits(CandleStick, _Bar);\n\n  function CandleStick() {\n    _classCallCheck(this, CandleStick);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CandleStick).apply(this, arguments));\n  }\n\n  _createClass(CandleStick, [{\n    key: \"draw\",\n    value: function draw(series, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      this.candlestickOptions = this.w.config.plotOptions.candlestick;\n      var coreUtils = new CoreUtils(this.ctx, w);\n      this.series = coreUtils.getLogSeries(series);\n      series = this.series;\n      this.yRatio = coreUtils.getLogYRatios(this.yRatio);\n      this.initVariables(series);\n      var ret = graphics.group({\n        class: 'apexcharts-candlestick-series apexcharts-plot-series'\n      });\n      ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\"));\n\n      for (var i = 0, bc = 0; i < series.length; i++, bc++) {\n        var pathTo = void 0,\n            pathFrom = void 0;\n        var x = void 0,\n            y = void 0,\n            xDivision = void 0,\n            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)\n        zeroH = void 0; // zeroH is the baseline where 0 meets y axis\n\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n\n        if (series[i].length > 0) {\n          this.visibleI = this.visibleI + 1;\n        }\n\n        var strokeWidth = 0;\n        var barHeight = 0;\n        var barWidth = 0;\n\n        if (this.yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        var initPositions = this.initialPositions();\n        y = initPositions.y;\n        barHeight = initPositions.barHeight;\n        x = initPositions.x;\n        barWidth = initPositions.barWidth;\n        xDivision = initPositions.xDivision;\n        zeroH = initPositions.zeroH;\n        xArrj.push(x + barWidth / 2); // eldatalabels\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n\n        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {\n          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {\n            this.isNullValue = true;\n          } else {\n            this.isNullValue = false;\n          }\n\n          if (w.config.stroke.show) {\n            if (this.isNullValue) {\n              strokeWidth = 0;\n            } else {\n              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;\n            }\n          }\n\n          var color = void 0;\n          var paths = this.drawCandleStickPaths({\n            indexes: {\n              i: i,\n              j: j,\n              realIndex: realIndex,\n              bc: bc\n            },\n            x: x,\n            y: y,\n            xDivision: xDivision,\n            pathTo: pathTo,\n            pathFrom: pathFrom,\n            barWidth: barWidth,\n            zeroH: zeroH,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries\n          });\n          pathTo = paths.pathTo;\n          pathFrom = paths.pathFrom;\n          y = paths.y;\n          x = paths.x;\n          color = paths.color; // push current X\n\n          if (j > 0) {\n            xArrj.push(x + barWidth / 2);\n          }\n\n          yArrj.push(y);\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex,\n            color: color\n          });\n          var lineFill = this.candlestickOptions.wick.useFillColor ? color : undefined;\n          elSeries = this.renderSeries({\n            realIndex: realIndex,\n            pathFill: pathFill,\n            lineFill: lineFill,\n            j: j,\n            i: i,\n            pathFrom: pathFrom,\n            pathTo: pathTo,\n            strokeWidth: strokeWidth,\n            elSeries: elSeries,\n            x: x,\n            y: y,\n            series: series,\n            barHeight: barHeight,\n            barWidth: barWidth,\n            elDataLabelsWrap: elDataLabelsWrap,\n            visibleSeries: this.visibleI,\n            type: 'candlestick'\n          });\n        } // push all x val arrays into main xArr\n\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj;\n        ret.add(elSeries);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"drawCandleStickPaths\",\n    value: function drawCandleStickPaths(_ref) {\n      var indexes = _ref.indexes,\n          x = _ref.x,\n          y = _ref.y,\n          xDivision = _ref.xDivision,\n          pathTo = _ref.pathTo,\n          pathFrom = _ref.pathFrom,\n          barWidth = _ref.barWidth,\n          zeroH = _ref.zeroH,\n          strokeWidth = _ref.strokeWidth;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var i = indexes.i;\n      var j = indexes.j;\n      var isPositive = true;\n      var colorPos = w.config.plotOptions.candlestick.colors.upward;\n      var colorNeg = w.config.plotOptions.candlestick.colors.downward;\n      var yRatio = this.yRatio[this.yaxisIndex];\n      var realIndex = indexes.realIndex;\n      var ohlc = this.getOHLCValue(realIndex, j);\n      var l1 = zeroH;\n      var l2 = zeroH;\n\n      if (ohlc.o > ohlc.c) {\n        isPositive = false;\n      }\n\n      var y1 = Math.min(ohlc.o, ohlc.c);\n      var y2 = Math.max(ohlc.o, ohlc.c);\n\n      if (w.globals.isXNumeric) {\n        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;\n      }\n\n      var barXPosition = x + barWidth * this.visibleI;\n      pathTo = graphics.move(barXPosition, zeroH);\n      pathFrom = graphics.move(barXPosition, zeroH);\n\n      if (w.globals.previousPaths.length > 0) {\n        pathFrom = this.getPathFrom(realIndex, j, true);\n      }\n\n      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {\n        y1 = zeroH;\n      } else {\n        y1 = zeroH - y1 / yRatio;\n        y2 = zeroH - y2 / yRatio;\n        l1 = zeroH - ohlc.h / yRatio;\n        l2 = zeroH - ohlc.l / yRatio;\n      }\n\n      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);\n\n      if (!w.globals.isXNumeric) {\n        x = x + xDivision;\n      }\n\n      return {\n        pathTo: pathTo,\n        pathFrom: pathFrom,\n        x: x,\n        y: y2,\n        barXPosition: barXPosition,\n        color: isPositive ? colorPos : colorNeg\n      };\n    }\n  }, {\n    key: \"getOHLCValue\",\n    value: function getOHLCValue(i, j) {\n      var w = this.w;\n      return {\n        o: w.globals.seriesCandleO[i][j],\n        h: w.globals.seriesCandleH[i][j],\n        l: w.globals.seriesCandleL[i][j],\n        c: w.globals.seriesCandleC[i][j]\n      };\n    }\n  }]);\n\n  return CandleStick;\n}(Bar);\n\nvar Crosshairs =\n/*#__PURE__*/\nfunction () {\n  function Crosshairs(ctx) {\n    _classCallCheck(this, Crosshairs);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Crosshairs, [{\n    key: \"drawXCrosshairs\",\n    value: function drawXCrosshairs() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var filters = new Filters(this.ctx);\n      var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;\n      var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;\n      var fillType = w.config.xaxis.crosshairs.fill.type;\n      var gradientFrom = crosshairGradient.colorFrom;\n      var gradientTo = crosshairGradient.colorTo;\n      var opacityFrom = crosshairGradient.opacityFrom;\n      var opacityTo = crosshairGradient.opacityTo;\n      var stops = crosshairGradient.stops;\n      var shadow = 'none';\n      var dropShadow = crosshairShadow.enabled;\n      var shadowLeft = crosshairShadow.left;\n      var shadowTop = crosshairShadow.top;\n      var shadowBlur = crosshairShadow.blur;\n      var shadowColor = crosshairShadow.color;\n      var shadowOpacity = crosshairShadow.opacity;\n      var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;\n\n      if (w.config.xaxis.crosshairs.show) {\n        if (fillType === 'gradient') {\n          xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);\n        }\n\n        var xcrosshairs = graphics.drawRect();\n\n        if (w.config.xaxis.crosshairs.width === 1) {\n          // to prevent drawing 2 lines, convert rect to line\n          xcrosshairs = graphics.drawLine();\n        }\n\n        xcrosshairs.attr({\n          class: 'apexcharts-xcrosshairs',\n          x: 0,\n          y: 0,\n          y2: w.globals.gridHeight,\n          width: Utils.isNumber(w.config.xaxis.crosshairs.width) ? w.config.xaxis.crosshairs.width : 0,\n          height: w.globals.gridHeight,\n          fill: xcrosshairsFill,\n          filter: shadow,\n          'fill-opacity': w.config.xaxis.crosshairs.opacity,\n          stroke: w.config.xaxis.crosshairs.stroke.color,\n          'stroke-width': w.config.xaxis.crosshairs.stroke.width,\n          'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray\n        });\n\n        if (dropShadow) {\n          xcrosshairs = filters.dropShadow(xcrosshairs, {\n            left: shadowLeft,\n            top: shadowTop,\n            blur: shadowBlur,\n            color: shadowColor,\n            opacity: shadowOpacity\n          });\n        }\n\n        w.globals.dom.elGraphical.add(xcrosshairs);\n      }\n    }\n  }, {\n    key: \"drawYCrosshairs\",\n    value: function drawYCrosshairs() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var crosshair = w.config.yaxis[0].crosshairs;\n\n      if (w.config.yaxis[0].crosshairs.show) {\n        var ycrosshairs = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);\n        ycrosshairs.attr({\n          class: 'apexcharts-ycrosshairs'\n        });\n        w.globals.dom.elGraphical.add(ycrosshairs);\n      } // draw an invisible crosshair to help in positioning the yaxis tooltip\n\n\n      var ycrosshairsHidden = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, 0, 0);\n      ycrosshairsHidden.attr({\n        class: 'apexcharts-ycrosshairs-hidden'\n      });\n      w.globals.dom.elGraphical.add(ycrosshairsHidden);\n    }\n  }]);\n\n  return Crosshairs;\n}();\n\n/**\n * DateTime Class to manipulate datetime values.\n *\n * @module DateTime\n **/\n\nvar DateTime =\n/*#__PURE__*/\nfunction () {\n  function DateTime(ctx) {\n    _classCallCheck(this, DateTime);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.months31 = [1, 3, 5, 7, 8, 10, 12];\n    this.months30 = [2, 4, 6, 9, 11];\n    this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n  }\n\n  _createClass(DateTime, [{\n    key: \"isValidDate\",\n    value: function isValidDate(date) {\n      return !isNaN(this.parseDate(date));\n    }\n  }, {\n    key: \"getUTCTimeStamp\",\n    value: function getUTCTimeStamp(dateStr) {\n      if (!Date.parse(dateStr)) {\n        return dateStr;\n      }\n\n      return new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();\n    }\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(dateStr) {\n      var parsed = Date.parse(dateStr);\n\n      if (!isNaN(parsed)) {\n        return this.getUTCTimeStamp(dateStr);\n      }\n\n      var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));\n      output = this.getUTCTimeStamp(output);\n      return output;\n    } // https://stackoverflow.com/a/11252167/6495043\n\n  }, {\n    key: \"treatAsUtc\",\n    value: function treatAsUtc(dateStr) {\n      var result = new Date(dateStr);\n      result.setMinutes(result.getMinutes() - result.getTimezoneOffset());\n      return result;\n    } // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191\n\n  }, {\n    key: \"formatDate\",\n    value: function formatDate(date, format) {\n      var utc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var convertToUTC = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var locale = this.w.globals.locale;\n      var MMMM = ['\\x00'].concat(_toConsumableArray(locale.months));\n      var MMM = ['\\x01'].concat(_toConsumableArray(locale.shortMonths));\n      var dddd = ['\\x02'].concat(_toConsumableArray(locale.days));\n      var ddd = ['\\x03'].concat(_toConsumableArray(locale.shortDays));\n\n      function ii(i, len) {\n        var s = i + '';\n        len = len || 2;\n\n        while (s.length < len) {\n          s = '0' + s;\n        }\n\n        return s;\n      }\n\n      if (convertToUTC) {\n        date = this.treatAsUtc(date);\n      }\n\n      var y = utc ? date.getUTCFullYear() : date.getFullYear();\n      format = format.replace(/(^|[^\\\\])yyyy+/g, '$1' + y);\n      format = format.replace(/(^|[^\\\\])yy/g, '$1' + y.toString().substr(2, 2));\n      format = format.replace(/(^|[^\\\\])y/g, '$1' + y);\n      var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n      format = format.replace(/(^|[^\\\\])MMMM+/g, '$1' + MMMM[0]);\n      format = format.replace(/(^|[^\\\\])MMM/g, '$1' + MMM[0]);\n      format = format.replace(/(^|[^\\\\])MM/g, '$1' + ii(M));\n      format = format.replace(/(^|[^\\\\])M/g, '$1' + M);\n      var d = utc ? date.getUTCDate() : date.getDate();\n      format = format.replace(/(^|[^\\\\])dddd+/g, '$1' + dddd[0]);\n      format = format.replace(/(^|[^\\\\])ddd/g, '$1' + ddd[0]);\n      format = format.replace(/(^|[^\\\\])dd/g, '$1' + ii(d));\n      format = format.replace(/(^|[^\\\\])d/g, '$1' + d);\n      var H = utc ? date.getUTCHours() : date.getHours();\n      format = format.replace(/(^|[^\\\\])HH+/g, '$1' + ii(H));\n      format = format.replace(/(^|[^\\\\])H/g, '$1' + H);\n      var h = H > 12 ? H - 12 : H === 0 ? 12 : H;\n      format = format.replace(/(^|[^\\\\])hh+/g, '$1' + ii(h));\n      format = format.replace(/(^|[^\\\\])h/g, '$1' + h);\n      var m = utc ? date.getUTCMinutes() : date.getMinutes();\n      format = format.replace(/(^|[^\\\\])mm+/g, '$1' + ii(m));\n      format = format.replace(/(^|[^\\\\])m/g, '$1' + m);\n      var s = utc ? date.getUTCSeconds() : date.getSeconds();\n      format = format.replace(/(^|[^\\\\])ss+/g, '$1' + ii(s));\n      format = format.replace(/(^|[^\\\\])s/g, '$1' + s);\n      var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n      format = format.replace(/(^|[^\\\\])fff+/g, '$1' + ii(f, 3));\n      f = Math.round(f / 10);\n      format = format.replace(/(^|[^\\\\])ff/g, '$1' + ii(f));\n      f = Math.round(f / 10);\n      format = format.replace(/(^|[^\\\\])f/g, '$1' + f);\n      var T = H < 12 ? 'AM' : 'PM';\n      format = format.replace(/(^|[^\\\\])TT+/g, '$1' + T);\n      format = format.replace(/(^|[^\\\\])T/g, '$1' + T.charAt(0));\n      var t = T.toLowerCase();\n      format = format.replace(/(^|[^\\\\])tt+/g, '$1' + t);\n      format = format.replace(/(^|[^\\\\])t/g, '$1' + t.charAt(0));\n      var tz = -date.getTimezoneOffset();\n      var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';\n\n      if (!utc) {\n        tz = Math.abs(tz);\n        var tzHrs = Math.floor(tz / 60);\n        var tzMin = tz % 60;\n        K += ii(tzHrs) + ':' + ii(tzMin);\n      }\n\n      format = format.replace(/(^|[^\\\\])K/g, '$1' + K);\n      var day = (utc ? date.getUTCDay() : date.getDay()) + 1;\n      format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);\n      format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);\n      format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);\n      format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);\n      format = format.replace(/\\\\(.)/g, '$1');\n      return format;\n    }\n  }, {\n    key: \"getTimeUnitsfromTimestamp\",\n    value: function getTimeUnitsfromTimestamp(minX, maxX) {\n      var w = this.w;\n\n      if (w.config.xaxis.min !== undefined) {\n        minX = w.config.xaxis.min;\n      }\n\n      if (w.config.xaxis.max !== undefined) {\n        maxX = w.config.xaxis.max;\n      }\n\n      var minYear = new Date(minX).getFullYear();\n      var maxYear = new Date(maxX).getFullYear();\n      var minMonth = new Date(minX).getMonth();\n      var maxMonth = new Date(maxX).getMonth();\n      var minDate = new Date(minX).getDate();\n      var maxDate = new Date(maxX).getDate();\n      var minHour = new Date(minX).getHours();\n      var maxHour = new Date(maxX).getHours();\n      var minMinute = new Date(minX).getMinutes();\n      var maxMinute = new Date(maxX).getMinutes();\n      return {\n        minMinute: minMinute,\n        maxMinute: maxMinute,\n        minHour: minHour,\n        maxHour: maxHour,\n        minDate: minDate,\n        maxDate: maxDate,\n        minMonth: minMonth,\n        maxMonth: maxMonth,\n        minYear: minYear,\n        maxYear: maxYear\n      };\n    }\n  }, {\n    key: \"isLeapYear\",\n    value: function isLeapYear(year) {\n      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    }\n  }, {\n    key: \"calculcateLastDaysOfMonth\",\n    value: function calculcateLastDaysOfMonth(month, year, subtract) {\n      var days = this.determineDaysOfMonths(month, year); // whatever days we get, subtract the number of days asked\n\n      return days - subtract;\n    }\n  }, {\n    key: \"determineDaysOfYear\",\n    value: function determineDaysOfYear(year) {\n      var days = 365;\n\n      if (this.isLeapYear(year)) {\n        days = 366;\n      }\n\n      return days;\n    }\n  }, {\n    key: \"determineRemainingDaysOfYear\",\n    value: function determineRemainingDaysOfYear(year, month, date) {\n      var dayOfYear = this.daysCntOfYear[month] + date;\n      if (month > 1 && this.isLeapYear()) dayOfYear++;\n      return dayOfYear;\n    }\n  }, {\n    key: \"determineDaysOfMonths\",\n    value: function determineDaysOfMonths(month, year) {\n      var days = 30;\n      month = Utils.monthMod(month);\n\n      switch (true) {\n        case this.months30.indexOf(month) > -1:\n          if (month === 2) {\n            if (this.isLeapYear(year)) {\n              days = 29;\n            } else {\n              days = 28;\n            }\n          }\n\n          break;\n\n        case this.months31.indexOf(month) > -1:\n          days = 31;\n          break;\n\n        default:\n          days = 31;\n          break;\n      }\n\n      return days;\n    }\n  }]);\n\n  return DateTime;\n}();\n\n/**\n * ApexCharts HeatMap Class.\n * @module HeatMap\n **/\n\nvar HeatMap =\n/*#__PURE__*/\nfunction () {\n  function HeatMap(ctx, xyRatios) {\n    _classCallCheck(this, HeatMap);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.xRatio = xyRatios.xRatio;\n    this.yRatio = xyRatios.yRatio;\n    this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;\n    this.rectRadius = this.w.config.plotOptions.heatmap.radius;\n    this.strokeWidth = this.w.config.stroke.width;\n  }\n\n  _createClass(HeatMap, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-heatmap'\n      });\n      ret.attr('clip-path', \"url(#gridRectMask\".concat(w.globals.cuid, \")\")); // width divided into equal parts\n\n      var xDivision = w.globals.gridWidth / w.globals.dataPoints;\n      var yDivision = w.globals.gridHeight / w.globals.series.length;\n      var y1 = 0;\n      var rev = false;\n      var heatSeries = series.slice();\n\n      if (w.config.yaxis[0].reversed) {\n        rev = true;\n        heatSeries.reverse();\n      }\n\n      for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {\n        // el to which series will be drawn\n        var elSeries = graphics.group({\n          class: \"apexcharts-series apexcharts-heatmap-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          rel: i + 1,\n          'data:realIndex': i\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var shadow = w.config.chart.dropShadow;\n          var filters = new Filters(this.ctx);\n          filters.dropShadow(elSeries, shadow);\n        }\n\n        var x1 = 0;\n\n        for (var j = 0; j < heatSeries[i].length; j++) {\n          var colorShadePercent = 1;\n          var heatColorProps = this.determineHeatColor(i, j);\n\n          if (w.globals.hasNegs) {\n            var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;\n\n            if (heatColorProps.percent < 0) {\n              colorShadePercent = 1 - (1 + heatColorProps.percent / 100) * shadeIntensity;\n            } else {\n              colorShadePercent = (1 - heatColorProps.percent / 100) * shadeIntensity;\n            }\n          } else {\n            colorShadePercent = 1 - heatColorProps.percent / 100;\n          }\n\n          var color = heatColorProps.color;\n\n          if (w.config.plotOptions.heatmap.enableShades) {\n            var utils = new Utils();\n            color = Utils.hexToRgba(utils.shadeColor(colorShadePercent, heatColorProps.color), w.config.fill.opacity);\n          }\n\n          var radius = this.rectRadius;\n          var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);\n          rect.attr({\n            cx: x1,\n            cy: y1\n          });\n          rect.node.classList.add('apexcharts-heatmap-rect');\n          elSeries.add(rect);\n          rect.attr({\n            fill: color,\n            i: i,\n            index: i,\n            j: j,\n            val: heatSeries[i][j],\n            'stroke-width': this.strokeWidth,\n            stroke: w.globals.stroke.colors[0],\n            color: color\n          });\n          rect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, rect));\n          rect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, rect));\n          rect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, rect));\n\n          if (w.config.chart.animations.enabled && !w.globals.dataChanged) {\n            var speed = 1;\n\n            if (!w.globals.resized) {\n              speed = w.config.chart.animations.speed;\n            }\n\n            this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);\n          }\n\n          if (w.globals.dataChanged) {\n            var _speed = 1;\n\n            if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {\n              _speed = this.dynamicAnim.speed;\n              var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;\n              if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';\n              this.animateHeatColor(rect, Utils.isColorHex(colorFrom) ? colorFrom : Utils.rgb2hex(colorFrom), Utils.isColorHex(color) ? color : Utils.rgb2hex(color), _speed);\n            }\n          }\n\n          var dataLabels = this.calculateHeatmapDataLabels({\n            x: x1,\n            y: y1,\n            i: i,\n            j: j,\n            series: heatSeries,\n            rectHeight: yDivision,\n            rectWidth: xDivision\n          });\n\n          if (dataLabels !== null) {\n            elSeries.add(dataLabels);\n          }\n\n          x1 = x1 + xDivision;\n        }\n\n        y1 = y1 + yDivision;\n        ret.add(elSeries);\n      } // adjust yaxis labels for heatmap\n\n\n      var yAxisScale = w.globals.yAxisScale[0].result.slice();\n\n      if (w.config.yaxis[0].reversed) {\n        yAxisScale.unshift('');\n      } else {\n        yAxisScale.push('');\n      }\n\n      w.globals.yAxisScale[0].result = yAxisScale;\n      var divisor = w.globals.gridHeight / w.globals.series.length;\n      w.config.yaxis[0].labels.offsetY = -(divisor / 2);\n      return ret;\n    }\n  }, {\n    key: \"determineHeatColor\",\n    value: function determineHeatColor(i, j) {\n      var w = this.w;\n      var val = w.globals.series[i][j];\n      var heatmap = w.config.plotOptions.heatmap;\n      var seriesNumber = heatmap.colorScale.inverse ? j : i;\n      var color = w.globals.colors[seriesNumber];\n      var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));\n      var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));\n\n      if (!heatmap.distributed) {\n        min = w.globals.minY;\n        max = w.globals.maxY;\n      }\n\n      if (typeof heatmap.colorScale.min !== 'undefined') {\n        min = heatmap.colorScale.min < w.globals.minY ? heatmap.colorScale.min : w.globals.minY;\n        max = heatmap.colorScale.max > w.globals.maxY ? heatmap.colorScale.max : w.globals.maxY;\n      }\n\n      var total = Math.abs(max) + Math.abs(min);\n      var percent = 100 * val / (total === 0 ? total - 0.000001 : total);\n\n      if (heatmap.colorScale.ranges.length > 0) {\n        var colorRange = heatmap.colorScale.ranges;\n        colorRange.map(function (range, index) {\n          if (val >= range.from && val <= range.to) {\n            color = range.color;\n            min = range.from;\n            max = range.to;\n            total = Math.abs(max) + Math.abs(min);\n            percent = 100 * val / total;\n          }\n        });\n      }\n\n      return {\n        color: color,\n        percent: percent\n      };\n    }\n  }, {\n    key: \"calculateHeatmapDataLabels\",\n    value: function calculateHeatmapDataLabels(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          i = _ref.i,\n          j = _ref.j,\n          series = _ref.series,\n          rectHeight = _ref.rectHeight,\n          rectWidth = _ref.rectWidth;\n      var w = this.w; // let graphics = new Graphics(this.ctx)\n\n      var dataLabelsConfig = w.config.dataLabels;\n      var graphics = new Graphics(this.ctx);\n      var dataLabels = new DataLabels(this.ctx);\n      var formatter = dataLabelsConfig.formatter;\n      var elDataLabelsWrap = null;\n\n      if (dataLabelsConfig.enabled) {\n        elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-data-labels'\n        });\n        var offX = dataLabelsConfig.offsetX;\n        var offY = dataLabelsConfig.offsetY;\n        var dataLabelsX = x + rectWidth / 2 + offX;\n        var dataLabelsY = y + rectHeight / 2 + parseInt(dataLabelsConfig.style.fontSize) / 3 + offY;\n        var text = formatter(w.globals.series[i][j], {\n          seriesIndex: i,\n          dataPointIndex: j,\n          w: w\n        });\n        dataLabels.plotDataLabelsText({\n          x: dataLabelsX,\n          y: dataLabelsY,\n          text: text,\n          i: i,\n          j: j,\n          parent: elDataLabelsWrap,\n          dataLabelsConfig: dataLabelsConfig\n        });\n      }\n\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"animateHeatMap\",\n    value: function animateHeatMap(el, x, y, width, height, speed) {\n      var _this = this;\n\n      var animations = new Animations(this.ctx);\n      animations.animateRect(el, {\n        x: x + width / 2,\n        y: y + height / 2,\n        width: 0,\n        height: 0\n      }, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      }, speed, function () {\n        _this.w.globals.animationEnded = true;\n      });\n    }\n  }, {\n    key: \"animateHeatColor\",\n    value: function animateHeatColor(el, colorFrom, colorTo, speed) {\n      el.attr({\n        fill: colorFrom\n      }).animate(speed).attr({\n        fill: colorTo\n      });\n    }\n  }]);\n\n  return HeatMap;\n}();\n\n/**\n * ApexCharts Pie Class for drawing Pie / Donut Charts.\n * @module Pie\n **/\n\nvar Pie =\n/*#__PURE__*/\nfunction () {\n  function Pie(ctx) {\n    _classCallCheck(this, Pie);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.chartType = this.w.config.chart.type;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n    this.animBeginArr = [0];\n    this.animDur = 0;\n    this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;\n    var w = this.w;\n    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;\n    this.centerY = this.defaultSize / 2;\n    this.centerX = w.globals.gridWidth / 2;\n    this.fullAngle = 360;\n    this.size = 0;\n    this.donutSize = 0;\n    this.sliceLabels = [];\n    this.prevSectorAngleArr = []; // for dynamic animations\n  }\n\n  _createClass(Pie, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var self = this;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-pie'\n      });\n      var total = 0;\n\n      for (var k = 0; k < series.length; k++) {\n        // CALCULATE THE TOTAL\n        total += Utils.negToZero(series[k]);\n      }\n\n      var sectorAngleArr = []; // el to which series will be drawn\n\n      var elSeries = graphics.group(); // prevent division by zero error if there is no data\n\n      if (total === 0) {\n        total = 0.00001;\n      }\n\n      for (var i = 0; i < series.length; i++) {\n        // CALCULATE THE ANGLES\n        var angle = this.fullAngle * Utils.negToZero(series[i]) / total;\n        sectorAngleArr.push(angle);\n      }\n\n      if (w.globals.dataChanged) {\n        var prevTotal = 0;\n\n        for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {\n          // CALCULATE THE PREV TOTAL\n          prevTotal += Utils.negToZero(w.globals.previousPaths[_k]);\n        }\n\n        var previousAngle;\n\n        for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {\n          // CALCULATE THE PREVIOUS ANGLES\n          previousAngle = this.fullAngle * Utils.negToZero(w.globals.previousPaths[_i]) / prevTotal;\n          this.prevSectorAngleArr.push(previousAngle);\n        }\n      }\n\n      this.size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;\n\n      if (w.config.plotOptions.pie.size !== undefined) {\n        this.size = w.config.plotOptions.pie.size;\n      }\n\n      this.donutSize = this.size * parseInt(w.config.plotOptions.pie.donut.size) / 100;\n      var scaleSize = w.config.plotOptions.pie.customScale;\n      var halfW = w.globals.gridWidth / 2;\n      var halfH = w.globals.gridHeight / 2;\n      var translateX = halfW - w.globals.gridWidth / 2 * scaleSize;\n      var translateY = halfH - w.globals.gridHeight / 2 * scaleSize;\n\n      if (this.donutDataLabels.show) {\n        var dataLabels = this.renderInnerDataLabels(this.donutDataLabels, {\n          hollowSize: this.donutSize,\n          centerX: this.centerX,\n          centerY: this.centerY,\n          opacity: this.donutDataLabels.show,\n          translateX: translateX,\n          translateY: translateY\n        });\n        ret.add(dataLabels);\n      }\n\n      if (w.config.chart.type === 'donut') {\n        // draw the inner circle and add some text to it\n        var circle = graphics.drawCircle(this.donutSize);\n        circle.attr({\n          cx: this.centerX,\n          cy: this.centerY,\n          fill: w.config.plotOptions.pie.donut.background\n        });\n        elSeries.add(circle);\n      }\n\n      var elG = self.drawArcs(sectorAngleArr, series); // add slice dataLabels at the end\n\n      this.sliceLabels.forEach(function (s) {\n        elG.add(s);\n      });\n      elSeries.attr({\n        transform: \"translate(\".concat(translateX, \", \").concat(translateY - 5, \") scale(\").concat(scaleSize, \")\")\n      });\n      ret.attr({\n        'data:innerTranslateX': translateX,\n        'data:innerTranslateY': translateY - 25\n      });\n      elSeries.add(elG);\n      ret.add(elSeries);\n      return ret;\n    } // core function for drawing pie arcs\n\n  }, {\n    key: \"drawArcs\",\n    value: function drawArcs(sectorAngleArr, series) {\n      var w = this.w;\n      var filters = new Filters(this.ctx);\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var g = graphics.group();\n      var startAngle = 0;\n      var prevStartAngle = 0;\n      var endAngle = 0;\n      var prevEndAngle = 0;\n      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;\n\n      for (var i = 0; i < sectorAngleArr.length; i++) {\n        // if(sectorAngleArr[i]>0) {\n        var elPieArc = graphics.group({\n          class: \"apexcharts-series apexcharts-pie-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          id: 'apexcharts-series-' + i,\n          rel: i + 1\n        });\n        g.add(elPieArc);\n        startAngle = endAngle;\n        prevStartAngle = prevEndAngle;\n        endAngle = startAngle + sectorAngleArr[i];\n        prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];\n        var angle = endAngle - startAngle;\n        var pathFill = fill.fillPath({\n          seriesNumber: i,\n          size: this.size\n        }); // additionaly, pass size for gradient drawing in the fillPath function\n\n        var path = this.getChangedPath(prevStartAngle, prevEndAngle);\n        var elPath = graphics.drawPath({\n          d: path,\n          stroke: this.lineColorArr instanceof Array ? this.lineColorArr[i] : this.lineColorArr,\n          strokeWidth: this.strokeWidth,\n          fill: pathFill,\n          fillOpacity: w.config.fill.opacity,\n          classes: 'apexcharts-pie-area'\n        });\n        elPath.attr({\n          id: 'apexcharts-pie-slice-' + i,\n          index: 0,\n          j: i\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var shadow = w.config.chart.dropShadow;\n          filters.dropShadow(elPath, shadow);\n        }\n\n        this.addListeners(elPath, this.donutDataLabels);\n        Graphics.setAttrs(elPath.node, {\n          'data:angle': angle,\n          'data:startAngle': startAngle,\n          'data:strokeWidth': this.strokeWidth,\n          'data:value': series[i]\n        });\n        var labelPosition = {\n          x: 0,\n          y: 0\n        };\n\n        if (w.config.chart.type === 'pie') {\n          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, this.size / 1.25 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);\n        } else if (w.config.chart.type === 'donut') {\n          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, (this.size + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);\n        }\n\n        elPieArc.add(elPath); // Animation code starts\n\n        var dur = 0;\n\n        if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / this.fullAngle * w.config.chart.animations.speed;\n          this.animDur = dur + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        } else {\n          this.animBeginArr.push(0);\n        }\n\n        if (this.dynamicAnim && w.globals.dataChanged) {\n          this.animatePaths(elPath, {\n            endAngle: endAngle,\n            startAngle: startAngle,\n            prevStartAngle: prevStartAngle,\n            prevEndAngle: prevEndAngle,\n            animateStartingPos: true,\n            i: i,\n            animBeginArr: this.animBeginArr,\n            dur: w.config.chart.animations.dynamicAnimation.speed\n          });\n        } else {\n          this.animatePaths(elPath, {\n            endAngle: endAngle,\n            startAngle: startAngle,\n            i: i,\n            totalItems: sectorAngleArr.length - 1,\n            animBeginArr: this.animBeginArr,\n            dur: dur\n          });\n        } // animation code ends\n\n\n        if (w.config.plotOptions.pie.expandOnClick) {\n          elPath.click(this.pieClicked.bind(this, i));\n        }\n\n        if (w.config.dataLabels.enabled) {\n          var xPos = labelPosition.x;\n          var yPos = labelPosition.y;\n          var text = 100 * (endAngle - startAngle) / 360 + '%';\n\n          if (angle !== 0) {\n            var formatter = w.config.dataLabels.formatter;\n\n            if (formatter !== undefined) {\n              text = formatter(w.globals.seriesPercent[i][0], {\n                seriesIndex: i,\n                w: w\n              });\n            }\n\n            var foreColor = w.globals.dataLabels.style.colors[i];\n            var elPieLabel = graphics.drawText({\n              x: xPos,\n              y: yPos,\n              text: text,\n              textAnchor: 'middle',\n              fontSize: w.config.dataLabels.style.fontSize,\n              fontFamily: w.config.dataLabels.style.fontFamily,\n              foreColor: foreColor\n            });\n\n            if (w.config.dataLabels.dropShadow.enabled) {\n              var textShadow = w.config.dataLabels.dropShadow;\n\n              var _filters = new Filters(this.ctx);\n\n              _filters.dropShadow(elPieLabel, textShadow);\n            }\n\n            elPieLabel.node.classList.add('apexcharts-pie-label');\n\n            if (w.config.chart.animations.animate && w.globals.resized === false) {\n              elPieLabel.node.classList.add('apexcharts-pie-label-delay');\n              elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';\n            }\n\n            this.sliceLabels.push(elPieLabel);\n          }\n        } // }\n\n      }\n\n      return g;\n    }\n  }, {\n    key: \"addListeners\",\n    value: function addListeners(elPath, dataLabels) {\n      var graphics = new Graphics(this.ctx); // append filters on mouseenter and mouseleave\n\n      elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));\n      elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n      elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));\n      elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));\n      elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));\n      elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));\n    } // This function can be used for other circle charts too\n\n  }, {\n    key: \"animatePaths\",\n    value: function animatePaths(el, opts) {\n      var w = this.w;\n      var me = this;\n      var angle = opts.endAngle - opts.startAngle;\n      var prevAngle = angle;\n      var fromStartAngle = opts.startAngle;\n      var toStartAngle = opts.startAngle;\n\n      if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {\n        fromStartAngle = opts.prevEndAngle;\n        prevAngle = opts.prevEndAngle - opts.prevStartAngle;\n      }\n\n      if (opts.i === w.config.series.length - 1) {\n        // some adjustments for the last overlapping paths\n        if (angle + toStartAngle > this.fullAngle) {\n          opts.endAngle = opts.endAngle - (angle + toStartAngle);\n        } else if (angle + toStartAngle < this.fullAngle) {\n          opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));\n        }\n      }\n\n      if (angle === this.fullAngle) angle = this.fullAngle - 0.01;\n      me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);\n    }\n  }, {\n    key: \"animateArc\",\n    value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {\n      var me = this;\n      var w = this.w;\n      var size = me.size;\n\n      if (!size) {\n        size = opts.size;\n      }\n\n      var path;\n\n      if (isNaN(fromStartAngle) || isNaN(prevAngle)) {\n        fromStartAngle = toStartAngle;\n        prevAngle = angle;\n        opts.dur = 0;\n      }\n\n      var currAngle = angle;\n      var startAngle = toStartAngle;\n      var fromAngle = fromStartAngle - toStartAngle;\n\n      if (w.globals.dataChanged && opts.shouldSetPrevPaths) {\n        // to avoid flickering, set prev path first and then we will animate from there\n        path = me.getPiePath({\n          me: me,\n          startAngle: startAngle,\n          angle: prevAngle,\n          size: size\n        });\n        el.attr({\n          d: path\n        });\n      }\n\n      if (opts.dur !== 0) {\n        el.animate(opts.dur, w.globals.easing, opts.animBeginArr[opts.i]).afterAll(function () {\n          if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {\n            this.animate(300).attr({\n              'stroke-width': w.config.stroke.width\n            });\n          }\n\n          w.globals.animationEnded = true;\n        }).during(function (pos) {\n          currAngle = fromAngle + (angle - fromAngle) * pos;\n\n          if (opts.animateStartingPos) {\n            currAngle = prevAngle + (angle - prevAngle) * pos;\n            startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;\n          }\n\n          path = me.getPiePath({\n            me: me,\n            startAngle: startAngle,\n            angle: currAngle,\n            size: size\n          });\n          el.node.setAttribute('data:pathOrig', path);\n          el.attr({\n            d: path\n          });\n        });\n      } else {\n        path = me.getPiePath({\n          me: me,\n          startAngle: startAngle,\n          angle: angle,\n          size: size\n        });\n\n        if (!opts.isTrack) {\n          w.globals.animationEnded = true;\n        }\n\n        el.node.setAttribute('data:pathOrig', path);\n        el.attr({\n          d: path\n        });\n      }\n    }\n  }, {\n    key: \"pieClicked\",\n    value: function pieClicked(i) {\n      var w = this.w;\n      var me = this;\n      var path;\n      var size = me.size + 3;\n      var elPath = w.globals.dom.Paper.select('#apexcharts-pie-slice-' + i).members[0];\n      var pathFrom = elPath.attr('d');\n\n      if (elPath.attr('data:pieClicked') === 'true') {\n        elPath.attr({\n          'data:pieClicked': 'false'\n        });\n        var origPath = elPath.attr('data:pathOrig');\n        elPath.attr({\n          d: origPath\n        });\n        return;\n      } else {\n        // reset all elems\n        var allEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area');\n        Array.prototype.forEach.call(allEls, function (pieSlice) {\n          pieSlice.setAttribute('data:pieClicked', 'false');\n          var origPath = pieSlice.getAttribute('data:pathOrig');\n          pieSlice.setAttribute('d', origPath);\n        });\n        elPath.attr('data:pieClicked', 'true');\n      }\n\n      var startAngle = parseInt(elPath.attr('data:startAngle'));\n      var angle = parseInt(elPath.attr('data:angle'));\n      path = me.getPiePath({\n        me: me,\n        startAngle: startAngle,\n        angle: angle,\n        size: size\n      });\n      if (angle === 360) return;\n      elPath.plot(path).animate(1).plot(pathFrom).animate(100).plot(path);\n    }\n  }, {\n    key: \"getChangedPath\",\n    value: function getChangedPath(prevStartAngle, prevEndAngle) {\n      var path = '';\n\n      if (this.dynamicAnim && this.w.globals.dataChanged) {\n        path = this.getPiePath({\n          me: this,\n          startAngle: prevStartAngle,\n          angle: prevEndAngle - prevStartAngle,\n          size: this.size\n        });\n      }\n\n      return path;\n    }\n  }, {\n    key: \"getPiePath\",\n    value: function getPiePath(_ref) {\n      var me = _ref.me,\n          startAngle = _ref.startAngle,\n          angle = _ref.angle,\n          size = _ref.size;\n      var w = this.w;\n      var path;\n      var startDeg = startAngle;\n      var startRadians = Math.PI * (startDeg - 90) / 180;\n      var endDeg = angle + startAngle;\n      if (Math.ceil(endDeg) >= 360) endDeg = 359.99;\n      var endRadians = Math.PI * (endDeg - 90) / 180;\n      var x1 = me.centerX + size * Math.cos(startRadians);\n      var y1 = me.centerY + size * Math.sin(startRadians);\n      var x2 = me.centerX + size * Math.cos(endRadians);\n      var y2 = me.centerY + size * Math.sin(endRadians);\n      var startInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);\n      var endInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);\n      var largeArc = angle > 180 ? 1 : 0;\n\n      if (w.config.chart.type === 'donut') {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z'].join(' ');\n      } else if (w.config.chart.type === 'pie') {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', me.centerX, me.centerY, 'L', x1, y1].join(' ');\n      } else {\n        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2].join(' ');\n      }\n\n      return path;\n    }\n  }, {\n    key: \"renderInnerDataLabels\",\n    value: function renderInnerDataLabels(dataLabelsConfig, opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var g = graphics.group({\n        class: 'apexcharts-datalabels-group',\n        transform: \"translate(\".concat(opts.translateX ? opts.translateX : 0, \", \").concat(opts.translateY ? opts.translateY : 0, \")\")\n      });\n      var showTotal = dataLabelsConfig.total.show;\n      g.node.style.opacity = opts.opacity;\n      var x = opts.centerX;\n      var y = opts.centerY;\n      var labelColor, valueColor;\n\n      if (dataLabelsConfig.name.color === undefined) {\n        labelColor = w.globals.colors[0];\n      } else {\n        labelColor = dataLabelsConfig.name.color;\n      }\n\n      if (dataLabelsConfig.value.color === undefined) {\n        valueColor = w.config.chart.foreColor;\n      } else {\n        valueColor = dataLabelsConfig.value.color;\n      }\n\n      var lbFormatter = dataLabelsConfig.value.formatter;\n      var val = '';\n      var name = '';\n\n      if (showTotal) {\n        labelColor = dataLabelsConfig.total.color;\n        name = dataLabelsConfig.total.label;\n        val = dataLabelsConfig.total.formatter(w);\n      } else {\n        if (w.globals.series.length === 1) {\n          val = lbFormatter(w.globals.series[0], w);\n          name = w.globals.seriesNames[0];\n        }\n      }\n\n      if (dataLabelsConfig.name.show) {\n        var elLabel = graphics.drawText({\n          x: x,\n          y: y + parseInt(dataLabelsConfig.name.offsetY),\n          text: name,\n          textAnchor: 'middle',\n          foreColor: labelColor,\n          fontSize: dataLabelsConfig.name.fontSize,\n          fontFamily: dataLabelsConfig.name.fontFamily\n        });\n        elLabel.node.classList.add('apexcharts-datalabel-label');\n        g.add(elLabel);\n      }\n\n      if (dataLabelsConfig.value.show) {\n        var valOffset = dataLabelsConfig.name.show ? parseInt(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;\n        var elValue = graphics.drawText({\n          x: x,\n          y: y + valOffset,\n          text: val,\n          textAnchor: 'middle',\n          foreColor: valueColor,\n          fontSize: dataLabelsConfig.value.fontSize,\n          fontFamily: dataLabelsConfig.value.fontFamily\n        });\n        elValue.node.classList.add('apexcharts-datalabel-value');\n        g.add(elValue);\n      } // for a multi-series circle chart, we need to show total value instead of first series labels\n\n\n      return g;\n    }\n    /**\n     *\n     * @param {string} name - The name of the series\n     * @param {string} val - The value of that series\n     * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total\n     */\n\n  }, {\n    key: \"printInnerLabels\",\n    value: function printInnerLabels(labelsConfig, name, val, el) {\n      var w = this.w;\n      var labelColor;\n\n      if (el) {\n        if (labelsConfig.name.color === undefined) {\n          labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel')) - 1];\n        } else {\n          labelColor = labelsConfig.name.color;\n        }\n      } else {\n        if (w.globals.series.length > 1 && labelsConfig.total.show) {\n          labelColor = labelsConfig.total.color;\n        }\n      }\n\n      var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');\n      var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');\n      var lbFormatter = labelsConfig.value.formatter;\n      val = lbFormatter(val, w); // we need to show Total Val - so get the formatter of it\n\n      if (!el && typeof labelsConfig.total.formatter === 'function') {\n        val = labelsConfig.total.formatter(w);\n      }\n\n      if (elLabel !== null) {\n        elLabel.textContent = name;\n      }\n\n      if (elValue !== null) {\n        elValue.textContent = val;\n      }\n\n      if (elLabel !== null) {\n        elLabel.style.fill = labelColor;\n      }\n    }\n  }, {\n    key: \"printDataLabelsInner\",\n    value: function printDataLabelsInner(el, dataLabelsConfig) {\n      var w = this.w;\n      var val = el.getAttribute('data:value');\n      var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel')) - 1];\n\n      if (w.globals.series.length > 1) {\n        this.printInnerLabels(dataLabelsConfig, name, val, el);\n      }\n\n      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n\n      if (dataLabelsGroup !== null) {\n        dataLabelsGroup.style.opacity = 1;\n      }\n    }\n  }, {\n    key: \"revertDataLabelsInner\",\n    value: function revertDataLabelsInner(el, dataLabelsConfig) {\n      var w = this.w;\n      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');\n\n      if (dataLabelsConfig.total.show && w.globals.series.length > 1) {\n        var pie = new Pie(this.ctx);\n        pie.printInnerLabels(dataLabelsConfig, dataLabelsConfig.total.label, dataLabelsConfig.total.formatter(w));\n      } else {\n        if (w.globals.selectedDataPoints.length) {\n          if (w.globals.selectedDataPoints[0].length > 0) {\n            var index = w.globals.selectedDataPoints[0];\n\n            var _el = w.globals.dom.baseEl.querySelector(\"#apexcharts-pie-slice-\".concat(index));\n\n            this.printDataLabelsInner(_el, dataLabelsConfig);\n          } else {\n            dataLabelsGroup.style.opacity = 0;\n          }\n        } else if (w.globals.selectedDataPoints.length === 0 || dataLabelsGroup !== null && w.globals.series.length > 1) {\n          dataLabelsGroup.style.opacity = 0;\n        }\n      }\n    }\n  }]);\n\n  return Pie;\n}();\n\n/**\n * ApexCharts Radar Class for Spider/Radar Charts.\n * @module Radar\n **/\n\nvar Radar =\n/*#__PURE__*/\nfunction () {\n  function Radar(ctx) {\n    _classCallCheck(this, Radar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.chartType = this.w.config.chart.type;\n    this.initialAnim = this.w.config.chart.animations.enabled;\n    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;\n    this.animDur = 0;\n    var w = this.w;\n    this.graphics = new Graphics(this.ctx);\n    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;\n    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;\n    this.maxValue = this.w.globals.maxY;\n    this.polygons = w.config.plotOptions.radar.polygons;\n    this.maxLabelWidth = 20;\n    var longestLabel = w.globals.labels.slice().sort(function (a, b) {\n      return b.length - a.length;\n    })[0];\n    var labelWidth = this.graphics.getTextRects(longestLabel, w.config.dataLabels.style.fontSize);\n    this.size = this.defaultSize / 2.1 - w.config.stroke.width - w.config.chart.dropShadow.blur - labelWidth.width / 1.75;\n\n    if (w.config.plotOptions.radar.size !== undefined) {\n      this.size = w.config.plotOptions.radar.size;\n    }\n\n    this.dataRadiusOfPercent = [];\n    this.dataRadius = [];\n    this.angleArr = [];\n    this.yaxisLabelsTextsPos = [];\n  }\n\n  _createClass(Radar, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var _this = this;\n\n      var w = this.w;\n      var fill = new Fill(this.ctx);\n      var allSeries = [];\n      this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;\n      this.disAngle = Math.PI * 2 / this.dataPointsLen;\n      var halfW = w.globals.gridWidth / 2;\n      var halfH = w.globals.gridHeight / 2;\n      var translateX = halfW;\n      var translateY = halfH;\n      var ret = this.graphics.group({\n        class: 'apexcharts-radar-series',\n        'data:innerTranslateX': translateX,\n        'data:innerTranslateY': translateY - 25,\n        transform: \"translate(\".concat(translateX || 0, \", \").concat(translateY || 0, \")\")\n      });\n      var dataPointsPos = [];\n      var elPointsMain = null;\n      this.yaxisLabels = this.graphics.group({\n        class: 'apexcharts-yaxis'\n      });\n      series.forEach(function (s, i) {\n        // el to which series will be drawn\n        var elSeries = _this.graphics.group().attr({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[i])),\n          rel: i + 1,\n          'data:realIndex': i\n        });\n\n        _this.dataRadiusOfPercent[i] = [];\n        _this.dataRadius[i] = [];\n        _this.angleArr[i] = [];\n        s.forEach(function (dv, j) {\n          _this.dataRadiusOfPercent[i][j] = dv / _this.maxValue;\n          _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;\n          _this.angleArr[i][j] = j * _this.disAngle;\n        });\n        dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);\n\n        var paths = _this.createPaths(dataPointsPos, {\n          x: 0,\n          y: 0\n        }); // points\n\n\n        elPointsMain = _this.graphics.group({\n          class: 'apexcharts-series-markers-wrap hidden'\n        });\n        w.globals.delayedElements.push({\n          el: elPointsMain.node,\n          index: i\n        });\n        var defaultRenderedPathOptions = {\n          i: i,\n          realIndex: i,\n          animationDelay: i,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-radar\",\n          id: \"apexcharts-radar\",\n          shouldClipToGrid: false,\n          bindEventsOnPaths: false,\n          stroke: w.globals.stroke.colors[i],\n          strokeLineCap: w.config.stroke.lineCap\n        };\n        var pathFrom = null;\n\n        if (w.globals.previousPaths.length > 0) {\n          pathFrom = _this.getPathFrom(i);\n        }\n\n        for (var p = 0; p < paths.linePathsTo.length; p++) {\n          var renderedLinePath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n            pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,\n            pathTo: paths.linePathsTo[p],\n            strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width,\n            fill: 'none'\n          }));\n\n          elSeries.add(renderedLinePath);\n          var pathFill = fill.fillPath({\n            seriesNumber: i\n          });\n\n          var renderedAreaPath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n            pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,\n            pathTo: paths.areaPathsTo[p],\n            strokeWidth: 0,\n            fill: pathFill\n          }));\n\n          if (w.config.chart.dropShadow.enabled) {\n            var filters = new Filters(_this.ctx);\n            var shadow = w.config.chart.dropShadow;\n            filters.dropShadow(renderedAreaPath, _objectSpread({}, shadow, {\n              noUserSpaceOnUse: true\n            }));\n          }\n\n          elSeries.add(renderedAreaPath);\n        }\n\n        s.forEach(function (sj, j) {\n          var markers = new Markers(_this.ctx);\n          var opts = markers.getMarkerConfig('apexcharts-marker', i);\n\n          var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);\n\n          point.attr('rel', j);\n          point.attr('j', j);\n          point.attr('index', i);\n          point.node.setAttribute('default-marker-size', opts.pSize);\n\n          var elPointsWrap = _this.graphics.group({\n            class: 'apexcharts-series-markers'\n          });\n\n          if (elPointsWrap) {\n            elPointsWrap.add(point);\n          }\n\n          elPointsMain.add(elPointsWrap);\n          elSeries.add(elPointsMain);\n        });\n        allSeries.push(elSeries);\n      });\n      this.drawPolygons({\n        parent: ret\n      });\n\n      if (w.config.dataLabels.enabled) {\n        var dataLabels = this.drawLabels();\n        ret.add(dataLabels);\n      }\n\n      ret.add(this.yaxisLabels);\n      allSeries.forEach(function (elS) {\n        ret.add(elS);\n      });\n      return ret;\n    }\n  }, {\n    key: \"drawPolygons\",\n    value: function drawPolygons(opts) {\n      var _this2 = this;\n\n      var w = this.w;\n      var parent = opts.parent;\n      var yaxisTexts = w.globals.yAxisScale[0].result.reverse();\n      var layers = yaxisTexts.length;\n      var radiusSizes = [];\n      var layerDis = this.size / (layers - 1);\n\n      for (var i = 0; i < layers; i++) {\n        radiusSizes[i] = layerDis * i;\n      }\n\n      radiusSizes.reverse();\n      var polygonStrings = [];\n      var lines = [];\n      radiusSizes.forEach(function (radiusSize, r) {\n        var polygon = _this2.getPolygonPos(radiusSize);\n\n        var string = '';\n        polygon.forEach(function (p, i) {\n          if (r === 0) {\n            var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);\n\n            lines.push(line);\n          }\n\n          if (i === 0) {\n            _this2.yaxisLabelsTextsPos.push({\n              x: p.x,\n              y: p.y\n            });\n          }\n\n          string += p.x + ',' + p.y + ' ';\n        });\n        polygonStrings.push(string);\n      });\n      polygonStrings.forEach(function (p, i) {\n        var strokeColors = _this2.polygons.strokeColors;\n\n        var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, w.globals.radarPolygons.fill.colors[i]);\n\n        parent.add(polygon);\n      });\n      lines.forEach(function (l) {\n        parent.add(l);\n      });\n\n      if (w.config.yaxis[0].show) {\n        this.yaxisLabelsTextsPos.forEach(function (p, i) {\n          var yText = _this2.drawYAxisText(p.x, p.y, i, yaxisTexts[i]);\n\n          _this2.yaxisLabels.add(yText);\n        });\n      }\n    }\n  }, {\n    key: \"drawYAxisText\",\n    value: function drawYAxisText(x, y, i, text) {\n      var w = this.w;\n      var yaxisConfig = w.config.yaxis[0];\n      var formatter = w.globals.yLabelFormatters[0];\n      var yaxisLabel = this.graphics.drawText({\n        x: x + yaxisConfig.labels.offsetX,\n        y: y + yaxisConfig.labels.offsetY,\n        text: formatter(text, i),\n        textAnchor: 'middle',\n        fontSize: yaxisConfig.labels.style.fontSize,\n        fontFamily: yaxisConfig.labels.style.fontFamily,\n        foreColor: yaxisConfig.labels.style.color\n      });\n      return yaxisLabel;\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels() {\n      var _this3 = this;\n\n      var w = this.w;\n      var limit = 10;\n      var textAnchor = 'middle';\n      var dataLabelsConfig = w.config.dataLabels;\n      var elDataLabelsWrap = this.graphics.group({\n        class: 'apexcharts-datalabels'\n      });\n      var polygonPos = this.getPolygonPos(this.size);\n      var currPosX = 0;\n      var currPosY = 0;\n      w.globals.labels.forEach(function (label, i) {\n        var formatter = dataLabelsConfig.formatter;\n        var dataLabels = new DataLabels(_this3.ctx);\n\n        if (polygonPos[i]) {\n          currPosX = polygonPos[i].x;\n          currPosY = polygonPos[i].y;\n\n          if (Math.abs(polygonPos[i].x) >= limit) {\n            if (polygonPos[i].x > 0) {\n              textAnchor = 'start';\n              currPosX += 10;\n            } else if (polygonPos[i].x < 0) {\n              textAnchor = 'end';\n              currPosX -= 10;\n            }\n          } else {\n            textAnchor = 'middle';\n          }\n\n          if (Math.abs(polygonPos[i].y) >= _this3.size - limit) {\n            if (polygonPos[i].y < 0) {\n              currPosY -= 10;\n            } else if (polygonPos[i].y > 0) {\n              currPosY += 10;\n            }\n          }\n\n          var text = formatter(label, {\n            seriesIndex: -1,\n            dataPointIndex: i,\n            w: w\n          });\n          dataLabels.plotDataLabelsText({\n            x: currPosX,\n            y: currPosY,\n            text: text,\n            textAnchor: textAnchor,\n            i: i,\n            j: i,\n            parent: elDataLabelsWrap,\n            dataLabelsConfig: dataLabelsConfig,\n            offsetCorrection: false\n          });\n        }\n      });\n      return elDataLabelsWrap;\n    }\n  }, {\n    key: \"createPaths\",\n    value: function createPaths(pos, origin) {\n      var _this4 = this;\n\n      var linePathsTo = [];\n      var linePathsFrom = [];\n      var areaPathsTo = [];\n      var areaPathsFrom = [];\n\n      if (pos.length) {\n        linePathsFrom = [this.graphics.move(origin.x, origin.y)];\n        areaPathsFrom = [this.graphics.move(origin.x, origin.y)];\n        var linePathTo = this.graphics.move(pos[0].x, pos[0].y);\n        var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);\n        pos.forEach(function (p, i) {\n          linePathTo += _this4.graphics.line(p.x, p.y);\n          areaPathTo += _this4.graphics.line(p.x, p.y);\n\n          if (i === pos.length - 1) {\n            linePathTo += 'Z';\n            areaPathTo += 'Z';\n          }\n        });\n        linePathsTo.push(linePathTo);\n        areaPathsTo.push(areaPathTo);\n      }\n\n      return {\n        linePathsFrom: linePathsFrom,\n        linePathsTo: linePathsTo,\n        areaPathsFrom: areaPathsFrom,\n        areaPathsTo: areaPathsTo\n      };\n    }\n  }, {\n    key: \"getPathFrom\",\n    value: function getPathFrom(realIndex) {\n      var w = this.w;\n      var pathFrom = null;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {\n            pathFrom = w.globals.previousPaths[pp].paths[0].d;\n          }\n        }\n      }\n\n      return pathFrom;\n    }\n  }, {\n    key: \"getDataPointsPos\",\n    value: function getDataPointsPos(dataRadiusArr, angleArr) {\n      var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;\n      dataRadiusArr = dataRadiusArr || [];\n      angleArr = angleArr || [];\n      var dataPointsPosArray = [];\n\n      for (var j = 0; j < dataPointsLen; j++) {\n        var curPointPos = {};\n        curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);\n        curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);\n        dataPointsPosArray.push(curPointPos);\n      }\n\n      return dataPointsPosArray;\n    }\n  }, {\n    key: \"getPolygonPos\",\n    value: function getPolygonPos(size) {\n      var dotsArray = [];\n      var angle = Math.PI * 2 / this.dataPointsLen;\n\n      for (var i = 0; i < this.dataPointsLen; i++) {\n        var curPos = {};\n        curPos.x = size * Math.sin(i * angle);\n        curPos.y = -size * Math.cos(i * angle);\n        dotsArray.push(curPos);\n      }\n\n      return dotsArray;\n    }\n  }]);\n\n  return Radar;\n}();\n\n/**\n * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.\n * @module Radial\n **/\n\nvar Radial =\n/*#__PURE__*/\nfunction (_Pie) {\n  _inherits(Radial, _Pie);\n\n  function Radial(ctx) {\n    var _this;\n\n    _classCallCheck(this, Radial);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Radial).call(this, ctx));\n    _this.ctx = ctx;\n    _this.w = ctx.w;\n    _this.animBeginArr = [0];\n    _this.animDur = 0;\n    var w = _this.w;\n    _this.startAngle = w.config.plotOptions.radialBar.startAngle;\n    _this.endAngle = w.config.plotOptions.radialBar.endAngle;\n    _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;\n    _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;\n    _this.radialDataLabels = w.config.plotOptions.radialBar.dataLabels;\n    if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;\n    if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;\n    if (_this.endAngle === 360) _this.endAngle = 359.99;\n    _this.fullAngle = 360 - w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle;\n    _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin);\n    return _this;\n  }\n\n  _createClass(Radial, [{\n    key: \"draw\",\n    value: function draw(series) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var ret = graphics.group({\n        class: 'apexcharts-radialbar'\n      });\n      var elSeries = graphics.group();\n      var centerY = this.defaultSize / 2;\n      var centerX = w.globals.gridWidth / 2;\n      var size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;\n\n      if (w.config.plotOptions.radialBar.size !== undefined) {\n        size = w.config.plotOptions.radialBar.size;\n      }\n\n      var colorArr = w.globals.fill.colors;\n\n      if (w.config.plotOptions.radialBar.track.show) {\n        var elTracks = this.drawTracks({\n          size: size,\n          centerX: centerX,\n          centerY: centerY,\n          colorArr: colorArr,\n          series: series\n        });\n        elSeries.add(elTracks);\n      }\n\n      var elG = this.drawArcs({\n        size: size,\n        centerX: centerX,\n        centerY: centerY,\n        colorArr: colorArr,\n        series: series\n      });\n      elSeries.add(elG.g);\n\n      if (w.config.plotOptions.radialBar.hollow.position === 'front') {\n        elG.g.add(elG.elHollow);\n\n        if (elG.dataLabels) {\n          elG.g.add(elG.dataLabels);\n        }\n      }\n\n      ret.add(elSeries);\n      return ret;\n    }\n  }, {\n    key: \"drawTracks\",\n    value: function drawTracks(opts) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var g = graphics.group();\n      var filters = new Filters(this.ctx);\n      var fill = new Fill(this.ctx);\n      var strokeWidth = this.getStrokeWidth(opts);\n      opts.size = opts.size - strokeWidth / 2;\n\n      for (var i = 0; i < opts.series.length; i++) {\n        var elRadialBarTrack = graphics.group({\n          class: 'apexcharts-radialbar-track apexcharts-track'\n        });\n        g.add(elRadialBarTrack);\n        elRadialBarTrack.attr({\n          id: 'apexcharts-track-' + i,\n          rel: i + 1\n        });\n        opts.size = opts.size - strokeWidth - this.margin;\n        var trackConfig = w.config.plotOptions.radialBar.track;\n        var pathFill = fill.fillPath({\n          seriesNumber: 0,\n          size: opts.size,\n          fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,\n          solid: true\n        });\n        var startAngle = this.trackStartAngle;\n        var endAngle = this.trackEndAngle;\n        if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;\n        var elPath = graphics.drawPath({\n          d: '',\n          stroke: pathFill,\n          strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth) / 100,\n          fill: 'none',\n          strokeOpacity: trackConfig.opacity,\n          classes: 'apexcharts-radialbar-area'\n        });\n\n        if (trackConfig.dropShadow.enabled) {\n          var shadow = trackConfig.dropShadow;\n          filters.dropShadow(elPath, shadow);\n        }\n\n        elRadialBarTrack.add(elPath);\n        elPath.attr('id', 'apexcharts-radialbarTrack-' + i);\n        var pie = new Pie(this.ctx);\n        pie.animatePaths(elPath, {\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          endAngle: endAngle,\n          startAngle: startAngle,\n          size: opts.size,\n          i: i,\n          totalItems: 2,\n          animBeginArr: 0,\n          dur: 0,\n          isTrack: true,\n          easing: w.globals.easing\n        });\n      }\n\n      return g;\n    }\n  }, {\n    key: \"drawArcs\",\n    value: function drawArcs(opts) {\n      var w = this.w; // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series\n\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var filters = new Filters(this.ctx);\n      var g = graphics.group();\n      var strokeWidth = this.getStrokeWidth(opts);\n      opts.size = opts.size - strokeWidth / 2;\n      var hollowFillID = w.config.plotOptions.radialBar.hollow.background;\n      var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth) / 100 / 2;\n      var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;\n\n      if (w.config.plotOptions.radialBar.hollow.image !== undefined) {\n        hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);\n      }\n\n      var elHollow = this.drawHollow({\n        size: hollowRadius,\n        centerX: opts.centerX,\n        centerY: opts.centerY,\n        fill: hollowFillID\n      });\n\n      if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {\n        var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;\n        filters.dropShadow(elHollow, shadow);\n      }\n\n      var shown = 1;\n\n      if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {\n        shown = 0;\n      }\n\n      var pie = new Pie(this.ctx);\n      var dataLabels = null;\n\n      if (this.radialDataLabels.show) {\n        dataLabels = pie.renderInnerDataLabels(this.radialDataLabels, {\n          hollowSize: hollowSize,\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          opacity: shown\n        });\n      }\n\n      if (w.config.plotOptions.radialBar.hollow.position === 'back') {\n        g.add(elHollow);\n\n        if (dataLabels) {\n          g.add(dataLabels);\n        }\n      }\n\n      var reverseLoop = false;\n\n      if (w.config.plotOptions.radialBar.inverseOrder) {\n        reverseLoop = true;\n      }\n\n      for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {\n        var elRadialBarArc = graphics.group({\n          class: \"apexcharts-series apexcharts-radial-series \".concat(Utils.escapeString(w.globals.seriesNames[i]))\n        });\n        g.add(elRadialBarArc);\n        elRadialBarArc.attr({\n          id: 'apexcharts-series-' + i,\n          rel: i + 1\n        });\n        this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);\n        opts.size = opts.size - strokeWidth - this.margin;\n        var pathFill = fill.fillPath({\n          seriesNumber: i,\n          size: opts.size\n        });\n        var startAngle = this.startAngle;\n        var prevStartAngle = void 0;\n        var totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle); // if data exceeds 100, make it 100\n\n        var dataValue = Utils.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;\n        var endAngle = Math.round(totalAngle * dataValue) + this.startAngle;\n        var prevEndAngle = void 0;\n\n        if (w.globals.dataChanged) {\n          prevStartAngle = this.startAngle;\n          prevEndAngle = Math.round(totalAngle * Utils.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;\n        }\n\n        var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);\n\n        if (currFullAngle >= 360) {\n          endAngle = endAngle - 0.01;\n        }\n\n        var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);\n\n        if (prevFullAngle >= 360) {\n          prevEndAngle = prevEndAngle - 0.01;\n        }\n\n        var angle = endAngle - startAngle;\n        var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;\n        var elPath = graphics.drawPath({\n          d: '',\n          stroke: pathFill,\n          strokeWidth: strokeWidth,\n          fill: 'none',\n          fillOpacity: w.config.fill.opacity,\n          classes: 'apexcharts-radialbar-area',\n          strokeDashArray: dashArray\n        });\n        Graphics.setAttrs(elPath.node, {\n          'data:angle': angle,\n          'data:value': opts.series[i]\n        });\n\n        if (w.config.chart.dropShadow.enabled) {\n          var _shadow = w.config.chart.dropShadow;\n          filters.dropShadow(elPath, _shadow);\n        }\n\n        this.addListeners(elPath, this.radialDataLabels);\n\n        var _pie = new Pie(this.ctx);\n\n        elRadialBarArc.add(elPath);\n        elPath.attr({\n          id: 'apexcharts-radialArc-' + i,\n          index: 0,\n          j: i\n        });\n        var dur = 0;\n\n        if (_pie.initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.speed;\n          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        }\n\n        if (w.globals.dataChanged) {\n          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.dynamicAnimation.speed;\n          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;\n          this.animBeginArr.push(this.animDur);\n        }\n\n        _pie.animatePaths(elPath, {\n          centerX: opts.centerX,\n          centerY: opts.centerY,\n          endAngle: endAngle,\n          startAngle: startAngle,\n          prevEndAngle: prevEndAngle,\n          prevStartAngle: prevStartAngle,\n          size: opts.size,\n          i: i,\n          totalItems: 2,\n          animBeginArr: this.animBeginArr,\n          dur: dur,\n          shouldSetPrevPaths: true,\n          easing: w.globals.easing\n        });\n      }\n\n      return {\n        g: g,\n        elHollow: elHollow,\n        dataLabels: dataLabels\n      };\n    }\n  }, {\n    key: \"drawHollow\",\n    value: function drawHollow(opts) {\n      var graphics = new Graphics(this.ctx);\n      var circle = graphics.drawCircle(opts.size * 2);\n      circle.attr({\n        class: 'apexcharts-radialbar-hollow',\n        cx: opts.centerX,\n        cy: opts.centerY,\n        r: opts.size,\n        fill: opts.fill\n      });\n      return circle;\n    }\n  }, {\n    key: \"drawHollowImage\",\n    value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {\n      var w = this.w;\n      var fill = new Fill(this.ctx);\n      var randID = (Math.random() + 1).toString(36).substring(4);\n      var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;\n\n      if (w.config.plotOptions.radialBar.hollow.imageClipped) {\n        fill.clippedImgArea({\n          width: hollowSize,\n          height: hollowSize,\n          image: hollowFillImg,\n          patternID: \"pattern\".concat(w.globals.cuid).concat(randID)\n        });\n        hollowFillID = \"url(#pattern\".concat(w.globals.cuid).concat(randID, \")\");\n      } else {\n        var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;\n        var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;\n\n        if (imgWidth === undefined && imgHeight === undefined) {\n          var image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n            this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n          });\n          g.add(image);\n        } else {\n          var _image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {\n            this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);\n            this.size(imgWidth, imgHeight);\n          });\n\n          g.add(_image);\n        }\n      }\n\n      return hollowFillID;\n    }\n  }, {\n    key: \"getStrokeWidth\",\n    value: function getStrokeWidth(opts) {\n      var w = this.w;\n      return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size)) / 100 / (opts.series.length + 1) - this.margin;\n    }\n  }]);\n\n  return Radial;\n}(Pie);\n\n/**\n * ApexCharts Line Class responsible for drawing Line / Area Charts.\n * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions\n * @module Line\n **/\n\nvar Line =\n/*#__PURE__*/\nfunction () {\n  function Line(ctx, xyRatios, isPointsChart) {\n    _classCallCheck(this, Line);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.xyRatios = xyRatios;\n    this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;\n    this.scatter = new Scatter(this.ctx);\n    this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;\n    this.yaxisIndex = 0;\n  }\n\n  _createClass(Line, [{\n    key: \"draw\",\n    value: function draw(series, ptype, seriesIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var fill = new Fill(this.ctx);\n      var type = w.globals.comboCharts ? ptype : w.config.chart.type;\n      var ret = graphics.group({\n        class: \"apexcharts-\".concat(type, \"-series apexcharts-plot-series\")\n      });\n      var coreUtils = new CoreUtils(this.ctx, w);\n      series = coreUtils.getLogSeries(series);\n      var yRatio = this.xyRatios.yRatio;\n      yRatio = coreUtils.getLogYRatios(yRatio);\n      var zRatio = this.xyRatios.zRatio;\n      var xRatio = this.xyRatios.xRatio;\n      var baseLineY = this.xyRatios.baseLineY; // push all series in an array, so we can draw in reverse order (for stacked charts)\n\n      var allSeries = [];\n      var prevSeriesY = [];\n      var categoryAxisCorrection = 0;\n\n      for (var i = 0; i < series.length; i++) {\n        // width divided into equal parts\n        var xDivision = w.globals.gridWidth / w.globals.dataPoints;\n        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;\n\n        if (yRatio.length > 1) {\n          this.yaxisIndex = realIndex;\n        }\n\n        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;\n        var yArrj = []; // hold y values of current iterating series\n\n        var xArrj = []; // hold x values of current iterating series\n        // zeroY is the 0 value in y series which can be used in negative charts\n\n        var zeroY = w.globals.gridHeight - baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? baseLineY[this.yaxisIndex] * 2 : 0);\n        var areaBottomY = zeroY;\n\n        if (zeroY > w.globals.gridHeight) {\n          areaBottomY = w.globals.gridHeight;\n        }\n\n        categoryAxisCorrection = xDivision / 2;\n        var x = w.globals.padHorizontal + categoryAxisCorrection;\n        var y = 1;\n\n        if (w.globals.isXNumeric) {\n          x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio;\n        }\n\n        xArrj.push(x);\n        var linePath = void 0,\n            areaPath = void 0,\n            pathFromLine = void 0,\n            pathFromArea = void 0;\n        var linePaths = [];\n        var areaPaths = []; // el to which series will be drawn\n\n        var elSeries = graphics.group({\n          class: \"apexcharts-series \".concat(Utils.escapeString(w.globals.seriesNames[realIndex]))\n        }); // points\n\n        var elPointsMain = graphics.group({\n          class: 'apexcharts-series-markers-wrap'\n        }); // eldatalabels\n\n        var elDataLabelsWrap = graphics.group({\n          class: 'apexcharts-datalabels'\n        });\n        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);\n        var longestSeries = series[i].length === w.globals.dataPoints;\n        elSeries.attr({\n          'data:longestSeries': longestSeries,\n          rel: i + 1,\n          'data:realIndex': realIndex\n        });\n        this.appendPathFrom = true;\n        var pX = x;\n        var pY = void 0;\n        var prevX = pX;\n        var prevY = zeroY; // w.globals.svgHeight;\n\n        var lineYPosition = 0; // the first value in the current series is not null or undefined\n\n        var firstPrevY = this.determineFirstPrevY({\n          i: i,\n          series: series,\n          yRatio: yRatio[this.yaxisIndex],\n          zeroY: zeroY,\n          prevY: prevY,\n          prevSeriesY: prevSeriesY,\n          lineYPosition: lineYPosition\n        });\n        prevY = firstPrevY.prevY;\n        yArrj.push(prevY);\n        pY = prevY;\n\n        if (series[i][0] === null) {\n          // when the first value itself is null, we need to move the pointer to a location where a null value is not found\n          for (var s = 0; s < series[i].length; s++) {\n            if (series[i][s] !== null) {\n              prevX = xDivision * s;\n              prevY = zeroY - series[i][s] / yRatio[this.yaxisIndex];\n              linePath = graphics.move(prevX, prevY);\n              areaPath = graphics.move(prevX, areaBottomY);\n              break;\n            }\n          }\n        } else {\n          linePath = graphics.move(prevX, prevY);\n          areaPath = graphics.move(prevX, areaBottomY) + graphics.line(prevX, prevY);\n        }\n\n        pathFromLine = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);\n        pathFromArea = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);\n\n        if (w.globals.previousPaths.length > 0) {\n          var pathFrom = this.checkPreviousPaths({\n            pathFromLine: pathFromLine,\n            pathFromArea: pathFromArea,\n            realIndex: realIndex\n          });\n          pathFromLine = pathFrom.pathFromLine;\n          pathFromArea = pathFrom.pathFromArea;\n        }\n\n        var iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;\n\n        for (var j = 0; j < iterations; j++) {\n          if (w.globals.isXNumeric) {\n            var sX = w.globals.seriesX[realIndex][j + 1];\n\n            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {\n              /* fix #374 */\n              sX = w.globals.seriesX[realIndex][iterations - 1];\n            }\n\n            x = (sX - w.globals.minX) / xRatio;\n          } else {\n            x = x + xDivision;\n          }\n\n          var minY = Utils.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;\n\n          if (w.config.chart.stacked) {\n            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {\n              lineYPosition = prevSeriesY[i - 1][j + 1];\n            } else {\n              // the first series will not have prevY values\n              lineYPosition = zeroY;\n            }\n\n            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {\n              y = lineYPosition - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;\n            } else {\n              y = lineYPosition - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;\n            }\n          } else {\n            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {\n              y = zeroY - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;\n            } else {\n              y = zeroY - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;\n            }\n          } // push current X\n\n\n          xArrj.push(x); // push current Y that will be used as next series's bottom position\n\n          yArrj.push(y);\n          var calculatedPaths = this.createPaths({\n            series: series,\n            i: i,\n            j: j,\n            x: x,\n            y: y,\n            xDivision: xDivision,\n            pX: pX,\n            pY: pY,\n            areaBottomY: areaBottomY,\n            linePath: linePath,\n            areaPath: areaPath,\n            linePaths: linePaths,\n            areaPaths: areaPaths\n          });\n          areaPaths = calculatedPaths.areaPaths;\n          linePaths = calculatedPaths.linePaths;\n          pX = calculatedPaths.pX;\n          pY = calculatedPaths.pY;\n          areaPath = calculatedPaths.areaPath;\n          linePath = calculatedPaths.linePath;\n\n          if (this.appendPathFrom) {\n            pathFromLine = pathFromLine + graphics.line(x, zeroY);\n            pathFromArea = pathFromArea + graphics.line(x, zeroY);\n          }\n\n          var pointsPos = this.calculatePoints({\n            series: series,\n            x: x,\n            y: y,\n            realIndex: realIndex,\n            i: i,\n            j: j,\n            prevY: prevY,\n            categoryAxisCorrection: categoryAxisCorrection,\n            xRatio: xRatio\n          });\n\n          if (!this.pointsChart) {\n            var markers = new Markers(this.ctx);\n\n            if (w.globals.dataPoints > 1) {\n              elPointsMain.node.classList.add('hidden');\n            }\n\n            var elPointsWrap = markers.plotChartMarkers(pointsPos, realIndex, j + 1);\n\n            if (elPointsWrap !== null) {\n              elPointsMain.add(elPointsWrap);\n            }\n          } else {\n            // scatter / bubble chart points creation\n            this.scatter.draw(elSeries, j, {\n              realIndex: realIndex,\n              pointsPos: pointsPos,\n              zRatio: zRatio,\n              elParent: elPointsMain\n            });\n          }\n\n          var dataLabels = new DataLabels(this.ctx);\n          var drawnLabels = dataLabels.drawDataLabel(pointsPos, realIndex, j + 1);\n\n          if (drawnLabels !== null) {\n            elDataLabelsWrap.add(drawnLabels);\n          }\n        } // push all current y values array to main PrevY Array\n\n\n        prevSeriesY.push(yArrj); // push all x val arrays into main xArr\n\n        w.globals.seriesXvalues[realIndex] = xArrj;\n        w.globals.seriesYvalues[realIndex] = yArrj; // these elements will be shown after area path animation completes\n\n        if (!this.pointsChart) {\n          w.globals.delayedElements.push({\n            el: elPointsMain.node,\n            index: realIndex\n          });\n        }\n\n        var defaultRenderedPathOptions = {\n          i: i,\n          realIndex: realIndex,\n          animationDelay: i,\n          initialSpeed: w.config.chart.animations.speed,\n          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,\n          className: \"apexcharts-\".concat(type),\n          id: \"apexcharts-\".concat(type)\n        };\n\n        if (w.config.stroke.show && !this.pointsChart) {\n          var lineFill = null;\n\n          if (type === 'line') {\n            // fillable lines only for lineChart\n            lineFill = fill.fillPath({\n              seriesNumber: realIndex,\n              i: i\n            });\n          } else {\n            lineFill = w.globals.stroke.colors[realIndex];\n          }\n\n          for (var p = 0; p < linePaths.length; p++) {\n            var renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n              pathFrom: pathFromLine,\n              pathTo: linePaths[p],\n              stroke: lineFill,\n              strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width,\n              strokeLineCap: w.config.stroke.lineCap,\n              fill: 'none'\n            }));\n            elSeries.add(renderedPath);\n          }\n        } // we have drawn the lines, now if it is area chart, we need to fill paths\n\n\n        if (type === 'area') {\n          var pathFill = fill.fillPath({\n            seriesNumber: realIndex\n          });\n\n          for (var _p = 0; _p < areaPaths.length; _p++) {\n            var _renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {\n              pathFrom: pathFromArea,\n              pathTo: areaPaths[_p],\n              stroke: 'none',\n              strokeWidth: 0,\n              strokeLineCap: null,\n              fill: pathFill\n            }));\n\n            elSeries.add(_renderedPath);\n          }\n        }\n\n        elSeries.add(elPointsMain);\n        elSeries.add(elDataLabelsWrap);\n        allSeries.push(elSeries);\n      }\n\n      for (var _s = allSeries.length; _s > 0; _s--) {\n        ret.add(allSeries[_s - 1]);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"createPaths\",\n    value: function createPaths(_ref) {\n      var series = _ref.series,\n          i = _ref.i,\n          j = _ref.j,\n          x = _ref.x,\n          y = _ref.y,\n          pX = _ref.pX,\n          pY = _ref.pY,\n          xDivision = _ref.xDivision,\n          areaBottomY = _ref.areaBottomY,\n          linePath = _ref.linePath,\n          areaPath = _ref.areaPath,\n          linePaths = _ref.linePaths,\n          areaPaths = _ref.areaPaths;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var curve = Array.isArray(w.config.stroke.curve) ? w.config.stroke.curve[i] : w.config.stroke.curve; // logic of smooth curve derived from chartist\n      // CREDITS: https://gionkunz.github.io/chartist-js/\n\n      if (curve === 'smooth') {\n        var length = (x - pX) * 0.35;\n\n        if (w.globals.hasNullValues) {\n          if (series[i][j] !== null) {\n            if (series[i][j + 1] !== null) {\n              linePath = graphics.move(pX, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y);\n              areaPath = graphics.move(pX + 1, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y) + graphics.line(x, areaBottomY) + graphics.line(pX, areaBottomY) + 'z';\n            } else {\n              linePath = graphics.move(pX, pY);\n              areaPath = graphics.move(pX, pY) + 'z';\n            }\n          }\n\n          linePaths.push(linePath);\n          areaPaths.push(areaPath);\n        } else {\n          linePath = linePath + graphics.curve(pX + length, pY, x - length, y, x, y);\n          areaPath = areaPath + graphics.curve(pX + length, pY, x - length, y, x, y);\n        }\n\n        pX = x;\n        pY = y;\n\n        if (j === series[i].length - 2) {\n          // last loop, close path\n          areaPath = areaPath + graphics.curve(pX, pY, x, y, x, areaBottomY) + graphics.move(x, y) + 'z';\n\n          if (!w.globals.hasNullValues) {\n            linePaths.push(linePath);\n            areaPaths.push(areaPath);\n          }\n        }\n      } else {\n        if (series[i][j + 1] === null) {\n          linePath = linePath + graphics.move(x, y);\n          areaPath = areaPath + graphics.line(x - xDivision, areaBottomY) + graphics.move(x, y);\n        }\n\n        if (series[i][j] === null) {\n          linePath = linePath + graphics.move(x, y);\n          areaPath = areaPath + graphics.move(x, areaBottomY);\n        }\n\n        if (curve === 'stepline') {\n          linePath = linePath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n          areaPath = areaPath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');\n        } else if (curve === 'straight') {\n          linePath = linePath + graphics.line(x, y);\n          areaPath = areaPath + graphics.line(x, y);\n        }\n\n        if (j === series[i].length - 2) {\n          // last loop, close path\n          areaPath = areaPath + graphics.line(x, areaBottomY) + graphics.move(x, y) + 'z';\n          linePaths.push(linePath);\n          areaPaths.push(areaPath);\n        }\n      }\n\n      return {\n        linePaths: linePaths,\n        areaPaths: areaPaths,\n        pX: pX,\n        pY: pY,\n        linePath: linePath,\n        areaPath: areaPath\n      };\n    }\n  }, {\n    key: \"calculatePoints\",\n    value: function calculatePoints(_ref2) {\n      var series = _ref2.series,\n          realIndex = _ref2.realIndex,\n          x = _ref2.x,\n          y = _ref2.y,\n          i = _ref2.i,\n          j = _ref2.j,\n          prevY = _ref2.prevY,\n          categoryAxisCorrection = _ref2.categoryAxisCorrection,\n          xRatio = _ref2.xRatio;\n      var w = this.w;\n      var ptX = [];\n      var ptY = [];\n\n      if (j === 0) {\n        var xPT1st = categoryAxisCorrection + w.config.markers.offsetX; // the first point for line series\n        // we need to check whether it's not a time series, because a time series may\n        // start from the middle of the x axis\n\n        if (w.globals.isXNumeric) {\n          xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio + w.config.markers.offsetX;\n        } // push 2 points for the first data values\n\n\n        ptX.push(xPT1st);\n        ptY.push(Utils.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);\n        ptX.push(x + w.config.markers.offsetX);\n        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n      } else {\n        ptX.push(x + w.config.markers.offsetX);\n        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);\n      }\n\n      var pointsPos = {\n        x: ptX,\n        y: ptY\n      };\n      return pointsPos;\n    }\n  }, {\n    key: \"checkPreviousPaths\",\n    value: function checkPreviousPaths(_ref3) {\n      var pathFromLine = _ref3.pathFromLine,\n          pathFromArea = _ref3.pathFromArea,\n          realIndex = _ref3.realIndex;\n      var w = this.w;\n\n      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {\n        var gpp = w.globals.previousPaths[pp];\n\n        if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {\n          if (gpp.type === 'line') {\n            this.appendPathFrom = false;\n            pathFromLine = w.globals.previousPaths[pp].paths[0].d;\n          } else if (gpp.type === 'area') {\n            this.appendPathFrom = false;\n\n            if (w.config.stroke.show) {\n              pathFromLine = w.globals.previousPaths[pp].paths[0].d;\n              pathFromArea = w.globals.previousPaths[pp].paths[1].d;\n            } else {\n              pathFromArea = w.globals.previousPaths[pp].paths[0].d;\n            }\n          }\n        }\n      }\n\n      return {\n        pathFromLine: pathFromLine,\n        pathFromArea: pathFromArea\n      };\n    }\n  }, {\n    key: \"determineFirstPrevY\",\n    value: function determineFirstPrevY(_ref4) {\n      var i = _ref4.i,\n          series = _ref4.series,\n          yRatio = _ref4.yRatio,\n          zeroY = _ref4.zeroY,\n          prevY = _ref4.prevY,\n          prevSeriesY = _ref4.prevSeriesY,\n          lineYPosition = _ref4.lineYPosition;\n      var w = this.w;\n\n      if (typeof series[i][0] !== 'undefined') {\n        if (w.config.chart.stacked) {\n          if (i > 0) {\n            // 1st y value of previous series\n            lineYPosition = prevSeriesY[i - 1][0];\n          } else {\n            // the first series will not have prevY values\n            lineYPosition = zeroY;\n          }\n\n          prevY = lineYPosition - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;\n        } else {\n          prevY = zeroY - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;\n        }\n      } else {\n        // the first value in the current series is null\n        if (w.config.chart.stacked && i > 0 && typeof series[i][0] === 'undefined') {\n          // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)\n          for (var s = i - 1; s >= 0; s--) {\n            // for loop to get to 1st previous value until we get it\n            if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {\n              lineYPosition = prevSeriesY[s][0];\n              prevY = lineYPosition;\n              break;\n            }\n          }\n        }\n      }\n\n      return {\n        prevY: prevY,\n        lineYPosition: lineYPosition\n      };\n    }\n  }]);\n\n  return Line;\n}();\n\n/**\n * ApexCharts YAxis Class for drawing Y-Axis.\n *\n * @module YAxis\n **/\n\nvar YAxis =\n/*#__PURE__*/\nfunction () {\n  function YAxis(ctx) {\n    _classCallCheck(this, YAxis);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.xaxisFontSize = this.w.config.xaxis.labels.style.fontSize;\n    this.axisFontFamily = this.w.config.xaxis.labels.style.fontFamily;\n    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);\n    this.xaxisForeColors = this.w.config.xaxis.labels.style.colors;\n    this.xAxisoffX = 0;\n\n    if (this.w.config.xaxis.position === 'bottom') {\n      this.xAxisoffX = this.w.globals.gridHeight;\n    }\n  }\n\n  _createClass(YAxis, [{\n    key: \"drawYaxis\",\n    value: function drawYaxis(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var yaxisFontSize = w.config.yaxis[realIndex].labels.style.fontSize;\n      var yaxisFontFamily = w.config.yaxis[realIndex].labels.style.fontFamily;\n      var elYaxis = graphics.group({\n        class: 'apexcharts-yaxis',\n        rel: realIndex,\n        transform: 'translate(' + w.globals.translateYAxisX[realIndex] + ', 0)'\n      });\n\n      if (!w.config.yaxis[realIndex].show) {\n        return elYaxis;\n      }\n\n      var elYaxisTexts = graphics.group({\n        class: 'apexcharts-yaxis-texts-g'\n      });\n      elYaxis.add(elYaxisTexts);\n      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg height/number of ticks\n\n      var labelsDivider = w.globals.gridHeight / tickAmount + 0.1; // initial label position = 0;\n\n      var l = w.globals.translateY;\n      var lbFormatter = w.globals.yLabelFormatters[realIndex];\n      var labels = w.globals.yAxisScale[realIndex].result.slice();\n\n      if (w.config.yaxis[realIndex].reversed) {\n        labels.reverse();\n      }\n\n      if (w.config.yaxis[realIndex].labels.show) {\n        for (var i = tickAmount; i >= 0; i--) {\n          var val = labels[i];\n          val = lbFormatter(val, i);\n          var xPad = w.config.yaxis[realIndex].labels.padding;\n\n          if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) {\n            xPad = xPad * -1;\n          }\n\n          var label = graphics.drawText({\n            x: xPad,\n            y: l + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY + 1,\n            text: val,\n            textAnchor: w.config.yaxis[realIndex].opposite ? 'start' : 'end',\n            fontSize: yaxisFontSize,\n            fontFamily: yaxisFontFamily,\n            foreColor: w.config.yaxis[realIndex].labels.style.color,\n            cssClass: 'apexcharts-yaxis-label ' + w.config.yaxis[realIndex].labels.style.cssClass\n          });\n          elYaxisTexts.add(label);\n          var labelRotatingCenter = graphics.rotateAroundCenter(label.node);\n\n          if (w.config.yaxis[realIndex].labels.rotate !== 0) {\n            label.node.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].labels.rotate, \" \").concat(labelRotatingCenter.x, \" \").concat(labelRotatingCenter.y, \")\"));\n          }\n\n          l = l + labelsDivider;\n        }\n      }\n\n      if (w.config.yaxis[realIndex].title.text !== undefined) {\n        var elYaxisTitle = graphics.group({\n          class: 'apexcharts-yaxis-title'\n        });\n        var x = 0;\n\n        if (w.config.yaxis[realIndex].opposite) {\n          x = w.globals.translateYAxisX[realIndex];\n        }\n\n        var elYAxisTitleText = graphics.drawText({\n          x: x,\n          y: w.globals.gridHeight / 2 + w.globals.translateY,\n          text: w.config.yaxis[realIndex].title.text,\n          textAnchor: 'end',\n          foreColor: w.config.yaxis[realIndex].title.style.color,\n          fontSize: w.config.yaxis[realIndex].title.style.fontSize,\n          fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,\n          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[realIndex].title.style.cssClass\n        });\n        elYaxisTitle.add(elYAxisTitleText);\n        elYaxis.add(elYaxisTitle);\n      }\n\n      var axisBorder = w.config.yaxis[realIndex].axisBorder;\n\n      if (axisBorder.show) {\n        var _x = 31 + axisBorder.offsetX;\n\n        if (w.config.yaxis[realIndex].opposite) {\n          _x = -31 - axisBorder.offsetX;\n        }\n\n        var elVerticalLine = graphics.drawLine(_x, w.globals.translateY + axisBorder.offsetY - 2, _x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color);\n        elYaxis.add(elVerticalLine);\n        this.drawAxisTicks(_x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);\n      }\n\n      return elYaxis;\n    } // This actually becomes horizonal axis (for bar charts)\n\n  }, {\n    key: \"drawYaxisInversed\",\n    value: function drawYaxisInversed(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var elXaxis = graphics.group({\n        class: 'apexcharts-xaxis apexcharts-yaxis-inversed'\n      });\n      var elXaxisTexts = graphics.group({\n        class: 'apexcharts-xaxis-texts-g',\n        transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n      });\n      elXaxis.add(elXaxisTexts);\n      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg width/number of ticks\n\n      var labelsDivider = w.globals.gridWidth / tickAmount + 0.1; // initial label position;\n\n      var l = labelsDivider + w.config.xaxis.labels.offsetX;\n      var lbFormatter = w.globals.xLabelFormatter;\n      var labels = w.globals.yAxisScale[realIndex].result.slice();\n\n      if (w.config.yaxis[realIndex].reversed) {\n        labels.reverse();\n      }\n\n      if (w.config.xaxis.labels.show) {\n        for (var i = tickAmount; i >= 0; i--) {\n          var val = labels[i];\n          val = lbFormatter(val, i);\n          var elTick = graphics.drawText({\n            x: w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX),\n            y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30,\n            text: '',\n            textAnchor: 'middle',\n            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,\n            fontSize: this.xaxisFontSize,\n            fontFamily: this.xaxisFontFamily,\n            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass\n          });\n          elXaxisTexts.add(elTick);\n          elTick.tspan(val);\n          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n          elTooltipTitle.textContent = val;\n          elTick.node.appendChild(elTooltipTitle);\n          l = l + labelsDivider;\n        }\n      }\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var elYaxisTitle = graphics.group({\n          class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'\n        });\n        var elYAxisTitleText = graphics.drawText({\n          x: w.globals.gridWidth / 2,\n          y: this.xAxisoffX + parseInt(this.xaxisFontSize) + parseInt(w.config.xaxis.title.style.fontSize) + 20,\n          text: w.config.xaxis.title.text,\n          textAnchor: 'middle',\n          fontSize: w.config.xaxis.title.style.fontSize,\n          fontFamily: w.config.xaxis.title.style.fontFamily,\n          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n        });\n        elYaxisTitle.add(elYAxisTitleText);\n        elXaxis.add(elYaxisTitle);\n      }\n\n      var axisBorder = w.config.yaxis[realIndex].axisBorder;\n\n      if (axisBorder.show) {\n        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color);\n        elXaxis.add(elVerticalLine);\n      }\n\n      return elXaxis;\n    }\n  }, {\n    key: \"drawAxisTicks\",\n    value: function drawAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx); // initial label position = 0;\n\n      var t = w.globals.translateY;\n\n      if (axisTicks.show) {\n        if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;\n\n        for (var i = tickAmount; i >= 0; i--) {\n          var tY = t + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY - 1;\n\n          if (this.isBarHorizontal) {\n            tY = labelsDivider * i;\n          }\n\n          var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisBorder.color);\n          elYaxis.add(elTick);\n          t = t + labelsDivider;\n        }\n      }\n    }\n  }, {\n    key: \"yAxisTitleRotate\",\n    value: function yAxisTitleRotate(realIndex, yAxisOpposite) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var yAxisLabelsCoord = {\n        width: 0,\n        height: 0\n      };\n      var yAxisTitleCoord = {\n        width: 0,\n        height: 0\n      };\n      var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(\" .apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-texts-g\"));\n\n      if (elYAxisLabelsWrap !== null) {\n        yAxisLabelsCoord = elYAxisLabelsWrap.getBoundingClientRect();\n      }\n\n      var yAxisTitle = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxis[rel='\".concat(realIndex, \"'] .apexcharts-yaxis-title text\"));\n\n      if (yAxisTitle !== null) {\n        yAxisTitleCoord = yAxisTitle.getBoundingClientRect();\n      }\n\n      if (yAxisTitle !== null) {\n        var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);\n        yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));\n      }\n\n      if (yAxisTitle !== null) {\n        var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);\n\n        if (!yAxisOpposite) {\n          yAxisTitle.setAttribute('transform', \"rotate(-\".concat(w.config.yaxis[realIndex].title.rotate, \" \").concat(titleRotatingCenter.x, \" \").concat(titleRotatingCenter.y, \")\"));\n        } else {\n          yAxisTitle.setAttribute('transform', \"rotate(\".concat(w.config.yaxis[realIndex].title.rotate, \" \").concat(titleRotatingCenter.x, \" \").concat(titleRotatingCenter.y, \")\"));\n        }\n      }\n    }\n  }, {\n    key: \"xPaddingForYAxisTitle\",\n    value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {\n      var w = this.w;\n      var oppositeAxisCount = 0;\n      var x = 0;\n      var padd = 10;\n\n      if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {\n        return {\n          xPos: x,\n          padd: 0\n        };\n      }\n\n      if (yAxisOpposite) {\n        x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;\n        oppositeAxisCount += 1;\n\n        if (oppositeAxisCount === 0) {\n          x = x - padd / 2;\n        }\n      } else {\n        x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;\n\n        if (this.isBarHorizontal) {\n          padd = 25;\n          x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;\n        }\n      }\n\n      return {\n        xPos: x,\n        padd: padd\n      };\n    } // sets the x position of the y-axis by counting the labels width, title width and any offset\n\n  }, {\n    key: \"setYAxisXPosition\",\n    value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {\n      var _this = this;\n\n      var w = this.w;\n      var xLeft = 0;\n      var xRight = 0;\n      var leftOffsetX = 21;\n      var rightOffsetX = 1;\n\n      if (w.config.yaxis.length > 1) {\n        this.multipleYs = true;\n      }\n\n      w.config.yaxis.map(function (yaxe, index) {\n        var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.indexOf(index) > -1 || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;\n        var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;\n\n        if (!yaxe.opposite) {\n          xLeft = w.globals.translateX - leftOffsetX;\n\n          if (!shouldNotDrawAxis) {\n            leftOffsetX = leftOffsetX + axisWidth + 20;\n          }\n\n          w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;\n        } else {\n          if (_this.isBarHorizontal) {\n            xRight = w.globals.gridWidth + w.globals.translateX - 1;\n            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;\n          } else {\n            xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;\n\n            if (!shouldNotDrawAxis) {\n              rightOffsetX = rightOffsetX + axisWidth + 20;\n            }\n\n            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;\n          }\n        }\n      });\n    }\n  }]);\n\n  return YAxis;\n}();\n\n/**\n * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.\n *\n * @module Formatters\n **/\n\nvar Formatters =\n/*#__PURE__*/\nfunction () {\n  function Formatters(ctx) {\n    _classCallCheck(this, Formatters);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.tooltipKeyFormat = 'dd MMM';\n  }\n\n  _createClass(Formatters, [{\n    key: \"xLabelFormat\",\n    value: function xLabelFormat(fn, val) {\n      var w = this.w;\n\n      if (w.config.xaxis.type === 'datetime') {\n        // if user has not specified a custom formatter, use the default tooltip.x.format\n        if (w.config.tooltip.x.formatter === undefined) {\n          var datetimeObj = new DateTime(this.ctx);\n          return datetimeObj.formatDate(new Date(val), w.config.tooltip.x.format, true, true);\n        }\n      }\n\n      return fn(val);\n    }\n  }, {\n    key: \"setLabelFormatters\",\n    value: function setLabelFormatters() {\n      var w = this.w;\n\n      w.globals.xLabelFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.xaxisTooltipFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.ttKeyFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.ttZFormatter = function (val) {\n        return val;\n      };\n\n      w.globals.legendFormatter = function (val) {\n        return val;\n      };\n\n      if (typeof w.config.tooltip.x.formatter === 'function') {\n        w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;\n      }\n\n      if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n        w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;\n      }\n\n      if (Array.isArray(w.config.tooltip.y)) {\n        w.globals.ttVal = w.config.tooltip.y;\n      } else {\n        if (w.config.tooltip.y.formatter !== undefined) {\n          w.globals.ttVal = w.config.tooltip.y;\n        }\n      }\n\n      if (w.config.tooltip.z.formatter !== undefined) {\n        w.globals.ttZFormatter = w.config.tooltip.z.formatter;\n      } // legend formatter - if user wants to append any global values of series to legend text\n\n\n      if (w.config.legend.formatter !== undefined) {\n        w.globals.legendFormatter = w.config.legend.formatter;\n      } // formatter function will always overwrite format property\n\n\n      if (w.config.xaxis.labels.formatter !== undefined) {\n        w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;\n      } else {\n        w.globals.xLabelFormatter = function (val) {\n          if (Utils.isNumber(val)) {\n            // numeric xaxis may have smaller range, so defaulting to 1 decimal\n            if (w.config.xaxis.type === 'numeric' && w.globals.dataPoints < 50) {\n              return val.toFixed(1);\n            }\n\n            return val.toFixed(0);\n          }\n\n          return val;\n        };\n      } // formatter function will always overwrite format property\n\n\n      w.config.yaxis.forEach(function (yaxe, i) {\n        if (yaxe.labels.formatter !== undefined) {\n          w.globals.yLabelFormatters[i] = yaxe.labels.formatter;\n        } else {\n          w.globals.yLabelFormatters[i] = function (val) {\n            if (Utils.isNumber(val)) {\n              if (w.globals.yValueDecimal !== 0 || w.globals.maxY - w.globals.minY < 1) {\n                return val.toFixed(yaxe.decimalsInFloat);\n              } else {\n                return val.toFixed(0);\n              }\n            }\n\n            return val;\n          };\n        }\n      });\n      return w.globals;\n    }\n  }, {\n    key: \"heatmapLabelFormatters\",\n    value: function heatmapLabelFormatters() {\n      var w = this.w;\n\n      if (w.config.chart.type === 'heatmap') {\n        w.globals.yAxisScale[0].result = w.globals.seriesNames.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n        var longest = w.globals.seriesNames.reduce(function (a, b) {\n          return a.length > b.length ? a : b;\n        }, 0);\n        w.globals.yAxisScale[0].niceMax = longest;\n        w.globals.yAxisScale[0].niceMin = longest;\n      }\n    }\n  }]);\n\n  return Formatters;\n}();\n\n/**\n * ApexCharts XAxis Class for drawing X-Axis.\n *\n * @module XAxis\n **/\n\nvar XAxis =\n/*#__PURE__*/\nfunction () {\n  function XAxis(ctx) {\n    _classCallCheck(this, XAxis);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.xaxisLabels = w.globals.labels.slice();\n\n    if (w.globals.timelineLabels.length > 0) {\n      //  timeline labels are there\n      this.xaxisLabels = w.globals.timelineLabels.slice();\n    }\n\n    this.drawnLabels = [];\n\n    if (w.config.xaxis.position === 'top') {\n      this.offY = 0;\n    } else {\n      this.offY = w.globals.gridHeight + 1;\n    }\n\n    this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;\n    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;\n    this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;\n    this.xaxisForeColors = w.config.xaxis.labels.style.colors;\n    this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;\n\n    if (this.xaxisBorderWidth.indexOf('%') > -1) {\n      this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth) / 100;\n    } else {\n      this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth);\n    }\n\n    this.xaxisBorderHeight = w.config.xaxis.axisBorder.height; // For bars, we will only consider single y xais,\n    // as we are not providing multiple yaxis for bar charts\n\n    this.yaxis = w.config.yaxis[0];\n  }\n\n  _createClass(XAxis, [{\n    key: \"drawXaxis\",\n    value: function drawXaxis() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var elXaxis = graphics.group({\n        class: 'apexcharts-xaxis',\n        transform: \"translate(\".concat(w.config.xaxis.offsetX, \", \").concat(w.config.xaxis.offsetY, \")\")\n      });\n      var elXaxisTexts = graphics.group({\n        class: 'apexcharts-xaxis-texts-g',\n        transform: \"translate(\".concat(w.globals.translateXAxisX, \", \").concat(w.globals.translateXAxisY, \")\")\n      });\n      elXaxis.add(elXaxisTexts);\n      var colWidth; // initial x Position (keep adding column width in the loop)\n\n      var xPos = w.globals.padHorizontal;\n      var labels = [];\n\n      for (var i = 0; i < this.xaxisLabels.length; i++) {\n        labels.push(this.xaxisLabels[i]);\n      }\n\n      if (w.globals.isXNumeric) {\n        colWidth = w.globals.gridWidth / (labels.length - 1);\n        xPos = xPos + colWidth / 2 + w.config.xaxis.labels.offsetX;\n      } else {\n        colWidth = w.globals.gridWidth / labels.length;\n        xPos = xPos + colWidth + w.config.xaxis.labels.offsetX;\n      }\n\n      var xlbFormatter = w.globals.xLabelFormatter;\n      var customFormatter = w.config.xaxis.labels.formatter;\n      var labelsLen = labels.length;\n\n      if (w.config.xaxis.labels.show) {\n        for (var _i = 0; _i <= labelsLen - 1; _i++) {\n          var rawLabel = typeof labels[_i] === 'undefined' ? '' : labels[_i];\n          var label = void 0;\n          var xFormat = new Formatters(this.ctx);\n          label = xFormat.xLabelFormat(xlbFormatter, rawLabel);\n\n          if (customFormatter !== undefined) {\n            label = customFormatter(rawLabel, this.xaxisLabels[_i], _i);\n          }\n\n          var x = xPos - colWidth / 2 + w.config.xaxis.labels.offsetX;\n\n          if (w.globals.timelineLabels.length > 0) {\n            x = w.globals.timelineLabels[_i].position;\n            label = w.globals.timelineLabels[_i].value;\n          } else {\n            if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {\n              label = '';\n            }\n          }\n\n          label = label.toString();\n\n          if (label.indexOf('NaN') === 0 || label === 'undefined' || label.toLowerCase().indexOf('invalid') === 0 || label.toLowerCase().indexOf('infinity') >= 0 || this.drawnLabels.indexOf(label) >= 0 && !w.config.xaxis.labels.showDuplicates) {\n            label = '';\n          }\n\n          this.drawnLabels.push(label);\n          var offsetYCorrection = 28;\n\n          if (w.globals.rotateXLabels) {\n            offsetYCorrection = 22;\n          }\n\n          var elTick = graphics.drawText({\n            x: x,\n            y: this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection,\n            text: '',\n            textAnchor: 'middle',\n            fontSize: this.xaxisFontSize,\n            fontFamily: this.xaxisFontFamily,\n            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[_i] : this.xaxisForeColors,\n            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass\n          });\n          elXaxisTexts.add(elTick);\n          graphics.addTspan(elTick, label, this.xaxisFontFamily);\n          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');\n          elTooltipTitle.textContent = label;\n          elTick.node.appendChild(elTooltipTitle);\n          xPos = xPos + colWidth;\n        }\n      }\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var elXaxisTitle = graphics.group({\n          class: 'apexcharts-xaxis-title'\n        });\n        var elXAxisTitleText = graphics.drawText({\n          x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,\n          y: this.offY - parseInt(this.xaxisFontSize) + w.globals.xAxisLabelsHeight + w.config.xaxis.title.offsetY,\n          text: w.config.xaxis.title.text,\n          textAnchor: 'middle',\n          fontSize: w.config.xaxis.title.style.fontSize,\n          fontFamily: w.config.xaxis.title.style.fontFamily,\n          foreColor: w.config.xaxis.title.style.color,\n          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass\n        });\n        elXaxisTitle.add(elXAxisTitleText);\n        elXaxis.add(elXaxisTitle);\n      }\n\n      if (w.config.xaxis.axisBorder.show) {\n        var lineCorrection = 0;\n\n        if (w.config.chart.type === 'bar' && w.globals.isXNumeric) {\n          lineCorrection = lineCorrection - 15;\n        }\n\n        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);\n        elXaxis.add(elHorzLine);\n      }\n\n      return elXaxis;\n    } // this actually becomes the vertical axis (for bar charts)\n\n  }, {\n    key: \"drawXaxisInversed\",\n    value: function drawXaxisInversed(realIndex) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;\n      var elYaxis = graphics.group({\n        class: 'apexcharts-yaxis apexcharts-xaxis-inversed',\n        rel: realIndex\n      });\n      var elYaxisTexts = graphics.group({\n        class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',\n        transform: 'translate(' + translateYAxisX + ', 0)'\n      });\n      elYaxis.add(elYaxisTexts);\n      var colHeight; // initial x Position (keep adding column width in the loop)\n\n      var yPos;\n      var labels = [];\n\n      for (var i = 0; i < this.xaxisLabels.length; i++) {\n        labels.push(this.xaxisLabels[i]);\n      }\n\n      colHeight = w.globals.gridHeight / labels.length;\n      yPos = -(colHeight / 2.2);\n      var lbFormatter = w.globals.yLabelFormatters[0];\n      var ylabels = w.config.yaxis[0].labels;\n\n      if (ylabels.show) {\n        for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {\n          var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];\n          label = lbFormatter(label);\n          var elLabel = graphics.drawText({\n            x: ylabels.offsetX - 15,\n            y: yPos + colHeight + ylabels.offsetY,\n            text: label,\n            textAnchor: this.yaxis.opposite ? 'start' : 'end',\n            foreColor: ylabels.style.color ? ylabels.style.color : ylabels.style.colors[_i2],\n            fontSize: ylabels.style.fontSize,\n            fontFamily: ylabels.style.fontFamily,\n            cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass\n          }); // let labelRotatingCenter = graphics.rotateAroundCenter(elLabel.node)\n          // if (ylabels.rotate !== 0) {\n          //   elLabel.node.setAttribute(\n          //     'transform',\n          //     `rotate(${ylabels.rotate} ${labelRotatingCenter.x} ${labelRotatingCenter.y})`\n          //   )\n          // }\n\n          elYaxisTexts.add(elLabel);\n          yPos = yPos + colHeight;\n        }\n      }\n\n      if (w.config.yaxis[0].title.text !== undefined) {\n        var elXaxisTitle = graphics.group({\n          class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',\n          transform: 'translate(' + translateYAxisX + ', 0)'\n        });\n        var elXAxisTitleText = graphics.drawText({\n          x: 0,\n          y: w.globals.gridHeight / 2,\n          text: w.config.yaxis[0].title.text,\n          textAnchor: 'middle',\n          foreColor: w.config.yaxis[0].title.style.color,\n          fontSize: w.config.yaxis[0].title.style.fontSize,\n          fontFamily: w.config.yaxis[0].title.style.fontFamily,\n          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass\n        });\n        elXaxisTitle.add(elXAxisTitleText);\n        elYaxis.add(elXaxisTitle);\n      }\n\n      if (w.config.xaxis.axisBorder.show) {\n        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, this.yaxis.axisBorder.color, 0, this.xaxisBorderHeight);\n        elYaxis.add(elHorzLine); // let x = w.globals.yAxisWidths[0] / 2\n        // if (w.config.yaxis[0].opposite) {\n        //   x = -w.globals.yAxisWidths[0] / 2\n        // }\n\n        var yaxis = new YAxis(this.ctx);\n        yaxis.drawAxisTicks(0, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);\n      }\n\n      return elYaxis;\n    }\n  }, {\n    key: \"drawXaxisTicks\",\n    value: function drawXaxisTicks(x1, appendToElement) {\n      var w = this.w;\n      var x2 = x1;\n      if (x1 < 0 || x1 > w.globals.gridWidth) return;\n      var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;\n      var y2 = y1 + w.config.xaxis.axisTicks.height;\n\n      if (w.config.xaxis.axisTicks.show) {\n        var graphics = new Graphics(this.ctx);\n        var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color); // we are not returning anything, but appending directly to the element pased in param\n\n        appendToElement.add(line);\n        line.node.classList.add('apexcharts-xaxis-tick');\n      }\n    }\n  }, {\n    key: \"getXAxisTicksPositions\",\n    value: function getXAxisTicksPositions() {\n      var w = this.w;\n      var xAxisTicksPositions = [];\n      var xCount = this.xaxisLabels.length;\n      var x1 = w.globals.padHorizontal;\n\n      if (w.globals.timelineLabels.length > 0) {\n        for (var i = 0; i < xCount; i++) {\n          x1 = this.xaxisLabels[i].position;\n          xAxisTicksPositions.push(x1);\n        }\n      } else {\n        var xCountForCategoryCharts = xCount;\n\n        for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {\n          var x1Count = xCountForCategoryCharts;\n\n          if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {\n            x1Count -= 1;\n          }\n\n          x1 = x1 + w.globals.gridWidth / x1Count;\n          xAxisTicksPositions.push(x1);\n        }\n      }\n\n      return xAxisTicksPositions;\n    } // to rotate x-axis labels or to put ... for longer text in xaxis\n\n  }, {\n    key: \"xAxisLabelCorrections\",\n    value: function xAxisLabelCorrections() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');\n      var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text');\n      var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');\n      var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text');\n\n      if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {\n        for (var xat = 0; xat < xAxisTexts.length; xat++) {\n          var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);\n          textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;\n\n          textRotatingCenter.x = textRotatingCenter.x + 1;\n          xAxisTexts[xat].setAttribute('transform', \"rotate(\".concat(w.config.xaxis.labels.rotate, \" \").concat(textRotatingCenter.x, \" \").concat(textRotatingCenter.y, \")\"));\n          xAxisTexts[xat].setAttribute('text-anchor', \"end\");\n          var offsetHeight = 10;\n          xAxis.setAttribute('transform', \"translate(0, \".concat(-offsetHeight, \")\"));\n          var tSpan = xAxisTexts[xat].childNodes;\n\n          if (w.config.xaxis.labels.trim) {\n            graphics.placeTextWithEllipsis(tSpan[0], tSpan[0].textContent, w.config.xaxis.labels.maxHeight - 40);\n          }\n        }\n      } else {\n        var width = w.globals.gridWidth / w.globals.labels.length;\n\n        for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {\n          var _tSpan = xAxisTexts[_xat].childNodes;\n\n          if (w.config.xaxis.labels.trim && w.config.chart.type !== 'bar' && w.config.plotOptions.bar.horizontal) {\n            graphics.placeTextWithEllipsis(_tSpan[0], _tSpan[0].textContent, width);\n          }\n        }\n      }\n\n      if (yAxisTextsInversed.length > 0) {\n        // truncate rotated y axis in bar chart (x axis)\n        var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();\n        var lastLabelPosX = yAxisTextsInversed[0].getBBox();\n\n        if (firstLabelPosX.x < -20) {\n          yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);\n        }\n\n        if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth) {\n          yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);\n        } // truncate rotated x axis in bar chart (y axis)\n\n\n        for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {\n          graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - parseInt(w.config.yaxis[0].title.style.fontSize) * 2 - 20);\n        }\n      }\n    } // renderXAxisBands() {\n    //   let w = this.w;\n    //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')\n    //   w.globals.dom.elGraphical.add(plotBand)\n    // }\n\n  }]);\n\n  return XAxis;\n}();\n\nvar Range =\n/*#__PURE__*/\nfunction () {\n  function Range(ctx) {\n    _classCallCheck(this, Range);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);\n  } // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axiss\n  // This routine creates the Y axis values for a graph.\n\n\n  _createClass(Range, [{\n    key: \"niceScale\",\n    value: function niceScale(yMin, yMax) {\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var ticks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n\n      if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils.isNumber(yMin) && !Utils.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {\n        // when all values are 0\n        yMin = 0;\n        yMax = ticks;\n        var linearScale = this.linearScale(yMin, yMax, ticks);\n        return linearScale;\n      }\n\n      if (yMin > yMax) {\n        // if somehow due to some wrong config, user sent max less than min,\n        // adjust the min/max again\n        console.warn('yaxis.min cannot be greater than yaxis.max');\n        yMax = yMin + 0.1;\n      } else if (yMin === yMax) {\n        // If yMin and yMax are identical, then\n        // adjust the yMin and yMax values to actually\n        // make a graph. Also avoids division by zero errors.\n        yMin = yMin === 0 ? 0 : yMin - 0.1; // some small value\n\n        yMax = yMax === 0 ? 2 : yMax + 0.1; // some small value\n      } // Calculate Min amd Max graphical labels and graph\n      // increments.  The number of ticks defaults to\n      // 10 which is the SUGGESTED value.  Any tick value\n      // entered is used as a suggested value which is\n      // adjusted to be a 'pretty' value.\n      //\n      // Output will be an array of the Y axis values that\n      // encompass the Y values.\n\n\n      var result = []; // Determine Range\n\n      var range = yMax - yMin;\n      var tiks = ticks + 1; // Adjust ticks if needed\n\n      if (tiks < 2) {\n        tiks = 2;\n      } else if (tiks > 2) {\n        tiks -= 2;\n      } // Get raw step value\n\n\n      var tempStep = range / tiks; // Calculate pretty step value\n\n      var mag = Math.floor(Utils.log10(tempStep));\n      var magPow = Math.pow(10, mag);\n      var magMsd = parseInt(tempStep / magPow);\n      var stepSize = magMsd * magPow; // build Y label array.\n      // Lower and upper bounds calculations\n\n      var lb = stepSize * Math.floor(yMin / stepSize);\n      var ub = stepSize * Math.ceil(yMax / stepSize); // Build array\n\n      var val = lb;\n\n      while (1) {\n        result.push(val);\n        val += stepSize;\n\n        if (val > ub) {\n          break;\n        }\n      } // TODO: need to remove this condition below which makes this function tightly coupled with w.\n\n\n      if (this.w.config.yaxis[index].max === undefined && this.w.config.yaxis[index].min === undefined || this.w.config.yaxis[index].forceNiceScale) {\n        return {\n          result: result,\n          niceMin: result[0],\n          niceMax: result[result.length - 1]\n        };\n      } else {\n        result = [];\n        var v = yMin;\n        result.push(v);\n        var valuesDivider = Math.abs(yMax - yMin) / ticks;\n\n        for (var i = 0; i <= ticks - 1; i++) {\n          v = v + valuesDivider;\n          result.push(v);\n        }\n\n        return {\n          result: result,\n          niceMin: result[0],\n          niceMax: result[result.length - 1]\n        };\n      }\n    }\n  }, {\n    key: \"linearScale\",\n    value: function linearScale(yMin, yMax) {\n      var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      var range = Math.abs(yMax - yMin);\n      var step = range / ticks;\n\n      if (ticks === Number.MAX_VALUE) {\n        ticks = 10;\n        step = 1;\n      }\n\n      var result = [];\n      var v = yMin;\n\n      while (ticks >= 0) {\n        result.push(v);\n        v = v + step;\n        ticks -= 1;\n      }\n\n      return {\n        result: result,\n        niceMin: result[0],\n        niceMax: result[result.length - 1]\n      };\n    }\n  }, {\n    key: \"logarithmicScale\",\n    value: function logarithmicScale(index, yMin, yMax, ticks) {\n      if (yMin < 0 || yMin === Number.MIN_VALUE) yMin = 0.01;\n      var base = 10;\n      var min = Math.log(yMin) / Math.log(base);\n      var max = Math.log(yMax) / Math.log(base);\n      var range = Math.abs(yMax - yMin);\n      var step = range / ticks;\n      var result = [];\n      var v = yMin;\n\n      while (ticks >= 0) {\n        result.push(v);\n        v = v + step;\n        ticks -= 1;\n      }\n\n      var logs = result.map(function (niceNumber, i) {\n        if (niceNumber <= 0) {\n          niceNumber = 0.01;\n        } // calculate adjustment factor\n\n\n        var scale = (max - min) / (yMax - yMin);\n        var logVal = Math.pow(base, min + scale * (niceNumber - min));\n        return Math.round(logVal / Utils.roundToBase(logVal, base)) * Utils.roundToBase(logVal, base);\n      }); // Math.floor may have rounded the value to 0, revert back to 1\n\n      if (logs[0] === 0) logs[0] = 1;\n      return {\n        result: logs,\n        niceMin: logs[0],\n        niceMax: logs[logs.length - 1]\n      };\n    }\n  }, {\n    key: \"setYScaleForIndex\",\n    value: function setYScaleForIndex(index, minY, maxY) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var y = this.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];\n\n      if (typeof gl.yAxisScale[index] === 'undefined') {\n        gl.yAxisScale[index] = [];\n      }\n\n      if (y.logarithmic) {\n        gl.allSeriesCollapsed = false;\n        gl.yAxisScale[index] = this.logarithmicScale(index, minY, maxY, y.tickAmount ? y.tickAmount : Math.floor(Math.log10(maxY)));\n      } else {\n        if (maxY === -Number.MAX_VALUE || !Utils.isNumber(maxY)) {\n          // no data in the chart. Either all series collapsed or user passed a blank array\n          gl.yAxisScale[index] = this.linearScale(0, 5, 5);\n        } else {\n          // there is some data. Turn off the allSeriesCollapsed flag\n          gl.allSeriesCollapsed = false;\n          gl.yAxisScale[index] = this.niceScale(minY, maxY, index, y.tickAmount ? y.tickAmount : 5);\n        }\n      }\n    }\n  }, {\n    key: \"setMultipleYScales\",\n    value: function setMultipleYScales() {\n      var _this = this;\n\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var minYArr = gl.minYArr.concat([]);\n      var maxYArr = gl.maxYArr.concat([]);\n      var scalesIndices = []; // here, we loop through the yaxis array and find the item which has \"seriesName\" property\n\n      cnf.yaxis.forEach(function (yaxe, i) {\n        var index = i;\n        cnf.series.forEach(function (s, si) {\n          // if seriesName matches and that series is not collapsed, we use that scale\n          if (s.name === yaxe.seriesName && gl.collapsedSeriesIndices.indexOf(si) === -1) {\n            index = si;\n\n            if (i !== si) {\n              scalesIndices.push({\n                index: si,\n                similarIndex: i,\n                alreadyExists: true\n              });\n            } else {\n              scalesIndices.push({\n                index: si\n              });\n            }\n          }\n        });\n        var minY = minYArr[index];\n        var maxY = maxYArr[index];\n\n        _this.setYScaleForIndex(i, minY, maxY);\n      });\n      this.sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices);\n    }\n  }, {\n    key: \"sameScaleInMultipleAxes\",\n    value: function sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices) {\n      var _this2 = this;\n\n      var cnf = this.w.config;\n      var gl = this.w.globals; // we got the scalesIndices array in the above code, but we need to filter out the items which doesn't have same scales\n\n      var similarIndices = [];\n      scalesIndices.forEach(function (scale) {\n        if (scale.alreadyExists) {\n          if (typeof similarIndices[scale.index] === 'undefined') {\n            similarIndices[scale.index] = [];\n          }\n\n          similarIndices[scale.index].push(scale.index);\n          similarIndices[scale.index].push(scale.similarIndex);\n        }\n      });\n\n      function intersect(a, b) {\n        return a.filter(function (value) {\n          return b.indexOf(value) !== -1;\n        });\n      }\n\n      similarIndices.forEach(function (si, i) {\n        similarIndices.forEach(function (sj, j) {\n          if (i !== j) {\n            if (intersect(si, sj).length > 0) {\n              similarIndices[i] = similarIndices[i].concat(similarIndices[j]);\n            }\n          }\n        });\n      }); // then, we remove duplicates from the similarScale array\n\n      var uniqueSimilarIndices = similarIndices.map(function (item) {\n        return item.filter(function (i, pos) {\n          return item.indexOf(i) === pos;\n        });\n      }); // sort further to remove whole duplicate arrays later\n\n      var sortedIndices = uniqueSimilarIndices.map(function (s) {\n        return s.sort();\n      }); // remove undefined items\n\n      similarIndices = similarIndices.filter(function (s) {\n        return !!s;\n      });\n      var indices = sortedIndices.slice();\n      var stringIndices = indices.map(function (ind) {\n        return JSON.stringify(ind);\n      });\n      indices = indices.filter(function (ind, p) {\n        return stringIndices.indexOf(JSON.stringify(ind)) === p;\n      });\n      var sameScaleMinYArr = [];\n      var sameScaleMaxYArr = [];\n      minYArr.forEach(function (minYValue, yi) {\n        indices.forEach(function (scale, i) {\n          // we compare only the yIndex which exists in the indices array\n          if (scale.indexOf(yi) > -1) {\n            if (typeof sameScaleMinYArr[i] === 'undefined') {\n              sameScaleMinYArr[i] = [];\n              sameScaleMaxYArr[i] = [];\n            }\n\n            sameScaleMinYArr[i].push({\n              key: yi,\n              value: minYValue\n            });\n            sameScaleMaxYArr[i].push({\n              key: yi,\n              value: maxYArr[yi]\n            });\n          }\n        });\n      });\n      var sameScaleMin = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, Number.MIN_VALUE);\n      var sameScaleMax = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);\n      sameScaleMinYArr.forEach(function (s, i) {\n        s.forEach(function (sc, j) {\n          sameScaleMin[i] = Math.min(sc.value, sameScaleMin[i]);\n        });\n      });\n      sameScaleMaxYArr.forEach(function (s, i) {\n        s.forEach(function (sc, j) {\n          sameScaleMax[i] = Math.max(sc.value, sameScaleMax[i]);\n        });\n      });\n      minYArr.forEach(function (min, i) {\n        sameScaleMaxYArr.forEach(function (s, si) {\n          var minY = sameScaleMin[si];\n          var maxY = sameScaleMax[si];\n          s.forEach(function (ind, k) {\n            if (s[k].key === i) {\n              if (cnf.yaxis[i].min !== undefined) {\n                if (typeof cnf.yaxis[i].min === 'function') {\n                  minY = cnf.yaxis[i].min(gl.minY);\n                } else {\n                  minY = cnf.yaxis[i].min;\n                }\n              }\n\n              if (cnf.yaxis[i].max !== undefined) {\n                if (typeof cnf.yaxis[i].max === 'function') {\n                  maxY = cnf.yaxis[i].max(gl.maxY);\n                } else {\n                  maxY = cnf.yaxis[i].max;\n                }\n              }\n\n              _this2.setYScaleForIndex(i, minY, maxY);\n            }\n          });\n        });\n      });\n    }\n  }, {\n    key: \"autoScaleY\",\n    value: function autoScaleY(ctx, e) {\n      if (!ctx) {\n        ctx = this;\n      }\n\n      var ret = [];\n      ctx.w.config.series.forEach(function (serie) {\n        var min, max;\n        var first = serie.data.find(function (x) {\n          return x[0] >= e.xaxis.min;\n        });\n        var firstValue = first[1];\n        max = min = firstValue;\n        serie.data.forEach(function (data) {\n          if (data[0] <= e.xaxis.max && data[0] >= e.xaxis.min) {\n            if (data[1] > max && data[1] !== null) max = data[1];\n            if (data[1] < min && data[1] !== null) min = data[1];\n          }\n        });\n        min *= 0.95;\n        max *= 1.05;\n        ret.push({\n          min: min,\n          max: max\n        });\n      });\n      return ret;\n    }\n  }]);\n\n  return Range;\n}();\n\n/**\n * Range is used to generates values between min and max.\n *\n * @module Range\n **/\n\nvar Range$1 =\n/*#__PURE__*/\nfunction () {\n  function Range$$1(ctx) {\n    _classCallCheck(this, Range$$1);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);\n    this.scales = new Range(ctx);\n  }\n\n  _createClass(Range$$1, [{\n    key: \"init\",\n    value: function init() {\n      this.setYRange();\n      this.setXRange();\n      this.setZRange();\n    }\n  }, {\n    key: \"getMinYMaxY\",\n    value: function getMinYMaxY(startingIndex) {\n      var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n      var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;\n      var len = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var gl = this.w.globals;\n      var maxY = -Number.MAX_VALUE;\n      var minY = Number.MIN_VALUE;\n\n      if (len === null) {\n        len = startingIndex + 1;\n      }\n\n      var series = gl.series;\n      var seriesMin = series;\n      var seriesMax = series;\n\n      if (this.w.config.chart.type === 'candlestick') {\n        seriesMin = gl.seriesCandleL;\n        seriesMax = gl.seriesCandleH;\n      }\n\n      for (var i = startingIndex; i < len; i++) {\n        gl.dataPoints = Math.max(gl.dataPoints, series[i].length);\n\n        for (var j = 0; j < gl.series[i].length; j++) {\n          if (series[i][j] !== null && Utils.isNumber(series[i][j])) {\n            maxY = Math.max(maxY, seriesMax[i][j]);\n            lowestY = Math.min(lowestY, seriesMin[i][j]);\n            highestY = Math.max(highestY, seriesMin[i][j]);\n\n            if (Utils.isFloat(series[i][j])) {\n              gl.yValueDecimal = Math.max(gl.yValueDecimal, series[i][j].toString().split('.')[1].length);\n            }\n\n            if (minY > seriesMin[i][j] && seriesMin[i][j] < 0) {\n              minY = seriesMin[i][j];\n            }\n          } else {\n            gl.hasNullValues = true;\n          }\n        }\n      }\n\n      return {\n        minY: minY,\n        maxY: maxY,\n        lowestY: lowestY,\n        highestY: highestY\n      };\n    }\n  }, {\n    key: \"setYRange\",\n    value: function setYRange() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.maxY = -Number.MAX_VALUE;\n      gl.minY = Number.MIN_VALUE;\n      var lowestYInAllSeries = Number.MAX_VALUE;\n\n      if (gl.isMultipleYAxis) {\n        // we need to get minY and maxY for multiple y axis\n        for (var i = 0; i < gl.series.length; i++) {\n          var minYMaxYArr = this.getMinYMaxY(i, lowestYInAllSeries, null, i + 1);\n          gl.minYArr.push(minYMaxYArr.minY);\n          gl.maxYArr.push(minYMaxYArr.maxY);\n          lowestYInAllSeries = minYMaxYArr.lowestY;\n        }\n      } // and then, get the minY and maxY from all series\n\n\n      var minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);\n      gl.minY = minYMaxY.minY;\n      gl.maxY = minYMaxY.maxY;\n      lowestYInAllSeries = minYMaxY.lowestY;\n\n      if (cnf.chart.stacked) {\n        // for stacked charts, we calculate each series's parallel values. i.e, series[0][j] + series[1][j] .... [series[i.length][j]] and get the max out of it\n        var stackedPoss = [];\n        var stackedNegs = [];\n\n        for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {\n          var poss = 0;\n          var negs = 0;\n\n          for (var _i = 0; _i < gl.series.length; _i++) {\n            if (gl.series[_i][j] !== null && Utils.isNumber(gl.series[_i][j])) {\n              if (gl.series[_i][j] > 0) {\n                // 0.0001 fixes #185 when values are very small\n                poss = poss + parseFloat(gl.series[_i][j]) + 0.0001;\n              } else {\n                negs = negs + parseFloat(gl.series[_i][j]);\n              }\n            }\n\n            if (_i === gl.series.length - 1) {\n              // push all the totals to the array for future use\n              stackedPoss.push(poss);\n              stackedNegs.push(negs);\n            }\n          }\n        } // get the max/min out of the added parallel values\n\n\n        for (var z = 0; z < stackedPoss.length; z++) {\n          gl.maxY = Math.max(gl.maxY, stackedPoss[z]);\n          gl.minY = Math.min(gl.minY, stackedNegs[z]);\n        }\n      } // if the numbers are too big, reduce the range\n      // for eg, if number is between 100000-110000, putting 0 as the lowest value is not so good idea. So change the gl.minY for line/area/candlesticks\n\n\n      if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'candlestick') {\n        if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE) {\n          var diff = gl.maxY - lowestYInAllSeries;\n\n          if (lowestYInAllSeries >= 0 && lowestYInAllSeries <= 10) {\n            // if minY is already 0/low value, we don't want to go negatives here - so this check is essential.\n            diff = 0;\n          }\n\n          gl.minY = lowestYInAllSeries - diff * 5 / 100;\n          gl.maxY = gl.maxY + diff * 5 / 100 + 0.05;\n        }\n      }\n\n      cnf.yaxis.map(function (yaxe, index) {\n        // override all min/max values by user defined values (y axis)\n        if (yaxe.max !== undefined) {\n          if (typeof yaxe.max === 'number') {\n            gl.maxYArr[index] = yaxe.max;\n          } else if (typeof yaxe.max === 'function') {\n            gl.maxYArr[index] = yaxe.max(gl.maxY);\n          } // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n          gl.maxY = gl.maxYArr[index];\n        }\n\n        if (yaxe.min !== undefined) {\n          if (typeof yaxe.min === 'number') {\n            gl.minYArr[index] = yaxe.min;\n          } else if (typeof yaxe.min === 'function') {\n            gl.minYArr[index] = yaxe.min(gl.minY);\n          } // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis\n\n\n          gl.minY = gl.minYArr[index];\n        }\n      }); // for horizontal bar charts, we need to check xaxis min/max as user may have specified there\n\n      if (this.isBarHorizontal) {\n        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {\n          gl.minY = cnf.xaxis.min;\n        }\n\n        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {\n          gl.maxY = cnf.xaxis.max;\n        }\n      } // for multi y-axis we need different scales for each\n\n\n      if (gl.isMultipleYAxis) {\n        this.scales.setMultipleYScales();\n        gl.minY = lowestYInAllSeries;\n        gl.yAxisScale.forEach(function (scale, i) {\n          gl.minYArr[i] = scale.niceMin;\n          gl.maxYArr[i] = scale.niceMax;\n        });\n      } else {\n        this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);\n        gl.minY = gl.yAxisScale[0].niceMin;\n        gl.maxY = gl.yAxisScale[0].niceMax;\n        gl.minYArr[0] = gl.yAxisScale[0].niceMin;\n        gl.maxYArr[0] = gl.yAxisScale[0].niceMax;\n      }\n    }\n  }, {\n    key: \"setXRange\",\n    value: function setXRange() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided; // minX maxX starts here\n\n      if (gl.isXNumeric) {\n        for (var i = 0; i < gl.series.length; i++) {\n          if (gl.labels[i]) {\n            for (var j = 0; j < gl.labels[i].length; j++) {\n              if (gl.labels[i][j] !== null && Utils.isNumber(gl.labels[i][j])) {\n                gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);\n                gl.initialmaxX = Math.max(gl.maxX, gl.labels[i][j]);\n                gl.minX = Math.min(gl.minX, gl.labels[i][j]);\n                gl.initialminX = Math.min(gl.minX, gl.labels[i][j]);\n              }\n            }\n          }\n        }\n      }\n\n      if (gl.noLabelsProvided) {\n        if (cnf.xaxis.categories.length === 0) {\n          gl.maxX = gl.labels[gl.labels.length - 1];\n          gl.initialmaxX = gl.labels[gl.labels.length - 1];\n          gl.minX = 1;\n          gl.initialminX = 1;\n        }\n      } // for numeric xaxis, we need to adjust some padding left and right for bar charts\n\n\n      if (gl.comboChartsHasBars || cnf.chart.type === 'candlestick' || cnf.chart.type === 'bar' && cnf.xaxis.type !== 'category') {\n        if (cnf.xaxis.type !== 'category') {\n          var minX = gl.minX - gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;\n          gl.minX = minX;\n          gl.initialminX = minX;\n          var maxX = gl.maxX + gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;\n          gl.maxX = maxX;\n          gl.initialmaxX = maxX;\n        }\n      }\n\n      if (gl.isXNumeric || gl.noLabelsProvided) {\n        var ticks;\n\n        if (cnf.xaxis.tickAmount === undefined) {\n          ticks = Math.round(gl.svgWidth / 150); // no labels provided and total number of dataPoints is less than 20\n\n          if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 20) {\n            ticks = gl.dataPoints - 1;\n          } // this check is for when ticks exceeds total datapoints and that would result in duplicate labels\n\n\n          if (ticks > gl.dataPoints && gl.dataPoints !== 0) {\n            ticks = gl.dataPoints - 1;\n          }\n        } else if (cnf.xaxis.tickAmount === 'dataPoints') {\n          ticks = gl.series[gl.maxValsInArrayIndex].length - 1;\n        } else {\n          ticks = cnf.xaxis.tickAmount;\n        } // override all min/max values by user defined values (x axis)\n\n\n        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {\n          gl.maxX = cnf.xaxis.max;\n        }\n\n        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {\n          gl.minX = cnf.xaxis.min;\n        } // if range is provided, adjust the new minX\n\n\n        if (cnf.xaxis.range !== undefined) {\n          gl.minX = gl.maxX - cnf.xaxis.range;\n        }\n\n        if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {\n          gl.xAxisScale = this.scales.linearScale(gl.minX, gl.maxX, ticks);\n        } else {\n          gl.xAxisScale = this.scales.linearScale(1, ticks, ticks);\n\n          if (gl.noLabelsProvided && gl.labels.length > 0) {\n            gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1);\n            gl.seriesX = gl.labels.slice();\n          }\n        } // we will still store these labels as the count for this will be different (to draw grid and labels placement)\n\n\n        if (isXNumeric) {\n          gl.labels = gl.xAxisScale.result.slice();\n        }\n      }\n\n      if (gl.minX === gl.maxX) {\n        // single dataPoint\n        if (cnf.xaxis.type === 'datetime') {\n          var newMinX = new Date(gl.minX);\n          newMinX.setDate(newMinX.getDate() - 2);\n          gl.minX = new Date(newMinX).getTime();\n          var newMaxX = new Date(gl.maxX);\n          newMaxX.setDate(newMaxX.getDate() + 2);\n          gl.maxX = new Date(newMaxX).getTime();\n        } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {\n          gl.minX = gl.minX - 2;\n          gl.maxX = gl.maxX + 2;\n        }\n      }\n    }\n  }, {\n    key: \"setZRange\",\n    value: function setZRange() {\n      var gl = this.w.globals; // minZ, maxZ starts here\n\n      if (gl.isDataXYZ) {\n        for (var i = 0; i < gl.series.length; i++) {\n          if (typeof gl.seriesZ[i] !== 'undefined') {\n            for (var j = 0; j < gl.seriesZ[i].length; j++) {\n              if (gl.seriesZ[i][j] !== null && Utils.isNumber(gl.seriesZ[i][j])) {\n                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);\n                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return Range$$1;\n}();\n\n/**\n * ApexCharts Series Class for interation with the Series of the chart.\n *\n * @module Series\n **/\n\nvar Series =\n/*#__PURE__*/\nfunction () {\n  function Series(ctx) {\n    _classCallCheck(this, Series);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Series, [{\n    key: \"getAllSeriesEls\",\n    value: function getAllSeriesEls() {\n      return this.w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series\");\n    }\n  }, {\n    key: \"getSeriesByName\",\n    value: function getSeriesByName(seriesName) {\n      return this.w.globals.dom.baseEl.querySelector(\".apexcharts-series.\".concat(Utils.escapeString(seriesName)));\n    }\n  }, {\n    key: \"addCollapsedClassToSeries\",\n    value: function addCollapsedClassToSeries(elSeries, index) {\n      var w = this.w;\n\n      for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {\n        if (w.globals.collapsedSeries[cs].index === index) {\n          elSeries.node.classList.add('apexcharts-series-collapsed');\n        }\n      }\n    }\n  }, {\n    key: \"toggleSeriesOnHover\",\n    value: function toggleSeriesOnHover(e, targetElement) {\n      var w = this.w;\n      var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series\");\n\n      if (e.type === 'mousemove') {\n        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;\n        var seriesEl = null;\n\n        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n          if (w.globals.axisCharts) {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n          } else {\n            seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n          }\n        } else {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n        }\n\n        for (var se = 0; se < allSeriesEls.length; se++) {\n          allSeriesEls[se].classList.add('legend-mouseover-inactive');\n        }\n\n        if (seriesEl !== null) {\n          if (!w.globals.axisCharts) {\n            seriesEl.parentNode.classList.remove('legend-mouseover-inactive');\n          }\n\n          seriesEl.classList.remove('legend-mouseover-inactive');\n        }\n      } else if (e.type === 'mouseout') {\n        for (var _se = 0; _se < allSeriesEls.length; _se++) {\n          allSeriesEls[_se].classList.remove('legend-mouseover-inactive');\n        }\n      }\n    }\n  }, {\n    key: \"highlightRangeInSeries\",\n    value: function highlightRangeInSeries(e, targetElement) {\n      var w = this.w;\n      var allHeatMapElements = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect');\n\n      var allActive = function allActive() {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          allHeatMapElements[i].classList.remove('legend-mouseover-inactive');\n        }\n      };\n\n      var allInactive = function allInactive() {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          allHeatMapElements[i].classList.add('legend-mouseover-inactive');\n        }\n      };\n\n      var selectedActive = function selectedActive(range) {\n        for (var i = 0; i < allHeatMapElements.length; i++) {\n          var val = parseInt(allHeatMapElements[i].getAttribute('val'));\n\n          if (val >= range.from && val <= range.to) {\n            allHeatMapElements[i].classList.remove('legend-mouseover-inactive');\n          }\n        }\n      };\n\n      if (e.type === 'mousemove') {\n        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;\n        allActive();\n        allInactive();\n        var range = w.config.plotOptions.heatmap.colorScale.ranges[seriesCnt];\n        selectedActive(range);\n      } else if (e.type === 'mouseout') {\n        allActive();\n      }\n    }\n  }, {\n    key: \"getActiveSeriesIndex\",\n    value: function getActiveSeriesIndex() {\n      var w = this.w;\n      var activeIndex = 0;\n\n      if (w.globals.series.length > 1) {\n        // active series flag is required to know if user has not deactivated via legend click\n        var firstActiveSeriesIndex = w.globals.series.map(function (series, index) {\n          if (series.length > 0 && w.config.series[index].type !== 'bar' && w.config.series[index].type !== 'column') {\n            return index;\n          } else {\n            return -1;\n          }\n        });\n\n        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n          if (firstActiveSeriesIndex[a] !== -1) {\n            activeIndex = firstActiveSeriesIndex[a];\n            break;\n          }\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"getActiveConfigSeriesIndex\",\n    value: function getActiveConfigSeriesIndex() {\n      var w = this.w;\n      var activeIndex = 0;\n\n      if (w.config.series.length > 1) {\n        // active series flag is required to know if user has not deactivated via legend click\n        var firstActiveSeriesIndex = w.config.series.map(function (series, index) {\n          if (series.data && series.data.length > 0) {\n            return index;\n          } else {\n            return -1;\n          }\n        });\n\n        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n          if (firstActiveSeriesIndex[a] !== -1) {\n            activeIndex = firstActiveSeriesIndex[a];\n            break;\n          }\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"getPreviousPaths\",\n    value: function getPreviousPaths() {\n      var w = this.w;\n      w.globals.previousPaths = [];\n\n      function pushPaths(seriesEls, i, type) {\n        var paths = seriesEls[i].childNodes;\n        var dArr = {\n          type: type,\n          paths: [],\n          realIndex: seriesEls[i].getAttribute('data:realIndex')\n        };\n\n        for (var j = 0; j < paths.length; j++) {\n          if (paths[j].hasAttribute('pathTo')) {\n            var d = paths[j].getAttribute('pathTo');\n            dArr.paths.push({\n              d: d\n            });\n          }\n        }\n\n        w.globals.previousPaths.push(dArr);\n      }\n\n      var linePaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-series');\n\n      if (linePaths.length > 0) {\n        for (var p = linePaths.length - 1; p >= 0; p--) {\n          pushPaths(linePaths, p, 'line');\n        }\n      }\n\n      var areapaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-series');\n\n      if (areapaths.length > 0) {\n        for (var i = areapaths.length - 1; i >= 0; i--) {\n          pushPaths(areapaths, i, 'area');\n        }\n      }\n\n      var barPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series .apexcharts-series');\n\n      if (barPaths.length > 0) {\n        for (var _p = 0; _p < barPaths.length; _p++) {\n          pushPaths(barPaths, _p, 'bar');\n        }\n      }\n\n      var candlestickPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-candlestick-series .apexcharts-series');\n\n      if (candlestickPaths.length > 0) {\n        for (var _p2 = 0; _p2 < candlestickPaths.length; _p2++) {\n          pushPaths(candlestickPaths, _p2, 'candlestick');\n        }\n      }\n\n      var radarPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-radar-series .apexcharts-series');\n\n      if (radarPaths.length > 0) {\n        for (var _p3 = 0; _p3 < radarPaths.length; _p3++) {\n          pushPaths(radarPaths, _p3, 'radar');\n        }\n      }\n\n      var bubblepaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bubble-series .apexcharts-series');\n\n      if (bubblepaths.length > 0) {\n        for (var s = 0; s < bubblepaths.length; s++) {\n          var seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-bubble-series .apexcharts-series[data\\\\:realIndex='\".concat(s, \"'] circle\"));\n          var dArr = [];\n\n          for (var _i = 0; _i < seriesEls.length; _i++) {\n            dArr.push({\n              x: seriesEls[_i].getAttribute('cx'),\n              y: seriesEls[_i].getAttribute('cy'),\n              r: seriesEls[_i].getAttribute('r')\n            });\n          }\n\n          w.globals.previousPaths.push(dArr);\n        }\n      }\n\n      var scatterpaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-scatter-series .apexcharts-series');\n\n      if (scatterpaths.length > 0) {\n        for (var _s = 0; _s < scatterpaths.length; _s++) {\n          var _seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-scatter-series .apexcharts-series[data\\\\:realIndex='\".concat(_s, \"'] circle\"));\n\n          var _dArr = [];\n\n          for (var _i2 = 0; _i2 < _seriesEls.length; _i2++) {\n            _dArr.push({\n              x: _seriesEls[_i2].getAttribute('cx'),\n              y: _seriesEls[_i2].getAttribute('cy'),\n              r: _seriesEls[_i2].getAttribute('r')\n            });\n          }\n\n          w.globals.previousPaths.push(_dArr);\n        }\n      }\n\n      var heatmapColors = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series');\n\n      if (heatmapColors.length > 0) {\n        for (var h = 0; h < heatmapColors.length; h++) {\n          var _seriesEls2 = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-heatmap .apexcharts-series[data\\\\:realIndex='\".concat(h, \"'] rect\"));\n\n          var _dArr2 = [];\n\n          for (var _i3 = 0; _i3 < _seriesEls2.length; _i3++) {\n            _dArr2.push({\n              color: _seriesEls2[_i3].getAttribute('color')\n            });\n          }\n\n          w.globals.previousPaths.push(_dArr2);\n        }\n      }\n\n      if (!w.globals.axisCharts) {\n        // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)\n        w.globals.previousPaths = w.globals.series;\n      }\n    }\n  }, {\n    key: \"handleNoData\",\n    value: function handleNoData() {\n      var w = this.w;\n      var me = this;\n      var noDataOpts = w.config.noData;\n      var graphics = new Graphics(me.ctx);\n      var x = w.globals.svgWidth / 2;\n      var y = w.globals.svgHeight / 2;\n      var textAnchor = 'middle';\n      w.globals.noData = true;\n      w.globals.animationEnded = true;\n\n      if (noDataOpts.align === 'left') {\n        x = 10;\n        textAnchor = 'start';\n      } else if (noDataOpts.align === 'right') {\n        x = w.globals.svgWidth - 10;\n        textAnchor = 'end';\n      }\n\n      if (noDataOpts.verticalAlign === 'top') {\n        y = 50;\n      } else if (noDataOpts.verticalAlign === 'bottom') {\n        y = w.globals.svgHeight - 50;\n      }\n\n      x = x + noDataOpts.offsetX;\n      y = y + parseInt(noDataOpts.style.fontSize) + 2;\n\n      if (noDataOpts.text !== undefined && noDataOpts.text !== '') {\n        var titleText = graphics.drawText({\n          x: x,\n          y: y,\n          text: noDataOpts.text,\n          textAnchor: textAnchor,\n          fontSize: noDataOpts.style.fontSize,\n          fontFamily: noDataOpts.style.fontFamily,\n          foreColor: noDataOpts.style.color,\n          opacity: 1,\n          class: 'apexcharts-text-nodata'\n        });\n        titleText.node.setAttribute('class', 'apexcharts-title-text');\n        w.globals.dom.Paper.add(titleText);\n      }\n    } // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]\n    // This is because we don't want to alter the series' length as it is used at many places\n\n  }, {\n    key: \"setNullSeriesToZeroValues\",\n    value: function setNullSeriesToZeroValues(series) {\n      var w = this.w;\n\n      for (var sl = 0; sl < series.length; sl++) {\n        if (series[sl].length === 0) {\n          for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {\n            series[sl].push(0);\n          }\n        }\n      }\n\n      return series;\n    }\n  }, {\n    key: \"hasAllSeriesEqualX\",\n    value: function hasAllSeriesEqualX() {\n      var equalLen = true;\n      var w = this.w;\n      var filteredSerX = this.filteredSeriesX();\n\n      for (var i = 0; i < filteredSerX.length - 1; i++) {\n        if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {\n          equalLen = false;\n          break;\n        }\n      }\n\n      w.globals.allSeriesHasEqualX = equalLen;\n      return equalLen;\n    }\n  }, {\n    key: \"filteredSeriesX\",\n    value: function filteredSeriesX() {\n      var w = this.w;\n      var filteredSeriesX = w.globals.seriesX.map(function (ser, index) {\n        if (ser.length > 0) {\n          return ser;\n        } else {\n          return [];\n        }\n      });\n      return filteredSeriesX;\n    }\n  }]);\n\n  return Series;\n}();\n\n/**\n * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.\n *\n * @module Dimensions\n **/\n\nvar Dimensions =\n/*#__PURE__*/\nfunction () {\n  function Dimensions(ctx) {\n    _classCallCheck(this, Dimensions);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.lgRect = {};\n    this.yAxisWidth = 0;\n    this.xAxisHeight = 0;\n    this.isSparkline = this.w.config.chart.sparkline.enabled;\n    this.xPadRight = 0;\n    this.xPadLeft = 0;\n    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);\n  }\n  /**\n   * @memberof Dimensions\n   * @param {object} w - chart context\n   **/\n\n\n  _createClass(Dimensions, [{\n    key: \"plotCoords\",\n    value: function plotCoords() {\n      var w = this.w;\n      var gl = w.globals;\n      var lgRect = this.getLegendsRect();\n\n      if (gl.axisCharts) {\n        // for line / area / scatter / column\n        this.setGridCoordsForAxisCharts(lgRect);\n      } else {\n        // for pie / donuts / circle\n        this.setGridCoordsForNonAxisCharts(lgRect);\n      }\n\n      this.titleSubtitleOffset(); // after calculating everything, apply padding set by user\n\n      gl.gridHeight = gl.gridHeight - w.config.grid.padding.top - w.config.grid.padding.bottom;\n      gl.gridWidth = gl.gridWidth - w.config.grid.padding.left - w.config.grid.padding.right - this.xPadRight - this.xPadLeft;\n      gl.translateX = gl.translateX + w.config.grid.padding.left + this.xPadLeft;\n      gl.translateY = gl.translateY + w.config.grid.padding.top;\n    }\n  }, {\n    key: \"conditionalChecksForAxisCoords\",\n    value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords) {\n      var w = this.w;\n      this.xAxisHeight = (xaxisLabelCoords.height + xtitleCoords.height) * w.globals.LINE_HEIGHT_RATIO + 15;\n      this.xAxisWidth = xaxisLabelCoords.width;\n\n      if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {\n        this.xAxisHeight = w.config.xaxis.labels.maxHeight;\n      }\n\n      if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {\n        this.xAxisHeight = w.config.xaxis.labels.minHeight;\n      }\n\n      if (w.config.xaxis.floating) {\n        this.xAxisHeight = 0;\n      }\n\n      if (!this.isBarHorizontal) {\n        this.yAxisWidth = this.getTotalYAxisWidth();\n      } else {\n        this.yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;\n      }\n\n      if (!w.globals.isMultipleYAxis) {\n        if (this.yAxisWidth < w.config.yaxis[0].labels.minWidth) {\n          this.yAxisWidth = w.config.yaxis[0].labels.minWidth;\n        }\n\n        if (this.yAxisWidth > w.config.yaxis[0].labels.maxWidth) {\n          this.yAxisWidth = w.config.yaxis[0].labels.maxWidth;\n        }\n      }\n    }\n  }, {\n    key: \"setGridCoordsForAxisCharts\",\n    value: function setGridCoordsForAxisCharts(lgRect) {\n      var w = this.w;\n      var gl = w.globals;\n      var yaxisLabelCoords = this.getyAxisLabelsCoords();\n      var xaxisLabelCoords = this.getxAxisLabelsCoords();\n      var yTitleCoords = this.getyAxisTitleCoords();\n      var xtitleCoords = this.getxAxisTitleCoords();\n      w.globals.yLabelsCoords = [];\n      w.globals.yTitleCoords = [];\n      w.config.yaxis.map(function (yaxe, index) {\n        // store the labels and titles coords in global vars\n        w.globals.yLabelsCoords.push({\n          width: yaxisLabelCoords[index].width,\n          index: index\n        });\n        w.globals.yTitleCoords.push({\n          width: yTitleCoords[index].width,\n          index: index\n        });\n      });\n      this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords);\n      gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;\n      gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;\n\n      if (this.isBarHorizontal) {\n        gl.rotateXLabels = false;\n        gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize) / 1.5);\n      }\n\n      gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;\n      gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;\n      var yAxisWidth = this.yAxisWidth;\n      var xAxisHeight = this.xAxisHeight;\n      gl.xAxisLabelsHeight = this.xAxisHeight;\n      gl.xAxisHeight = this.xAxisHeight;\n      var translateY = 10;\n\n      if (!w.config.grid.show || w.config.chart.type === 'radar') {\n        yAxisWidth = 0;\n        xAxisHeight = 35;\n      }\n\n      if (this.isSparkline) {\n        lgRect = {\n          height: 0,\n          width: 0\n        };\n        xAxisHeight = 0;\n        yAxisWidth = 0;\n        translateY = 0;\n      }\n\n      this.additionalPaddingXLabels(xaxisLabelCoords);\n\n      switch (w.config.legend.position) {\n        case 'bottom':\n          gl.translateY = translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);\n          gl.gridWidth = gl.svgWidth - yAxisWidth;\n          break;\n\n        case 'top':\n          gl.translateY = lgRect.height + translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);\n          gl.gridWidth = gl.svgWidth - yAxisWidth;\n          break;\n\n        case 'left':\n          gl.translateY = translateY;\n          gl.translateX = lgRect.width + yAxisWidth;\n          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth;\n          break;\n\n        case 'right':\n          gl.translateY = translateY;\n          gl.translateX = yAxisWidth;\n          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;\n          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth - 5;\n          break;\n\n        default:\n          throw new Error('Legend position not supported');\n      }\n\n      this.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords); // after drawing everything, set the Y axis positions\n\n      var objyAxis = new YAxis(this.ctx);\n      objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);\n    }\n  }, {\n    key: \"setGridCoordsForNonAxisCharts\",\n    value: function setGridCoordsForNonAxisCharts(lgRect) {\n      var w = this.w;\n      var gl = w.globals;\n      var xPad = 0;\n\n      if (w.config.legend.show && !w.config.legend.floating) {\n        xPad = 20;\n      }\n\n      var offY = 10;\n      var offX = 0;\n\n      if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {\n        offY = offY + w.config.plotOptions.pie.offsetY;\n        offX = offX + w.config.plotOptions.pie.offsetX;\n      } else if (w.config.chart.type === 'radialBar') {\n        offY = offY + w.config.plotOptions.radialBar.offsetY;\n        offX = offX + w.config.plotOptions.radialBar.offsetX;\n      }\n\n      if (!w.config.legend.show) {\n        gl.gridHeight = gl.svgHeight - 35;\n        gl.gridWidth = gl.gridHeight;\n        gl.translateY = offY - 10;\n        gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n        return;\n      }\n\n      switch (w.config.legend.position) {\n        case 'bottom':\n          gl.gridHeight = gl.svgHeight - lgRect.height - 35;\n          gl.gridWidth = gl.gridHeight;\n          gl.translateY = offY - 20;\n          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n          break;\n\n        case 'top':\n          gl.gridHeight = gl.svgHeight - lgRect.height - 35;\n          gl.gridWidth = gl.gridHeight;\n          gl.translateY = lgRect.height + offY;\n          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;\n          break;\n\n        case 'left':\n          gl.gridWidth = gl.svgWidth - lgRect.width - xPad;\n          gl.gridHeight = gl.gridWidth;\n          gl.translateY = offY;\n          gl.translateX = offX + lgRect.width + xPad;\n          break;\n\n        case 'right':\n          gl.gridWidth = gl.svgWidth - lgRect.width - xPad - 5;\n          gl.gridHeight = gl.gridWidth;\n          gl.translateY = offY;\n          gl.translateX = offX + 10;\n          break;\n\n        default:\n          throw new Error('Legend position not supported');\n      }\n    }\n  }, {\n    key: \"setGridXPosForDualYAxis\",\n    value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {\n      var w = this.w;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !w.config.yaxis[index].floating && w.config.yaxis[index].show) {\n          if (yaxe.opposite) {\n            w.globals.translateX = w.globals.translateX - (yaxisLabelCoords[index].width + yTitleCoords[index].width) - parseInt(w.config.yaxis[index].labels.style.fontSize) / 1.2 - 12;\n          }\n        }\n      });\n    } // Sometimes, the last labels gets cropped in category/numeric xaxis.\n    // Hence, we add some additional padding based on the label length to avoid the last label being cropped.\n    // NOTE: datetime x-axis won't have any effect with this as we don't know the label length there due to many constraints.\n\n  }, {\n    key: \"additionalPaddingXLabels\",\n    value: function additionalPaddingXLabels(xaxisLabelCoords) {\n      var _this = this;\n\n      var w = this.w;\n\n      if (w.config.xaxis.type === 'category' && this.isBarHorizontal || w.config.xaxis.type === 'numeric') {\n        var rightPad = function rightPad(labels) {\n          if (w.config.grid.padding.right < labels.width) {\n            _this.xPadRight = labels.width / 2 + 1;\n          }\n        };\n\n        var leftPad = function leftPad(labels) {\n          if (w.config.grid.padding.left < labels.width) {\n            _this.xPadLeft = labels.width / 2 + 1;\n          }\n        };\n\n        var lineArea = w.config.chart.type === 'line' || w.config.chart.type === 'area';\n        w.config.yaxis.forEach(function (yaxe, i) {\n          var shouldPad = !yaxe.show || yaxe.floating || w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea || yaxe.opposite && _this.isBarHorizontal;\n\n          if (shouldPad) {\n            if (lineArea && w.globals.isMultipleYAxis && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || _this.isBarHorizontal && yaxe.opposite) {\n              leftPad(xaxisLabelCoords);\n            }\n\n            if (!_this.isBarHorizontal && yaxe.opposite && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea && !w.globals.isMultipleYAxis) {\n              rightPad(xaxisLabelCoords);\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"titleSubtitleOffset\",\n    value: function titleSubtitleOffset() {\n      var w = this.w;\n      var gl = w.globals;\n      var gridShrinkOffset = this.isSparkline ? 0 : 10;\n\n      if (w.config.title.text !== undefined) {\n        gridShrinkOffset += w.config.title.margin;\n      } else {\n        gridShrinkOffset += this.isSparkline ? 0 : 5;\n      }\n\n      if (w.config.subtitle.text !== undefined) {\n        gridShrinkOffset += w.config.subtitle.margin;\n      } else {\n        gridShrinkOffset += this.isSparkline ? 0 : 5;\n      }\n\n      if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && w.config.series.length > 1) {\n        gridShrinkOffset += 10;\n      }\n\n      var titleCoords = this.getTitleSubtitleCoords('title');\n      var subtitleCoords = this.getTitleSubtitleCoords('subtitle');\n      gl.gridHeight = gl.gridHeight - titleCoords.height - subtitleCoords.height - gridShrinkOffset;\n      gl.translateY = gl.translateY + titleCoords.height + subtitleCoords.height + gridShrinkOffset;\n    }\n  }, {\n    key: \"getTotalYAxisWidth\",\n    value: function getTotalYAxisWidth() {\n      var w = this.w;\n      var yAxisWidth = 0;\n      var padding = 10;\n\n      var isHiddenYAxis = function isHiddenYAxis(index) {\n        return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;\n      };\n\n      w.globals.yLabelsCoords.map(function (yLabelCoord, index) {\n        var floating = w.config.yaxis[index].floating;\n\n        if (yLabelCoord.width > 0 && !floating) {\n          yAxisWidth = yAxisWidth + yLabelCoord.width + padding;\n\n          if (isHiddenYAxis(index)) {\n            yAxisWidth = yAxisWidth - yLabelCoord.width - padding;\n          }\n        } else {\n          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);\n        }\n      });\n      w.globals.yTitleCoords.map(function (yTitleCoord, index) {\n        var floating = w.config.yaxis[index].floating;\n        padding = parseInt(w.config.yaxis[index].title.style.fontSize);\n\n        if (yTitleCoord.width > 0 && !floating) {\n          yAxisWidth = yAxisWidth + yTitleCoord.width + padding;\n\n          if (isHiddenYAxis(index)) {\n            yAxisWidth = yAxisWidth - yTitleCoord.width - padding;\n          }\n        } else {\n          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);\n        }\n      });\n      return yAxisWidth;\n    }\n  }, {\n    key: \"getxAxisTimeScaleLabelsCoords\",\n    value: function getxAxisTimeScaleLabelsCoords() {\n      var w = this.w;\n      var rect;\n      var timescaleLabels = w.globals.timelineLabels.slice();\n      var labels = timescaleLabels.map(function (label) {\n        return label.value;\n      }); //  get the longest string from the labels array and also apply label formatter to it\n\n      var val = labels.reduce(function (a, b) {\n        // if undefined, maybe user didn't pass the datetime(x) values\n        if (typeof a === 'undefined') {\n          console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');\n          return 0;\n        } else {\n          return a.length > b.length ? a : b;\n        }\n      }, 0);\n      var graphics = new Graphics(this.ctx);\n      rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n      var totalWidthRotated = rect.width * 1.05 * labels.length;\n\n      if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {\n        w.globals.overlappingXLabels = true;\n      }\n\n      return rect;\n    }\n    /**\n     * Get X Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getxAxisLabelsCoords\",\n    value: function getxAxisLabelsCoords() {\n      var w = this.w;\n      var xaxisLabels = w.globals.labels.slice();\n      var rect;\n\n      if (w.globals.timelineLabels.length > 0) {\n        var coords = this.getxAxisTimeScaleLabelsCoords();\n        rect = {\n          width: coords.width,\n          height: coords.height\n        };\n      } else {\n        var lgWidthForSideLegends = w.config.legend.position === 'left' && w.config.legend.position === 'right' && !w.config.legend.floating ? this.lgRect.width : 0; //  get the longest string from the labels array and also apply label formatter to it\n\n        var val = xaxisLabels.reduce(function (a, b) {\n          return a.length > b.length ? a : b;\n        }, 0); // the labels gets changed for bar charts\n\n        if (this.isBarHorizontal) {\n          val = w.globals.yAxisScale[0].result.reduce(function (a, b) {\n            return a.length > b.length ? a : b;\n          }, 0);\n        }\n\n        var xlbFormatter = w.globals.xLabelFormatter;\n        var xFormat = new Formatters(this.ctx);\n        val = xFormat.xLabelFormat(xlbFormatter, val);\n        var graphics = new Graphics(this.ctx);\n        var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);\n        rect = {\n          width: xLabelrect.width,\n          height: xLabelrect.height\n        };\n\n        if (rect.width * xaxisLabels.length > w.globals.svgWidth - lgWidthForSideLegends - this.yAxisWidth && w.config.xaxis.labels.rotate !== 0) {\n          if (!this.isBarHorizontal) {\n            w.globals.rotateXLabels = true;\n            xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, \"rotate(\".concat(w.config.xaxis.labels.rotate, \" 0 0)\"), false);\n            rect.height = xLabelrect.height / 1.66;\n          }\n        } else {\n          w.globals.rotateXLabels = false;\n        }\n      }\n\n      if (!w.config.xaxis.labels.show) {\n        rect = {\n          width: 0,\n          height: 0\n        };\n      }\n\n      return {\n        width: rect.width,\n        height: rect.height\n      };\n    }\n    /**\n     * Get Y Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getyAxisLabelsCoords\",\n    value: function getyAxisLabelsCoords() {\n      var _this2 = this;\n\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n      var ret = [];\n      var labelPad = 10;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (yaxe.show && yaxe.labels.show && w.globals.yAxisScale[index].result.length) {\n          var lbFormatter = w.globals.yLabelFormatters[index]; // the second parameter -1 is the index of tick which user can use in the formatter\n\n          var val = lbFormatter(w.globals.yAxisScale[index].niceMax, -1); // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.\n\n          if (typeof val === 'undefined' || val.length === 0) {\n            val = w.globals.yAxisScale[index].niceMax;\n          }\n\n          if (_this2.isBarHorizontal) {\n            labelPad = 0;\n            var barYaxisLabels = w.globals.labels.slice(); //  get the longest string from the labels array and also apply label formatter to it\n\n            val = barYaxisLabels.reduce(function (a, b) {\n              return a.length > b.length ? a : b;\n            }, 0);\n            val = lbFormatter(val, -1);\n          }\n\n          var graphics = new Graphics(_this2.ctx);\n          var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize);\n          ret.push({\n            width: rect.width + labelPad,\n            height: rect.height\n          });\n        } else {\n          ret.push({\n            width: width,\n            height: height\n          });\n        }\n      });\n      return ret;\n    }\n    /**\n     * Get X Axis Title Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getxAxisTitleCoords\",\n    value: function getxAxisTitleCoords() {\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n\n      if (w.config.xaxis.title.text !== undefined) {\n        var graphics = new Graphics(this.ctx);\n        var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);\n        width = rect.width;\n        height = rect.height;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n    /**\n     * Get Y Axis Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getyAxisTitleCoords\",\n    value: function getyAxisTitleCoords() {\n      var _this3 = this;\n\n      var w = this.w;\n      var ret = [];\n      w.config.yaxis.map(function (yaxe, index) {\n        if (yaxe.show && yaxe.title.text !== undefined) {\n          var graphics = new Graphics(_this3.ctx);\n          var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, 'rotate(-90 0 0)', false);\n          ret.push({\n            width: rect.width,\n            height: rect.height\n          });\n        } else {\n          ret.push({\n            width: 0,\n            height: 0\n          });\n        }\n      });\n      return ret;\n    }\n    /**\n     * Get Chart Title/Subtitle Dimensions\n     * @memberof Dimensions\n     * @return {{width, height}}\n     **/\n\n  }, {\n    key: \"getTitleSubtitleCoords\",\n    value: function getTitleSubtitleCoords(type) {\n      var w = this.w;\n      var width = 0;\n      var height = 0;\n      var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;\n      var el = w.globals.dom.baseEl.querySelector(\".apexcharts-\".concat(type, \"-text\"));\n\n      if (el !== null && !floating) {\n        var coord = el.getBoundingClientRect();\n        width = coord.width;\n        height = w.globals.axisCharts ? coord.height + 5 : coord.height;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }, {\n    key: \"getLegendsRect\",\n    value: function getLegendsRect() {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var lgRect = Object.assign({}, Utils.getBoundingClientRect(elLegendWrap));\n\n      if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {\n        this.lgRect = {\n          x: lgRect.x,\n          y: lgRect.y,\n          height: lgRect.height,\n          width: lgRect.height === 0 ? 0 : lgRect.width\n        };\n      } else {\n        this.lgRect = {\n          x: 0,\n          y: 0,\n          height: 0,\n          width: 0\n        };\n      }\n\n      return this.lgRect;\n    }\n  }]);\n\n  return Dimensions;\n}();\n\n/**\n * ApexCharts TimeScale Class for generating time ticks for x-axis.\n *\n * @module TimeScale\n **/\n\nvar TimeScale =\n/*#__PURE__*/\nfunction () {\n  function TimeScale(ctx) {\n    _classCallCheck(this, TimeScale);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.timeScaleArray = [];\n  }\n\n  _createClass(TimeScale, [{\n    key: \"calculateTimeScaleTicks\",\n    value: function calculateTimeScaleTicks(minX, maxX) {\n      var _this = this;\n\n      var w = this.w; // null check when no series to show\n\n      if (w.globals.allSeriesCollapsed) {\n        w.globals.labels = [];\n        w.globals.timelineLabels = [];\n        return [];\n      }\n\n      var dt = new DateTime(this.ctx);\n      var daysDiff = (maxX - minX) / (1000 * 60 * 60 * 24);\n      this.determineInterval(daysDiff);\n      w.globals.disableZoomIn = false;\n      w.globals.disableZoomOut = false;\n\n      if (daysDiff < 0.005) {\n        w.globals.disableZoomIn = true;\n      } else if (daysDiff > 50000) {\n        w.globals.disableZoomOut = true;\n      }\n\n      var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX);\n      var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;\n      var hoursWidthOnXAxis = daysWidthOnXAxis / 24;\n      var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;\n      var numberOfHours = Math.floor(daysDiff * 24);\n      var numberOfMinutes = Math.floor(daysDiff * 24 * 60);\n      var numberOfDays = Math.floor(daysDiff);\n      var numberOfMonths = Math.floor(daysDiff / 30);\n      var numberOfYears = Math.floor(daysDiff / 365);\n      var firstVal = {\n        minMinute: timeIntervals.minMinute,\n        minHour: timeIntervals.minHour,\n        minDate: timeIntervals.minDate,\n        minMonth: timeIntervals.minMonth,\n        minYear: timeIntervals.minYear\n      };\n      var currentMinute = firstVal.minMinute;\n      var currentHour = firstVal.minHour;\n      var currentMonthDate = firstVal.minDate;\n      var currentDate = firstVal.minDate;\n      var currentMonth = firstVal.minMonth;\n      var currentYear = firstVal.minYear;\n      var params = {\n        firstVal: firstVal,\n        currentMinute: currentMinute,\n        currentHour: currentHour,\n        currentMonthDate: currentMonthDate,\n        currentDate: currentDate,\n        currentMonth: currentMonth,\n        currentYear: currentYear,\n        daysWidthOnXAxis: daysWidthOnXAxis,\n        hoursWidthOnXAxis: hoursWidthOnXAxis,\n        minutesWidthOnXAxis: minutesWidthOnXAxis,\n        numberOfMinutes: numberOfMinutes,\n        numberOfHours: numberOfHours,\n        numberOfDays: numberOfDays,\n        numberOfMonths: numberOfMonths,\n        numberOfYears: numberOfYears\n      };\n\n      switch (this.tickInterval) {\n        case 'years':\n          {\n            this.generateYearScale(params);\n            break;\n          }\n\n        case 'months':\n        case 'half_year':\n          {\n            this.generateMonthScale(params);\n            break;\n          }\n\n        case 'months_days':\n        case 'months_fortnight':\n        case 'days':\n        case 'week_days':\n          {\n            this.generateDayScale(params);\n            break;\n          }\n\n        case 'hours':\n          {\n            this.generateHourScale(params);\n            break;\n          }\n\n        case 'minutes':\n          this.generateMinuteScale(params);\n          break;\n      } // first, we will adjust the month values index\n      // as in the upper function, it is starting from 0\n      // we will start them from 1\n\n\n      var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {\n        var defaultReturn = {\n          position: ts.position,\n          unit: ts.unit,\n          year: ts.year,\n          day: ts.day ? ts.day : 1,\n          hour: ts.hour ? ts.hour : 0,\n          month: ts.month + 1\n        };\n\n        if (ts.unit === 'month') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value + 1\n          });\n        } else if (ts.unit === 'day' || ts.unit === 'hour') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value\n          });\n        } else if (ts.unit === 'minute') {\n          return _objectSpread({}, defaultReturn, {\n            value: ts.value,\n            minute: ts.value\n          });\n        }\n\n        return ts;\n      });\n      var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {\n        var modulo = 1;\n        var ticks = Math.ceil(w.globals.gridWidth / 120);\n        var value = ts.value;\n\n        if (w.config.xaxis.tickAmount !== undefined) {\n          ticks = w.config.xaxis.tickAmount;\n        }\n\n        if (adjustedMonthInTimeScaleArray.length > ticks) {\n          modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);\n        }\n\n        var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months\n\n        var shouldNotPrint = false; // should skip these values\n\n        switch (_this.tickInterval) {\n          case 'half_year':\n            modulo = 7;\n\n            if (ts.unit === 'year') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'months':\n            modulo = 1;\n\n            if (ts.unit === 'year') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'months_fortnight':\n            modulo = 15;\n\n            if (ts.unit === 'year' || ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            if (value === 30) {\n              shouldNotPrint = true;\n            }\n\n            break;\n\n          case 'months_days':\n            modulo = 10;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            if (value === 30) {\n              shouldNotPrint = true;\n            }\n\n            break;\n\n          case 'week_days':\n            modulo = 8;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'days':\n            modulo = 1;\n\n            if (ts.unit === 'month') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'hours':\n            if (ts.unit === 'day') {\n              shouldNotSkipUnit = true;\n            }\n\n            break;\n\n          case 'minutes':\n            if (value % 5 !== 0) {\n              shouldNotPrint = true;\n            }\n\n            break;\n        }\n\n        if (_this.tickInterval === 'minutes' || _this.tickInterval === 'hours') {\n          if (!shouldNotPrint) {\n            return true;\n          }\n        } else {\n          if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {\n            return true;\n          }\n        }\n      });\n      return filteredTimeScale;\n    }\n  }, {\n    key: \"recalcDimensionsBasedOnFormat\",\n    value: function recalcDimensionsBasedOnFormat(filteredTimeScale) {\n      var w = this.w;\n      var reformattedTimescaleArray = this.formatDates(filteredTimeScale);\n      var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);\n      w.globals.timelineLabels = removedOverlappingTS.slice(); // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords\n      // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX\n      // Dependency on Dimensions(), need to refactor correctly\n      // TODO - find an alternate way to avoid calling this Heavy method twice\n\n      var dimensions = new Dimensions(this.ctx);\n      dimensions.plotCoords();\n    }\n  }, {\n    key: \"determineInterval\",\n    value: function determineInterval(daysDiff) {\n      switch (true) {\n        case daysDiff > 1825:\n          // difference is more than 5 years\n          this.tickInterval = 'years';\n          break;\n\n        case daysDiff > 800 && daysDiff <= 1825:\n          this.tickInterval = 'half_year';\n          break;\n\n        case daysDiff > 180 && daysDiff <= 800:\n          this.tickInterval = 'months';\n          break;\n\n        case daysDiff > 90 && daysDiff <= 180:\n          this.tickInterval = 'months_fortnight';\n          break;\n\n        case daysDiff > 60 && daysDiff <= 90:\n          this.tickInterval = 'months_days';\n          break;\n\n        case daysDiff > 30 && daysDiff <= 60:\n          this.tickInterval = 'week_days';\n          break;\n\n        case daysDiff > 2 && daysDiff <= 30:\n          this.tickInterval = 'days';\n          break;\n\n        case daysDiff > 0.1 && daysDiff <= 2:\n          // less than  2 days\n          this.tickInterval = 'hours';\n          break;\n\n        case daysDiff < 0.1:\n          this.tickInterval = 'minutes';\n          break;\n\n        default:\n          this.tickInterval = 'days';\n          break;\n      }\n    }\n  }, {\n    key: \"generateYearScale\",\n    value: function generateYearScale(params) {\n      var firstVal = params.firstVal,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          daysWidthOnXAxis = params.daysWidthOnXAxis,\n          numberOfYears = params.numberOfYears;\n      var firstTickValue = firstVal.minYear;\n      var firstTickPosition = 0;\n      var dt = new DateTime(this.ctx);\n      var unit = 'year';\n\n      if (firstVal.minDate > 1 && firstVal.minMonth > 0) {\n        var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate); // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n\n        var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1; // calculate the first tick position\n\n        firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;\n        firstTickValue = firstVal.minYear + 1; // push the first tick in the array\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: firstTickValue,\n          month: Utils.monthMod(currentMonth + 1)\n        });\n      } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {\n        // push the first tick in the array\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: currentYear,\n          month: Utils.monthMod(currentMonth + 1)\n        });\n      }\n\n      var year = firstTickValue;\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfYears; i++) {\n        year++;\n        pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;\n        this.timeScaleArray.push({\n          position: pos,\n          value: year,\n          unit: unit,\n          year: year,\n          month: 1\n        });\n      }\n    }\n  }, {\n    key: \"generateMonthScale\",\n    value: function generateMonthScale(params) {\n      var firstVal = params.firstVal,\n          currentMonthDate = params.currentMonthDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          daysWidthOnXAxis = params.daysWidthOnXAxis,\n          numberOfMonths = params.numberOfMonths;\n      var firstTickValue = currentMonth;\n      var firstTickPosition = 0;\n      var dt = new DateTime(this.ctx);\n      var unit = 'month';\n      var yrCounter = 0;\n\n      if (firstVal.minDate > 1) {\n        // remainingDaysofFirstMonth is used to reacht the 2nd tick position\n        var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1; // calculate the first tick position\n\n        firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;\n        firstTickValue = Utils.monthMod(currentMonth + 1);\n        var year = currentYear + yrCounter;\n\n        var _month = Utils.monthMod(firstTickValue);\n\n        var value = firstTickValue; // it's Jan, so update the year\n\n        if (firstTickValue === 0) {\n          unit = 'year';\n          value = year;\n          _month = 1;\n          yrCounter += 1;\n          year = year + yrCounter;\n        } // push the first tick in the array\n\n\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: value,\n          unit: unit,\n          year: year,\n          month: _month\n        });\n      } else {\n        // push the first tick in the array\n        this.timeScaleArray.push({\n          position: firstTickPosition,\n          value: firstTickValue,\n          unit: unit,\n          year: currentYear,\n          month: Utils.monthMod(currentMonth)\n        });\n      }\n\n      var month = firstTickValue + 1;\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {\n        month = Utils.monthMod(month);\n\n        if (month === 0) {\n          unit = 'year';\n          yrCounter += 1;\n        } else {\n          unit = 'month';\n        }\n\n        var _year = currentYear + Math.floor(month / 12) + yrCounter;\n\n        pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;\n        var monthVal = month === 0 ? _year : month;\n        this.timeScaleArray.push({\n          position: pos,\n          value: monthVal,\n          unit: unit,\n          year: _year,\n          month: month === 0 ? 1 : month\n        });\n        month++;\n      }\n    }\n  }, {\n    key: \"generateDayScale\",\n    value: function generateDayScale(params) {\n      var firstVal = params.firstVal,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          hoursWidthOnXAxis = params.hoursWidthOnXAxis,\n          numberOfDays = params.numberOfDays;\n      var dt = new DateTime(this.ctx);\n      var unit = 'day';\n      var remainingHours = 24 - firstVal.minHour;\n      var yrCounter = 0; // calculate the first tick position\n\n      var firstTickPosition = remainingHours * hoursWidthOnXAxis;\n      var firstTickValue = firstVal.minDate + 1;\n      var val = firstTickValue;\n\n      var changeMonth = function changeMonth(dateVal, month, year) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, year);\n\n        if (dateVal > monthdays) {\n          month = month + 1;\n          date = 1;\n          unit = 'month';\n          val = month;\n          return month;\n        }\n\n        return month;\n      };\n\n      var date = firstTickValue;\n      var month = changeMonth(date, currentMonth, currentYear); // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: val,\n        unit: unit,\n        year: currentYear,\n        month: Utils.monthMod(month),\n        day: date\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfDays; i++) {\n        date += 1;\n        unit = 'day';\n        month = changeMonth(date, month, currentYear + Math.floor(month / 12) + yrCounter);\n        var year = currentYear + Math.floor(month / 12) + yrCounter;\n        pos = 24 * hoursWidthOnXAxis + pos;\n\n        var _val = date === 1 ? Utils.monthMod(month) : date;\n\n        this.timeScaleArray.push({\n          position: pos,\n          value: _val,\n          unit: unit,\n          year: year,\n          month: Utils.monthMod(month),\n          day: _val\n        });\n      }\n    }\n  }, {\n    key: \"generateHourScale\",\n    value: function generateHourScale(params) {\n      var firstVal = params.firstVal,\n          currentDate = params.currentDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          minutesWidthOnXAxis = params.minutesWidthOnXAxis,\n          numberOfHours = params.numberOfHours;\n      var dt = new DateTime(this.ctx);\n      var yrCounter = 0;\n      var unit = 'hour';\n\n      var changeDate = function changeDate(dateVal, month) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n        if (dateVal > monthdays) {\n          date = 1;\n          month = month + 1;\n        }\n\n        return {\n          month: month,\n          date: date\n        };\n      };\n\n      var changeMonth = function changeMonth(dateVal, month) {\n        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);\n\n        if (dateVal > monthdays) {\n          month = month + 1;\n          return month;\n        }\n\n        return month;\n      };\n\n      var remainingMins = 60 - firstVal.minMinute;\n      var firstTickPosition = remainingMins * minutesWidthOnXAxis;\n      var firstTickValue = firstVal.minHour + 1;\n      var hour = firstTickValue + 1;\n\n      if (remainingMins === 60) {\n        firstTickPosition = 0;\n        firstTickValue = firstVal.minHour;\n        hour = firstTickValue + 1;\n      }\n\n      var date = currentDate;\n      var month = changeMonth(date, currentMonth); // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: firstTickValue,\n        unit: unit,\n        day: date,\n        hour: hour,\n        year: currentYear,\n        month: Utils.monthMod(month)\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfHours; i++) {\n        unit = 'hour';\n\n        if (hour >= 24) {\n          hour = 0;\n          date += 1;\n          unit = 'day';\n          var checkNextMonth = changeDate(date, month);\n          month = checkNextMonth.month;\n          month = changeMonth(date, month);\n        }\n\n        var year = currentYear + Math.floor(month / 12) + yrCounter;\n        pos = hour === 0 && i === 0 ? remainingMins * minutesWidthOnXAxis : 60 * minutesWidthOnXAxis + pos;\n        var val = hour === 0 ? date : hour;\n        this.timeScaleArray.push({\n          position: pos,\n          value: val,\n          unit: unit,\n          hour: hour,\n          day: date,\n          year: year,\n          month: Utils.monthMod(month)\n        });\n        hour++;\n      }\n    }\n  }, {\n    key: \"generateMinuteScale\",\n    value: function generateMinuteScale(params) {\n      var firstVal = params.firstVal,\n          currentMinute = params.currentMinute,\n          currentHour = params.currentHour,\n          currentDate = params.currentDate,\n          currentMonth = params.currentMonth,\n          currentYear = params.currentYear,\n          minutesWidthOnXAxis = params.minutesWidthOnXAxis,\n          numberOfMinutes = params.numberOfMinutes;\n      var yrCounter = 0;\n      var unit = 'minute';\n      var remainingMins = currentMinute - firstVal.minMinute;\n      var firstTickPosition = minutesWidthOnXAxis - remainingMins;\n      var firstTickValue = firstVal.minMinute + 1;\n      var minute = firstTickValue + 1;\n      var date = currentDate;\n      var month = currentMonth;\n      var year = currentYear;\n      var hour = currentHour; // push the first tick in the array\n\n      this.timeScaleArray.push({\n        position: firstTickPosition,\n        value: firstTickValue,\n        unit: unit,\n        day: date,\n        hour: hour,\n        minute: minute,\n        year: year,\n        month: Utils.monthMod(month)\n      });\n      var pos = firstTickPosition; // keep drawing rest of the ticks\n\n      for (var i = 0; i < numberOfMinutes; i++) {\n        if (minute >= 60) {\n          minute = 0;\n          hour += 1;\n\n          if (hour === 24) {\n            hour = 0;\n          }\n        }\n\n        var _year2 = currentYear + Math.floor(month / 12) + yrCounter;\n\n        pos = minutesWidthOnXAxis + pos;\n        var val = minute;\n        this.timeScaleArray.push({\n          position: pos,\n          value: val,\n          unit: unit,\n          hour: hour,\n          minute: minute,\n          day: date,\n          year: _year2,\n          month: Utils.monthMod(month)\n        });\n        minute++;\n      }\n    }\n  }, {\n    key: \"createRawDateString\",\n    value: function createRawDateString(ts, value) {\n      var raw = ts.year;\n      raw += '-' + ('0' + ts.month.toString()).slice(-2); // unit is day\n\n      if (ts.unit === 'day') {\n        raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';\n      } else {\n        raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);\n      } // unit is hour\n\n\n      if (ts.unit === 'hour') {\n        raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';\n      } else {\n        raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);\n      } // unit is minute\n\n\n      raw += ts.unit === 'minute' ? ':' + ('0' + value).slice(-2) + ':00.000Z' : ':00:00.000Z';\n      return raw;\n    }\n  }, {\n    key: \"formatDates\",\n    value: function formatDates(filteredTimeScale) {\n      var _this2 = this;\n\n      var w = this.w;\n      var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {\n        var value = ts.value.toString();\n        var dt = new DateTime(_this2.ctx);\n\n        var raw = _this2.createRawDateString(ts, value); // parse the whole ISO datestring\n\n\n        var dateString = new Date(Date.parse(raw));\n\n        if (w.config.xaxis.labels.format === undefined) {\n          var customFormat = 'dd MMM';\n          var dtFormatter = w.config.xaxis.labels.datetimeFormatter;\n          if (ts.unit === 'year') customFormat = dtFormatter.year;\n          if (ts.unit === 'month') customFormat = dtFormatter.month;\n          if (ts.unit === 'day') customFormat = dtFormatter.day;\n          if (ts.unit === 'hour') customFormat = dtFormatter.hour;\n          if (ts.unit === 'minute') customFormat = dtFormatter.minute;\n          value = dt.formatDate(dateString, customFormat, true, false);\n        } else {\n          value = dt.formatDate(dateString, w.config.xaxis.labels.format);\n        }\n\n        return {\n          dateString: raw,\n          position: ts.position,\n          value: value,\n          unit: ts.unit,\n          year: ts.year,\n          month: ts.month\n        };\n      });\n      return reformattedTimescaleArray;\n    }\n  }, {\n    key: \"removeOverlappingTS\",\n    value: function removeOverlappingTS(arr) {\n      var _this3 = this;\n\n      var graphics = new Graphics(this.ctx);\n      var lastDrawnIndex = 0;\n      var filteredArray = arr.map(function (item, index) {\n        if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {\n          var prevLabelWidth = graphics.getTextRects(arr[lastDrawnIndex].value).width;\n          var prevPos = arr[lastDrawnIndex].position;\n          var pos = item.position;\n\n          if (pos > prevPos + prevLabelWidth + 10) {\n            lastDrawnIndex = index;\n            return item;\n          } else {\n            return null;\n          }\n        } else {\n          return item;\n        }\n      });\n      filteredArray = filteredArray.filter(function (f) {\n        return f !== null;\n      });\n      return filteredArray;\n    }\n  }]);\n\n  return TimeScale;\n}();\n\n/**\n * ApexCharts Core Class responsible for major calculations and creating elements.\n *\n * @module Core\n **/\n\nvar Core =\n/*#__PURE__*/\nfunction () {\n  function Core(el, ctx) {\n    _classCallCheck(this, Core);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.el = el;\n    this.coreUtils = new CoreUtils(this.ctx);\n    this.twoDSeries = [];\n    this.threeDSeries = [];\n    this.twoDSeriesX = [];\n  } // get data and store into appropriate vars\n\n\n  _createClass(Core, [{\n    key: \"setupElements\",\n    value: function setupElements() {\n      var gl = this.w.globals;\n      var cnf = this.w.config; // const graphics = new Graphics(this.ctx)\n\n      var ct = cnf.chart.type;\n      var axisChartsArrTypes = ['line', 'area', 'bar', 'candlestick', 'radar', 'scatter', 'bubble', 'heatmap'];\n      var xyChartsArrTypes = ['line', 'area', 'bar', 'candlestick', 'scatter', 'bubble'];\n      gl.axisCharts = axisChartsArrTypes.indexOf(ct) > -1;\n      gl.xyCharts = xyChartsArrTypes.indexOf(ct) > -1;\n      gl.chartClass = '.apexcharts' + gl.cuid;\n      gl.dom.baseEl = this.el;\n      gl.dom.elWrap = document.createElement('div');\n      Graphics.setAttrs(gl.dom.elWrap, {\n        id: gl.chartClass.substring(1),\n        class: 'apexcharts-canvas ' + gl.chartClass.substring(1)\n      });\n      this.el.appendChild(gl.dom.elWrap);\n      gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap);\n      gl.dom.Paper.attr({\n        class: 'apexcharts-svg',\n        'xmlns:data': 'ApexChartsNS',\n        transform: \"translate(\".concat(cnf.chart.offsetX, \", \").concat(cnf.chart.offsetY, \")\")\n      });\n      gl.dom.Paper.node.style.background = cnf.chart.background;\n      this.setSVGDimensions();\n      gl.dom.elGraphical = gl.dom.Paper.group().attr({\n        class: 'apexcharts-inner apexcharts-graphical'\n      });\n      gl.dom.elDefs = gl.dom.Paper.defs();\n      gl.dom.elLegendWrap = document.createElement('div');\n      gl.dom.elLegendWrap.classList.add('apexcharts-legend');\n      gl.dom.elWrap.appendChild(gl.dom.elLegendWrap); // gl.dom.Paper.add(gl.dom.elLegendWrap)\n\n      gl.dom.Paper.add(gl.dom.elGraphical);\n      gl.dom.elGraphical.add(gl.dom.elDefs);\n    }\n  }, {\n    key: \"plotChartType\",\n    value: function plotChartType(ser, xyRatios) {\n      var w = this.w;\n      var cnf = w.config;\n      var gl = w.globals;\n      var lineSeries = {\n        series: [],\n        i: []\n      };\n      var areaSeries = {\n        series: [],\n        i: []\n      };\n      var scatterSeries = {\n        series: [],\n        i: []\n      };\n      var columnSeries = {\n        series: [],\n        i: []\n      };\n      var candlestickSeries = {\n        series: [],\n        i: []\n      };\n      gl.series.map(function (series, st) {\n        // if user has specified a particular type for particular series\n        if (typeof ser[st].type !== 'undefined') {\n          if (ser[st].type === 'column' || ser[st].type === 'bar') {\n            w.config.plotOptions.bar.horizontal = false; // bar not supported in mixed charts\n\n            columnSeries.series.push(series);\n            columnSeries.i.push(st);\n          } else if (ser[st].type === 'area') {\n            areaSeries.series.push(series);\n            areaSeries.i.push(st);\n          } else if (ser[st].type === 'line') {\n            lineSeries.series.push(series);\n            lineSeries.i.push(st);\n          } else if (ser[st].type === 'scatter') {\n            scatterSeries.series.push(series);\n            scatterSeries.i.push(st);\n          } else if (ser[st].type === 'bubble') ; else if (ser[st].type === 'candlestick') {\n            candlestickSeries.series.push(series);\n            candlestickSeries.i.push(st);\n          } else {\n            // user has specified type, but it is not valid (other than line/area/column)\n            console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble');\n          }\n\n          gl.comboCharts = true;\n        } else {\n          lineSeries.series.push(series);\n          lineSeries.i.push(st);\n        }\n      });\n      var line = new Line(this.ctx, xyRatios);\n      var candlestick = new CandleStick(this.ctx, xyRatios);\n      var pie = new Pie(this.ctx);\n      var radialBar = new Radial(this.ctx);\n      var radar = new Radar(this.ctx);\n      var elGraph = [];\n\n      if (gl.comboCharts) {\n        if (areaSeries.series.length > 0) {\n          elGraph.push(line.draw(areaSeries.series, 'area', areaSeries.i));\n        }\n\n        if (columnSeries.series.length > 0) {\n          if (w.config.chart.stacked) {\n            var barStacked = new BarStacked(this.ctx, xyRatios);\n            elGraph.push(barStacked.draw(columnSeries.series, columnSeries.i));\n          } else {\n            var bar = new Bar(this.ctx, xyRatios);\n            elGraph.push(bar.draw(columnSeries.series, columnSeries.i));\n          }\n        }\n\n        if (lineSeries.series.length > 0) {\n          elGraph.push(line.draw(lineSeries.series, 'line', lineSeries.i));\n        }\n\n        if (candlestickSeries.series.length > 0) {\n          elGraph.push(candlestick.draw(candlestickSeries.series, candlestickSeries.i));\n        }\n\n        if (scatterSeries.series.length > 0) {\n          var scatterLine = new Line(this.ctx, xyRatios, true);\n          elGraph.push(scatterLine.draw(scatterSeries.series, 'scatter', scatterSeries.i));\n        } // TODO: allow bubble series in a combo chart\n        // if (bubbleSeries.series.length > 0) {\n        //   const bubbleLine = new Line(this.ctx, xyRatios, true)\n        //   elGraph.push(\n        //     bubbleLine.draw(bubbleSeries.series, 'bubble', bubbleSeries.i)\n        //   )\n        // }\n\n      } else {\n        switch (cnf.chart.type) {\n          case 'line':\n            elGraph = line.draw(gl.series, 'line');\n            break;\n\n          case 'area':\n            elGraph = line.draw(gl.series, 'area');\n            break;\n\n          case 'bar':\n            if (cnf.chart.stacked) {\n              var _barStacked = new BarStacked(this.ctx, xyRatios);\n\n              elGraph = _barStacked.draw(gl.series);\n            } else {\n              var _bar = new Bar(this.ctx, xyRatios);\n\n              elGraph = _bar.draw(gl.series);\n            }\n\n            break;\n\n          case 'candlestick':\n            var candleStick = new CandleStick(this.ctx, xyRatios);\n            elGraph = candleStick.draw(gl.series);\n            break;\n\n          case 'heatmap':\n            var heatmap = new HeatMap(this.ctx, xyRatios);\n            elGraph = heatmap.draw(gl.series);\n            break;\n\n          case 'pie':\n          case 'donut':\n            elGraph = pie.draw(gl.series);\n            break;\n\n          case 'radialBar':\n            elGraph = radialBar.draw(gl.series);\n            break;\n\n          case 'radar':\n            elGraph = radar.draw(gl.series);\n            break;\n\n          default:\n            elGraph = line.draw(gl.series);\n        }\n      }\n\n      return elGraph;\n    }\n  }, {\n    key: \"setSVGDimensions\",\n    value: function setSVGDimensions() {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.svgWidth = cnf.chart.width;\n      gl.svgHeight = cnf.chart.height;\n      var elDim = Utils.getDimensions(this.el);\n      var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();\n\n      if (widthUnit === '%') {\n        if (Utils.isNumber(elDim[0])) {\n          if (elDim[0].width === 0) {\n            elDim = Utils.getDimensions(this.el.parentNode);\n          }\n\n          gl.svgWidth = elDim[0] * parseInt(cnf.chart.width) / 100;\n        }\n      } else if (widthUnit === 'px' || widthUnit === '') {\n        gl.svgWidth = parseInt(cnf.chart.width);\n      }\n\n      if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {\n        var heightUnit = cnf.chart.height.toString().split(/[0-9]+/g).pop();\n\n        if (heightUnit === '%') {\n          var elParentDim = Utils.getDimensions(this.el.parentNode);\n          gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height) / 100;\n        } else {\n          gl.svgHeight = parseInt(cnf.chart.height);\n        }\n      } else {\n        if (gl.axisCharts) {\n          gl.svgHeight = gl.svgWidth / 1.61;\n        } else {\n          gl.svgHeight = gl.svgWidth;\n        }\n      }\n\n      Graphics.setAttrs(gl.dom.Paper.node, {\n        width: gl.svgWidth,\n        height: gl.svgHeight\n      }); // gl.dom.Paper.node.parentNode.parentNode.style.minWidth = gl.svgWidth + \"px\";\n\n      var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? 14 : 5;\n      gl.dom.Paper.node.parentNode.parentNode.style.minHeight = gl.svgHeight + offsetY + 'px';\n      gl.dom.elWrap.style.width = gl.svgWidth + 'px';\n      gl.dom.elWrap.style.height = gl.svgHeight + 'px';\n    }\n  }, {\n    key: \"shiftGraphPosition\",\n    value: function shiftGraphPosition() {\n      var gl = this.w.globals;\n      var tY = gl.translateY;\n      var tX = gl.translateX;\n      var scalingAttrs = {\n        transform: 'translate(' + tX + ', ' + tY + ')'\n      };\n      Graphics.setAttrs(gl.dom.elGraphical.node, scalingAttrs);\n    }\n    /*\n     ** All the calculations for setting range in charts will be done here\n     */\n\n  }, {\n    key: \"coreCalculations\",\n    value: function coreCalculations() {\n      var range = new Range$1(this.ctx);\n      range.init();\n    }\n  }, {\n    key: \"resetGlobals\",\n    value: function resetGlobals() {\n      var _this = this;\n\n      var gl = this.w.globals;\n      gl.series = [];\n      gl.seriesCandleO = [];\n      gl.seriesCandleH = [];\n      gl.seriesCandleL = [];\n      gl.seriesCandleC = [];\n      gl.seriesPercent = [];\n      gl.seriesX = [];\n      gl.seriesZ = [];\n      gl.seriesNames = [];\n      gl.seriesTotals = [];\n      gl.stackedSeriesTotals = [];\n      gl.labels = [];\n      gl.timelineLabels = [];\n      gl.noLabelsProvided = false;\n      gl.timescaleTicks = [];\n      gl.resizeTimer = null;\n      gl.selectionResizeTimer = null;\n\n      gl.seriesXvalues = function () {\n        return _this.w.config.series.map(function (s) {\n          return [];\n        });\n      }();\n\n      gl.seriesYvalues = function () {\n        return _this.w.config.series.map(function (s) {\n          return [];\n        });\n      }();\n\n      gl.delayedElements = [];\n      gl.pointsArray = [];\n      gl.dataLabelsRects = [];\n      gl.isXNumeric = false;\n      gl.isDataXYZ = false;\n      gl.maxY = -Number.MAX_VALUE;\n      gl.minY = Number.MIN_VALUE;\n      gl.minYArr = [];\n      gl.maxYArr = [];\n      gl.maxX = -Number.MAX_VALUE;\n      gl.minX = Number.MAX_VALUE;\n      gl.initialmaxX = -Number.MAX_VALUE;\n      gl.initialminX = Number.MAX_VALUE;\n      gl.maxDate = 0;\n      gl.minDate = Number.MAX_VALUE;\n      gl.minZ = Number.MAX_VALUE;\n      gl.maxZ = -Number.MAX_VALUE;\n      gl.yAxisScale = [];\n      gl.xAxisScale = null;\n      gl.xAxisTicksPositions = [];\n      gl.yLabelsCoords = [];\n      gl.yTitleCoords = [];\n      gl.xRange = 0;\n      gl.yRange = [];\n      gl.zRange = 0;\n      gl.dataPoints = 0;\n    }\n  }, {\n    key: \"isMultipleY\",\n    value: function isMultipleY() {\n      // user has supplied an array in yaxis property. So, turn on multipleYAxis flag\n      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) {\n        // first, turn off stacking if multiple y axis\n        this.w.config.chart.stacked = false;\n        this.w.globals.isMultipleYAxis = true;\n        return true;\n      }\n    }\n  }, {\n    key: \"excludeCollapsedSeriesInYAxis\",\n    value: function excludeCollapsedSeriesInYAxis() {\n      var _this2 = this;\n\n      var w = this.w;\n      w.globals.ignoreYAxisIndexes = w.globals.collapsedSeries.map(function (collapsed, i) {\n        if (_this2.w.globals.isMultipleYAxis) {\n          return collapsed.index;\n        }\n      });\n    }\n  }, {\n    key: \"isMultiFormat\",\n    value: function isMultiFormat() {\n      return this.isFormatXY() || this.isFormat2DArray();\n    } // given format is [{x, y}, {x, y}]\n\n  }, {\n    key: \"isFormatXY\",\n    value: function isFormatXY() {\n      var series = this.w.config.series.slice();\n      var sr = new Series(this.ctx);\n      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {\n        return true;\n      }\n    } // given format is [[x, y], [x, y]]\n\n  }, {\n    key: \"isFormat2DArray\",\n    value: function isFormat2DArray() {\n      var series = this.w.config.series.slice();\n      var sr = new Series(this.ctx);\n      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();\n\n      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {\n        return true;\n      }\n    }\n  }, {\n    key: \"handleFormat2DArray\",\n    value: function handleFormat2DArray(ser, i) {\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n\n      for (var j = 0; j < ser[i].data.length; j++) {\n        if (typeof ser[i].data[j][1] !== 'undefined') {\n          if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4) {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1][3]));\n          } else {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1]));\n          }\n        }\n\n        if (cnf.xaxis.type === 'datetime') {\n          // if timestamps are provided and xaxis type is datettime,\n          var ts = new Date(ser[i].data[j][0]);\n          ts = new Date(ts).getTime();\n          this.twoDSeriesX.push(ts);\n        } else {\n          this.twoDSeriesX.push(ser[i].data[j][0]);\n        }\n      }\n\n      for (var _j = 0; _j < ser[i].data.length; _j++) {\n        if (typeof ser[i].data[_j][2] !== 'undefined') {\n          this.threeDSeries.push(ser[i].data[_j][2]);\n          gl.isDataXYZ = true;\n        }\n      }\n    }\n  }, {\n    key: \"handleFormatXY\",\n    value: function handleFormatXY(ser, i) {\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n      var dt = new DateTime(this.ctx);\n      var activeI = i;\n\n      if (gl.collapsedSeriesIndices.indexOf(i) > -1) {\n        // fix #368\n        activeI = this.activeSeriesIndex;\n      } // get series\n\n\n      for (var j = 0; j < ser[i].data.length; j++) {\n        if (typeof ser[i].data[j].y !== 'undefined') {\n          if (Array.isArray(ser[i].data[j].y) && ser[i].data[j].y.length === 4) {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y[3]));\n          } else {\n            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y));\n          }\n        }\n      } // get seriesX\n\n\n      for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {\n        var isXString = typeof ser[activeI].data[_j2].x === 'string';\n        var isXDate = !!dt.isValidDate(ser[activeI].data[_j2].x.toString());\n\n        if (isXString || isXDate) {\n          // user supplied '01/01/2017' or a date string (a JS date object is not supported)\n          if (isXString) {\n            if (cnf.xaxis.type === 'datetime') {\n              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));\n            } else {\n              // a category and not a numeric x value\n              this.fallbackToCategory = true;\n              this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n            }\n          } else {\n            if (cnf.xaxis.type === 'datetime') {\n              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));\n            } else {\n              this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));\n            }\n          }\n        } else {\n          // a numeric value in x property\n          this.twoDSeriesX.push(ser[activeI].data[_j2].x);\n        }\n      }\n\n      if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {\n        for (var t = 0; t < ser[i].data.length; t++) {\n          this.threeDSeries.push(ser[i].data[t].z);\n        }\n\n        gl.isDataXYZ = true;\n      }\n    }\n  }, {\n    key: \"handleCandleStickData\",\n    value: function handleCandleStickData(ser, i) {\n      var gl = this.w.globals;\n      var ohlc = {};\n\n      if (this.isFormat2DArray()) {\n        ohlc = this.handleCandleStickDataFormat('array', ser, i);\n      } else if (this.isFormatXY()) {\n        ohlc = this.handleCandleStickDataFormat('xy', ser, i);\n      }\n\n      gl.seriesCandleO.push(ohlc.o);\n      gl.seriesCandleH.push(ohlc.h);\n      gl.seriesCandleL.push(ohlc.l);\n      gl.seriesCandleC.push(ohlc.c);\n      return ohlc;\n    }\n  }, {\n    key: \"handleCandleStickDataFormat\",\n    value: function handleCandleStickDataFormat(format, ser, i) {\n      var serO = [];\n      var serH = [];\n      var serL = [];\n      var serC = [];\n      var err = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick';\n\n      if (format === 'array') {\n        if (ser[i].data[0][1].length !== 4) {\n          throw new Error(err);\n        }\n\n        for (var j = 0; j < ser[i].data.length; j++) {\n          serO.push(ser[i].data[j][1][0]);\n          serH.push(ser[i].data[j][1][1]);\n          serL.push(ser[i].data[j][1][2]);\n          serC.push(ser[i].data[j][1][3]);\n        }\n      } else if (format === 'xy') {\n        if (ser[i].data[0].y.length !== 4) {\n          throw new Error(err);\n        }\n\n        for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {\n          serO.push(ser[i].data[_j3].y[0]);\n          serH.push(ser[i].data[_j3].y[1]);\n          serL.push(ser[i].data[_j3].y[2]);\n          serC.push(ser[i].data[_j3].y[3]);\n        }\n      }\n\n      return {\n        o: serO,\n        h: serH,\n        l: serL,\n        c: serC\n      };\n    }\n  }, {\n    key: \"parseDataAxisCharts\",\n    value: function parseDataAxisCharts(ser) {\n      var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;\n      var cnf = this.w.config;\n      var gl = this.w.globals;\n      var dt = new DateTime(ctx);\n\n      for (var i = 0; i < ser.length; i++) {\n        this.twoDSeries = [];\n        this.twoDSeriesX = [];\n        this.threeDSeries = [];\n\n        if (typeof ser[i].data === 'undefined') {\n          console.error(\"It is a possibility that you may have not included 'data' property in series.\");\n          return;\n        }\n\n        if (this.isMultiFormat()) {\n          if (this.isFormat2DArray()) {\n            this.handleFormat2DArray(ser, i);\n          } else if (this.isFormatXY()) {\n            this.handleFormatXY(ser, i);\n          }\n\n          if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick') {\n            this.handleCandleStickData(ser, i);\n          }\n\n          gl.series.push(this.twoDSeries);\n          gl.labels.push(this.twoDSeriesX);\n          gl.seriesX.push(this.twoDSeriesX);\n\n          if (!this.fallbackToCategory) {\n            gl.isXNumeric = true;\n          }\n        } else {\n          if (cnf.xaxis.type === 'datetime') {\n            // user didn't supplied [{x,y}] or [[x,y]], but single array in data.\n            // Also labels/categories were supplied differently\n            gl.isXNumeric = true;\n            var dates = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();\n\n            for (var j = 0; j < dates.length; j++) {\n              if (typeof dates[j] === 'string') {\n                var isDate = dt.isValidDate(dates[j]);\n\n                if (isDate) {\n                  this.twoDSeriesX.push(dt.parseDate(dates[j]));\n                } else {\n                  throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');\n                }\n              }\n            }\n\n            gl.seriesX.push(this.twoDSeriesX);\n          } else if (cnf.xaxis.type === 'numeric') {\n            gl.isXNumeric = true;\n            var x = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();\n\n            if (x.length > 0) {\n              this.twoDSeriesX = x;\n              gl.seriesX.push(this.twoDSeriesX);\n            }\n          }\n\n          gl.labels.push(this.twoDSeriesX);\n          var singleArray = ser[i].data.map(function (d) {\n            return Utils.parseNumber(d);\n          });\n          gl.series.push(singleArray);\n        }\n\n        gl.seriesZ.push(this.threeDSeries);\n\n        if (ser[i].name !== undefined) {\n          gl.seriesNames.push(ser[i].name);\n        } else {\n          gl.seriesNames.push('series-' + parseInt(i + 1));\n        }\n      }\n\n      return this.w;\n    }\n  }, {\n    key: \"parseDataNonAxisCharts\",\n    value: function parseDataNonAxisCharts(ser) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      gl.series = ser.slice();\n      gl.seriesNames = cnf.labels.slice();\n\n      for (var i = 0; i < gl.series.length; i++) {\n        if (gl.seriesNames[i] === undefined) {\n          gl.seriesNames.push('series-' + (i + 1));\n        }\n      }\n\n      return this.w;\n    }\n  }, {\n    key: \"handleExternalLabelsData\",\n    value: function handleExternalLabelsData(ser) {\n      var cnf = this.w.config;\n      var gl = this.w.globals; // user provided labels in category axis\n\n      if (cnf.xaxis.categories.length > 0) {\n        gl.labels = cnf.xaxis.categories;\n      } else if (cnf.labels.length > 0) {\n        gl.labels = cnf.labels.slice();\n      } else if (this.fallbackToCategory) {\n        gl.labels = gl.labels[0];\n      } else {\n        // user didn't provided labels, fallback to 1-2-3-4-5\n        var labelArr = [];\n\n        if (gl.axisCharts) {\n          for (var i = 0; i < gl.series[gl.maxValsInArrayIndex].length; i++) {\n            labelArr.push(i + 1);\n          }\n\n          for (var _i = 0; _i < ser.length; _i++) {\n            gl.seriesX.push(labelArr);\n          }\n\n          gl.isXNumeric = true;\n        } // no series to pull labels from, put a 0-10 series\n\n\n        if (labelArr.length === 0) {\n          labelArr = [0, 10];\n\n          for (var _i2 = 0; _i2 < ser.length; _i2++) {\n            gl.seriesX.push(labelArr);\n          }\n        }\n\n        gl.labels = labelArr;\n        gl.noLabelsProvided = true;\n\n        if (cnf.xaxis.type === 'category') {\n          gl.isXNumeric = false;\n        }\n      }\n    } // Segregate user provided data into appropriate vars\n\n  }, {\n    key: \"parseData\",\n    value: function parseData(ser) {\n      var w = this.w;\n      var cnf = w.config;\n      var gl = w.globals;\n      this.excludeCollapsedSeriesInYAxis();\n      this.fallbackToCategory = false;\n      this.resetGlobals();\n      this.isMultipleY();\n\n      if (gl.axisCharts) {\n        this.parseDataAxisCharts(ser);\n      } else {\n        this.parseDataNonAxisCharts(ser);\n      }\n\n      this.coreUtils.getLargestSeries(); // set Null values to 0 in all series when user hides/shows some series\n\n      if (cnf.chart.type === 'bar' && cnf.chart.stacked) {\n        var series = new Series(this.ctx);\n        gl.series = series.setNullSeriesToZeroValues(gl.series);\n      }\n\n      this.coreUtils.getSeriesTotals();\n\n      if (gl.axisCharts) {\n        this.coreUtils.getStackedSeriesTotals();\n      }\n\n      this.coreUtils.getPercentSeries(); // user didn't provide a [[x,y],[x,y]] series, but a named series\n\n      if (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0) {\n        this.handleExternalLabelsData(ser);\n      }\n    }\n  }, {\n    key: \"xySettings\",\n    value: function xySettings() {\n      var xyRatios = null;\n      var w = this.w;\n\n      if (w.globals.axisCharts) {\n        if (w.config.xaxis.crosshairs.position === 'back') {\n          var crosshairs = new Crosshairs(this.ctx);\n          crosshairs.drawXCrosshairs();\n        }\n\n        if (w.config.yaxis[0].crosshairs.position === 'back') {\n          var _crosshairs = new Crosshairs(this.ctx);\n\n          _crosshairs.drawYCrosshairs();\n        }\n\n        xyRatios = this.coreUtils.getCalculatedRatios();\n\n        if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined && isFinite(w.globals.minX) && isFinite(w.globals.maxX)) {\n          var ts = new TimeScale(this.ctx);\n          var formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);\n          ts.recalcDimensionsBasedOnFormat(formattedTimeScale);\n        }\n      }\n\n      return xyRatios;\n    }\n  }, {\n    key: \"drawAxis\",\n    value: function drawAxis(type, xyRatios) {\n      var gl = this.w.globals;\n      var cnf = this.w.config;\n      var xAxis = new XAxis(this.ctx);\n      var yAxis = new YAxis(this.ctx);\n\n      if (gl.axisCharts && type !== 'radar') {\n        var elXaxis, elYaxis;\n\n        if (type === 'bar' && cnf.plotOptions.bar.horizontal) {\n          elYaxis = yAxis.drawYaxisInversed(0);\n          elXaxis = xAxis.drawXaxisInversed(0);\n          gl.dom.elGraphical.add(elXaxis);\n          gl.dom.elGraphical.add(elYaxis);\n        } else {\n          elXaxis = xAxis.drawXaxis();\n          gl.dom.elGraphical.add(elXaxis);\n          cnf.yaxis.map(function (yaxe, index) {\n            if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {\n              elYaxis = yAxis.drawYaxis(index);\n              gl.dom.Paper.add(elYaxis);\n            }\n          });\n        }\n      }\n\n      cnf.yaxis.map(function (yaxe, index) {\n        if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {\n          yAxis.yAxisTitleRotate(index, yaxe.opposite);\n        }\n      });\n    }\n  }, {\n    key: \"setupBrushHandler\",\n    value: function setupBrushHandler() {\n      var _this3 = this;\n\n      var w = this.w; // only for brush charts\n\n      if (!w.config.chart.brush.enabled) {\n        return;\n      } // if user has not defined a custom function for selection - we handle the brush chart\n      // otherwise we leave it to the user to define the functionality for selection\n\n\n      if (typeof w.config.chart.events.selection !== 'function') {\n        var targets = w.config.chart.brush.targets || [w.config.chart.brush.target]; // retro compatibility with single target option\n\n        targets.forEach(function (target) {\n          var targetChart = ApexCharts.getChartByID(target);\n          targetChart.w.globals.brushSource = _this3.ctx;\n\n          var updateSourceChart = function updateSourceChart() {\n            _this3.ctx._updateOptions({\n              chart: {\n                selection: {\n                  xaxis: {\n                    min: targetChart.w.globals.minX,\n                    max: targetChart.w.globals.maxX\n                  }\n                }\n              }\n            }, false, false);\n          };\n\n          if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {\n            targetChart.w.config.chart.events.zoomed = function () {\n              updateSourceChart();\n            };\n          }\n\n          if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {\n            targetChart.w.config.chart.events.scrolled = function () {\n              updateSourceChart();\n            };\n          }\n\n          w.config.chart.events.selection = function (chart, e) {\n            var yaxis = Utils.clone(w.config.yaxis);\n\n            if (w.config.chart.brush.autoScaleYaxis) {\n              var scale = new Range(targetChart);\n              yaxis = scale.autoScaleY(targetChart, e);\n            }\n\n            targetChart._updateOptions({\n              xaxis: {\n                min: e.xaxis.min,\n                max: e.xaxis.max\n              },\n              yaxis: yaxis\n            }, false, false, false);\n          };\n        });\n      }\n    }\n  }]);\n\n  return Core;\n}();\n\n/**\n * @this {Promise}\n */\nfunction finallyConstructor(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n}\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\n/**\n * @constructor\n * @param {Function} fn\n */\nfunction Promise$1(fn) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  /** @type {!number} */\n  this._state = 0;\n  /** @type {!boolean} */\n  this._handled = false;\n  /** @type {Promise|undefined} */\n  this._value = undefined;\n  /** @type {!Array<!Function>} */\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise$1._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise$1) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise$1._immediateFn(function() {\n      if (!self._handled) {\n        Promise$1._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\n/**\n * @constructor\n */\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise$1.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise$1.prototype.then = function(onFulfilled, onRejected) {\n  // @ts-ignore\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise$1.prototype['finally'] = finallyConstructor;\n\nPromise$1.all = function(arr) {\n  return new Promise$1(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise$1.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise$1) {\n    return value;\n  }\n\n  return new Promise$1(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise$1.reject = function(value) {\n  return new Promise$1(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise$1.race = function(values) {\n  return new Promise$1(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise$1._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nvar Exports =\n/*#__PURE__*/\nfunction () {\n  function Exports(ctx) {\n    _classCallCheck(this, Exports);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(Exports, [{\n    key: \"getSvgString\",\n    value: function getSvgString() {\n      return this.w.globals.dom.Paper.svg();\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var w = this.w; // hide some elements to avoid printing them on exported svg\n\n      var xcrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');\n      var ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');\n\n      if (xcrosshairs) {\n        xcrosshairs.setAttribute('x', -500);\n      }\n\n      if (ycrosshairs) {\n        ycrosshairs.setAttribute('y1', -100);\n        ycrosshairs.setAttribute('y2', -100);\n      }\n    }\n  }, {\n    key: \"svgUrl\",\n    value: function svgUrl() {\n      this.cleanup();\n      var svgData = this.getSvgString();\n      var svgBlob = new Blob([svgData], {\n        type: 'image/svg+xml;charset=utf-8'\n      });\n      return URL.createObjectURL(svgBlob);\n    }\n  }, {\n    key: \"dataURI\",\n    value: function dataURI() {\n      var _this = this;\n\n      return new Promise$1(function (resolve) {\n        var w = _this.w;\n\n        _this.cleanup();\n\n        var canvas = document.createElement('canvas');\n        canvas.width = w.globals.svgWidth;\n        canvas.height = w.globals.svgHeight;\n        var canvasBg = w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background;\n        var ctx = canvas.getContext('2d');\n        ctx.fillStyle = canvasBg;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        var DOMURL = window.URL || window.webkitURL || window;\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n\n        var svgData = _this.getSvgString();\n\n        var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);\n\n        img.onload = function () {\n          ctx.drawImage(img, 0, 0);\n          DOMURL.revokeObjectURL(svgUrl);\n          var imgURI = canvas.toDataURL('image/png');\n          resolve(imgURI);\n        };\n\n        img.src = svgUrl;\n      });\n    }\n  }, {\n    key: \"exportToSVG\",\n    value: function exportToSVG() {\n      this.triggerDownload(this.svgUrl(), '.svg');\n    }\n  }, {\n    key: \"exportToPng\",\n    value: function exportToPng() {\n      var _this2 = this;\n\n      this.dataURI().then(function (imgURI) {\n        _this2.triggerDownload(imgURI, '.png');\n      });\n    }\n  }, {\n    key: \"triggerDownload\",\n    value: function triggerDownload(href, ext) {\n      var downloadLink = document.createElement('a');\n      downloadLink.href = href;\n      downloadLink.download = this.w.globals.chartID + ext;\n      document.body.appendChild(downloadLink);\n      downloadLink.click();\n      document.body.removeChild(downloadLink);\n    }\n  }]);\n\n  return Exports;\n}();\n\n/**\n * ApexCharts Grid Class for drawing Cartesian Grid.\n *\n * @module Grid\n **/\n\nvar Grid =\n/*#__PURE__*/\nfunction () {\n  function Grid(ctx) {\n    _classCallCheck(this, Grid);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.anim = new Animations(this.ctx);\n    this.xaxisLabels = w.globals.labels.slice();\n    this.animX = w.config.grid.xaxis.lines.animate && w.config.chart.animations.enabled;\n    this.animY = w.config.grid.yaxis.lines.animate && w.config.chart.animations.enabled;\n\n    if (w.globals.timelineLabels.length > 0) {\n      //  timeline labels are there\n      this.xaxisLabels = w.globals.timelineLabels.slice();\n    }\n  } // .when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well\n\n\n  _createClass(Grid, [{\n    key: \"drawGridArea\",\n    value: function drawGridArea() {\n      var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n\n      if (elGrid === null) {\n        elGrid = graphics.group({\n          class: 'apexcharts-grid'\n        });\n      }\n\n      var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');\n      var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');\n      elGrid.add(elHorzLine);\n      elGrid.add(elVerticalLine);\n      return elGrid;\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var w = this.w;\n      var xAxis = new XAxis(this.ctx);\n      var gl = this.w.globals;\n      var elgrid = null;\n\n      if (gl.axisCharts) {\n        if (w.config.grid.show) {\n          // grid is drawn after xaxis and yaxis are drawn\n          elgrid = this.renderGrid();\n          gl.dom.elGraphical.add(elgrid.el);\n          this.drawGridArea(elgrid.el);\n        } else {\n          var elgridArea = this.drawGridArea();\n          gl.dom.elGraphical.add(elgridArea);\n        }\n\n        if (elgrid !== null) {\n          xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);\n        }\n      }\n    } // This mask will clip off overflowing graphics from the drawable area\n\n  }, {\n    key: \"createGridMask\",\n    value: function createGridMask() {\n      var w = this.w;\n      var gl = w.globals;\n      var graphics = new Graphics(this.ctx);\n      var strokeSize = Array.isArray(w.config.stroke.width) ? 0 : w.config.stroke.width;\n\n      if (Array.isArray(w.config.stroke.width)) {\n        var strokeMaxSize = 0;\n        w.config.stroke.width.forEach(function (m) {\n          strokeMaxSize = Math.max(strokeMaxSize, m);\n        });\n        strokeSize = strokeMaxSize;\n      }\n\n      gl.dom.elGridRectMask = document.createElementNS(gl.SVGNS, 'clipPath');\n      gl.dom.elGridRectMask.setAttribute('id', \"gridRectMask\".concat(gl.cuid));\n      gl.dom.elGridRectMarkerMask = document.createElementNS(gl.SVGNS, 'clipPath');\n      gl.dom.elGridRectMarkerMask.setAttribute('id', \"gridRectMarkerMask\".concat(gl.cuid));\n      gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2, -strokeSize / 2, gl.gridWidth + strokeSize, gl.gridHeight + strokeSize, 0, '#fff');\n      var coreUtils = new CoreUtils(this);\n      coreUtils.getLargestMarkerSize();\n      var markerSize = w.globals.markers.largestSize + w.config.markers.hover.sizeOffset + 1;\n      gl.dom.elGridRectMarker = graphics.drawRect(-markerSize, -markerSize, gl.gridWidth + markerSize * 2, gl.gridHeight + markerSize * 2, 0, '#fff');\n      gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);\n      gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);\n      var defs = gl.dom.baseEl.querySelector('defs');\n      defs.appendChild(gl.dom.elGridRectMask);\n      defs.appendChild(gl.dom.elGridRectMarkerMask);\n    } // actual grid rendering\n\n  }, {\n    key: \"renderGrid\",\n    value: function renderGrid() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var strokeDashArray = w.config.grid.strokeDashArray;\n      var elg = graphics.group({\n        class: 'apexcharts-grid'\n      });\n      var tickAmount = 8;\n\n      for (var i = 0; i < w.globals.series.length; i++) {\n        if (typeof w.globals.yAxisScale[i] !== 'undefined') {\n          tickAmount = w.globals.yAxisScale[i].result.length - 1;\n        }\n\n        if (tickAmount > 2) break;\n      }\n\n      var xCount;\n      var inversedGrid = !!(w.config.plotOptions.bar.horizontal && w.config.chart.type === 'bar');\n\n      if (!inversedGrid) {\n        xCount = this.xaxisLabels.length; // draw vertical lines\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var x1 = w.globals.padHorizontal;\n          var y1 = 0;\n          var x2;\n          var y2 = w.globals.gridHeight;\n\n          if (w.globals.timelineLabels.length > 0) {\n            for (var _i = 0; _i < xCount; _i++) {\n              x1 = this.xaxisLabels[_i].position;\n              x2 = this.xaxisLabels[_i].position;\n\n              if (w.config.grid.xaxis.lines.show && x1 > 0 && x1 < w.globals.gridWidth) {\n                var line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);\n                line.node.classList.add('apexcharts-gridline');\n                elg.add(line);\n\n                if (this.animX) {\n                  this.animateLine(line, {\n                    x1: 0,\n                    x2: 0\n                  }, {\n                    x1: x1,\n                    x2: x2\n                  });\n                }\n              }\n\n              var xAxis = new XAxis(this.ctx);\n              xAxis.drawXaxisTicks(x1, elg);\n            }\n          } else {\n            var xCountForCategoryCharts = xCount;\n\n            for (var _i2 = 0; _i2 < xCountForCategoryCharts; _i2++) {\n              var x1Count = xCountForCategoryCharts;\n\n              if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {\n                x1Count -= 1;\n              }\n\n              x1 = x1 + w.globals.gridWidth / x1Count;\n              x2 = x1; // skip the last line\n\n              if (_i2 === x1Count - 1) break;\n\n              if (w.config.grid.xaxis.lines.show) {\n                var _line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);\n\n                _line.node.classList.add('apexcharts-gridline');\n\n                elg.add(_line);\n\n                if (this.animX) {\n                  this.animateLine(_line, {\n                    x1: 0,\n                    x2: 0\n                  }, {\n                    x1: x1,\n                    x2: x2\n                  });\n                }\n              }\n\n              var _xAxis = new XAxis(this.ctx);\n\n              _xAxis.drawXaxisTicks(x1, elg);\n            }\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x = 0;\n          var _y = 0;\n          var _y2 = 0;\n          var _x2 = w.globals.gridWidth;\n\n          for (var _i3 = 0; _i3 < tickAmount + 1; _i3++) {\n            var _line2 = graphics.drawLine(_x, _y, _x2, _y2, w.config.grid.borderColor, strokeDashArray);\n\n            elg.add(_line2);\n\n            _line2.node.classList.add('apexcharts-gridline');\n\n            if (this.animY) {\n              this.animateLine(_line2, {\n                y1: _y + 20,\n                y2: _y2 + 20\n              }, {\n                y1: _y,\n                y2: _y2\n              });\n            }\n\n            _y = _y + w.globals.gridHeight / tickAmount;\n            _y2 = _y;\n          }\n        }\n      } else {\n        xCount = tickAmount; // draw vertical lines\n\n        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {\n          var _x3 = w.globals.padHorizontal;\n          var _y3 = 0;\n\n          var _x4;\n\n          var _y4 = w.globals.gridHeight;\n\n          for (var _i4 = 0; _i4 < xCount + 1; _i4++) {\n            _x3 = _x3 + w.globals.gridWidth / xCount + 0.3;\n            _x4 = _x3; // skip the last vertical line\n\n            if (_i4 === xCount - 1) break;\n\n            if (w.config.grid.xaxis.lines.show) {\n              var _line3 = graphics.drawLine(_x3, _y3, _x4, _y4, w.config.grid.borderColor, strokeDashArray);\n\n              _line3.node.classList.add('apexcharts-gridline');\n\n              elg.add(_line3);\n\n              if (this.animX) {\n                this.animateLine(_line3, {\n                  x1: 0,\n                  x2: 0\n                }, {\n                  x1: _x3,\n                  x2: _x4\n                });\n              }\n            } // skip the first vertical line\n\n\n            var _xAxis2 = new XAxis(this.ctx);\n\n            _xAxis2.drawXaxisTicks(_x3, elg);\n          }\n        } // draw horizontal lines\n\n\n        if (w.config.grid.yaxis.lines.show) {\n          var _x5 = 0;\n          var _y5 = 0;\n          var _y6 = 0;\n          var _x6 = w.globals.gridWidth;\n\n          for (var _i5 = 0; _i5 < w.globals.dataPoints + 1; _i5++) {\n            var _line4 = graphics.drawLine(_x5, _y5, _x6, _y6, w.config.grid.borderColor, strokeDashArray);\n\n            elg.add(_line4);\n\n            _line4.node.classList.add('apexcharts-gridline');\n\n            if (this.animY) {\n              this.animateLine(_line4, {\n                y1: _y5 + 20,\n                y2: _y6 + 20\n              }, {\n                y1: _y5,\n                y2: _y6\n              });\n            }\n\n            _y5 = _y5 + w.globals.gridHeight / w.globals.dataPoints;\n            _y6 = _y5;\n          }\n        }\n      }\n\n      this.drawGridBands(elg, xCount, tickAmount);\n      return {\n        el: elg,\n        xAxisTickWidth: w.globals.gridWidth / xCount\n      };\n    }\n  }, {\n    key: \"drawGridBands\",\n    value: function drawGridBands(elg, xCount, tickAmount) {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx); // rows background bands\n\n      if (w.config.grid.row.colors !== undefined && w.config.grid.row.colors.length > 0) {\n        var x1 = 0;\n        var y1 = 0;\n        var y2 = w.globals.gridHeight / tickAmount;\n        var x2 = w.globals.gridWidth;\n\n        for (var i = 0, c = 0; i < tickAmount; i++, c++) {\n          if (c >= w.config.grid.row.colors.length) {\n            c = 0;\n          }\n\n          var color = w.config.grid.row.colors[c];\n          var rect = graphics.drawRect(x1, y1, x2, y2, 0, color, w.config.grid.row.opacity);\n          elg.add(rect);\n          rect.node.classList.add('apexcharts-gridRow');\n          y1 = y1 + w.globals.gridHeight / tickAmount;\n        }\n      } // columns background bands\n\n\n      if (w.config.grid.column.colors !== undefined && w.config.grid.column.colors.length > 0) {\n        var _x7 = w.globals.padHorizontal;\n        var _y7 = 0;\n\n        var _x8 = w.globals.padHorizontal + w.globals.gridWidth / xCount;\n\n        var _y8 = w.globals.gridHeight;\n\n        for (var _i6 = 0, _c = 0; _i6 < xCount; _i6++, _c++) {\n          if (_c >= w.config.grid.column.colors.length) {\n            _c = 0;\n          }\n\n          var _color = w.config.grid.column.colors[_c];\n\n          var _rect = graphics.drawRect(_x7, _y7, _x8, _y8, 0, _color, w.config.grid.column.opacity);\n\n          _rect.node.classList.add('apexcharts-gridColumn');\n\n          elg.add(_rect);\n          _x7 = _x7 + w.globals.gridWidth / xCount;\n        }\n      }\n    }\n  }, {\n    key: \"animateLine\",\n    value: function animateLine(line, from, to) {\n      var w = this.w;\n      var initialAnim = w.config.chart.animations;\n\n      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {\n        var speed = initialAnim.speed;\n        this.anim.animateLine(line, from, to, speed);\n      }\n    }\n  }]);\n\n  return Grid;\n}();\n\n/**\n * ApexCharts Legend Class to draw legend.\n *\n * @module Legend\n **/\n\nvar Legend =\n/*#__PURE__*/\nfunction () {\n  function Legend(ctx, opts) {\n    _classCallCheck(this, Legend);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.onLegendClick = this.onLegendClick.bind(this);\n    this.onLegendHovered = this.onLegendHovered.bind(this);\n  }\n\n  _createClass(Legend, [{\n    key: \"init\",\n    value: function init() {\n      var w = this.w;\n      var gl = w.globals;\n      var cnf = w.config;\n      var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || gl.series.length > 1;\n\n      if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {\n        while (gl.dom.elLegendWrap.firstChild) {\n          gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);\n        }\n\n        this.drawLegends();\n\n        if (!Utils.isIE11()) {\n          this.appendToForeignObject();\n        } else {\n          // IE11 doesn't supports foreignObject, hence append it to <head>\n          document.getElementsByTagName('head')[0].appendChild(this.getLegendStyles());\n        }\n\n        if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {\n          this.legendAlignHorizontal();\n        } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {\n          this.legendAlignVertical();\n        }\n      }\n    }\n  }, {\n    key: \"appendToForeignObject\",\n    value: function appendToForeignObject() {\n      var gl = this.w.globals;\n      var elForeign = document.createElementNS(gl.SVGNS, 'foreignObject');\n      elForeign.setAttribute('x', 0);\n      elForeign.setAttribute('y', 0);\n      elForeign.setAttribute('width', gl.svgWidth);\n      elForeign.setAttribute('height', gl.svgHeight);\n      gl.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n      elForeign.appendChild(gl.dom.elLegendWrap);\n      elForeign.appendChild(this.getLegendStyles());\n      gl.dom.Paper.node.insertBefore(elForeign, gl.dom.elGraphical.node);\n    }\n  }, {\n    key: \"drawLegends\",\n    value: function drawLegends() {\n      var self = this;\n      var w = this.w;\n      var fontFamily = w.config.legend.fontFamily;\n      var legendNames = w.globals.seriesNames;\n      var fillcolor = w.globals.colors.slice();\n\n      if (w.config.chart.type === 'heatmap') {\n        var ranges = w.config.plotOptions.heatmap.colorScale.ranges;\n        legendNames = ranges.map(function (colorScale) {\n          return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;\n        });\n        fillcolor = ranges.map(function (color) {\n          return color.color;\n        });\n      }\n\n      var legendFormatter = w.globals.legendFormatter;\n\n      for (var i = 0; i <= legendNames.length - 1; i++) {\n        var text = legendFormatter(legendNames[i], {\n          seriesIndex: i,\n          w: w\n        });\n        var collapsedSeries = false;\n        var ancillaryCollapsedSeries = false;\n\n        if (w.globals.collapsedSeries.length > 0) {\n          for (var c = 0; c < w.globals.collapsedSeries.length; c++) {\n            if (w.globals.collapsedSeries[c].index === i) {\n              collapsedSeries = true;\n            }\n          }\n        }\n\n        if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {\n          for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {\n            if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {\n              ancillaryCollapsedSeries = true;\n            }\n          }\n        }\n\n        var elMarker = document.createElement('span');\n        elMarker.classList.add('apexcharts-legend-marker');\n        var mOffsetX = w.config.legend.markers.offsetX;\n        var mOffsetY = w.config.legend.markers.offsetY;\n        var mHeight = w.config.legend.markers.height;\n        var mWidth = w.config.legend.markers.width;\n        var mBorderWidth = w.config.legend.markers.strokeWidth;\n        var mBorderColor = w.config.legend.markers.strokeColor;\n        var mBorderRadius = w.config.legend.markers.radius;\n        var mStyle = elMarker.style;\n        mStyle.background = fillcolor[i];\n        mStyle.color = fillcolor[i];\n        mStyle.height = Array.isArray(mHeight) ? parseFloat(mHeight[i]) + 'px' : parseFloat(mHeight) + 'px';\n        mStyle.width = Array.isArray(mWidth) ? parseFloat(mWidth[i]) + 'px' : parseFloat(mWidth) + 'px';\n        mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX;\n        mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY;\n        mStyle.borderWidth = Array.isArray(mBorderWidth) ? mBorderWidth[i] : mBorderWidth;\n        mStyle.borderColor = Array.isArray(mBorderColor) ? mBorderColor[i] : mBorderColor;\n        mStyle.borderRadius = Array.isArray(mBorderRadius) ? parseFloat(mBorderRadius[i]) + 'px' : parseFloat(mBorderRadius) + 'px';\n\n        if (w.config.legend.markers.customHTML) {\n          if (Array.isArray(w.config.legend.markers.customHTML)) {\n            elMarker.innerHTML = w.config.legend.markers.customHTML[i]();\n          } else {\n            elMarker.innerHTML = w.config.legend.markers.customHTML();\n          }\n        }\n\n        Graphics.setAttrs(elMarker, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n\n        if (collapsedSeries || ancillaryCollapsedSeries) {\n          elMarker.classList.add('inactive-legend');\n        }\n\n        var elLegend = document.createElement('div');\n        var elLegendText = document.createElement('span');\n        elLegendText.classList.add('apexcharts-legend-text');\n        elLegendText.innerHTML = text;\n        var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : w.config.legend.labels.colors;\n\n        if (!textColor) {\n          textColor = w.config.chart.foreColor;\n        }\n\n        elLegendText.style.color = textColor;\n        elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';\n        elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;\n        Graphics.setAttrs(elLegendText, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n        elLegend.appendChild(elMarker);\n        elLegend.appendChild(elLegendText);\n        var coreUtils = new CoreUtils(this.ctx);\n\n        if (!w.config.legend.showForZeroSeries) {\n          var total = coreUtils.getSeriesTotalByIndex(i);\n\n          if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n            elLegend.classList.add('apexcharts-hidden-zero-series');\n          }\n        }\n\n        if (!w.config.legend.showForNullSeries) {\n          if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {\n            elLegend.classList.add('apexcharts-hidden-null-series');\n          }\n        }\n\n        w.globals.dom.elLegendWrap.appendChild(elLegend);\n        w.globals.dom.elLegendWrap.classList.add(w.config.legend.horizontalAlign); // w.globals.dom.elLegendWrap.classList.add(w.config.legend.verticalAlign)\n\n        w.globals.dom.elLegendWrap.classList.add('position-' + w.config.legend.position);\n        elLegend.classList.add('apexcharts-legend-series');\n        elLegend.style.margin = \"\".concat(w.config.legend.itemMargin.horizontal, \"px \").concat(w.config.legend.itemMargin.vertical, \"px\");\n        w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';\n        w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';\n        Graphics.setAttrs(elLegend, {\n          rel: i + 1,\n          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n        });\n\n        if (collapsedSeries || ancillaryCollapsedSeries) {\n          elLegend.classList.add('inactive-legend');\n        }\n\n        if (!w.config.legend.onItemClick.toggleDataSeries) {\n          elLegend.classList.add('no-click');\n        }\n      } // for now - just prevent click on heatmap legend - and allow hover only\n\n\n      var clickAllowed = w.config.chart.type !== 'heatmap';\n\n      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {\n        w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true);\n      }\n\n      if (w.config.legend.onItemHover.highlightDataSeries) {\n        w.globals.dom.elWrap.addEventListener('mousemove', self.onLegendHovered, true);\n        w.globals.dom.elWrap.addEventListener('mouseout', self.onLegendHovered, true);\n      }\n    }\n  }, {\n    key: \"getLegendBBox\",\n    value: function getLegendBBox() {\n      var w = this.w;\n      var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var currLegendsWrapRect = currLegendsWrap.getBoundingClientRect();\n      var currLegendsWrapWidth = currLegendsWrapRect.width;\n      var currLegendsWrapHeight = currLegendsWrapRect.height;\n      return {\n        clwh: currLegendsWrapHeight,\n        clww: currLegendsWrapWidth\n      };\n    }\n  }, {\n    key: \"setLegendWrapXY\",\n    value: function setLegendWrapXY(offsetX, offsetY) {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      var legendRect = elLegendWrap.getBoundingClientRect();\n      var x = 0;\n      var y = 0;\n\n      if (w.config.legend.position === 'bottom') {\n        y = y + (w.globals.svgHeight - legendRect.height / 2);\n      } else if (w.config.legend.position === 'top') {\n        var dim = new Dimensions(this.ctx);\n        var titleH = dim.getTitleSubtitleCoords('title').height;\n        var subtitleH = dim.getTitleSubtitleCoords('subtitle').height;\n        y = y + (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);\n      }\n\n      elLegendWrap.style.position = 'absolute';\n      x = x + offsetX + w.config.legend.offsetX;\n      y = y + offsetY + w.config.legend.offsetY;\n      elLegendWrap.style.left = x + 'px';\n      elLegendWrap.style.top = y + 'px';\n\n      if (w.config.legend.position === 'bottom') {\n        elLegendWrap.style.top = 'auto';\n        elLegendWrap.style.bottom = 10 + w.config.legend.offsetY + 'px';\n      } else if (w.config.legend.position === 'right') {\n        elLegendWrap.style.left = 'auto';\n        elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';\n      }\n\n      if (elLegendWrap.style.width) {\n        elLegendWrap.style.width = parseInt(w.config.legend.width) + 'px';\n      }\n\n      if (elLegendWrap.style.height) {\n        elLegendWrap.style.height = parseInt(w.config.legend.height) + 'px';\n      }\n    }\n  }, {\n    key: \"legendAlignHorizontal\",\n    value: function legendAlignHorizontal() {\n      var w = this.w;\n      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');\n      elLegendWrap.style.right = 0;\n      var lRect = this.getLegendBBox();\n      var dimensions = new Dimensions(this.ctx);\n      var titleRect = dimensions.getTitleSubtitleCoords('title');\n      var subtitleRect = dimensions.getTitleSubtitleCoords('subtitle');\n      var offsetX = 20;\n      var offsetY = 0; // the whole legend box is set to bottom\n\n      if (w.config.legend.position === 'bottom') {\n        offsetY = -lRect.clwh / 1.8;\n      } else if (w.config.legend.position === 'top') {\n        offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 15;\n      }\n\n      this.setLegendWrapXY(offsetX, offsetY);\n    }\n  }, {\n    key: \"legendAlignVertical\",\n    value: function legendAlignVertical() {\n      var w = this.w;\n      var lRect = this.getLegendBBox();\n      var offsetY = 20;\n      var offsetX = 0;\n\n      if (w.config.legend.position === 'left') {\n        offsetX = 20;\n      }\n\n      if (w.config.legend.position === 'right') {\n        offsetX = w.globals.svgWidth - lRect.clww - 10;\n      }\n\n      this.setLegendWrapXY(offsetX, offsetY);\n    }\n  }, {\n    key: \"onLegendHovered\",\n    value: function onLegendHovered(e) {\n      var w = this.w;\n      var hoverOverLegend = e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');\n\n      if (w.config.chart.type !== 'heatmap') {\n        if (!e.target.classList.contains('inactive-legend') && hoverOverLegend) {\n          var series = new Series(this.ctx);\n          series.toggleSeriesOnHover(e, e.target);\n        }\n      } else {\n        // for heatmap handling\n        if (hoverOverLegend) {\n          var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;\n          this.ctx.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);\n\n          var _series = new Series(this.ctx);\n\n          _series.highlightRangeInSeries(e, e.target);\n        }\n      }\n    }\n  }, {\n    key: \"onLegendClick\",\n    value: function onLegendClick(e) {\n      if (e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {\n        var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;\n        var isHidden = e.target.getAttribute('data:collapsed') === 'true';\n        var legendClick = this.w.config.chart.events.legendClick;\n\n        if (typeof legendClick === 'function') {\n          legendClick(this.ctx, seriesCnt, this.w);\n        }\n\n        this.ctx.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);\n        var markerClick = this.w.config.legend.markers.onClick;\n\n        if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {\n          markerClick(this.ctx, seriesCnt, this.w);\n          this.ctx.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);\n        }\n\n        this.toggleDataSeries(seriesCnt, isHidden);\n      }\n    }\n  }, {\n    key: \"getLegendStyles\",\n    value: function getLegendStyles() {\n      var stylesheet = document.createElement('style');\n      stylesheet.setAttribute('type', 'text/css');\n      var text = \"\\n    \\n      .apexcharts-legend {\\n        display: flex;\\n        overflow: auto;\\n        padding: 0 10px;\\n      }\\n\\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\\n        flex-wrap: wrap\\n      }\\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\\n        flex-direction: column;\\n        bottom: 0;\\n      }\\n\\n      .apexcharts-legend.position-bottom.left, .apexcharts-legend.position-top.left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\\n        justify-content: flex-start;\\n      }\\n\\n      .apexcharts-legend.position-bottom.center, .apexcharts-legend.position-top.center {\\n        justify-content: center;  \\n      }\\n\\n      .apexcharts-legend.position-bottom.right, .apexcharts-legend.position-top.right {\\n        justify-content: flex-end;\\n      }\\n\\n      .apexcharts-legend-series {\\n        cursor: pointer;\\n        line-height: normal;\\n      }\\n\\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\\n        display: flex;\\n        align-items: center;\\n      }\\n\\n      .apexcharts-legend-text {\\n        position: relative;\\n        font-size: 14px;\\n      }\\n\\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\\n        pointer-events: none;\\n      }\\n\\n      .apexcharts-legend-marker {\\n        position: relative;\\n        display: inline-block;\\n        cursor: pointer;\\n        margin-right: 3px;\\n      }\\n      \\n      .apexcharts-legend.right .apexcharts-legend-series, .apexcharts-legend.left .apexcharts-legend-series{\\n        display: inline-block;\\n      }\\n\\n      .apexcharts-legend-series.no-click {\\n        cursor: auto;\\n      }\\n\\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\\n        display: none !important;\\n      }\\n\\n      .inactive-legend {\\n        opacity: 0.45;\\n      }\";\n      var rules = document.createTextNode(text);\n      stylesheet.appendChild(rules);\n      return stylesheet;\n    }\n  }, {\n    key: \"resetToggleDataSeries\",\n    value: function resetToggleDataSeries() {\n      var w = this.w;\n      var seriesEls = null;\n      var realIndexes = [];\n\n      if (w.globals.axisCharts) {\n        seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:realIndex]\");\n        seriesEls.forEach(function (v) {\n          realIndexes.push(parseInt(v.getAttribute('data:realIndex')));\n        });\n      } else {\n        seriesEls = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[rel]\");\n        seriesEls.forEach(function (v) {\n          realIndexes.push(parseInt(v.getAttribute('rel')) - 1);\n        });\n      }\n\n      realIndexes.sort();\n\n      if (w.globals.collapsedSeries.length > 0) {\n        var risingSeries = w.globals.risingSeries.slice();\n        var series = w.config.series.slice();\n\n        for (var c = 0; c < w.globals.collapsedSeries.length; c++) {\n          var index = realIndexes.indexOf(w.globals.collapsedSeries[c].index);\n\n          if (index !== -1) {\n            if (w.globals.axisCharts) {\n              series[index].data = w.globals.collapsedSeries.slice()[c].data.slice();\n            } else {\n              series[index] = w.globals.collapsedSeries.slice()[c].data;\n            }\n\n            risingSeries.push(index);\n          }\n        }\n\n        w.globals.collapsedSeries = [];\n        w.globals.ancillaryCollapsedSeries = [];\n        w.globals.collapsedSeriesIndices = [];\n        w.globals.ancillaryCollapsedSeriesIndices = [];\n        w.globals.risingSeries = risingSeries;\n        w.config.series = series;\n\n        this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n      }\n    }\n  }, {\n    key: \"toggleDataSeries\",\n    value: function toggleDataSeries(seriesCnt, isHidden) {\n      var w = this.w;\n\n      if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {\n        w.globals.resized = true; // we don't want initial animations again\n\n        var seriesEl = null;\n        var realIndex = null; // yes, make it null. 1 series will rise at a time\n\n        w.globals.risingSeries = [];\n\n        if (w.globals.axisCharts) {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesCnt, \"']\"));\n          realIndex = parseInt(seriesEl.getAttribute('data:realIndex'));\n        } else {\n          seriesEl = w.globals.dom.baseEl.querySelector(\".apexcharts-series[rel='\".concat(seriesCnt + 1, \"']\"));\n          realIndex = parseInt(seriesEl.getAttribute('rel')) - 1;\n        }\n\n        if (isHidden) {\n          this.riseCollapsedSeries(w.globals.collapsedSeries, w.globals.collapsedSeriesIndices, realIndex);\n          this.riseCollapsedSeries(w.globals.ancillaryCollapsedSeries, w.globals.ancillaryCollapsedSeriesIndices, realIndex);\n        } else {\n          if (w.globals.axisCharts) {\n            var shouldNotHideYAxis = false;\n\n            if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].show && w.config.yaxis[realIndex].showAlways) {\n              shouldNotHideYAxis = true;\n\n              if (w.globals.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {\n                w.globals.ancillaryCollapsedSeries.push({\n                  index: realIndex,\n                  data: w.config.series[realIndex].data.slice(),\n                  type: seriesEl.parentNode.className.baseVal.split('-')[1]\n                });\n                w.globals.ancillaryCollapsedSeriesIndices.push(realIndex);\n              }\n            }\n\n            if (!shouldNotHideYAxis) {\n              w.globals.collapsedSeries.push({\n                index: realIndex,\n                data: w.config.series[realIndex].data.slice(),\n                type: seriesEl.parentNode.className.baseVal.split('-')[1]\n              });\n              w.globals.collapsedSeriesIndices.push(realIndex);\n              var removeIndexOfRising = w.globals.risingSeries.indexOf(realIndex);\n              w.globals.risingSeries.splice(removeIndexOfRising, 1);\n            } // TODO: AVOID mutating the user's config object below\n\n\n            w.config.series[realIndex].data = [];\n          } else {\n            w.globals.collapsedSeries.push({\n              index: realIndex,\n              data: w.config.series[realIndex]\n            });\n            w.globals.collapsedSeriesIndices.push(realIndex);\n            w.config.series[realIndex] = 0;\n          }\n\n          var seriesChildren = seriesEl.childNodes;\n\n          for (var sc = 0; sc < seriesChildren.length; sc++) {\n            if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {\n              if (seriesChildren[sc].classList.contains('apexcharts-hide')) {\n                seriesChildren[sc].classList.remove('apexcharts-hide');\n              } else {\n                seriesChildren[sc].classList.add('apexcharts-hide');\n              }\n            }\n          }\n\n          w.globals.allSeriesCollapsed = w.globals.collapsedSeries.length === w.globals.series.length;\n\n          this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      } else {\n        // for non-axis charts i.e pie / donuts\n        var _seriesEl = w.globals.dom.Paper.select(\" .apexcharts-series[rel='\".concat(seriesCnt + 1, \"'] path\"));\n\n        _seriesEl.fire('click');\n      }\n    }\n  }, {\n    key: \"riseCollapsedSeries\",\n    value: function riseCollapsedSeries(series, seriesIndices, realIndex) {\n      var w = this.w;\n\n      if (series.length > 0) {\n        for (var c = 0; c < series.length; c++) {\n          if (series[c].index === realIndex) {\n            if (w.globals.axisCharts) {\n              w.config.series[realIndex].data = series[c].data.slice();\n              series.splice(c, 1);\n              seriesIndices.splice(c, 1);\n              w.globals.risingSeries.push(realIndex);\n            } else {\n              w.config.series[realIndex] = series[c].data;\n              series.splice(c, 1);\n              seriesIndices.splice(c, 1);\n              w.globals.risingSeries.push(realIndex);\n            }\n\n            this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Legend;\n}();\n\n/**\n * ApexCharts Responsive Class to override options for different screen sizes.\n *\n * @module Responsive\n **/\n\nvar Responsive =\n/*#__PURE__*/\nfunction () {\n  function Responsive(ctx) {\n    _classCallCheck(this, Responsive);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  } // the opts parameter if not null has to be set overriding everything\n  // as the opts is set by user externally\n\n\n  _createClass(Responsive, [{\n    key: \"checkResponsiveConfig\",\n    value: function checkResponsiveConfig(opts) {\n      var _this = this;\n\n      var w = this.w;\n      var cnf = w.config; // check if responsive config exists\n\n      if (cnf.responsive.length === 0) return;\n      var res = cnf.responsive.slice();\n      res.sort(function (a, b) {\n        return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;\n      }).reverse();\n      var config = new Config({});\n\n      var iterateResponsiveOptions = function iterateResponsiveOptions() {\n        var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var largestBreakpoint = res[0].breakpoint;\n        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;\n\n        if (width > largestBreakpoint) {\n          var options = CoreUtils.extendArrayProps(config, w.globals.initialConfig);\n          newOptions = Utils.extend(options, newOptions);\n          newOptions = Utils.extend(w.config, newOptions);\n\n          _this.overrideResponsiveOptions(newOptions);\n        } else {\n          for (var i = 0; i < res.length; i++) {\n            if (width < res[i].breakpoint) {\n              newOptions = Utils.extend(config, newOptions);\n              newOptions = CoreUtils.extendArrayProps(newOptions, res[i].options);\n              newOptions = Utils.extend(w.config, newOptions);\n\n              _this.overrideResponsiveOptions(newOptions);\n            }\n          }\n        }\n      };\n\n      if (opts) {\n        var options = CoreUtils.extendArrayProps(config, opts);\n        options = Utils.extend(w.config, options);\n        options = Utils.extend(options, opts);\n        iterateResponsiveOptions(options);\n      } else {\n        iterateResponsiveOptions({});\n      }\n    }\n  }, {\n    key: \"overrideResponsiveOptions\",\n    value: function overrideResponsiveOptions(newOptions) {\n      var newConfig = new Config(newOptions).init();\n      this.w.config = newConfig;\n    }\n  }]);\n\n  return Responsive;\n}();\n\n/**\n * ApexCharts Theme Class for setting the colors and palettes.\n *\n * @module Theme\n **/\n\nvar Theme =\n/*#__PURE__*/\nfunction () {\n  function Theme(ctx) {\n    _classCallCheck(this, Theme);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.colors = [];\n  }\n\n  _createClass(Theme, [{\n    key: \"init\",\n    value: function init() {\n      this.setDefaultColors();\n    }\n  }, {\n    key: \"setDefaultColors\",\n    value: function setDefaultColors() {\n      var w = this.w;\n      var utils = new Utils();\n\n      if (w.config.colors === undefined) {\n        w.globals.colors = this.predefined();\n      } else {\n        w.globals.colors = w.config.colors;\n      }\n\n      if (w.config.theme.monochrome.enabled) {\n        var monoArr = [];\n        var glsCnt = w.globals.series.length;\n\n        if (w.config.plotOptions.bar.distributed && w.config.chart.type === 'bar') {\n          glsCnt = w.globals.series[0].length * w.globals.series.length;\n        }\n\n        var mainColor = w.config.theme.monochrome.color;\n        var part = 1 / (glsCnt / w.config.theme.monochrome.shadeIntensity);\n        var shade = w.config.theme.monochrome.shadeTo;\n        var percent = 0;\n\n        for (var gsl = 0; gsl < glsCnt; gsl++) {\n          var newColor = void 0;\n\n          if (shade === 'dark') {\n            newColor = utils.shadeColor(percent * -1, mainColor);\n            percent = percent + part;\n          } else {\n            newColor = utils.shadeColor(percent, mainColor);\n            percent = percent + part;\n          }\n\n          monoArr.push(newColor);\n        }\n\n        w.globals.colors = monoArr.slice();\n      }\n\n      var defaultColors = w.globals.colors.slice(); // if user specfied less colors than no. of series, push the same colors again\n\n      this.pushExtraColors(w.globals.colors); // The Border colors\n\n      if (w.config.stroke.colors === undefined) {\n        w.globals.stroke.colors = defaultColors;\n      } else {\n        w.globals.stroke.colors = w.config.stroke.colors;\n      }\n\n      this.pushExtraColors(w.globals.stroke.colors); // The FILL colors\n\n      if (w.config.fill.colors === undefined) {\n        w.globals.fill.colors = defaultColors;\n      } else {\n        w.globals.fill.colors = w.config.fill.colors;\n      }\n\n      this.pushExtraColors(w.globals.fill.colors);\n\n      if (w.config.dataLabels.style.colors === undefined) {\n        w.globals.dataLabels.style.colors = defaultColors;\n      } else {\n        w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors;\n      }\n\n      this.pushExtraColors(w.globals.dataLabels.style.colors, 50);\n\n      if (w.config.plotOptions.radar.polygons.fill.colors === undefined) {\n        w.globals.radarPolygons.fill.colors = ['#fff'];\n      } else {\n        w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors;\n      }\n\n      this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20); // The point colors\n\n      if (w.config.markers.colors === undefined) {\n        w.globals.markers.colors = defaultColors;\n      } else {\n        w.globals.markers.colors = w.config.markers.colors;\n      }\n\n      this.pushExtraColors(w.globals.markers.colors);\n    } // When the number of colors provided is less than the number of series, this method\n    // will push same colors to the list\n    // params:\n    // distributed is only valid for distributed column/bar charts\n\n  }, {\n    key: \"pushExtraColors\",\n    value: function pushExtraColors(colorSeries, length) {\n      var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var w = this.w;\n      var len = length || w.globals.series.length;\n\n      if (distributed === null) {\n        distributed = w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.colorScale.inverse;\n      }\n\n      if (distributed) {\n        len = w.globals.series[0].length * w.globals.series.length;\n      }\n\n      if (colorSeries.length < len) {\n        var diff = len - colorSeries.length;\n\n        for (var i = 0; i < diff; i++) {\n          colorSeries.push(colorSeries[i]);\n        }\n      }\n    }\n  }, {\n    key: \"predefined\",\n    value: function predefined() {\n      var palette = this.w.config.theme.palette; // D6E3F8, FCEFEF, DCE0D9, A5978B, EDDDD4, D6E3F8, FEF5EF\n\n      switch (palette) {\n        case 'palette1':\n          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n          break;\n\n        case 'palette2':\n          this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800'];\n          break;\n\n        case 'palette3':\n          this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B'];\n          break;\n\n        case 'palette4':\n          this.colors = ['#546E7A', '#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a'];\n          break;\n\n        case 'palette5':\n          this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7'];\n          break;\n\n        case 'palette6':\n          this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'];\n          break;\n\n        case 'palette7':\n          this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'];\n          break;\n\n        case 'palette8':\n          this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'];\n          break;\n\n        case 'palette9':\n          this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'];\n          break;\n\n        case 'palette10':\n          this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2'];\n          break;\n\n        default:\n          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];\n          break;\n      }\n\n      return this.colors;\n    }\n  }]);\n\n  return Theme;\n}();\n\nvar Utils$1 =\n/*#__PURE__*/\nfunction () {\n  function Utils(tooltipContext) {\n    _classCallCheck(this, Utils);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n  }\n  /**\n   ** When hovering over series, you need to capture which series is being hovered on.\n   ** This function will return both capturedseries index as well as inner index of that series\n   * @memberof Utils\n   * @param {object}\n   * - hoverArea = the rect on which user hovers\n   * - elGrid = dimensions of the hover rect (it can be different than hoverarea)\n   */\n\n\n  _createClass(Utils, [{\n    key: \"getNearestValues\",\n    value: function getNearestValues(_ref) {\n      var hoverArea = _ref.hoverArea,\n          elGrid = _ref.elGrid,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY,\n          hasBars = _ref.hasBars;\n      var w = this.w;\n      var hoverWidth = w.globals.gridWidth;\n      var xDivisor = hoverWidth / (w.globals.dataPoints - 1);\n      var seriesBound = elGrid.getBoundingClientRect();\n\n      if (hasBars && w.globals.comboCharts || hasBars) {\n        xDivisor = hoverWidth / w.globals.dataPoints;\n      }\n\n      var hoverX = clientX - seriesBound.left;\n      var hoverY = clientY - seriesBound.top;\n      var inRect = hoverX < 0 || hoverY < 0 || hoverX > w.globals.gridWidth || hoverY > w.globals.gridHeight;\n\n      if (inRect) {\n        hoverArea.classList.remove('hovering-zoom');\n        hoverArea.classList.remove('hovering-pan');\n      } else {\n        if (w.globals.zoomEnabled) {\n          hoverArea.classList.remove('hovering-pan');\n          hoverArea.classList.add('hovering-zoom');\n        } else if (w.globals.panEnabled) {\n          hoverArea.classList.remove('hovering-zoom');\n          hoverArea.classList.add('hovering-pan');\n        }\n      }\n\n      var j = Math.round(hoverX / xDivisor);\n\n      if (hasBars) {\n        j = Math.ceil(hoverX / xDivisor);\n        j = j - 1;\n      }\n\n      var capturedSeries = null;\n      var closest = null;\n      var seriesXValArr = [];\n      var seriesYValArr = [];\n\n      for (var s = 0; s < w.globals.seriesXvalues.length; s++) {\n        seriesXValArr.push([w.globals.seriesXvalues[s][0] - 0.000001].concat(w.globals.seriesXvalues[s]));\n      }\n\n      seriesXValArr = seriesXValArr.map(function (seriesXVal) {\n        return seriesXVal.filter(function (s) {\n          return s;\n        });\n      });\n      seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {\n        return seriesYVal.filter(function (s) {\n          return s;\n        });\n      }); // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value\n\n      if (w.globals.isXNumeric) {\n        closest = this.closestInMultiArray(hoverX, hoverY, seriesXValArr, seriesYValArr);\n        capturedSeries = closest.index;\n        j = closest.j;\n\n        if (capturedSeries !== null) {\n          // initial push, it should be a little smaller than the 1st val\n          seriesXValArr = w.globals.seriesXvalues[capturedSeries];\n          closest = this.closestInArray(hoverX, seriesXValArr);\n          j = closest.index;\n        }\n      }\n\n      if (!j || j < 1) j = 0;\n      return {\n        capturedSeries: capturedSeries,\n        j: j,\n        hoverX: hoverX,\n        hoverY: hoverY\n      };\n    }\n  }, {\n    key: \"closestInMultiArray\",\n    value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {\n      var w = this.w;\n      var activeIndex = 0;\n      var currIndex = null;\n      var j = -1;\n\n      if (w.globals.series.length > 1) {\n        activeIndex = this.getFirstActiveXArray(Xarrays);\n      } else {\n        currIndex = 0;\n      }\n\n      var currY = Yarrays[activeIndex][0];\n      var currX = Xarrays[activeIndex][0];\n      var diffX = Math.abs(hoverX - currX);\n      var diffY = Math.abs(hoverY - currY);\n      var diff = diffY + diffX;\n      Yarrays.map(function (arrY, arrIndex) {\n        arrY.map(function (y, innerKey) {\n          var newdiffY = Math.abs(hoverY - Yarrays[arrIndex][innerKey]);\n          var newdiffX = Math.abs(hoverX - Xarrays[arrIndex][innerKey]);\n          var newdiff = newdiffX + newdiffY;\n\n          if (newdiff < diff) {\n            diff = newdiff;\n            diffX = newdiffX;\n            diffY = newdiffY;\n            currIndex = arrIndex;\n            j = innerKey;\n          }\n        });\n      });\n      return {\n        index: currIndex,\n        j: j\n      };\n    }\n  }, {\n    key: \"getFirstActiveXArray\",\n    value: function getFirstActiveXArray(Xarrays) {\n      var activeIndex = 0;\n      var coreUtils = new CoreUtils(this.ctx);\n      var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {\n        if (xarr.length > 0) {\n          return index;\n        } else {\n          return -1;\n        }\n      });\n\n      for (var a = 0; a < firstActiveSeriesIndex.length; a++) {\n        var total = coreUtils.getSeriesTotalByIndex(a);\n\n        if (firstActiveSeriesIndex[a] !== -1 && total !== 0 && !coreUtils.seriesHaveSameValues(a)) {\n          activeIndex = firstActiveSeriesIndex[a];\n          break;\n        }\n      }\n\n      return activeIndex;\n    }\n  }, {\n    key: \"closestInArray\",\n    value: function closestInArray(val, arr) {\n      var curr = arr[0];\n      var currIndex = null;\n      var diff = Math.abs(val - curr);\n\n      for (var i = 0; i < arr.length; i++) {\n        var newdiff = Math.abs(val - arr[i]);\n\n        if (newdiff < diff) {\n          diff = newdiff;\n          curr = arr[i];\n          currIndex = i;\n        }\n      }\n\n      return {\n        index: currIndex\n      };\n    }\n    /**\n     * When there are multiple series, it is possible to have different x values for each series.\n     * But it may be possible in those multiple series, that there is same x value for 2 or more\n     * series.\n     * @memberof Utils\n     * @param {int}\n     * - j = is the inner index of series -> (series[i][j])\n     * @return {bool}\n     */\n\n  }, {\n    key: \"isXoverlap\",\n    value: function isXoverlap(j) {\n      var w = this.w;\n      var xSameForAllSeriesJArr = [];\n      var seriesX = w.globals.seriesX.filter(function (s) {\n        return typeof s[0] !== 'undefined';\n      });\n\n      if (seriesX.length > 0) {\n        for (var i = 0; i < seriesX.length - 1; i++) {\n          if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {\n            if (seriesX[i][j] !== seriesX[i + 1][j]) {\n              xSameForAllSeriesJArr.push('unEqual');\n            }\n          }\n        }\n      }\n\n      if (xSameForAllSeriesJArr.length === 0) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isinitialSeriesSameLen\",\n    value: function isinitialSeriesSameLen() {\n      var sameLen = true;\n      var initialSeries = this.w.globals.initialSeries;\n\n      for (var i = 0; i < initialSeries.length - 1; i++) {\n        if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {\n          sameLen = false;\n          break;\n        }\n      }\n\n      return sameLen;\n    }\n  }, {\n    key: \"getBarsHeight\",\n    value: function getBarsHeight(allbars) {\n      var bars = _toConsumableArray(allbars);\n\n      var totalHeight = bars.reduce(function (acc, bar) {\n        return acc + bar.getBBox().height;\n      }, 0);\n      return totalHeight;\n    }\n  }, {\n    key: \"toggleAllTooltipSeriesGroups\",\n    value: function toggleAllTooltipSeriesGroups(state) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.allTooltipSeriesGroups.length === 0) {\n        ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');\n      }\n\n      var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;\n\n      for (var i = 0; i < allTooltipSeriesGroups.length; i++) {\n        if (state === 'enable') {\n          allTooltipSeriesGroups[i].classList.add('active');\n          allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;\n        } else {\n          allTooltipSeriesGroups[i].classList.remove('active');\n          allTooltipSeriesGroups[i].style.display = 'none';\n        }\n      }\n    }\n  }]);\n\n  return Utils;\n}();\n\n/**\n * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.\n *\n * @module Tooltip.Labels\n **/\n\nvar Labels =\n/*#__PURE__*/\nfunction () {\n  function Labels(tooltipContext) {\n    _classCallCheck(this, Labels);\n\n    this.w = tooltipContext.w;\n    this.ctx = tooltipContext.ctx;\n    this.ttCtx = tooltipContext;\n    this.tooltipUtil = new Utils$1(tooltipContext);\n  }\n\n  _createClass(Labels, [{\n    key: \"drawSeriesTexts\",\n    value: function drawSeriesTexts(_ref) {\n      var _ref$shared = _ref.shared,\n          shared = _ref$shared === void 0 ? true : _ref$shared,\n          ttItems = _ref.ttItems,\n          _ref$i = _ref.i,\n          i = _ref$i === void 0 ? 0 : _ref$i,\n          _ref$j = _ref.j,\n          j = _ref$j === void 0 ? null : _ref$j;\n      var w = this.w;\n\n      if (w.config.tooltip.custom !== undefined) {\n        this.handleCustomTooltip({\n          i: i,\n          j: j\n        });\n      } else {\n        this.toggleActiveInactiveSeries(shared);\n      }\n\n      var values = this.getValuesToPrint({\n        i: i,\n        j: j\n      });\n      this.printLabels({\n        i: i,\n        j: j,\n        values: values,\n        ttItems: ttItems,\n        shared: shared\n      }); // Re-calculate tooltip dimensions now that we have drawn the text\n\n      var tooltipEl = this.ttCtx.getElTooltip();\n      this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;\n      this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;\n    }\n  }, {\n    key: \"printLabels\",\n    value: function printLabels(_ref2) {\n      var i = _ref2.i,\n          j = _ref2.j,\n          values = _ref2.values,\n          ttItems = _ref2.ttItems,\n          shared = _ref2.shared;\n      var w = this.w;\n      var val;\n      var xVal = values.xVal,\n          zVal = values.zVal,\n          xAxisTTVal = values.xAxisTTVal;\n      var seriesName = '';\n      var pColor = w.globals.colors[i];\n\n      if (j !== null && w.config.plotOptions.bar.distributed) {\n        pColor = w.globals.colors[j];\n      }\n\n      for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {\n        var f = this.getFormatters(i);\n        seriesName = this.getSeriesName({\n          fn: f.yLbTitleFormatter,\n          index: i,\n          seriesIndex: i,\n          j: j\n        });\n\n        if (shared) {\n          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;\n          f = this.getFormatters(tIndex);\n          seriesName = this.getSeriesName({\n            fn: f.yLbTitleFormatter,\n            index: tIndex,\n            seriesIndex: i,\n            j: j\n          });\n          pColor = w.globals.colors[tIndex]; // for plot charts, not for pie/donuts\n\n          val = f.yLbFormatter(w.globals.series[tIndex][j], {\n            series: w.globals.series,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          }); // discard 0 values in BARS\n\n          if (this.ttCtx.hasBars() && w.config.chart.stacked && w.globals.series[tIndex][j] === 0 || typeof w.globals.series[tIndex][j] === 'undefined') {\n            val = undefined;\n          }\n        } else {\n          val = f.yLbFormatter(w.globals.series[i][j], {\n            series: w.globals.series,\n            seriesIndex: i,\n            dataPointIndex: j,\n            w: w\n          });\n        } // for pie / donuts\n\n\n        if (j === null) {\n          val = f.yLbFormatter(w.globals.series[i], w);\n        }\n\n        this.DOMHandling({\n          t: t,\n          ttItems: ttItems,\n          values: {\n            val: val,\n            xVal: xVal,\n            xAxisTTVal: xAxisTTVal,\n            zVal: zVal\n          },\n          seriesName: seriesName,\n          shared: shared,\n          pColor: pColor\n        });\n      }\n    }\n  }, {\n    key: \"getFormatters\",\n    value: function getFormatters(i) {\n      var w = this.w;\n      var yLbFormatter = w.globals.yLabelFormatters[i];\n      var yLbTitleFormatter;\n\n      if (w.globals.ttVal !== undefined) {\n        if (Array.isArray(w.globals.ttVal)) {\n          yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;\n          yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;\n        } else {\n          yLbFormatter = w.globals.ttVal.formatter;\n\n          if (typeof w.globals.ttVal.title.formatter === 'function') {\n            yLbTitleFormatter = w.globals.ttVal.title.formatter;\n          }\n        }\n      } else {\n        yLbTitleFormatter = w.config.tooltip.y.title.formatter;\n      }\n\n      if (typeof yLbFormatter !== 'function') {\n        if (w.globals.yLabelFormatters[0]) {\n          yLbFormatter = w.globals.yLabelFormatters[0];\n        } else {\n          yLbFormatter = function yLbFormatter(label) {\n            return label;\n          };\n        }\n      }\n\n      if (typeof yLbTitleFormatter !== 'function') {\n        yLbTitleFormatter = function yLbTitleFormatter(label) {\n          return label;\n        };\n      }\n\n      return {\n        yLbFormatter: yLbFormatter,\n        yLbTitleFormatter: yLbTitleFormatter\n      };\n    }\n  }, {\n    key: \"getSeriesName\",\n    value: function getSeriesName(_ref3) {\n      var fn = _ref3.fn,\n          index = _ref3.index,\n          seriesIndex = _ref3.seriesIndex,\n          j = _ref3.j;\n      var w = this.w;\n      return fn(String(w.globals.seriesNames[index]), {\n        series: w.globals.series,\n        seriesIndex: seriesIndex,\n        dataPointIndex: j,\n        w: w\n      });\n    }\n  }, {\n    key: \"DOMHandling\",\n    value: function DOMHandling(_ref4) {\n      var t = _ref4.t,\n          ttItems = _ref4.ttItems,\n          values = _ref4.values,\n          seriesName = _ref4.seriesName,\n          shared = _ref4.shared,\n          pColor = _ref4.pColor;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var val = values.val,\n          xVal = values.xVal,\n          xAxisTTVal = values.xAxisTTVal,\n          zVal = values.zVal;\n      var ttItemsChildren = null;\n      ttItemsChildren = ttItems[t].children;\n\n      if (w.config.tooltip.fillSeriesColor) {\n        //  elTooltip.style.backgroundColor = pColor\n        ttItems[t].style.backgroundColor = pColor;\n        ttItemsChildren[0].style.display = 'none';\n      }\n\n      if (ttCtx.showTooltipTitle) {\n        if (ttCtx.tooltipTitle === null) {\n          // get it once if null, and store it in class property\n          ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');\n        }\n\n        ttCtx.tooltipTitle.innerHTML = xVal;\n      } // if xaxis tooltip is constructed, we need to replace the innerHTML\n\n\n      if (ttCtx.blxaxisTooltip) {\n        ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;\n      }\n\n      var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label');\n\n      if (ttYLabel) {\n        ttYLabel.innerHTML = seriesName ? seriesName + ': ' : '';\n      }\n\n      var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value');\n\n      if (ttYVal) {\n        ttYVal.innerHTML = val;\n      }\n\n      if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {\n        ttItemsChildren[0].style.backgroundColor = pColor;\n      }\n\n      if (!w.config.tooltip.marker.show) {\n        ttItemsChildren[0].style.display = 'none';\n      }\n\n      if (zVal !== null) {\n        var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');\n        ttZLabel.innerHTML = w.config.tooltip.z.title;\n        var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');\n        ttZVal.innerHTML = zVal;\n      }\n\n      if (shared && ttItemsChildren[0]) {\n        // hide when no Val or series collapsed\n        if (typeof val === 'undefined' || val === null || w.globals.collapsedSeriesIndices.indexOf(t) > -1) {\n          ttItemsChildren[0].parentNode.style.display = 'none';\n        } else {\n          ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;\n        }\n      }\n    }\n  }, {\n    key: \"toggleActiveInactiveSeries\",\n    value: function toggleActiveInactiveSeries(shared) {\n      var w = this.w;\n\n      if (shared) {\n        // make all tooltips active\n        this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');\n      } else {\n        // disable all tooltip text groups\n        this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); // enable the first tooltip text group\n\n        var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group');\n\n        if (firstTooltipSeriesGroup) {\n          firstTooltipSeriesGroup.classList.add('active');\n          firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;\n        }\n      }\n    }\n  }, {\n    key: \"getValuesToPrint\",\n    value: function getValuesToPrint(_ref5) {\n      var i = _ref5.i,\n          j = _ref5.j;\n      var w = this.w;\n      var filteredSeriesX = this.ctx.series.filteredSeriesX();\n      var xVal = '';\n      var xAxisTTVal = '';\n      var zVal = null;\n      var val = null;\n      var customFormatterOpts = {\n        series: w.globals.series,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      };\n      var zFormatter = w.globals.ttZFormatter;\n\n      if (j === null) {\n        val = w.globals.series[i];\n      } else {\n        if (w.globals.isXNumeric) {\n          xVal = filteredSeriesX[i][j];\n\n          if (filteredSeriesX[i].length === 0) {\n            // a series (possibly the first one) might be collapsed, so get the next active index\n            var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);\n            xVal = filteredSeriesX[firstActiveSeriesIndex][j];\n          }\n        } else {\n          xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';\n        }\n      }\n\n      var bufferXVal = xVal;\n\n      if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {\n        var xFormat = new Formatters(this.ctx);\n        xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal);\n      } else {\n        xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);\n      } // override default x-axis formatter with tooltip formatter\n\n\n      if (w.config.tooltip.x.formatter !== undefined) {\n        xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);\n      }\n\n      if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[0].length > 0) {\n        zVal = zFormatter(w.globals.seriesZ[i][j], w);\n      }\n\n      if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n        xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);\n      } else {\n        xAxisTTVal = xVal;\n      }\n\n      return {\n        val: val,\n        xVal: xVal,\n        xAxisTTVal: xAxisTTVal,\n        zVal: zVal\n      };\n    }\n  }, {\n    key: \"handleCustomTooltip\",\n    value: function handleCustomTooltip(_ref6) {\n      var i = _ref6.i,\n          j = _ref6.j;\n      var w = this.w;\n      var tooltipEl = this.ttCtx.getElTooltip(); // override everything with a custom html tooltip and replace it\n\n      tooltipEl.innerHTML = w.config.tooltip.custom({\n        series: w.globals.series,\n        seriesIndex: i,\n        dataPointIndex: j,\n        w: w\n      });\n    }\n  }]);\n\n  return Labels;\n}();\n\n/**\n * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.\n *\n * @module Tooltip.Position\n **/\n\nvar Position =\n/*#__PURE__*/\nfunction () {\n  function Position(tooltipContext) {\n    _classCallCheck(this, Position);\n\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n    this.w = tooltipContext.w;\n  }\n  /**\n   * This will move the crosshair (the vertical/horz line that moves along with mouse)\n   * Along with this, this function also calls the xaxisMove function\n   * @memberof Position\n   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n   */\n\n\n  _createClass(Position, [{\n    key: \"moveXCrosshairs\",\n    value: function moveXCrosshairs(cx) {\n      var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n      var xcrosshairs = ttCtx.getElXCrosshairs();\n      var x = cx - ttCtx.xcrosshairsWidth / 2;\n      var tickAmount = w.globals.labels.slice().length;\n\n      if (j !== null) {\n        x = w.globals.gridWidth / tickAmount * j;\n      }\n\n      if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {\n        if (x + ttCtx.xcrosshairsWidth > w.globals.gridWidth) {\n          x = w.globals.gridWidth - ttCtx.xcrosshairsWidth;\n        }\n      } else {\n        if (j !== null) {\n          x = x + w.globals.gridWidth / tickAmount / 2;\n        }\n      }\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      if (x > w.globals.gridWidth) {\n        x = w.globals.gridWidth;\n      }\n\n      if (xcrosshairs !== null) {\n        xcrosshairs.setAttribute('x', x);\n        xcrosshairs.setAttribute('x1', x);\n        xcrosshairs.setAttribute('x2', x);\n        xcrosshairs.setAttribute('y2', w.globals.gridHeight);\n        xcrosshairs.classList.add('active');\n      }\n\n      if (ttCtx.blxaxisTooltip) {\n        var tx = x;\n\n        if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {\n          tx = x + ttCtx.xcrosshairsWidth / 2;\n        }\n\n        this.moveXAxisTooltip(tx);\n      }\n    }\n    /**\n     * This will move the crosshair (the vertical/horz line that moves along with mouse)\n     * Along with this, this function also calls the xaxisMove function\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair\n     */\n\n  }, {\n    key: \"moveYCrosshairs\",\n    value: function moveYCrosshairs(cy) {\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.ycrosshairs !== null) {\n        Graphics.setAttrs(ttCtx.ycrosshairs, {\n          y1: cy,\n          y2: cy\n        });\n        Graphics.setAttrs(ttCtx.ycrosshairsHidden, {\n          y1: cy,\n          y2: cy\n        });\n      }\n    }\n    /**\n     ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move\n     */\n\n  }, {\n    key: \"moveXAxisTooltip\",\n    value: function moveXAxisTooltip(cx) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.xaxisTooltip !== null) {\n        ttCtx.xaxisTooltip.classList.add('active');\n        var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;\n        var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();\n        var xaxisTTTextWidth = xaxisTTText.width;\n        cx = cx - xaxisTTTextWidth / 2;\n\n        if (!isNaN(cx)) {\n          cx = cx + w.globals.translateX;\n          var textRect = 0;\n          var graphics = new Graphics(this.ctx);\n          textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);\n          ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';\n          ttCtx.xaxisTooltip.style.left = cx + 'px';\n          ttCtx.xaxisTooltip.style.top = cy + 'px';\n        }\n      }\n    }\n  }, {\n    key: \"moveYAxisTooltip\",\n    value: function moveYAxisTooltip(index) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (ttCtx.yaxisTTEls === null) {\n        ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n      }\n\n      var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'));\n      var cy = w.globals.translateY + ycrosshairsHiddenRectY1;\n      var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();\n      var yAxisTTHeight = yAxisTTRect.height;\n      var cx = w.globals.translateYAxisX[index] - 2;\n\n      if (w.config.yaxis[index].opposite) {\n        cx = cx - 26;\n      }\n\n      cy = cy - yAxisTTHeight / 2;\n\n      if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {\n        ttCtx.yaxisTTEls[index].classList.add('active');\n        ttCtx.yaxisTTEls[index].style.top = cy + 'px';\n        ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';\n      } else {\n        ttCtx.yaxisTTEls[index].classList.remove('active');\n      }\n    }\n    /**\n     ** moves the whole tooltip by changing x, y attrs\n     * @memberof Position\n     * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip\n     * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip\n     * @param {int} - r = point's radius\n     */\n\n  }, {\n    key: \"moveTooltip\",\n    value: function moveTooltip(cx, cy) {\n      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var tooltipEl = ttCtx.getElTooltip();\n      var tooltipRect = ttCtx.tooltipRect;\n      var pointR = r !== null ? parseInt(r) : 1;\n      var x = parseInt(cx) + pointR + 5;\n      var y = parseInt(cy) + pointR / 2; // - tooltipRect.ttHeight / 2\n\n      if (x > w.globals.gridWidth / 2) {\n        x = x - tooltipRect.ttWidth - pointR - 15;\n      }\n\n      if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {\n        x = w.globals.gridWidth - tooltipRect.ttWidth;\n      }\n\n      if (x < -20) {\n        x = -20;\n      }\n\n      if (w.config.tooltip.followCursor) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        y = ttCtx.e.clientY - seriesBound.top - tooltipRect.ttHeight / 2;\n      }\n\n      var newPositions = this.positionChecks(tooltipRect, x, y);\n      x = newPositions.x;\n      y = newPositions.y;\n\n      if (!isNaN(x)) {\n        x = x + w.globals.translateX;\n        tooltipEl.style.left = x + 'px';\n        tooltipEl.style.top = y + 'px';\n      }\n    }\n  }, {\n    key: \"positionChecks\",\n    value: function positionChecks(tooltipRect, x, y) {\n      var w = this.w;\n\n      if (tooltipRect.ttHeight + y > w.globals.gridHeight) {\n        y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;\n      }\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"moveMarkers\",\n    value: function moveMarkers(i, j) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      if (w.globals.markers.size[i] > 0) {\n        var allPoints = w.globals.dom.baseEl.querySelectorAll(\" .apexcharts-series[data\\\\:realIndex='\".concat(i, \"'] .apexcharts-marker\"));\n\n        for (var p = 0; p < allPoints.length; p++) {\n          if (parseInt(allPoints[p].getAttribute('rel')) === j) {\n            ttCtx.marker.resetPointsSize();\n            ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);\n          }\n        }\n      } else {\n        ttCtx.marker.resetPointsSize();\n        this.moveDynamicPointOnHover(j, i);\n      }\n    } // This function is used when you need to show markers/points only on hover -\n    // DIFFERENT X VALUES in multiple series\n\n  }, {\n    key: \"moveDynamicPointOnHover\",\n    value: function moveDynamicPointOnHover(j, capturedSeries) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var cx = 0;\n      var cy = 0;\n      var pointsArr = w.globals.pointsArray;\n      var hoverSize = w.config.markers.hover.size;\n\n      if (hoverSize === undefined) {\n        hoverSize = w.globals.markers.size[capturedSeries] + w.config.markers.hover.sizeOffset;\n      }\n\n      cx = pointsArr[capturedSeries][j][0];\n      cy = pointsArr[capturedSeries][j][1] ? pointsArr[capturedSeries][j][1] : 0;\n      var point = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(capturedSeries, \"'] .apexcharts-series-markers circle\"));\n      point.setAttribute('r', hoverSize);\n      point.setAttribute('cx', cx);\n      point.setAttribute('cy', cy); // point.style.opacity = w.config.markers.hover.opacity\n\n      this.moveXCrosshairs(cx);\n\n      if (!ttCtx.fixedTooltip) {\n        this.moveTooltip(cx, cy, hoverSize);\n      }\n    } // This function is used when you need to show markers/points only on hover -\n    // SAME X VALUES in multiple series\n\n  }, {\n    key: \"moveDynamicPointsOnHover\",\n    value: function moveDynamicPointsOnHover(j) {\n      var ttCtx = this.ttCtx;\n      var w = ttCtx.w;\n      var cx = 0;\n      var cy = 0;\n      var activeSeries = 0;\n      var pointsArr = w.globals.pointsArray;\n      var series = new Series(this.ctx);\n      activeSeries = series.getActiveSeriesIndex();\n      var hoverSize = w.config.markers.hover.size;\n\n      if (hoverSize === undefined) {\n        hoverSize = w.globals.markers.size[activeSeries] + w.config.markers.hover.sizeOffset;\n      }\n\n      if (pointsArr[activeSeries]) {\n        cx = pointsArr[activeSeries][j][0];\n        cy = pointsArr[activeSeries][j][1];\n      }\n\n      var points = null;\n      var allPoints = ttCtx.getAllMarkers();\n\n      if (allPoints !== null) {\n        points = allPoints;\n      } else {\n        points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle');\n      }\n\n      if (points !== null) {\n        for (var p = 0; p < points.length; p++) {\n          var pointArr = pointsArr[p];\n\n          if (pointArr && pointArr.length) {\n            var pcy = pointsArr[p][j][1];\n            points[p].setAttribute('cx', cx);\n            var realIndex = parseInt(points[p].parentNode.parentNode.parentNode.getAttribute('data:realIndex'));\n\n            if (pcy !== null) {\n              points[realIndex] && points[realIndex].setAttribute('r', hoverSize);\n              points[realIndex] && points[realIndex].setAttribute('cy', pcy);\n            } else {\n              points[realIndex] && points[realIndex].setAttribute('r', 0);\n            }\n          }\n        }\n      }\n\n      this.moveXCrosshairs(cx);\n\n      if (!ttCtx.fixedTooltip) {\n        var tcy = cy || w.globals.gridHeight;\n        this.moveTooltip(cx, tcy, hoverSize);\n      }\n    }\n  }, {\n    key: \"moveStickyTooltipOverBars\",\n    value: function moveStickyTooltipOverBars(j) {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var jBar = w.globals.dom.baseEl.querySelector(\".apexcharts-bar-series .apexcharts-series[rel='1'] path[j='\".concat(j, \"'], .apexcharts-candlestick-series .apexcharts-series[rel='1'] path[j='\").concat(j, \"']\"));\n      var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;\n      var bcy = 0;\n      var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;\n\n      if (w.globals.isXNumeric) {\n        bcx = bcx - bw / 2;\n      } else {\n        bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;\n\n        if (isNaN(bcx)) {\n          bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;\n        }\n      } // tooltip will move vertically along with mouse as it is a shared tooltip\n\n\n      var elGrid = ttCtx.getElGrid();\n      var seriesBound = elGrid.getBoundingClientRect();\n      bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;\n      this.moveXCrosshairs(bcx);\n\n      if (!ttCtx.fixedTooltip) {\n        var tcy = bcy || w.globals.gridHeight;\n        this.moveTooltip(bcx, tcy);\n      }\n    }\n  }]);\n\n  return Position;\n}();\n\n/**\n * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.\n *\n * @module Tooltip.Marker\n **/\n\nvar Marker =\n/*#__PURE__*/\nfunction () {\n  function Marker(tooltipContext) {\n    _classCallCheck(this, Marker);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n    this.ctx = tooltipContext.ctx;\n    this.tooltipPosition = new Position(tooltipContext);\n  }\n\n  _createClass(Marker, [{\n    key: \"drawDynamicPoints\",\n    value: function drawDynamicPoints() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var marker = new Markers(this.ctx);\n      var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n\n      for (var i = 0; i < elsSeries.length; i++) {\n        var seriesIndex = parseInt(elsSeries[i].getAttribute('data:realIndex'));\n        var pointsMain = w.globals.dom.baseEl.querySelector(\".apexcharts-series[data\\\\:realIndex='\".concat(seriesIndex, \"'] .apexcharts-series-markers-wrap\"));\n\n        if (pointsMain !== null) {\n          // it can be null as we have tooltips in donut/bar charts\n          var point = void 0;\n          var PointClasses = \"apexcharts-marker w\".concat((Math.random() + 1).toString(36).substring(4));\n\n          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {\n            PointClasses += ' no-pointer-events';\n          }\n\n          var elPointOptions = marker.getMarkerConfig(PointClasses, seriesIndex);\n          point = graphics.drawMarker(0, 0, elPointOptions);\n          point.node.setAttribute('default-marker-size', 0);\n          var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');\n          elPointsG.classList.add('apexcharts-series-markers');\n          elPointsG.appendChild(point.node);\n          pointsMain.appendChild(elPointsG);\n        }\n      }\n    }\n  }, {\n    key: \"enlargeCurrentPoint\",\n    value: function enlargeCurrentPoint(rel, point) {\n      var w = this.w;\n\n      if (w.config.chart.type !== 'bubble') {\n        this.newPointSize(rel, point);\n      }\n\n      var cx = point.getAttribute('cx');\n      var cy = point.getAttribute('cy');\n      this.tooltipPosition.moveXCrosshairs(cx);\n\n      if (!this.fixedTooltip) {\n        if (w.config.chart.type === 'radar') {\n          var elGrid = this.ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          cx = this.ttCtx.e.clientX - seriesBound.left;\n        }\n\n        this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);\n      }\n    }\n  }, {\n    key: \"enlargePoints\",\n    value: function enlargePoints(j) {\n      var w = this.w;\n      var me = this;\n      var ttCtx = this.ttCtx;\n      var col = j;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n      var newSize = w.config.markers.hover.size;\n\n      for (var p = 0; p < points.length; p++) {\n        var rel = points[p].getAttribute('rel');\n        var index = points[p].getAttribute('index');\n\n        if (newSize === undefined) {\n          newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n        }\n\n        if (col === parseInt(rel)) {\n          me.newPointSize(col, points[p]);\n          var cx = points[p].getAttribute('cx');\n          var cy = points[p].getAttribute('cy');\n          me.tooltipPosition.moveXCrosshairs(cx);\n\n          if (!ttCtx.fixedTooltip) {\n            me.tooltipPosition.moveTooltip(cx, cy, newSize);\n          }\n        } else {\n          me.oldPointSize(points[p]);\n        }\n      }\n    }\n  }, {\n    key: \"newPointSize\",\n    value: function newPointSize(rel, point) {\n      var w = this.w;\n      var newSize = w.config.markers.hover.size;\n      var elPoint = null;\n\n      if (rel === 0) {\n        elPoint = point.parentNode.firstChild;\n      } else {\n        elPoint = point.parentNode.lastChild;\n      }\n\n      var index = parseInt(elPoint.getAttribute('index'));\n\n      if (newSize === undefined) {\n        newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;\n      }\n\n      elPoint.setAttribute('r', newSize);\n    }\n  }, {\n    key: \"oldPointSize\",\n    value: function oldPointSize(point) {\n      var size = parseInt(point.getAttribute('default-marker-size'));\n      point.setAttribute('r', size);\n    }\n  }, {\n    key: \"resetPointsSize\",\n    value: function resetPointsSize() {\n      var w = this.w;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');\n\n      for (var p = 0; p < points.length; p++) {\n        var size = parseInt(points[p].getAttribute('default-marker-size'));\n\n        if (Utils.isNumber(size)) {\n          points[p].setAttribute('r', size);\n        } else {\n          points[p].setAttribute('r', 0);\n        }\n      }\n    }\n  }]);\n\n  return Marker;\n}();\n\n/**\n * ApexCharts Tooltip.Intersect Class.\n *\n * @module Tooltip.Intersect\n **/\n\nvar Intersect =\n/*#__PURE__*/\nfunction () {\n  function Intersect(tooltipContext) {\n    _classCallCheck(this, Intersect);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n  }\n\n  _createClass(Intersect, [{\n    key: \"getAttr\",\n    value: function getAttr(e, attr) {\n      return parseFloat(e.target.getAttribute(attr));\n    }\n  }, {\n    key: \"handleHeatTooltip\",\n    value: function handleHeatTooltip(_ref) {\n      var e = _ref.e,\n          opt = _ref.opt,\n          x = _ref.x,\n          y = _ref.y;\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n\n      if (e.target.classList.contains('apexcharts-heatmap-rect')) {\n        var i = this.getAttr(e, 'i');\n        var j = this.getAttr(e, 'j');\n        var cx = this.getAttr(e, 'cx');\n        var cy = this.getAttr(e, 'cy');\n        var width = this.getAttr(e, 'width');\n        var height = this.getAttr(e, 'height');\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: false\n        });\n        x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;\n        y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;\n        ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);\n\n        if (x > w.globals.gridWidth / 2) {\n          x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;\n        }\n\n        if (ttCtx.w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect(); // x = ttCtx.e.clientX - seriesBound.left\n\n          y = ttCtx.e.clientY - seriesBound.top + w.globals.translateY / 2 - 10;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"handleMarkerTooltip\",\n    value: function handleMarkerTooltip(_ref2) {\n      var e = _ref2.e,\n          opt = _ref2.opt,\n          x = _ref2.x,\n          y = _ref2.y;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var i;\n      var j;\n\n      if (e.target.classList.contains('apexcharts-marker')) {\n        var cx = parseInt(opt.paths.getAttribute('cx'));\n        var cy = parseInt(opt.paths.getAttribute('cy'));\n        var val = parseFloat(opt.paths.getAttribute('val'));\n        j = parseInt(opt.paths.getAttribute('rel'));\n        i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel')) - 1;\n\n        if (ttCtx.intersect) {\n          var el = Utils.findAncestor(opt.paths, 'apexcharts-series');\n\n          if (el) {\n            i = parseInt(el.getAttribute('data:realIndex'));\n          }\n        }\n\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: ttCtx.intersect ? false : w.config.tooltip.shared\n        });\n        ttCtx.marker.enlargeCurrentPoint(j, opt.paths);\n        x = cx;\n        y = cy - ttCtx.tooltipRect.ttHeight * 1.4;\n\n        if (ttCtx.w.config.tooltip.followCursor) {\n          var elGrid = ttCtx.getElGrid();\n          var seriesBound = elGrid.getBoundingClientRect();\n          y = ttCtx.e.clientY - seriesBound.top;\n        }\n\n        if (val < 0) {\n          y = cy;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"handleBarTooltip\",\n    value: function handleBarTooltip(_ref3) {\n      var e = _ref3.e,\n          opt = _ref3.opt;\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var tooltipEl = ttCtx.getElTooltip();\n      var bx = 0;\n      var x = 0;\n      var y = 0; // let bW = 0\n\n      var i = 0;\n      var strokeWidth;\n      var barXY = this.getBarTooltipXY({\n        e: e,\n        opt: opt\n      });\n      i = barXY.i;\n      var barHeight = barXY.barHeight;\n      var j = barXY.j;\n\n      if (ttCtx.isBarHorizontal && ttCtx.hasBars() || !w.config.tooltip.shared) {\n        x = barXY.x;\n        y = barXY.y;\n        strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width; // bW = barXY.barWidth\n\n        bx = x;\n      } else {\n        if (!w.globals.comboCharts && !w.config.tooltip.shared) {\n          bx = bx / 2;\n        }\n      } // y is NaN, make it touch the bottom of grid area\n\n\n      if (isNaN(y)) {\n        y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;\n      } // x exceeds gridWidth\n\n\n      if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth) {\n        x = x - ttCtx.tooltipRect.ttWidth;\n      } else if (x < 0) {\n        x = x + ttCtx.tooltipRect.ttWidth;\n      }\n\n      if (ttCtx.w.config.tooltip.followCursor) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        y = ttCtx.e.clientY - seriesBound.top;\n      } // if tooltip is still null, querySelector\n\n\n      if (ttCtx.tooltip === null) {\n        ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n      }\n\n      if (!w.config.tooltip.shared) {\n        if (w.globals.comboChartsHasBars) {\n          ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);\n        } else {\n          ttCtx.tooltipPosition.moveXCrosshairs(bx);\n        }\n      } // move tooltip here\n\n\n      if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || ttCtx.isBarHorizontal && ttCtx.hasBars())) {\n        if (isReversed) {\n          x = w.globals.gridWidth - x;\n        }\n\n        tooltipEl.style.left = x + w.globals.translateX + 'px';\n        var seriesIndex = parseInt(opt.paths.parentNode.getAttribute('data:realIndex'));\n        var isReversed = w.globals.isMultipleYAxis ? w.config.yaxis[seriesIndex].reversed : w.config.yaxis[0].reversed;\n\n        if (isReversed && !(ttCtx.isBarHorizontal && ttCtx.hasBars())) {\n          y = y + barHeight - (w.globals.series[i][j] < 0 ? barHeight : 0) * 2;\n        }\n\n        if (ttCtx.tooltipRect.ttHeight + y > w.globals.gridHeight) {\n          y = w.globals.gridHeight - ttCtx.tooltipRect.ttHeight + w.globals.translateY;\n          tooltipEl.style.top = y + 'px';\n        } else {\n          tooltipEl.style.top = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2 + 'px';\n        }\n      }\n    }\n  }, {\n    key: \"getBarTooltipXY\",\n    value: function getBarTooltipXY(_ref4) {\n      var e = _ref4.e,\n          opt = _ref4.opt;\n      var w = this.w;\n      var j = null;\n      var ttCtx = this.ttCtx;\n      var i = 0;\n      var x = 0;\n      var y = 0;\n      var barWidth = 0;\n      var barHeight = 0;\n      var cl = e.target.classList;\n\n      if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area')) {\n        var bar = e.target;\n        var barRect = bar.getBoundingClientRect();\n        var seriesBound = opt.elGrid.getBoundingClientRect();\n        var bh = barRect.height;\n        barHeight = barRect.height;\n        var bw = barRect.width;\n        var cx = parseInt(bar.getAttribute('cx'));\n        var cy = parseInt(bar.getAttribute('cy'));\n        barWidth = parseFloat(bar.getAttribute('barWidth'));\n        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n        j = parseInt(bar.getAttribute('j'));\n        i = parseInt(bar.parentNode.getAttribute('rel')) - 1;\n\n        if (w.globals.comboCharts) {\n          i = parseInt(bar.parentNode.getAttribute('data:realIndex'));\n        } // if (w.config.tooltip.shared) {\n        // this check not needed  at the moment\n        //   const yDivisor = w.globals.gridHeight / (w.globals.series.length)\n        //   const hoverY = ttCtx.clientY - ttCtx.seriesBound.top\n        //   j = Math.ceil(hoverY / yDivisor)\n        // }\n\n\n        ttCtx.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: i,\n          j: j,\n          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared\n        });\n\n        if (w.config.tooltip.followCursor) {\n          if (w.config.plotOptions.bar.horizontal) {\n            x = clientX - seriesBound.left + 15;\n            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;\n          } else {\n            if (w.globals.isXNumeric) {\n              x = cx - bw / 2;\n            } else {\n              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;\n            }\n\n            y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;\n          }\n        } else {\n          if (w.config.plotOptions.bar.horizontal) {\n            x = cx;\n\n            if (x < ttCtx.xyRatios.baseLineInvertedY) {\n              x = cx - ttCtx.tooltipRect.ttWidth;\n            }\n\n            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;\n          } else {\n            // if columns\n            if (w.globals.isXNumeric) {\n              x = cx - bw / 2;\n            } else {\n              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;\n            }\n\n            y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y,\n        barHeight: barHeight,\n        barWidth: barWidth,\n        i: i,\n        j: j\n      };\n    }\n  }]);\n\n  return Intersect;\n}();\n\n/**\n * ApexCharts Tooltip.AxesTooltip Class.\n *\n * @module Tooltip.AxesTooltip\n **/\nvar AxesTooltip =\n/*#__PURE__*/\nfunction () {\n  function AxesTooltip(tooltipContext) {\n    _classCallCheck(this, AxesTooltip);\n\n    this.w = tooltipContext.w;\n    this.ttCtx = tooltipContext;\n  }\n  /**\n   * This method adds the secondary tooltip which appears below x axis\n   * @memberof Tooltip\n   **/\n\n\n  _createClass(AxesTooltip, [{\n    key: \"drawXaxisTooltip\",\n    value: function drawXaxisTooltip() {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n      var isBottom = w.config.xaxis.position === 'bottom';\n      ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : 1;\n      var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';\n      var renderTo = w.globals.dom.elWrap;\n\n      if (ttCtx.blxaxisTooltip) {\n        var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');\n\n        if (xaxisTooltip === null) {\n          ttCtx.xaxisTooltip = document.createElement('div');\n          ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass);\n          renderTo.appendChild(ttCtx.xaxisTooltip);\n          ttCtx.xaxisTooltipText = document.createElement('div');\n          ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');\n          ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;\n          ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;\n          ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);\n        }\n      }\n    }\n    /**\n     * This method adds the secondary tooltip which appears below x axis\n     * @memberof Tooltip\n     **/\n\n  }, {\n    key: \"drawYaxisTooltip\",\n    value: function drawYaxisTooltip() {\n      var w = this.w;\n      var ttCtx = this.ttCtx;\n\n      for (var i = 0; i < w.config.yaxis.length; i++) {\n        var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;\n        ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;\n        var tooltipCssClass = isRight ? \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-right\") : \"apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i, \" apexcharts-yaxistooltip-left\");\n        var renderTo = w.globals.dom.elWrap;\n\n        if (ttCtx.blyaxisTooltip) {\n          var yaxisTooltip = w.globals.dom.baseEl.querySelector(\".apexcharts-yaxistooltip apexcharts-yaxistooltip-\".concat(i));\n\n          if (yaxisTooltip === null) {\n            ttCtx.yaxisTooltip = document.createElement('div');\n            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass);\n            renderTo.appendChild(ttCtx.yaxisTooltip);\n            if (i === 0) ttCtx.yaxisTooltipText = [];\n            ttCtx.yaxisTooltipText.push(document.createElement('div'));\n            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');\n            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);\n          }\n        }\n      }\n    }\n    /**\n     * @memberof Tooltip\n     **/\n\n  }, {\n    key: \"setXCrosshairWidth\",\n    value: function setXCrosshairWidth() {\n      var w = this.w;\n      var ttCtx = this.ttCtx; // set xcrosshairs width\n\n      var xcrosshairs = ttCtx.getElXCrosshairs();\n      ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width);\n\n      if (!w.globals.comboCharts) {\n        if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n          var count = w.globals.labels.length;\n          ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;\n        } else if (w.config.xaxis.crosshairs.width === 'barWidth') {\n          var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n          if (bar !== null) {\n            var barWidth = parseFloat(bar.getAttribute('barWidth'));\n            ttCtx.xcrosshairsWidth = barWidth;\n          } else {\n            ttCtx.xcrosshairsWidth = 1;\n          }\n        }\n      } else {\n        var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');\n\n        if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {\n          var _barWidth = parseFloat(_bar.getAttribute('barWidth'));\n\n          ttCtx.xcrosshairsWidth = _barWidth;\n        } else {\n          if (w.config.xaxis.crosshairs.width === 'tickWidth') {\n            var _count = w.globals.labels.length;\n            ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;\n          }\n        }\n      }\n\n      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal) {\n        ttCtx.xcrosshairsWidth = 0;\n      }\n\n      if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {\n        xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);\n      }\n    }\n  }, {\n    key: \"handleYCrosshair\",\n    value: function handleYCrosshair() {\n      var w = this.w;\n      var ttCtx = this.ttCtx; // set ycrosshairs height\n\n      ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');\n      ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');\n    }\n  }, {\n    key: \"drawYaxisTooltipText\",\n    value: function drawYaxisTooltipText(index, clientY, xyRatios) {\n      var ttCtx = this.ttCtx;\n      var w = this.w;\n      var lbFormatter = w.globals.yLabelFormatters[index];\n\n      if (ttCtx.blyaxisTooltip) {\n        var elGrid = ttCtx.getElGrid();\n        var seriesBound = elGrid.getBoundingClientRect();\n        var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[index];\n        var height = w.globals.maxYArr[index] - w.globals.minYArr[index];\n        var val = w.globals.minYArr[index] + (height - hoverY);\n        ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);\n        ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);\n        ttCtx.tooltipPosition.moveYAxisTooltip(index);\n      }\n    }\n  }]);\n\n  return AxesTooltip;\n}();\n\n/**\n * ApexCharts Core Tooltip Class to handle the tooltip generation.\n *\n * @module Tooltip\n **/\n\nvar Tooltip =\n/*#__PURE__*/\nfunction () {\n  function Tooltip(ctx) {\n    _classCallCheck(this, Tooltip);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    var w = this.w;\n    this.tooltipUtil = new Utils$1(this);\n    this.tooltipLabels = new Labels(this);\n    this.tooltipPosition = new Position(this);\n    this.marker = new Marker(this);\n    this.intersect = new Intersect(this);\n    this.axesTooltip = new AxesTooltip(this);\n    this.showOnIntersect = w.config.tooltip.intersect;\n    this.showTooltipTitle = w.config.tooltip.x.show;\n    this.fixedTooltip = w.config.tooltip.fixed.enabled;\n    this.xaxisTooltip = null;\n    this.yaxisTTEls = null;\n    this.isBarHorizontal = w.config.plotOptions.bar.horizontal;\n    this.isBarShared = !w.config.plotOptions.bar.horizontal && w.config.tooltip.shared;\n  }\n\n  _createClass(Tooltip, [{\n    key: \"getElTooltip\",\n    value: function getElTooltip(ctx) {\n      if (!ctx) ctx = this;\n      return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');\n    }\n  }, {\n    key: \"getElXCrosshairs\",\n    value: function getElXCrosshairs() {\n      return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');\n    }\n  }, {\n    key: \"getElGrid\",\n    value: function getElGrid() {\n      return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n    }\n  }, {\n    key: \"drawTooltip\",\n    value: function drawTooltip(xyRatios) {\n      var w = this.w;\n      this.xyRatios = xyRatios;\n      this.blxaxisTooltip = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;\n      this.blyaxisTooltip = w.config.yaxis[0].tooltip.enabled && w.globals.axisCharts;\n      this.allTooltipSeriesGroups = [];\n\n      if (!w.globals.axisCharts) {\n        this.showTooltipTitle = false;\n      }\n\n      var tooltipEl = document.createElement('div');\n      tooltipEl.classList.add('apexcharts-tooltip');\n      tooltipEl.classList.add(w.config.tooltip.theme);\n      w.globals.dom.elWrap.appendChild(tooltipEl);\n\n      if (w.globals.axisCharts) {\n        this.axesTooltip.drawXaxisTooltip();\n        this.axesTooltip.drawYaxisTooltip();\n        this.axesTooltip.setXCrosshairWidth();\n        this.axesTooltip.handleYCrosshair();\n        var xAxis = new XAxis(this.ctx);\n        this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();\n      } // we forcefully set intersect true for these conditions\n\n\n      if (w.globals.comboCharts && !w.config.tooltip.shared || w.config.tooltip.intersect && !w.config.tooltip.shared || w.config.chart.type === 'bar' && !w.config.tooltip.shared) {\n        this.showOnIntersect = true;\n      }\n\n      if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {\n        // when user don't want to show points all the time, but only on when hovering on series\n        this.marker.drawDynamicPoints(this);\n      } // no visible series, exit\n\n\n      if (w.globals.collapsedSeries.length === w.globals.series.length) return;\n      this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;\n      this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;\n\n      if (this.showTooltipTitle) {\n        this.tooltipTitle = document.createElement('div');\n        this.tooltipTitle.classList.add('apexcharts-tooltip-title');\n        this.tooltipTitle.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;\n        this.tooltipTitle.style.fontSize = w.config.tooltip.style.fontSize;\n        tooltipEl.appendChild(this.tooltipTitle);\n      }\n\n      var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared\n\n      if ((w.globals.xyCharts || w.globals.comboCharts) && w.config.tooltip.shared) {\n        if (!this.showOnIntersect) {\n          ttItemsCnt = w.globals.series.length;\n        } else {\n          ttItemsCnt = 1;\n        }\n      }\n\n      this.ttItems = this.createTTElements(ttItemsCnt);\n      this.addSVGEvents();\n    }\n  }, {\n    key: \"createTTElements\",\n    value: function createTTElements(ttItemsCnt) {\n      var w = this.w;\n      var ttItems = [];\n      var tooltipEl = this.getElTooltip();\n\n      for (var i = 0; i < ttItemsCnt; i++) {\n        var gTxt = document.createElement('div');\n        gTxt.classList.add('apexcharts-tooltip-series-group');\n        var point = document.createElement('span');\n        point.classList.add('apexcharts-tooltip-marker');\n        point.style.backgroundColor = w.globals.colors[i];\n        gTxt.appendChild(point);\n        var gYZ = document.createElement('div');\n        gYZ.classList.add('apexcharts-tooltip-text');\n        gYZ.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;\n        gYZ.style.fontSize = w.config.tooltip.style.fontSize; // y values group\n\n        var gYValText = document.createElement('div');\n        gYValText.classList.add('apexcharts-tooltip-y-group');\n        var txtLabel = document.createElement('span');\n        txtLabel.classList.add('apexcharts-tooltip-text-label');\n        gYValText.appendChild(txtLabel);\n        var txtValue = document.createElement('span');\n        txtValue.classList.add('apexcharts-tooltip-text-value');\n        gYValText.appendChild(txtValue); // z values group\n\n        var gZValText = document.createElement('div');\n        gZValText.classList.add('apexcharts-tooltip-z-group');\n        var txtZLabel = document.createElement('span');\n        txtZLabel.classList.add('apexcharts-tooltip-text-z-label');\n        gZValText.appendChild(txtZLabel);\n        var txtZValue = document.createElement('span');\n        txtZValue.classList.add('apexcharts-tooltip-text-z-value');\n        gZValText.appendChild(txtZValue);\n        gYZ.appendChild(gYValText);\n        gYZ.appendChild(gZValText);\n        gTxt.appendChild(gYZ);\n        tooltipEl.appendChild(gTxt);\n        ttItems.push(gTxt);\n      }\n\n      return ttItems;\n    }\n  }, {\n    key: \"addSVGEvents\",\n    value: function addSVGEvents() {\n      var w = this.w;\n      var type = w.config.chart.type;\n      var tooltipEl = this.getElTooltip();\n      var barOrCandlestick = !!(type === 'bar' || type === 'candlestick');\n      var hoverArea = w.globals.dom.Paper.node;\n      var elGrid = this.getElGrid();\n\n      if (elGrid) {\n        this.seriesBound = elGrid.getBoundingClientRect();\n      }\n\n      var tooltipY = [];\n      var tooltipX = [];\n      var seriesHoverParams = {\n        hoverArea: hoverArea,\n        elGrid: elGrid,\n        tooltipEl: tooltipEl,\n        tooltipY: tooltipY,\n        tooltipX: tooltipX,\n        ttItems: this.ttItems\n      };\n      var points;\n\n      if (w.globals.axisCharts) {\n        if (type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble') {\n          points = w.globals.dom.baseEl.querySelectorAll(\".apexcharts-series[data\\\\:longestSeries='true'] .apexcharts-marker\");\n        } else if (barOrCandlestick) {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area', '.apexcharts-series .apexcharts-candlestick-area');\n        } else if (type === 'heatmap') {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap');\n        } else if (type === 'radar') {\n          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-marker');\n        }\n\n        if (points && points.length) {\n          for (var p = 0; p < points.length; p++) {\n            tooltipY.push(points[p].getAttribute('cy'));\n            tooltipX.push(points[p].getAttribute('cx'));\n          }\n        }\n      }\n\n      var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || barOrCandlestick && this.hasBars() && w.config.tooltip.shared;\n\n      if (validSharedChartTypes) {\n        this.addPathsEventListeners([hoverArea], seriesHoverParams);\n      } else if (barOrCandlestick && !w.globals.comboCharts) {\n        this.addBarsEventListeners(seriesHoverParams);\n      } else if (type === 'bubble' || type === 'scatter' || type === 'radar' || this.showOnIntersect && (type === 'area' || type === 'line')) {\n        this.addPointsEventsListeners(seriesHoverParams);\n      } else if (!w.globals.axisCharts || type === 'heatmap') {\n        var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');\n        this.addPathsEventListeners(seriesAll, seriesHoverParams);\n      }\n\n      if (this.showOnIntersect) {\n        var linePoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker');\n\n        if (linePoints.length > 0) {\n          // if we find any lineSeries, addEventListeners for them\n          this.addPathsEventListeners(linePoints, seriesHoverParams);\n        }\n\n        var areaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-marker');\n\n        if (areaPoints.length > 0) {\n          // if we find any areaSeries, addEventListeners for them\n          this.addPathsEventListeners(areaPoints, seriesHoverParams);\n        } // combo charts may have bars, so add event listeners here too\n\n\n        if (this.hasBars() && !w.config.tooltip.shared) {\n          this.addBarsEventListeners(seriesHoverParams);\n        }\n      }\n    }\n  }, {\n    key: \"drawFixedTooltipRect\",\n    value: function drawFixedTooltipRect() {\n      var w = this.w;\n      var tooltipEl = this.getElTooltip();\n      var tooltipRect = tooltipEl.getBoundingClientRect();\n      var ttWidth = tooltipRect.width + 10;\n      var ttHeight = tooltipRect.height + 10;\n      var x = w.config.tooltip.fixed.offsetX;\n      var y = w.config.tooltip.fixed.offsetY;\n\n      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('right') > -1) {\n        x = x + w.globals.svgWidth - ttWidth + 10;\n      }\n\n      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('bottom') > -1) {\n        y = y + w.globals.svgHeight - ttHeight - 10;\n      }\n\n      tooltipEl.style.left = x + 'px';\n      tooltipEl.style.top = y + 'px';\n      return {\n        x: x,\n        y: y,\n        ttWidth: ttWidth,\n        ttHeight: ttHeight\n      };\n    }\n  }, {\n    key: \"addPointsEventsListeners\",\n    value: function addPointsEventsListeners(seriesHoverParams) {\n      var w = this.w;\n      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');\n      this.addPathsEventListeners(points, seriesHoverParams);\n    }\n  }, {\n    key: \"addBarsEventListeners\",\n    value: function addBarsEventListeners(seriesHoverParams) {\n      var w = this.w;\n      var bars = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-area, .apexcharts-candlestick-area');\n      this.addPathsEventListeners(bars, seriesHoverParams);\n    }\n  }, {\n    key: \"addPathsEventListeners\",\n    value: function addPathsEventListeners(paths, opts) {\n      var _this = this;\n\n      var self = this;\n\n      var _loop = function _loop(p) {\n        var extendedOpts = {\n          paths: paths[p],\n          tooltipEl: opts.tooltipEl,\n          tooltipY: opts.tooltipY,\n          tooltipX: opts.tooltipX,\n          elGrid: opts.elGrid,\n          hoverArea: opts.hoverArea,\n          ttItems: opts.ttItems\n        };\n        _this.w.globals.tooltipOpts = extendedOpts;\n        var events = ['mousemove', 'touchmove', 'mouseout', 'touchend'];\n        events.map(function (ev) {\n          return paths[p].addEventListener(ev, self.seriesHover.bind(self, extendedOpts), {\n            capture: false,\n            passive: true\n          });\n        });\n      };\n\n      for (var p = 0; p < paths.length; p++) {\n        _loop(p);\n      }\n    }\n    /*\n     ** The actual series hover function\n     */\n\n  }, {\n    key: \"seriesHover\",\n    value: function seriesHover(opt, e) {\n      var _this2 = this;\n\n      var chartGroups = [];\n      var w = this.w; // if user has more than one charts in group, we need to sync\n\n      if (w.config.chart.group) {\n        chartGroups = this.ctx.getGroupedCharts();\n      }\n\n      if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {\n        return;\n      }\n\n      if (chartGroups.length) {\n        chartGroups.forEach(function (ch) {\n          var tooltipEl = _this2.getElTooltip(ch);\n\n          var newOpts = {\n            paths: opt.paths,\n            tooltipEl: tooltipEl,\n            tooltipY: opt.tooltipY,\n            tooltipX: opt.tooltipX,\n            elGrid: opt.elGrid,\n            hoverArea: opt.hoverArea,\n            ttItems: ch.w.globals.tooltip.ttItems // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly\n\n          };\n\n          if (ch.w.globals.minX === _this2.w.globals.minX && ch.w.globals.maxX === _this2.w.globals.maxX) {\n            ch.w.globals.tooltip.seriesHoverByContext({\n              chartCtx: ch,\n              ttCtx: ch.w.globals.tooltip,\n              opt: newOpts,\n              e: e\n            });\n          }\n        });\n      } else {\n        this.seriesHoverByContext({\n          chartCtx: this.ctx,\n          ttCtx: this.w.globals.tooltip,\n          opt: opt,\n          e: e\n        });\n      }\n    }\n  }, {\n    key: \"seriesHoverByContext\",\n    value: function seriesHoverByContext(_ref) {\n      var chartCtx = _ref.chartCtx,\n          ttCtx = _ref.ttCtx,\n          opt = _ref.opt,\n          e = _ref.e;\n      var w = chartCtx.w;\n      var tooltipEl = this.getElTooltip(); // tooltipRect is calculated on every mousemove, because the text is dynamic\n\n      ttCtx.tooltipRect = {\n        x: 0,\n        y: 0,\n        ttWidth: tooltipEl.getBoundingClientRect().width,\n        ttHeight: tooltipEl.getBoundingClientRect().height\n      };\n      ttCtx.e = e; // highlight the current hovered bars\n\n      if (ttCtx.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {\n        if (w.config.tooltip.onDatasetHover.highlightDataSeries) {\n          var series = new Series(chartCtx);\n          series.toggleSeriesOnHover(e, e.target.parentNode);\n        }\n      }\n\n      if (ttCtx.fixedTooltip) {\n        ttCtx.drawFixedTooltipRect();\n      }\n\n      if (w.globals.axisCharts) {\n        ttCtx.axisChartsTooltips({\n          e: e,\n          opt: opt,\n          tooltipRect: ttCtx.tooltipRect\n        });\n      } else {\n        // non-plot charts i.e pie/donut/circle\n        ttCtx.nonAxisChartsTooltips({\n          e: e,\n          opt: opt,\n          tooltipRect: ttCtx.tooltipRect\n        });\n      }\n    } // tooltip handling for line/area/bar/columns/scatter\n\n  }, {\n    key: \"axisChartsTooltips\",\n    value: function axisChartsTooltips(_ref2) {\n      var e = _ref2.e,\n          opt = _ref2.opt;\n      var w = this.w;\n      var j, x, y;\n      var self = this;\n      var capj = null;\n      var seriesBound = opt.elGrid.getBoundingClientRect();\n      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n      var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;\n      this.clientY = clientY;\n      this.clientX = clientX;\n\n      if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {\n        self.handleMouseOut(opt);\n        return;\n      }\n\n      var tooltipEl = this.getElTooltip();\n      var xcrosshairs = this.getElXCrosshairs();\n      var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !this.isBarHorizontal && this.hasBars() && w.config.tooltip.shared || w.globals.comboCharts && this.hasBars;\n\n      if (w.config.chart.type === 'bar' && this.isBarHorizontal && this.hasBars()) {\n        isStickyTooltip = false;\n      }\n\n      if (e.type === 'mousemove' || e.type === 'touchmove') {\n        if (xcrosshairs !== null) {\n          xcrosshairs.classList.add('active');\n        }\n\n        if (self.ycrosshairs !== null && self.blyaxisTooltip) {\n          self.ycrosshairs.classList.add('active');\n        }\n\n        if (isStickyTooltip && !self.showOnIntersect) {\n          capj = self.tooltipUtil.getNearestValues({\n            context: self,\n            hoverArea: opt.hoverArea,\n            elGrid: opt.elGrid,\n            clientX: clientX,\n            clientY: clientY,\n            hasBars: self.hasBars\n          });\n          j = capj.j;\n          var capturedSeries = capj.capturedSeries;\n\n          if (capj.hoverX < 0 || capj.hoverX > w.globals.gridWidth) {\n            self.handleMouseOut(opt);\n            return;\n          }\n\n          if (capturedSeries !== null) {\n            var ignoreNull = w.globals.series[capturedSeries][j] === null;\n\n            if (ignoreNull) {\n              opt.tooltipEl.classList.remove('active');\n              return;\n            }\n\n            if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {\n              if (w.config.tooltip.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isinitialSeriesSameLen()) {\n                this.create(self, capturedSeries, j, opt.ttItems);\n              } else {\n                this.create(self, capturedSeries, j, opt.ttItems, false);\n              }\n            } else {\n              if (this.tooltipUtil.isXoverlap(j)) {\n                self.create(self, 0, j, opt.ttItems);\n              }\n            }\n          } else {\n            // couldn't capture any series. check if shared X is same,\n            // if yes, draw a grouped tooltip\n            if (this.tooltipUtil.isXoverlap(j)) {\n              self.create(self, 0, j, opt.ttItems);\n            }\n          }\n        } else {\n          if (w.config.chart.type === 'heatmap') {\n            var markerXY = this.intersect.handleHeatTooltip({\n              e: e,\n              opt: opt,\n              x: x,\n              y: y\n            });\n            x = markerXY.x;\n            y = markerXY.y;\n            tooltipEl.style.left = x + 'px';\n            tooltipEl.style.top = y + 'px';\n          } else {\n            if (this.hasBars) {\n              this.intersect.handleBarTooltip({\n                e: e,\n                opt: opt\n              });\n            }\n\n            if (this.hasMarkers) {\n              // intersect - line/area/scatter/bubble\n              this.intersect.handleMarkerTooltip({\n                e: e,\n                opt: opt,\n                x: x,\n                y: y\n              });\n            }\n          }\n        }\n\n        if (this.blyaxisTooltip) {\n          for (var yt = 0; yt < w.config.yaxis.length; yt++) {\n            self.axesTooltip.drawYaxisTooltipText(yt, clientY, self.xyRatios);\n          }\n        }\n\n        opt.tooltipEl.classList.add('active');\n      } else if (e.type === 'mouseout' || e.type === 'touchend') {\n        this.handleMouseOut(opt);\n      }\n    } // tooltip handling for pie/donuts\n\n  }, {\n    key: \"nonAxisChartsTooltips\",\n    value: function nonAxisChartsTooltips(_ref3) {\n      var e = _ref3.e,\n          opt = _ref3.opt,\n          tooltipRect = _ref3.tooltipRect;\n      var w = this.w;\n      var rel = opt.paths.getAttribute('rel');\n      var tooltipEl = this.getElTooltip();\n      var trX = 0;\n      var trY = 0;\n      var elPie = null;\n      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n\n      if (w.config.chart.type === 'radialBar') {\n        elPie = w.globals.dom.baseEl.querySelector('.apexcharts-radialbar');\n      } else {\n        elPie = w.globals.dom.baseEl.querySelector('.apexcharts-pie');\n        trX = parseInt(elPie.getAttribute('data:innerTranslateX'));\n        trY = parseInt(elPie.getAttribute('data:innerTranslateY'));\n      }\n\n      var seriesBound = elPie.getBoundingClientRect();\n\n      if (e.type === 'mousemove' || e.type === 'touchmove') {\n        tooltipEl.classList.add('active');\n        this.tooltipLabels.drawSeriesTexts({\n          ttItems: opt.ttItems,\n          i: parseInt(rel) - 1,\n          shared: false\n        });\n        var x = clientX - seriesBound.left - tooltipRect.ttWidth / 2.2 + trX;\n        var y = e.clientY - seriesBound.top - tooltipRect.ttHeight / 2 - 15 + trY;\n\n        if (x < 0) {\n          x = 0;\n        } else if (x + tooltipRect.ttWidth > w.globals.gridWidth) {\n          x = clientX - seriesBound.left - tooltipRect.ttWidth + trX;\n        }\n\n        if (y < 0) y = tooltipRect.ttHeight + 20;\n        tooltipEl.style.left = x + w.globals.translateX + 'px';\n        tooltipEl.style.top = y + 'px';\n      } else if (e.type === 'mouseout' || e.type === 'touchend') {\n        tooltipEl.classList.remove('active');\n      }\n    }\n  }, {\n    key: \"deactivateHoverFilter\",\n    value: function deactivateHoverFilter() {\n      var w = this.w;\n      var graphics = new Graphics(this.ctx);\n      var allPaths = w.globals.dom.Paper.select(\".apexcharts-bar-area\");\n\n      for (var b = 0; b < allPaths.length; b++) {\n        graphics.pathMouseLeave(allPaths[b]);\n      }\n    }\n  }, {\n    key: \"handleMouseOut\",\n    value: function handleMouseOut(opt) {\n      var w = this.w;\n      var xcrosshairs = this.getElXCrosshairs();\n      opt.tooltipEl.classList.remove('active');\n      this.deactivateHoverFilter();\n\n      if (w.config.chart.type !== 'bubble') {\n        this.marker.resetPointsSize();\n      }\n\n      if (xcrosshairs !== null) {\n        xcrosshairs.classList.remove('active');\n      }\n\n      if (this.ycrosshairs !== null) {\n        this.ycrosshairs.classList.remove('active');\n      }\n\n      if (this.blxaxisTooltip) {\n        this.xaxisTooltip.classList.remove('active');\n      }\n\n      if (this.blyaxisTooltip) {\n        if (this.yaxisTTEls === null) {\n          this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');\n        }\n\n        for (var i = 0; i < this.yaxisTTEls.length; i++) {\n          this.yaxisTTEls[i].classList.remove('active');\n        }\n      }\n    }\n  }, {\n    key: \"getElMarkers\",\n    value: function getElMarkers() {\n      return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers');\n    }\n  }, {\n    key: \"getAllMarkers\",\n    value: function getAllMarkers() {\n      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');\n    }\n  }, {\n    key: \"hasMarkers\",\n    value: function hasMarkers() {\n      var markers = this.getElMarkers();\n      return markers.length > 0;\n    }\n  }, {\n    key: \"getElBars\",\n    value: function getElBars() {\n      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series');\n    }\n  }, {\n    key: \"hasBars\",\n    value: function hasBars() {\n      var bars = this.getElBars();\n      return bars.length > 0;\n    }\n  }, {\n    key: \"create\",\n    value: function create(context, capturedSeries, j, ttItems) {\n      var shared = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var w = this.w;\n      var self = context;\n      if (shared === null) shared = w.config.tooltip.shared;\n      var hasMarkers = this.hasMarkers();\n      var bars = this.getElBars();\n\n      if (shared) {\n        self.tooltipLabels.drawSeriesTexts({\n          ttItems: ttItems,\n          i: capturedSeries,\n          j: j,\n          shared: this.showOnIntersect ? false : w.config.tooltip.shared\n        });\n\n        if (hasMarkers) {\n          if (w.globals.markers.largestSize > 0) {\n            self.marker.enlargePoints(j);\n          } else {\n            self.tooltipPosition.moveDynamicPointsOnHover(j);\n          }\n        }\n\n        if (this.hasBars()) {\n          this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);\n\n          if (this.barSeriesHeight > 0) {\n            // hover state, activate snap filter\n            var graphics = new Graphics(this.ctx);\n            var paths = w.globals.dom.Paper.select(\".apexcharts-bar-area[j='\".concat(j, \"']\")); // de-activate first\n\n            this.deactivateHoverFilter();\n            this.tooltipPosition.moveStickyTooltipOverBars(j);\n\n            for (var b = 0; b < paths.length; b++) {\n              graphics.pathMouseEnter(paths[b]);\n            }\n          }\n        }\n      } else {\n        self.tooltipLabels.drawSeriesTexts({\n          shared: false,\n          ttItems: ttItems,\n          i: capturedSeries,\n          j: j\n        });\n\n        if (this.hasBars()) {\n          self.tooltipPosition.moveStickyTooltipOverBars(j);\n        }\n\n        if (hasMarkers) {\n          self.tooltipPosition.moveMarkers(capturedSeries, j);\n        }\n      }\n    }\n  }]);\n\n  return Tooltip;\n}();\n\nvar icoPan = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <defs>\\n        <path d=\\\"M0 0h24v24H0z\\\" id=\\\"a\\\"/>\\n    </defs>\\n    <clipPath id=\\\"b\\\">\\n        <use overflow=\\\"visible\\\" xlink:href=\\\"#a\\\"/>\\n    </clipPath>\\n    <path clip-path=\\\"url(#b)\\\" d=\\\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\\\"/>\\n</svg>\";\n\nvar icoZoom = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\">\\n    <path d=\\\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\\\"/>\\n    <path d=\\\"M0 0h24v24H0V0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\\\"/>\\n</svg>\";\n\nvar icoReset = \"<svg fill=\\\"#000000\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\\\"/>\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n</svg>\";\n\nvar icoZoomIn = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\nvar icoZoomOut = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\\\"/>\\n</svg>\\n\";\n\nvar icoSelect = \"<svg fill=\\\"#6E8192\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M0 0h24v24H0z\\\" fill=\\\"none\\\"/>\\n    <path d=\\\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\\\"/>\\n</svg>\";\n\nvar icoMenu = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path fill=\\\"none\\\" d=\\\"M0 0h24v24H0V0z\\\"/><path d=\\\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\\\"/></svg>\";\n\n/**\n * ApexCharts Toolbar Class for creating toolbar in axis based charts.\n *\n * @module Toolbar\n **/\n\nvar Toolbar =\n/*#__PURE__*/\nfunction () {\n  function Toolbar(ctx) {\n    _classCallCheck(this, Toolbar);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n    this.ev = this.w.config.chart.events;\n    this.localeValues = this.w.globals.locale.toolbar;\n  }\n\n  _createClass(Toolbar, [{\n    key: \"createToolbar\",\n    value: function createToolbar() {\n      var w = this.w;\n      var elToolbarWrap = document.createElement('div');\n      elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');\n      w.globals.dom.elWrap.appendChild(elToolbarWrap);\n      this.elZoom = document.createElement('div');\n      this.elZoomIn = document.createElement('div');\n      this.elZoomOut = document.createElement('div');\n      this.elPan = document.createElement('div');\n      this.elSelection = document.createElement('div');\n      this.elZoomReset = document.createElement('div');\n      this.elMenuIcon = document.createElement('div');\n      this.elMenu = document.createElement('div');\n      this.elCustomIcons = [];\n      this.t = w.config.chart.toolbar.tools;\n\n      if (Array.isArray(this.t.customIcons)) {\n        for (var i = 0; i < this.t.customIcons.length; i++) {\n          this.elCustomIcons.push(document.createElement('div'));\n        }\n      }\n\n      this.elMenuItems = [];\n      var toolbarControls = [];\n\n      if (this.t.zoomin && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomIn,\n          icon: typeof this.t.zoomin === 'string' ? this.t.zoomin : icoZoomIn,\n          title: this.localeValues.zoomIn,\n          class: 'apexcharts-zoom-in-icon'\n        });\n      }\n\n      if (this.t.zoomout && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomOut,\n          icon: typeof this.t.zoomout === 'string' ? this.t.zoomout : icoZoomOut,\n          title: this.localeValues.zoomOut,\n          class: 'apexcharts-zoom-out-icon'\n        });\n      }\n\n      if (this.t.zoom && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoom,\n          icon: typeof this.t.zoom === 'string' ? this.t.zoom : icoZoom,\n          title: this.localeValues.selectionZoom,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-zoom-icon'\n        });\n      }\n\n      if (this.t.selection && w.config.chart.selection.enabled) {\n        toolbarControls.push({\n          el: this.elSelection,\n          icon: typeof this.t.selection === 'string' ? this.t.selection : icoSelect,\n          title: this.localeValues.selection,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-selection-icon'\n        });\n      }\n\n      if (this.t.pan && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elPan,\n          icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,\n          title: this.localeValues.pan,\n          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-pan-icon'\n        });\n      }\n\n      if (this.t.reset && w.config.chart.zoom.enabled) {\n        toolbarControls.push({\n          el: this.elZoomReset,\n          icon: typeof this.t.reset === 'string' ? this.t.reset : icoReset,\n          title: this.localeValues.reset,\n          class: 'apexcharts-reset-zoom-icon'\n        });\n      }\n\n      if (this.t.download) {\n        toolbarControls.push({\n          el: this.elMenuIcon,\n          icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,\n          title: this.localeValues.menu,\n          class: 'apexcharts-menu-icon'\n        });\n      }\n\n      for (var _i = 0; _i < this.elCustomIcons.length; _i++) {\n        toolbarControls.push({\n          el: this.elCustomIcons[_i],\n          icon: this.t.customIcons[_i].icon,\n          title: this.t.customIcons[_i].title,\n          index: this.t.customIcons[_i].index,\n          class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class\n        });\n      }\n\n      toolbarControls.forEach(function (t, index) {\n        if (t.index) {\n          Utils.moveIndexInArray(toolbarControls, index, t.index);\n        }\n      });\n\n      for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {\n        Graphics.setAttrs(toolbarControls[_i2].el, {\n          class: toolbarControls[_i2].class,\n          title: toolbarControls[_i2].title\n        });\n        toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;\n        elToolbarWrap.appendChild(toolbarControls[_i2].el);\n      }\n\n      elToolbarWrap.appendChild(this.elMenu);\n      Graphics.setAttrs(this.elMenu, {\n        class: 'apexcharts-menu'\n      });\n      var menuItems = [{\n        name: 'exportSVG',\n        title: this.localeValues.exportToSVG\n      }, {\n        name: 'exportPNG',\n        title: this.localeValues.exportToPNG\n      }];\n\n      for (var _i3 = 0; _i3 < menuItems.length; _i3++) {\n        this.elMenuItems.push(document.createElement('div'));\n        this.elMenuItems[_i3].innerHTML = menuItems[_i3].title;\n        Graphics.setAttrs(this.elMenuItems[_i3], {\n          class: \"apexcharts-menu-item \".concat(menuItems[_i3].name),\n          title: menuItems[_i3].title\n        });\n        this.elMenu.appendChild(this.elMenuItems[_i3]);\n      }\n\n      if (w.globals.zoomEnabled) {\n        this.elZoom.classList.add('selected');\n      } else if (w.globals.panEnabled) {\n        this.elPan.classList.add('selected');\n      } else if (w.globals.selectionEnabled) {\n        this.elSelection.classList.add('selected');\n      }\n\n      this.addToolbarEventListeners();\n    }\n  }, {\n    key: \"addToolbarEventListeners\",\n    value: function addToolbarEventListeners() {\n      var _this = this;\n\n      this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));\n      this.elSelection.addEventListener('click', this.toggleSelection.bind(this));\n      this.elZoom.addEventListener('click', this.toggleZooming.bind(this));\n      this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));\n      this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));\n      this.elPan.addEventListener('click', this.togglePanning.bind(this));\n      this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));\n      this.elMenuItems.forEach(function (m) {\n        if (m.classList.contains('exportSVG')) {\n          m.addEventListener('click', _this.downloadSVG.bind(_this));\n        } else if (m.classList.contains('exportPNG')) {\n          m.addEventListener('click', _this.downloadPNG.bind(_this));\n        }\n      });\n\n      for (var i = 0; i < this.t.customIcons.length; i++) {\n        this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click);\n      }\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection() {\n      this.toggleOtherControls();\n      this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled;\n\n      if (!this.elSelection.classList.contains('selected')) {\n        this.elSelection.classList.add('selected');\n      } else {\n        this.elSelection.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"toggleZooming\",\n    value: function toggleZooming() {\n      this.toggleOtherControls();\n      this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled;\n\n      if (!this.elZoom.classList.contains('selected')) {\n        this.elZoom.classList.add('selected');\n      } else {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"getToolbarIconsReference\",\n    value: function getToolbarIconsReference() {\n      var w = this.w;\n\n      if (!this.elZoom) {\n        this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');\n      }\n\n      if (!this.elPan) {\n        this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');\n      }\n\n      if (!this.elSelection) {\n        this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');\n      }\n    }\n  }, {\n    key: \"enableZooming\",\n    value: function enableZooming() {\n      this.toggleOtherControls();\n      this.w.globals.zoomEnabled = true;\n\n      if (this.elZoom) {\n        this.elZoom.classList.add('selected');\n      }\n\n      if (this.elPan) {\n        this.elPan.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"enablePanning\",\n    value: function enablePanning() {\n      this.toggleOtherControls();\n      this.w.globals.panEnabled = true;\n\n      if (this.elPan) {\n        this.elPan.classList.add('selected');\n      }\n\n      if (this.elZoom) {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"togglePanning\",\n    value: function togglePanning() {\n      this.toggleOtherControls();\n      this.w.globals.panEnabled = !this.w.globals.panEnabled;\n\n      if (!this.elPan.classList.contains('selected')) {\n        this.elPan.classList.add('selected');\n      } else {\n        this.elPan.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"toggleOtherControls\",\n    value: function toggleOtherControls() {\n      var w = this.w;\n      w.globals.panEnabled = false;\n      w.globals.zoomEnabled = false;\n      w.globals.selectionEnabled = false;\n      this.getToolbarIconsReference();\n\n      if (this.elPan) {\n        this.elPan.classList.remove('selected');\n      }\n\n      if (this.elSelection) {\n        this.elSelection.classList.remove('selected');\n      }\n\n      if (this.elZoom) {\n        this.elZoom.classList.remove('selected');\n      }\n    }\n  }, {\n    key: \"handleZoomIn\",\n    value: function handleZoomIn() {\n      var w = this.w;\n      var centerX = (w.globals.minX + w.globals.maxX) / 2;\n      var newMinX = (w.globals.minX + centerX) / 2;\n      var newMaxX = (w.globals.maxX + centerX) / 2;\n\n      if (!w.globals.disableZoomIn) {\n        this.zoomUpdateOptions(newMinX, newMaxX);\n      }\n    }\n  }, {\n    key: \"handleZoomOut\",\n    value: function handleZoomOut() {\n      var w = this.w; // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis\n\n      if (w.config.xaxis.type === 'datetime' && new Date(w.globals.minX).getUTCFullYear() < 1000) {\n        return;\n      }\n\n      var centerX = (w.globals.minX + w.globals.maxX) / 2;\n      var newMinX = w.globals.minX - (centerX - w.globals.minX);\n      var newMaxX = w.globals.maxX - (centerX - w.globals.maxX);\n\n      if (!w.globals.disableZoomOut) {\n        this.zoomUpdateOptions(newMinX, newMaxX);\n      }\n    }\n  }, {\n    key: \"zoomUpdateOptions\",\n    value: function zoomUpdateOptions(newMinX, newMaxX) {\n      var xaxis = {\n        min: newMinX,\n        max: newMaxX\n      };\n      var beforeZoomRange = this.getBeforeZoomRange(xaxis);\n\n      if (beforeZoomRange) {\n        xaxis = beforeZoomRange.xaxis;\n      }\n\n      this.w.globals.zoomed = true;\n\n      this.ctx._updateOptions({\n        xaxis: xaxis\n      }, false, this.w.config.chart.animations.dynamicAnimation.enabled);\n\n      this.zoomCallback(xaxis);\n    }\n  }, {\n    key: \"zoomCallback\",\n    value: function zoomCallback(xaxis, yaxis) {\n      if (typeof this.ev.zoomed === 'function') {\n        this.ev.zoomed(this.ctx, {\n          xaxis: xaxis,\n          yaxis: yaxis\n        });\n      }\n    }\n  }, {\n    key: \"getBeforeZoomRange\",\n    value: function getBeforeZoomRange(xaxis, yaxis) {\n      var newRange = null;\n\n      if (typeof this.ev.beforeZoom === 'function') {\n        newRange = this.ev.beforeZoom(this, {\n          xaxis: xaxis,\n          yaxis: yaxis\n        });\n      }\n\n      return newRange;\n    }\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu() {\n      if (this.elMenu.classList.contains('open')) {\n        this.elMenu.classList.remove('open');\n      } else {\n        this.elMenu.classList.add('open');\n      }\n    }\n  }, {\n    key: \"downloadPNG\",\n    value: function downloadPNG() {\n      var downloadPNG = new Exports(this.ctx);\n      downloadPNG.exportToPng(this.ctx);\n      this.toggleMenu();\n    }\n  }, {\n    key: \"downloadSVG\",\n    value: function downloadSVG() {\n      var downloadSVG = new Exports(this.ctx);\n      downloadSVG.exportToSVG();\n      this.toggleMenu();\n    }\n  }, {\n    key: \"handleZoomReset\",\n    value: function handleZoomReset(e) {\n      var _this2 = this;\n\n      var charts = this.ctx.getSyncedCharts();\n      charts.forEach(function (ch) {\n        var w = ch.w;\n\n        if (w.globals.minX !== w.globals.initialminX && w.globals.maxX !== w.globals.initialmaxX) {\n          ch.revertDefaultAxisMinMax();\n\n          if (typeof w.config.chart.events.zoomed === 'function') {\n            _this2.zoomCallback({\n              min: w.config.xaxis.min,\n              max: w.config.xaxis.max\n            });\n          }\n\n          w.globals.zoomed = false;\n\n          ch._updateSeries(w.globals.initialSeries, w.config.chart.animations.dynamicAnimation.enabled);\n        }\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.elZoomReset) {\n        this.elZoomReset.removeEventListener('click', this.handleZoomReset.bind(this));\n        this.elSelection.removeEventListener('click', this.toggleSelection.bind(this));\n        this.elZoom.removeEventListener('click', this.toggleZooming.bind(this));\n        this.elZoomIn.removeEventListener('click', this.handleZoomIn.bind(this));\n        this.elZoomOut.removeEventListener('click', this.handleZoomOut.bind(this));\n        this.elPan.removeEventListener('click', this.togglePanning.bind(this));\n        this.elMenuIcon.removeEventListener('click', this.toggleMenu.bind(this));\n      }\n\n      this.elZoom = null;\n      this.elZoomIn = null;\n      this.elZoomOut = null;\n      this.elPan = null;\n      this.elSelection = null;\n      this.elZoomReset = null;\n      this.elMenuIcon = null;\n    }\n  }]);\n\n  return Toolbar;\n}();\n\n/**\n * ApexCharts Zoom Class for handling zooming and panning on axes based charts.\n *\n * @module ZoomPanSelection\n **/\n\nvar ZoomPanSelection =\n/*#__PURE__*/\nfunction (_Toolbar) {\n  _inherits(ZoomPanSelection, _Toolbar);\n\n  function ZoomPanSelection(ctx) {\n    var _this;\n\n    _classCallCheck(this, ZoomPanSelection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZoomPanSelection).call(this, ctx));\n    _this.ctx = ctx;\n    _this.w = ctx.w;\n    _this.dragged = false;\n    _this.graphics = new Graphics(_this.ctx);\n    _this.eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];\n    _this.clientX = 0;\n    _this.clientY = 0;\n    _this.startX = 0;\n    _this.endX = 0;\n    _this.dragX = 0;\n    _this.startY = 0;\n    _this.endY = 0;\n    _this.dragY = 0;\n    return _this;\n  }\n\n  _createClass(ZoomPanSelection, [{\n    key: \"init\",\n    value: function init(_ref) {\n      var _this2 = this;\n\n      var xyRatios = _ref.xyRatios;\n      var w = this.w;\n      var me = this;\n      this.xyRatios = xyRatios;\n      this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);\n      this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);\n      this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');\n      this.zoomRect.node.classList.add('apexcharts-zoom-rect');\n      this.selectionRect.node.classList.add('apexcharts-selection-rect');\n      w.globals.dom.elGraphical.add(this.zoomRect);\n      w.globals.dom.elGraphical.add(this.selectionRect);\n\n      if (w.config.chart.selection.type === 'x') {\n        this.slDraggableRect = this.selectionRect.draggable({\n          minX: 0,\n          minY: 0,\n          maxX: w.globals.gridWidth,\n          maxY: w.globals.gridHeight\n        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      } else if (w.config.chart.selection.type === 'y') {\n        this.slDraggableRect = this.selectionRect.draggable({\n          minX: 0,\n          maxX: w.globals.gridWidth\n        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      } else {\n        this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging'));\n      }\n\n      this.preselectedSelection();\n      this.hoverArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);\n      this.hoverArea.classList.add('zoomable');\n      this.eventList.forEach(function (event) {\n        _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {\n          capture: false,\n          passive: true\n        });\n      });\n    } // remove the event listeners which were previously added on hover area\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n\n      var me = this;\n      this.eventList.forEach(function (event) {\n        if (_this3.hoverArea) {\n          _this3.hoverArea.removeEventListener(event, me.svgMouseEvents.bind(me, me.xyRatios), {\n            capture: false,\n            passive: true\n          });\n        }\n      });\n\n      if (this.slDraggableRect) {\n        this.slDraggableRect.draggable(false);\n        this.slDraggableRect.off();\n        this.selectionRect.off();\n      }\n\n      this.selectionRect = null;\n      this.zoomRect = null;\n      this.gridRect = null;\n    }\n  }, {\n    key: \"svgMouseEvents\",\n    value: function svgMouseEvents(xyRatios, e) {\n      var w = this.w;\n      var me = this;\n      var toolbar = this.ctx.toolbar;\n      var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;\n\n      if (e.shiftKey) {\n        this.shiftWasPressed = true;\n        toolbar.enablePanning();\n      } else {\n        if (this.shiftWasPressed) {\n          toolbar.enableZooming();\n          this.shiftWasPressed = false;\n        }\n      }\n\n      var falsePositives = e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar');\n      if (falsePositives) return;\n      me.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;\n      me.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;\n\n      if (e.type === 'mousedown' && e.which === 1) {\n        var gridRectDim = me.gridRect.getBoundingClientRect();\n        me.startX = me.clientX - gridRectDim.left;\n        me.startY = me.clientY - gridRectDim.top;\n        me.dragged = false;\n        me.w.globals.mousedown = true;\n      }\n\n      if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {\n        me.dragged = true;\n\n        if (w.globals.panEnabled) {\n          w.globals.selection = null;\n\n          if (me.w.globals.mousedown) {\n            me.panDragging({\n              context: me,\n              zoomtype: zoomtype,\n              xyRatios: xyRatios\n            });\n          }\n        } else {\n          if (me.w.globals.mousedown && w.globals.zoomEnabled || me.w.globals.mousedown && w.globals.selectionEnabled) {\n            me.selection = me.selectionDrawing({\n              context: me,\n              zoomtype: zoomtype\n            });\n          }\n        }\n      }\n\n      if (e.type === 'mouseup' || e.type === 'touchend') {\n        // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup\n        var _gridRectDim = me.gridRect.getBoundingClientRect();\n\n        if (me.w.globals.mousedown) {\n          // user released the drag, now do all the calculations\n          me.endX = me.clientX - _gridRectDim.left;\n          me.endY = me.clientY - _gridRectDim.top;\n          me.dragX = Math.abs(me.endX - me.startX);\n          me.dragY = Math.abs(me.endY - me.startY);\n\n          if (w.globals.zoomEnabled || w.globals.selectionEnabled) {\n            me.selectionDrawn({\n              context: me,\n              zoomtype: zoomtype\n            });\n          }\n        }\n\n        if (w.globals.zoomEnabled) {\n          me.hideSelectionRect(this.selectionRect);\n        }\n\n        me.dragged = false;\n        me.w.globals.mousedown = false;\n      }\n\n      this.makeSelectionRectDraggable();\n    }\n  }, {\n    key: \"makeSelectionRectDraggable\",\n    value: function makeSelectionRectDraggable() {\n      var w = this.w;\n      if (!this.selectionRect) return;\n      var rectDim = this.selectionRect.node.getBoundingClientRect();\n\n      if (rectDim.width > 0 && rectDim.height > 0) {\n        this.slDraggableRect.selectize().resize({\n          constraint: {\n            minX: 0,\n            minY: 0,\n            maxX: w.globals.gridWidth,\n            maxY: w.globals.gridHeight\n          }\n        }).on('resizing', this.selectionDragging.bind(this, 'resizing'));\n      }\n    }\n  }, {\n    key: \"preselectedSelection\",\n    value: function preselectedSelection() {\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n\n      if (!w.globals.zoomEnabled) {\n        if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {\n          this.drawSelectionRect(w.globals.selection);\n        } else {\n          if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {\n            var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;\n            var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;\n            var selectionRect = {\n              x: x,\n              y: 0,\n              width: width,\n              height: w.globals.gridHeight,\n              translateX: 0,\n              translateY: 0,\n              selectionEnabled: true\n            };\n            this.drawSelectionRect(selectionRect);\n            this.makeSelectionRectDraggable();\n\n            if (typeof w.config.chart.events.selection === 'function') {\n              w.config.chart.events.selection(this.ctx, {\n                xaxis: {\n                  min: w.config.chart.selection.xaxis.min,\n                  max: w.config.chart.selection.xaxis.max\n                },\n                yaxis: {}\n              });\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"drawSelectionRect\",\n    value: function drawSelectionRect(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y,\n          width = _ref2.width,\n          height = _ref2.height,\n          translateX = _ref2.translateX,\n          translateY = _ref2.translateY;\n      var w = this.w;\n      var zoomRect = this.zoomRect;\n      var selectionRect = this.selectionRect;\n\n      if (this.dragged || w.globals.selection !== null) {\n        var scalingAttrs = {\n          transform: 'translate(' + translateX + ', ' + translateY + ')' // change styles based on zoom or selection\n          // zoom is Enabled and user has dragged, so draw blue rect\n\n        };\n\n        if (w.globals.zoomEnabled && this.dragged) {\n          zoomRect.attr({\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            fill: w.config.chart.zoom.zoomedArea.fill.color,\n            'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,\n            stroke: w.config.chart.zoom.zoomedArea.stroke.color,\n            'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,\n            'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity\n          });\n          Graphics.setAttrs(zoomRect.node, scalingAttrs);\n        } // selection is enabled\n\n\n        if (w.globals.selectionEnabled) {\n          selectionRect.attr({\n            x: x,\n            y: y,\n            width: width > 0 ? width : 0,\n            height: height > 0 ? height : 0,\n            fill: w.config.chart.selection.fill.color,\n            'fill-opacity': w.config.chart.selection.fill.opacity,\n            stroke: w.config.chart.selection.stroke.color,\n            'stroke-width': w.config.chart.selection.stroke.width,\n            'stroke-dasharray': w.config.chart.selection.stroke.dashArray,\n            'stroke-opacity': w.config.chart.selection.stroke.opacity\n          });\n          Graphics.setAttrs(selectionRect.node, scalingAttrs);\n        }\n      }\n    }\n  }, {\n    key: \"hideSelectionRect\",\n    value: function hideSelectionRect(rect) {\n      if (rect) {\n        rect.attr({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        });\n      }\n    }\n  }, {\n    key: \"selectionDrawing\",\n    value: function selectionDrawing(_ref3) {\n      var context = _ref3.context,\n          zoomtype = _ref3.zoomtype;\n      var w = this.w;\n      var me = context;\n      var gridRectDim = this.gridRect.getBoundingClientRect();\n      var startX = me.startX - 1;\n      var startY = me.startY;\n      var selectionWidth = me.clientX - gridRectDim.left - startX;\n      var selectionHeight = me.clientY - gridRectDim.top - startY;\n      var translateX = 0;\n      var translateY = 0;\n      var selectionRect = {};\n\n      if (Math.abs(selectionWidth + startX) > w.globals.gridWidth || me.clientX - gridRectDim.left < 0) {\n        // user dragged the mouse outside drawing area\n        // TODO: test the selectionRect and make sure it doesn't crosses drawing area\n        me.hideSelectionRect(this.zoomRect);\n        me.dragged = false;\n        me.w.globals.mousedown = false;\n      } // inverse selection X\n\n\n      if (startX > me.clientX - gridRectDim.left) {\n        selectionWidth = Math.abs(selectionWidth);\n        translateX = -selectionWidth;\n      } // inverse selection Y\n\n\n      if (startY > me.clientY - gridRectDim.top) {\n        selectionHeight = Math.abs(selectionHeight);\n        translateY = -selectionHeight;\n      }\n\n      if (zoomtype === 'x') {\n        selectionRect = {\n          x: startX,\n          y: 0,\n          width: selectionWidth,\n          height: w.globals.gridHeight,\n          translateX: translateX,\n          translateY: 0\n        };\n      } else if (zoomtype === 'y') {\n        selectionRect = {\n          x: 0,\n          y: startY,\n          width: w.globals.gridWidth,\n          height: selectionHeight,\n          translateX: 0,\n          translateY: translateY\n        };\n      } else {\n        selectionRect = {\n          x: startX,\n          y: startY,\n          width: selectionWidth,\n          height: selectionHeight,\n          translateX: translateX,\n          translateY: translateY\n        };\n      }\n\n      me.drawSelectionRect(selectionRect);\n      return selectionRect;\n    }\n  }, {\n    key: \"selectionDragging\",\n    value: function selectionDragging(type, e) {\n      var _this4 = this;\n\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n      var selRect = this.selectionRect;\n      var timerInterval = 0;\n\n      if (type === 'resizing') {\n        timerInterval = 30;\n      }\n\n      if (typeof w.config.chart.events.selection === 'function') {\n        // a small debouncer is required when resizing to avoid freezing the chart\n        clearTimeout(this.w.globals.selectionResizeTimer);\n        this.w.globals.selectionResizeTimer = window.setTimeout(function () {\n          var gridRectDim = _this4.gridRect.getBoundingClientRect();\n\n          var selectionRect = selRect.node.getBoundingClientRect();\n          var minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;\n          var maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;\n          var minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];\n          var maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];\n          w.config.chart.events.selection(_this4.ctx, {\n            xaxis: {\n              min: minX,\n              max: maxX\n            },\n            yaxis: {\n              min: minY,\n              max: maxY\n            }\n          });\n        }, timerInterval);\n      }\n    }\n  }, {\n    key: \"selectionDrawn\",\n    value: function selectionDrawn(_ref4) {\n      var context = _ref4.context,\n          zoomtype = _ref4.zoomtype;\n      var w = this.w;\n      var me = context;\n      var xyRatios = this.xyRatios;\n      var toolbar = this.ctx.toolbar;\n\n      if (me.startX > me.endX) {\n        var tempX = me.startX;\n        me.startX = me.endX;\n        me.endX = tempX;\n      }\n\n      if (me.startY > me.endY) {\n        var tempY = me.startY;\n        me.startY = me.endY;\n        me.endY = tempY;\n      }\n\n      var xLowestValue = w.globals.xAxisScale.niceMin + me.startX * xyRatios.xRatio;\n      var xHighestValue = w.globals.xAxisScale.niceMin + me.endX * xyRatios.xRatio; // TODO: we will consider the 1st y axis values here for getting highest and lowest y\n\n      var yHighestValue = [];\n      var yLowestValue = [];\n      w.config.yaxis.forEach(function (yaxe, index) {\n        yHighestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.startY));\n        yLowestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.endY));\n      });\n\n      if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {\n        if (w.globals.zoomEnabled) {\n          var yaxis = Utils.clone(w.config.yaxis); // before zooming in/out, store the last yaxis and xaxis range, so that when user hits the RESET button, we get the original range\n          // also - make sure user is not already zoomed in/out - otherwise we will store zoomed values in lastAxis\n\n          if (!w.globals.zoomed) {\n            w.globals.lastXAxis = Utils.clone(w.config.xaxis);\n            w.globals.lastYAxis = Utils.clone(w.config.yaxis);\n          }\n\n          var xaxis = {\n            min: xLowestValue,\n            max: xHighestValue\n          };\n\n          if (zoomtype === 'xy' || zoomtype === 'y') {\n            yaxis.forEach(function (yaxe, index) {\n              yaxis[index].min = yLowestValue[index];\n              yaxis[index].max = yHighestValue[index];\n            });\n          }\n\n          if (w.config.chart.zoom.autoScaleYaxis) {\n            var scale = new Range(me.ctx);\n            yaxis = scale.autoScaleY(me.ctx, {\n              xaxis: xaxis\n            });\n          }\n\n          if (toolbar) {\n            var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);\n\n            if (beforeZoomRange) {\n              xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;\n              yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxe : yaxis;\n            }\n          }\n\n          if (zoomtype === 'x') {\n            me.ctx._updateOptions({\n              xaxis: xaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          } else if (zoomtype === 'y') {\n            me.ctx._updateOptions({\n              yaxis: yaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          } else {\n            me.ctx._updateOptions({\n              xaxis: xaxis,\n              yaxis: yaxis\n            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);\n          }\n\n          if (typeof w.config.chart.events.zoomed === 'function') {\n            toolbar.zoomCallback(xaxis, yaxis);\n          }\n\n          w.globals.zoomed = true;\n        } else if (w.globals.selectionEnabled) {\n          var _yaxis = null;\n          var _xaxis = null;\n          _xaxis = {\n            min: xLowestValue,\n            max: xHighestValue\n          };\n\n          if (zoomtype === 'xy' || zoomtype === 'y') {\n            _yaxis = Utils.clone(w.config.yaxis);\n\n            _yaxis.forEach(function (yaxe, index) {\n              _yaxis[index].min = yLowestValue[index];\n              _yaxis[index].max = yHighestValue[index];\n            });\n          }\n\n          w.globals.selection = me.selection;\n\n          if (typeof w.config.chart.events.selection === 'function') {\n            w.config.chart.events.selection(me.ctx, {\n              xaxis: _xaxis,\n              yaxis: _yaxis\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"panDragging\",\n    value: function panDragging(_ref5) {\n      var context = _ref5.context,\n          zoomtype = _ref5.zoomtype;\n      var w = this.w;\n      var me = context;\n      var moveDirection; // check to make sure there is data to compare against\n\n      if (typeof w.globals.lastClientPosition.x !== 'undefined') {\n        // get the change from last position to this position\n        var deltaX = w.globals.lastClientPosition.x - me.clientX;\n        var deltaY = w.globals.lastClientPosition.y - me.clientY; // check which direction had the highest amplitude and then figure out direction by checking if the value is greater or less than zero\n\n        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {\n          moveDirection = 'left';\n        } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {\n          moveDirection = 'right';\n        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {\n          moveDirection = 'up';\n        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {\n          moveDirection = 'down';\n        }\n      } // set the new last position to the current for next time (to get the position of drag)\n\n\n      w.globals.lastClientPosition = {\n        x: me.clientX,\n        y: me.clientY\n      };\n      var xLowestValue = w.globals.minX;\n      var xHighestValue = w.globals.maxX;\n      this.panScrolled(moveDirection, xLowestValue, xHighestValue);\n    }\n  }, {\n    key: \"panScrolled\",\n    value: function panScrolled(moveDirection, xLowestValue, xHighestValue) {\n      var w = this.w;\n      var xyRatios = this.xyRatios;\n      var yaxis = Utils.clone(w.config.yaxis);\n\n      if (moveDirection === 'left') {\n        xLowestValue = w.globals.minX + w.globals.gridWidth / 15 * xyRatios.xRatio;\n        xHighestValue = w.globals.maxX + w.globals.gridWidth / 15 * xyRatios.xRatio;\n      } else if (moveDirection === 'right') {\n        xLowestValue = w.globals.minX - w.globals.gridWidth / 15 * xyRatios.xRatio;\n        xHighestValue = w.globals.maxX - w.globals.gridWidth / 15 * xyRatios.xRatio;\n      }\n\n      if (xLowestValue < w.globals.initialminX || xHighestValue > w.globals.initialmaxX) {\n        xLowestValue = w.globals.minX;\n        xHighestValue = w.globals.maxX;\n      }\n\n      var xaxis = {\n        min: xLowestValue,\n        max: xHighestValue\n      };\n\n      if (w.config.chart.zoom.autoScaleYaxis) {\n        var scale = new Range(me.ctx);\n        yaxis = scale.autoScaleY(me.ctx, {\n          xaxis: xaxis\n        });\n      }\n\n      this.ctx._updateOptions({\n        xaxis: {\n          min: xLowestValue,\n          max: xHighestValue\n        },\n        yaxis: yaxis\n      }, false, false);\n\n      if (typeof w.config.chart.events.scrolled === 'function') {\n        w.config.chart.events.scrolled(this.ctx, {\n          xaxis: {\n            min: xLowestValue,\n            max: xHighestValue\n          }\n        });\n      }\n    }\n  }]);\n\n  return ZoomPanSelection;\n}(Toolbar);\n\nvar TitleSubtitle =\n/*#__PURE__*/\nfunction () {\n  function TitleSubtitle(ctx) {\n    _classCallCheck(this, TitleSubtitle);\n\n    this.ctx = ctx;\n    this.w = ctx.w;\n  }\n\n  _createClass(TitleSubtitle, [{\n    key: \"draw\",\n    value: function draw() {\n      this.drawTitleSubtitle('title');\n      this.drawTitleSubtitle('subtitle');\n    }\n  }, {\n    key: \"drawTitleSubtitle\",\n    value: function drawTitleSubtitle(type) {\n      var w = this.w;\n      var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;\n      var x = w.globals.svgWidth / 2;\n      var y = tsConfig.offsetY;\n      var textAnchor = 'middle';\n\n      if (tsConfig.align === 'left') {\n        x = 10;\n        textAnchor = 'start';\n      } else if (tsConfig.align === 'right') {\n        x = w.globals.svgWidth - 10;\n        textAnchor = 'end';\n      }\n\n      x = x + tsConfig.offsetX;\n      y = y + parseInt(tsConfig.style.fontSize) + 2;\n\n      if (tsConfig.text !== undefined) {\n        var graphics = new Graphics(this.ctx);\n        var titleText = graphics.drawText({\n          x: x,\n          y: y,\n          text: tsConfig.text,\n          textAnchor: textAnchor,\n          fontSize: tsConfig.style.fontSize,\n          fontFamily: tsConfig.style.fontFamily,\n          foreColor: tsConfig.style.color,\n          opacity: 1\n        });\n        titleText.node.setAttribute('class', \"apexcharts-\".concat(type, \"-text\"));\n        w.globals.dom.Paper.add(titleText);\n      }\n    }\n  }]);\n\n  return TitleSubtitle;\n}();\n\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    define(function () {\n      return factory(root, root.document);\n    });\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    module.exports = root.document ? factory(root, root.document) : function (w) {\n      return factory(w, w.document);\n    };\n  } else {\n    root.SVG = factory(root, root.document);\n  }\n})(typeof window !== 'undefined' ? window : undefined, function (window, document) {\n  // Find global reference - uses 'this' by default when available,\n  // falls back to 'window' otherwise (for bundlers like Webpack)\n  var globalRef = typeof this !== 'undefined' ? this : window; // The main wrapping element\n\n  var SVG = globalRef.SVG = function (element) {\n    if (SVG.supported) {\n      element = new SVG.Doc(element);\n\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      return element;\n    }\n  }; // Default namespaces\n\n\n  SVG.ns = 'http://www.w3.org/2000/svg';\n  SVG.xmlns = 'http://www.w3.org/2000/xmlns/';\n  SVG.xlink = 'http://www.w3.org/1999/xlink';\n  SVG.svgjs = 'http://svgjs.com/svgjs'; // Svg support test\n\n  SVG.supported = function () {\n    return true; // !!document.createElementNS &&\n    //     !! document.createElementNS(SVG.ns,'svg').createSVGRect\n  }(); // Don't bother to continue if SVG is not supported\n\n\n  if (!SVG.supported) return false; // Element id sequence\n\n  SVG.did = 1000; // Get next named element id\n\n  SVG.eid = function (name) {\n    return 'Svgjs' + capitalize(name) + SVG.did++;\n  }; // Method for element creation\n\n\n  SVG.create = function (name) {\n    // create element\n    var element = document.createElementNS(this.ns, name); // apply unique id\n\n    element.setAttribute('id', this.eid(name));\n    return element;\n  }; // Method for extending objects\n\n\n  SVG.extend = function () {\n    var modules, methods, key, i; // Get list of modules\n\n    modules = [].slice.call(arguments); // Get object with extensions\n\n    methods = modules.pop();\n\n    for (i = modules.length - 1; i >= 0; i--) {\n      if (modules[i]) {\n        for (key in methods) {\n          modules[i].prototype[key] = methods[key];\n        }\n      }\n    } // Make sure SVG.Set inherits any newly added methods\n\n\n    if (SVG.Set && SVG.Set.inherit) {\n      SVG.Set.inherit();\n    }\n  }; // Invent new element\n\n\n  SVG.invent = function (config) {\n    // Create element initializer\n    var initializer = typeof config.create === 'function' ? config.create : function () {\n      this.constructor.call(this, SVG.create(config.create));\n    }; // Inherit prototype\n\n    if (config.inherit) {\n      initializer.prototype = new config.inherit();\n    } // Extend with methods\n\n\n    if (config.extend) {\n      SVG.extend(initializer, config.extend);\n    } // Attach construct method to parent\n\n\n    if (config.construct) {\n      SVG.extend(config.parent || SVG.Container, config.construct);\n    }\n\n    return initializer;\n  }; // Adopt existing svg elements\n\n\n  SVG.adopt = function (node) {\n    // check for presence of node\n    if (!node) return null; // make sure a node isn't already adopted\n\n    if (node.instance) return node.instance; // initialize variables\n\n    var element; // adopt with element-specific settings\n\n    if (node.nodeName == 'svg') {\n      element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();\n    } else if (node.nodeName == 'linearGradient') {\n      element = new SVG.Gradient('linear');\n    } else if (node.nodeName == 'radialGradient') {\n      element = new SVG.Gradient('radial');\n    } else if (SVG[capitalize(node.nodeName)]) {\n      element = new SVG[capitalize(node.nodeName)]();\n    } else {\n      element = new SVG.Element(node);\n    } // ensure references\n\n\n    element.type = node.nodeName;\n    element.node = node;\n    node.instance = element; // SVG.Class specific preparations\n\n    if (element instanceof SVG.Doc) {\n      element.namespace().defs();\n    } // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n\n\n    element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n    return element;\n  }; // Initialize parsing element\n\n\n  SVG.prepare = function () {\n    // Select document body and create invisible svg element\n    var body = document.getElementsByTagName('body')[0],\n        draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object\n\n    SVG.parser = {\n      body: body || document.documentElement,\n      draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node,\n      poly: draw.polyline().node,\n      path: draw.path().node,\n      native: SVG.create('svg')\n    };\n  };\n\n  SVG.parser = {\n    native: SVG.create('svg')\n  };\n  document.addEventListener('DOMContentLoaded', function () {\n    if (!SVG.parser.draw) {\n      SVG.prepare();\n    }\n  }, false); // Storage for regular expressions\n\n  SVG.regex = {\n    // Parse unit value\n    numberAndUnit: /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i,\n    // Parse hex value\n    hex: /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n    // Parse rgb value\n    rgb: /rgb\\((\\d+),(\\d+),(\\d+)\\)/,\n    // Parse reference id\n    reference: /#([a-z0-9\\-_]+)/i,\n    // splits a transformation chain\n    transforms: /\\)\\s*,?\\s*/,\n    // Whitespace\n    whitespace: /\\s/g,\n    // Test hex value\n    isHex: /^#[a-f0-9]{3,6}$/i,\n    // Test rgb value\n    isRgb: /^rgb\\(/,\n    // Test css declaration\n    isCss: /[^:]+:[^;]+;?/,\n    // Test for blank string\n    isBlank: /^(\\s+)?$/,\n    // Test for numeric string\n    isNumber: /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n    // Test for percent value\n    isPercent: /^-?[\\d\\.]+%$/,\n    // Test for image url\n    isImage: /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i,\n    // split at whitespace and comma\n    delimiter: /[\\s,]+/,\n    // The following regex are used to parse the d attribute of a path\n    // Matches all hyphens which are not after an exponent\n    hyphen: /([^e])\\-/gi,\n    // Replaces and tests for all path letters\n    pathLetters: /[MLHVCSQTAZ]/gi,\n    // yes we need this one, too\n    isPathLetter: /[MLHVCSQTAZ]/i,\n    // matches 0.154.23.45\n    numbersWithDots: /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi,\n    // matches .\n    dots: /\\./g\n  };\n  SVG.utils = {\n    // Map function\n    map: function map(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        result.push(block(array[i]));\n      }\n\n      return result;\n    },\n    // Filter function\n    filter: function filter(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        if (block(array[i])) {\n          result.push(array[i]);\n        }\n      }\n\n      return result;\n    },\n    // Degrees to radians\n    radians: function radians(d) {\n      return d % 360 * Math.PI / 180;\n    },\n    // Radians to degrees\n    degrees: function degrees(r) {\n      return r * 180 / Math.PI % 360;\n    },\n    filterSVGElements: function filterSVGElements(nodes) {\n      return this.filter(nodes, function (el) {\n        return el instanceof window.SVGElement;\n      });\n    }\n  };\n  SVG.defaults = {\n    // Default attribute values\n    attrs: {\n      // fill and stroke\n      'fill-opacity': 1,\n      'stroke-opacity': 1,\n      'stroke-width': 0,\n      'stroke-linejoin': 'miter',\n      'stroke-linecap': 'butt',\n      fill: '#000000',\n      stroke: '#000000',\n      opacity: 1,\n      // position\n      x: 0,\n      y: 0,\n      cx: 0,\n      cy: 0,\n      // size\n      width: 0,\n      height: 0,\n      // radius\n      r: 0,\n      rx: 0,\n      ry: 0,\n      // gradient\n      offset: 0,\n      'stop-opacity': 1,\n      'stop-color': '#000000',\n      // text\n      'font-size': 16,\n      'font-family': 'Helvetica, Arial, sans-serif',\n      'text-anchor': 'start'\n    } // Module for color convertions\n\n  };\n\n  SVG.Color = function (color) {\n    var match; // initialize defaults\n\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    if (!color) return; // parse color\n\n    if (typeof color === 'string') {\n      if (SVG.regex.isRgb.test(color)) {\n        // get rgb values\n        match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values\n\n        this.r = parseInt(match[1]);\n        this.g = parseInt(match[2]);\n        this.b = parseInt(match[3]);\n      } else if (SVG.regex.isHex.test(color)) {\n        // get hex values\n        match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values\n\n        this.r = parseInt(match[1], 16);\n        this.g = parseInt(match[2], 16);\n        this.b = parseInt(match[3], 16);\n      }\n    } else if (_typeof(color) === 'object') {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n    }\n  };\n\n  SVG.extend(SVG.Color, {\n    // Default to hex conversion\n    toString: function toString() {\n      return this.toHex();\n    },\n    // Build hex value\n    toHex: function toHex() {\n      return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);\n    },\n    // Build rgb value\n    toRgb: function toRgb() {\n      return 'rgb(' + [this.r, this.g, this.b].join() + ')';\n    },\n    // Calculate true brightness\n    brightness: function brightness() {\n      return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;\n    },\n    // Make color morphable\n    morph: function morph(color) {\n      this.destination = new SVG.Color(color);\n      return this;\n    },\n    // Get morphed color at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // normalise pos\n\n      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color\n\n      return new SVG.Color({\n        r: ~~(this.r + (this.destination.r - this.r) * pos),\n        g: ~~(this.g + (this.destination.g - this.g) * pos),\n        b: ~~(this.b + (this.destination.b - this.b) * pos)\n      });\n    }\n  }); // Testers\n  // Test if given value is a color string\n\n  SVG.Color.test = function (color) {\n    color += '';\n    return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);\n  }; // Test if given value is a rgb object\n\n\n  SVG.Color.isRgb = function (color) {\n    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n  }; // Test if given value is a color\n\n\n  SVG.Color.isColor = function (color) {\n    return SVG.Color.isRgb(color) || SVG.Color.test(color);\n  }; // Module for array conversion\n\n\n  SVG.Array = function (array, fallback) {\n    array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback\n\n    if (array.length == 0 && fallback) {\n      array = fallback.valueOf();\n    } // parse array\n\n\n    this.value = this.parse(array);\n  };\n\n  SVG.extend(SVG.Array, {\n    // Make array morphable\n    morph: function morph(array) {\n      this.destination = this.parse(array); // normalize length of arrays\n\n      if (this.value.length != this.destination.length) {\n        var lastValue = this.value[this.value.length - 1],\n            lastDestination = this.destination[this.destination.length - 1];\n\n        while (this.value.length > this.destination.length) {\n          this.destination.push(lastDestination);\n        }\n\n        while (this.value.length < this.destination.length) {\n          this.value.push(lastValue);\n        }\n      }\n\n      return this;\n    },\n    // Clean up any duplicate points\n    settle: function settle() {\n      // find all unique values\n      for (var i = 0, il = this.value.length, seen = []; i < il; i++) {\n        if (seen.indexOf(this.value[i]) == -1) {\n          seen.push(this.value[i]);\n        }\n      } // set new value\n\n\n      return this.value = seen;\n    },\n    // Get morphed array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed array\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos);\n      }\n\n      return new SVG.Array(array);\n    },\n    // Convert array to string\n    toString: function toString() {\n      return this.value.join(' ');\n    },\n    // Real value\n    valueOf: function valueOf() {\n      return this.value;\n    },\n    // Parse whitespace separated string\n    parse: function parse(array) {\n      array = array.valueOf(); // if already is an array, no need to parse it\n\n      if (Array.isArray(array)) return array;\n      return this.split(array);\n    },\n    // Strip unnecessary whitespace\n    split: function split(string) {\n      return string.trim().split(SVG.regex.delimiter).map(parseFloat);\n    },\n    // Reverse array\n    reverse: function reverse() {\n      this.value.reverse();\n      return this;\n    },\n    clone: function clone() {\n      var clone = new this.constructor();\n      clone.value = array_clone(this.value);\n      return clone;\n    }\n  }); // Poly points array\n\n  SVG.PointArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [[0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PointArray.prototype = new SVG.Array();\n  SVG.PointArray.prototype.constructor = SVG.PointArray;\n  SVG.extend(SVG.PointArray, {\n    // Convert array to string\n    toString: function toString() {\n      // convert to a poly point string\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i].join(','));\n      }\n\n      return array.join(' ');\n    },\n    // Convert array to line object\n    toLine: function toLine() {\n      return {\n        x1: this.value[0][0],\n        y1: this.value[0][1],\n        x2: this.value[1][0],\n        y2: this.value[1][1]\n      };\n    },\n    // Get morphed array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed point string\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);\n      }\n\n      return new SVG.PointArray(array);\n    },\n    // Parse point string and flat array\n    parse: function parse(array) {\n      var points = [];\n      array = array.valueOf(); // if it is an array\n\n      if (Array.isArray(array)) {\n        // and it is not flat, there is no need to parse it\n        if (Array.isArray(array[0])) {\n          // make sure to use a clone\n          return array.map(function (el) {\n            return el.slice();\n          });\n        } else if (array[0].x != null) {\n          // allow point objects to be passed\n          return array.map(function (el) {\n            return [el.x, el.y];\n          });\n        }\n      } else {\n        // Else, it is considered as a string\n        // parse points\n        array = array.trim().split(SVG.regex.delimiter).map(parseFloat);\n      } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n\n\n      if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples and parse points as floats\n\n      for (var i = 0, len = array.length; i < len; i = i + 2) {\n        points.push([array[i], array[i + 1]]);\n      }\n\n      return points;\n    },\n    // Move point string\n    move: function move(x, y) {\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y; // move every point\n\n      if (!isNaN(x) && !isNaN(y)) {\n        for (var i = this.value.length - 1; i >= 0; i--) {\n          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];\n        }\n      }\n\n      return this;\n    },\n    // Resize poly string\n    size: function size(width, height) {\n      var i,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        if (box.width) this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;\n        if (box.height) this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n      }\n\n      return this;\n    },\n    // Get bounding box of points\n    bbox: function bbox() {\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      SVG.parser.poly.setAttribute('points', this.toString());\n      return SVG.parser.poly.getBBox();\n    }\n  });\n  var pathHandlers = {\n    M: function M(c, p, p0) {\n      p.x = p0.x = c[0];\n      p.y = p0.y = c[1];\n      return ['M', p.x, p.y];\n    },\n    L: function L(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['L', c[0], c[1]];\n    },\n    H: function H(c, p) {\n      p.x = c[0];\n      return ['H', c[0]];\n    },\n    V: function V(c, p) {\n      p.y = c[0];\n      return ['V', c[0]];\n    },\n    C: function C(c, p) {\n      p.x = c[4];\n      p.y = c[5];\n      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n    },\n    S: function S(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['S', c[0], c[1], c[2], c[3]];\n    },\n    Q: function Q(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['Q', c[0], c[1], c[2], c[3]];\n    },\n    T: function T(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['T', c[0], c[1]];\n    },\n    Z: function Z(c, p, p0) {\n      p.x = p0.x;\n      p.y = p0.y;\n      return ['Z'];\n    },\n    A: function A(c, p) {\n      p.x = c[5];\n      p.y = c[6];\n      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n    }\n  };\n  var mlhvqtcsa = 'mlhvqtcsaz'.split('');\n\n  for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {\n    pathHandlers[mlhvqtcsa[i]] = function (i) {\n      return function (c, p, p0) {\n        if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {\n          c[5] = c[5] + p.x, c[6] = c[6] + p.y;\n        } else {\n          for (var j = 0, jl = c.length; j < jl; ++j) {\n            c[j] = c[j] + (j % 2 ? p.y : p.x);\n          }\n        }\n        return pathHandlers[i](c, p, p0);\n      };\n    }(mlhvqtcsa[i].toUpperCase());\n  } // Path points array\n\n\n  SVG.PathArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [['M', 0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PathArray.prototype = new SVG.Array();\n  SVG.PathArray.prototype.constructor = SVG.PathArray;\n  SVG.extend(SVG.PathArray, {\n    // Convert array to string\n    toString: function toString() {\n      return arrayToString(this.value);\n    },\n    // Move path string\n    move: function move(x, y) {\n      // get bounding box of current situation\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y;\n\n      if (!isNaN(x) && !isNaN(y)) {\n        // move every point\n        for (var l, i = this.value.length - 1; i >= 0; i--) {\n          l = this.value[i][0];\n\n          if (l == 'M' || l == 'L' || l == 'T') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n          } else if (l == 'H') {\n            this.value[i][1] += x;\n          } else if (l == 'V') {\n            this.value[i][1] += y;\n          } else if (l == 'C' || l == 'S' || l == 'Q') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n            this.value[i][3] += x;\n            this.value[i][4] += y;\n\n            if (l == 'C') {\n              this.value[i][5] += x;\n              this.value[i][6] += y;\n            }\n          } else if (l == 'A') {\n            this.value[i][6] += x;\n            this.value[i][7] += y;\n          }\n        }\n      }\n\n      return this;\n    },\n    // Resize path string\n    size: function size(width, height) {\n      // get bounding box of current situation\n      var i,\n          l,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        l = this.value[i][0];\n\n        if (l == 'M' || l == 'L' || l == 'T') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n        } else if (l == 'H') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n        } else if (l == 'V') {\n          this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n        } else if (l == 'C' || l == 'S' || l == 'Q') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n          this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;\n          this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;\n\n          if (l == 'C') {\n            this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;\n            this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y;\n          }\n        } else if (l == 'A') {\n          // resize radii\n          this.value[i][1] = this.value[i][1] * width / box.width;\n          this.value[i][2] = this.value[i][2] * height / box.height; // move position values\n\n          this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;\n          this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y;\n        }\n      }\n\n      return this;\n    },\n    // Test if the passed path array use the same path data commands as this path array\n    equalCommands: function equalCommands(pathArray) {\n      var i, il, equalCommands;\n      pathArray = new SVG.PathArray(pathArray);\n      equalCommands = this.value.length === pathArray.value.length;\n\n      for (i = 0, il = this.value.length; equalCommands && i < il; i++) {\n        equalCommands = this.value[i][0] === pathArray.value[i][0];\n      }\n\n      return equalCommands;\n    },\n    // Make path array morphable\n    morph: function morph(pathArray) {\n      pathArray = new SVG.PathArray(pathArray);\n\n      if (this.equalCommands(pathArray)) {\n        this.destination = pathArray;\n      } else {\n        this.destination = null;\n      }\n\n      return this;\n    },\n    // Get morphed path array at given position\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this;\n      var sourceArray = this.value,\n          destinationArray = this.destination.value,\n          array = [],\n          pathArray = new SVG.PathArray(),\n          i,\n          il,\n          j,\n          jl; // Animate has specified in the SVG spec\n      // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\n\n      for (i = 0, il = sourceArray.length; i < il; i++) {\n        array[i] = [sourceArray[i][0]];\n\n        for (j = 1, jl = sourceArray[i].length; j < jl; j++) {\n          array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;\n        } // For the two flags of the elliptical arc command, the SVG spec say:\n        // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\n        // Elliptical arc command as an array followed by corresponding indexes:\n        // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        //   0    1   2        3                 4             5      6  7\n\n\n        if (array[i][0] === 'A') {\n          array[i][4] = +(array[i][4] != 0);\n          array[i][5] = +(array[i][5] != 0);\n        }\n      } // Directly modify the value of a path array, this is done this way for performance\n\n\n      pathArray.value = array;\n      return pathArray;\n    },\n    // Absolutize and parse path to array\n    parse: function parse(array) {\n      // if it's already a patharray, no need to parse it\n      if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing\n\n      var s,\n          arr,\n          paramCnt = {\n        'M': 2,\n        'L': 2,\n        'H': 1,\n        'V': 1,\n        'C': 6,\n        'S': 4,\n        'Q': 4,\n        'T': 2,\n        'A': 7,\n        'Z': 0\n      };\n\n      if (typeof array === 'string') {\n        array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\n        .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen\n        .trim() // trim\n        .split(SVG.regex.delimiter); // split into array\n      } else {\n        array = array.reduce(function (prev, curr) {\n          return [].concat.call(prev, curr);\n        }, []);\n      } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n\n      var arr = [],\n          p = new SVG.Point(),\n          p0 = new SVG.Point(),\n          index = 0,\n          len = array.length;\n\n      do {\n        // Test if we have a path letter\n        if (SVG.regex.isPathLetter.test(array[index])) {\n          s = array[index];\n          ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n        } else if (s == 'M') {\n          s = 'L';\n        } else if (s == 'm') {\n          s = 'l';\n        }\n\n        arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));\n      } while (len > index);\n\n      return arr;\n    },\n    // Get bounding box of path\n    bbox: function bbox() {\n      if (!SVG.parser.draw) {\n        SVG.prepare();\n      }\n\n      SVG.parser.path.setAttribute('d', this.toString());\n      return SVG.parser.path.getBBox();\n    }\n  }); // Module for unit convertions\n\n  SVG.Number = SVG.invent({\n    // Initialize\n    create: function create(value, unit) {\n      // initialize defaults\n      this.value = 0;\n      this.unit = unit || ''; // parse value\n\n      if (typeof value === 'number') {\n        // ensure a valid numeric value\n        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n      } else if (typeof value === 'string') {\n        unit = value.match(SVG.regex.numberAndUnit);\n\n        if (unit) {\n          // make value numeric\n          this.value = parseFloat(unit[1]); // normalize\n\n          if (unit[5] == '%') {\n            this.value /= 100;\n          } else if (unit[5] == 's') {\n            this.value *= 1000;\n          } // store unit\n\n\n          this.unit = unit[5];\n        }\n      } else {\n        if (value instanceof SVG.Number) {\n          this.value = value.valueOf();\n          this.unit = value.unit;\n        }\n      }\n    },\n    // Add methods\n    extend: {\n      // Stringalize\n      toString: function toString() {\n        return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;\n      },\n      toJSON: function toJSON() {\n        return this.toString();\n      },\n      // Convert to primitive\n      valueOf: function valueOf() {\n        return this.value;\n      },\n      // Add number\n      plus: function plus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this + number, this.unit || number.unit);\n      },\n      // Subtract number\n      minus: function minus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this - number, this.unit || number.unit);\n      },\n      // Multiply number\n      times: function times(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this * number, this.unit || number.unit);\n      },\n      // Divide number\n      divide: function divide(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this / number, this.unit || number.unit);\n      },\n      // Convert to different unit\n      to: function to(unit) {\n        var number = new SVG.Number(this);\n\n        if (typeof unit === 'string') {\n          number.unit = unit;\n        }\n\n        return number;\n      },\n      // Make number morphable\n      morph: function morph(number) {\n        this.destination = new SVG.Number(number);\n\n        if (number.relative) {\n          this.destination.value += this.value;\n        }\n\n        return this;\n      },\n      // Get morphed number at given position\n      at: function at(pos) {\n        // Make sure a destination is defined\n        if (!this.destination) return this; // Generate new morphed number\n\n        return new SVG.Number(this.destination).minus(this).times(pos).plus(this);\n      }\n    }\n  });\n  SVG.Element = SVG.invent({\n    // Initialize node\n    create: function create(node) {\n      // make stroke value accessible dynamically\n      this._stroke = SVG.defaults.attrs.stroke;\n      this._event = null; // initialize data object\n\n      this.dom = {}; // create circular reference\n\n      if (this.node = node) {\n        this.type = node.nodeName;\n        this.node.instance = this; // store current attribute value\n\n        this._stroke = node.getAttribute('stroke') || this._stroke;\n      }\n    },\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x) {\n        return this.attr('x', _x);\n      },\n      // Move over y-axis\n      y: function y(_y) {\n        return this.attr('y', _y);\n      },\n      // Move by center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n      },\n      // Move by center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n      },\n      // Move element to given x and y values\n      move: function move(x, y) {\n        return this.x(x).y(y);\n      },\n      // Move element by its center\n      center: function center(x, y) {\n        return this.cx(x).cy(y);\n      },\n      // Set width of element\n      width: function width(_width) {\n        return this.attr('width', _width);\n      },\n      // Set height of element\n      height: function height(_height) {\n        return this.attr('height', _height);\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));\n      },\n      // Clone element\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // clone element and assign new id\n\n        var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) parent.add(clone);else this.after(clone);\n        return clone;\n      },\n      // Remove element\n      remove: function remove() {\n        if (this.parent()) {\n          this.parent().removeElement(this);\n        }\n\n        return this;\n      },\n      // Replace element\n      replace: function replace(element) {\n        this.after(element).remove();\n        return element;\n      },\n      // Add element to given container and return self\n      addTo: function addTo(parent) {\n        return parent.put(this);\n      },\n      // Add element to given container and return container\n      putIn: function putIn(parent) {\n        return parent.add(this);\n      },\n      // Get / set id\n      id: function id(_id) {\n        return this.attr('id', _id);\n      },\n      // Checks whether the given point inside the bounding box of the element\n      inside: function inside(x, y) {\n        var box = this.bbox();\n        return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n      },\n      // Show element\n      show: function show() {\n        return this.style('display', '');\n      },\n      // Hide element\n      hide: function hide() {\n        return this.style('display', 'none');\n      },\n      // Is element visible?\n      visible: function visible() {\n        return this.style('display') != 'none';\n      },\n      // Return id on string conversion\n      toString: function toString() {\n        return this.attr('id');\n      },\n      // Return array of classes on the node\n      classes: function classes() {\n        var attr = this.attr('class');\n        return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);\n      },\n      // Return true if class exists on the node, false otherwise\n      hasClass: function hasClass(name) {\n        return this.classes().indexOf(name) != -1;\n      },\n      // Add class to the node\n      addClass: function addClass(name) {\n        if (!this.hasClass(name)) {\n          var array = this.classes();\n          array.push(name);\n          this.attr('class', array.join(' '));\n        }\n\n        return this;\n      },\n      // Remove class from the node\n      removeClass: function removeClass(name) {\n        if (this.hasClass(name)) {\n          this.attr('class', this.classes().filter(function (c) {\n            return c != name;\n          }).join(' '));\n        }\n\n        return this;\n      },\n      // Toggle the presence of a class on the node\n      toggleClass: function toggleClass(name) {\n        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n      },\n      // Get referenced element form attribute value\n      reference: function reference(attr) {\n        return SVG.get(this.attr(attr));\n      },\n      // Returns the parent element instance\n      parent: function parent(type) {\n        var parent = this; // check for parent\n\n        if (!parent.node.parentNode) return null; // get parent element\n\n        parent = SVG.adopt(parent.node.parentNode);\n        if (!type) return parent; // loop trough ancestors if type is given\n\n        while (parent && parent.node instanceof window.SVGElement) {\n          if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n          if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document') return null; // #759, #720\n\n          parent = SVG.adopt(parent.node.parentNode);\n        }\n      },\n      // Get parent document\n      doc: function doc() {\n        return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);\n      },\n      // return array of all ancestors of given type up to the root svg\n      parents: function parents(type) {\n        var parents = [],\n            parent = this;\n\n        do {\n          parent = parent.parent(type);\n          if (!parent || !parent.node) break;\n          parents.push(parent);\n        } while (parent.parent);\n\n        return parents;\n      },\n      // matches the element vs a css selector\n      matches: function matches(selector) {\n        return _matches(this.node, selector);\n      },\n      // Returns the svg node to call native svg methods on it\n      native: function native() {\n        return this.node;\n      },\n      // Import raw svg\n      svg: function svg(_svg) {\n        // create temporary holder\n        var well = document.createElement('svg'); // act as a setter if svg is given\n\n        if (_svg && this instanceof SVG.Parent) {\n          // dump raw svg\n          well.innerHTML = '<svg>' + _svg.replace(/\\n/, '').replace(/<([\\w:-]+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes\n\n          for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {\n            this.node.appendChild(well.firstChild.firstChild);\n          } // otherwise act as a getter\n\n        } else {\n          // create a wrapping svg element in case of partial content\n          well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom\n\n          this.writeDataToDom(); // insert a copy of this node\n\n          _svg.appendChild(this.node.cloneNode(true)); // return target element\n\n\n          return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '');\n        }\n\n        return this;\n      },\n      // write svgjs data to the dom\n      writeDataToDom: function writeDataToDom() {\n        // dump variables recursively\n        if (this.each || this.lines) {\n          var fn = this.each ? this : this.lines();\n          fn.each(function () {\n            this.writeDataToDom();\n          });\n        } // remove previously set data\n\n\n        this.node.removeAttribute('svgjs:data');\n\n        if (Object.keys(this.dom).length) {\n          this.node.setAttribute('svgjs:data', JSON.stringify(this.dom));\n        } // see #428\n\n\n        return this;\n      },\n      // set given data to the elements data property\n      setData: function setData(o) {\n        this.dom = o;\n        return this;\n      },\n      is: function is(obj) {\n        return _is(this, obj);\n      }\n    }\n  });\n  SVG.easing = {\n    '-': function _(pos) {\n      return pos;\n    },\n    '<>': function _(pos) {\n      return -Math.cos(pos * Math.PI) / 2 + 0.5;\n    },\n    '>': function _(pos) {\n      return Math.sin(pos * Math.PI / 2);\n    },\n    '<': function _(pos) {\n      return -Math.cos(pos * Math.PI / 2) + 1;\n    }\n  };\n\n  SVG.morph = function (pos) {\n    return function (from, to) {\n      return new SVG.MorphObj(from, to).at(pos);\n    };\n  };\n\n  SVG.Situation = SVG.invent({\n    create: function create(o) {\n      this.init = false;\n      this.reversed = false;\n      this.reversing = false;\n      this.duration = new SVG.Number(o.duration).valueOf();\n      this.delay = new SVG.Number(o.delay).valueOf();\n      this.start = +new Date() + this.delay;\n      this.finish = this.start + this.duration;\n      this.ease = o.ease; // this.loop is incremented from 0 to this.loops\n      // it is also incremented when in an infinite loop (when this.loops is true)\n\n      this.loop = 0;\n      this.loops = false;\n      this.animations = {// functionToCall: [list of morphable objects]\n        // e.g. move: [SVG.Number, SVG.Number]\n      };\n      this.attrs = {// holds all attributes which are not represented from a function svg.js provides\n        // e.g. someAttr: SVG.Number\n      };\n      this.styles = {// holds all styles which should be animated\n        // e.g. fill-color: SVG.Color\n      };\n      this.transforms = [// holds all transformations as transformation objects\n        // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\n      ];\n      this.once = {// functions to fire at a specific position\n        // e.g. \"0.5\": function foo(){}\n      };\n    }\n  });\n  SVG.FX = SVG.invent({\n    create: function create(element) {\n      this._target = element;\n      this.situations = [];\n      this.active = false;\n      this.situation = null;\n      this.paused = false;\n      this.lastPos = 0;\n      this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\n      // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\n\n      this.absPos = 0;\n      this._speed = 1;\n    },\n    extend: {\n      /**\n       * sets or returns the target of this animation\n       * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\n       * @param ease function || string Function which should be used for easing or easing keyword\n       * @param delay Number indicating the delay before the animation starts\n       * @return target || this\n       */\n      animate: function animate(o, ease, delay) {\n        if (_typeof(o) === 'object') {\n          ease = o.ease;\n          delay = o.delay;\n          o = o.duration;\n        }\n\n        var situation = new SVG.Situation({\n          duration: o || 1000,\n          delay: delay || 0,\n          ease: SVG.easing[ease || '-'] || ease\n        });\n        this.queue(situation);\n        return this;\n      },\n\n      /**\n      * sets a delay before the next element of the queue is called\n      * @param delay Duration of delay in milliseconds\n      * @return this.target()\n      */\n      delay: function delay(_delay) {\n        // The delay is performed by an empty situation with its duration\n        // attribute set to the duration of the delay\n        var situation = new SVG.Situation({\n          duration: _delay,\n          delay: 0,\n          ease: SVG.easing['-']\n        });\n        return this.queue(situation);\n      },\n\n      /**\n      * sets or returns the target of this animation\n      * @param null || target SVG.Element which should be set as new target\n      * @return target || this\n      */\n      target: function target(_target) {\n        if (_target && _target instanceof SVG.Element) {\n          this._target = _target;\n          return this;\n        }\n\n        return this._target;\n      },\n      // returns the absolute position at a given time\n      timeToAbsPos: function timeToAbsPos(timestamp) {\n        return (timestamp - this.situation.start) / (this.situation.duration / this._speed);\n      },\n      // returns the timestamp from a given absolute positon\n      absPosToTime: function absPosToTime(absPos) {\n        return this.situation.duration / this._speed * absPos + this.situation.start;\n      },\n      // starts the animationloop\n      startAnimFrame: function startAnimFrame() {\n        this.stopAnimFrame();\n        this.animationFrame = window.requestAnimationFrame(function () {\n          this.step();\n        }.bind(this));\n      },\n      // cancels the animationframe\n      stopAnimFrame: function stopAnimFrame() {\n        window.cancelAnimationFrame(this.animationFrame);\n      },\n      // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\n      start: function start() {\n        // dont start if already started\n        if (!this.active && this.situation) {\n          this.active = true;\n          this.startCurrent();\n        }\n\n        return this;\n      },\n      // start the current situation\n      startCurrent: function startCurrent() {\n        this.situation.start = +new Date() + this.situation.delay / this._speed;\n        this.situation.finish = this.situation.start + this.situation.duration / this._speed;\n        return this.initAnimations().step();\n      },\n\n      /**\n      * adds a function / Situation to the animation queue\n      * @param fn function / situation to add\n      * @return this\n      */\n      queue: function queue(fn) {\n        if (typeof fn === 'function' || fn instanceof SVG.Situation) {\n          this.situations.push(fn);\n        }\n\n        if (!this.situation) this.situation = this.situations.shift();\n        return this;\n      },\n\n      /**\n      * pulls next element from the queue and execute it\n      * @return this\n      */\n      dequeue: function dequeue() {\n        // stop current animation\n        this.stop(); // get next animation from queue\n\n        this.situation = this.situations.shift();\n\n        if (this.situation) {\n          if (this.situation instanceof SVG.Situation) {\n            this.start();\n          } else {\n            // If it is not a SVG.Situation, then it is a function, we execute it\n            this.situation.call(this);\n          }\n        }\n\n        return this;\n      },\n      // updates all animations to the current state of the element\n      // this is important when one property could be changed from another property\n      initAnimations: function initAnimations() {\n        var i, j, source;\n        var s = this.situation;\n        if (s.init) return this;\n\n        for (i in s.animations) {\n          source = this.target()[i]();\n\n          if (!Array.isArray(source)) {\n            source = [source];\n          }\n\n          if (!Array.isArray(s.animations[i])) {\n            s.animations[i] = [s.animations[i]];\n          } // if(s.animations[i].length > source.length) {\n          //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\n          // }\n\n\n          for (j = source.length; j--;) {\n            // The condition is because some methods return a normal number instead\n            // of a SVG.Number\n            if (s.animations[i][j] instanceof SVG.Number) {\n              source[j] = new SVG.Number(source[j]);\n            }\n\n            s.animations[i][j] = source[j].morph(s.animations[i][j]);\n          }\n        }\n\n        for (i in s.attrs) {\n          s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);\n        }\n\n        for (i in s.styles) {\n          s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);\n        }\n\n        s.initialTransformation = this.target().matrixify();\n        s.init = true;\n        return this;\n      },\n      clearQueue: function clearQueue() {\n        this.situations = [];\n        return this;\n      },\n      clearCurrent: function clearCurrent() {\n        this.situation = null;\n        return this;\n      },\n\n      /** stops the animation immediately\n      * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\n      * @param clearQueue A Boolean indicating whether to remove queued animation as well.\n      * @return this\n      */\n      stop: function stop(jumpToEnd, clearQueue) {\n        var active = this.active;\n        this.active = false;\n\n        if (clearQueue) {\n          this.clearQueue();\n        }\n\n        if (jumpToEnd && this.situation) {\n          // initialize the situation if it was not\n          !active && this.startCurrent();\n          this.atEnd();\n        }\n\n        this.stopAnimFrame();\n        return this.clearCurrent();\n      },\n\n      /** resets the element to the state where the current element has started\n      * @return this\n      */\n      reset: function reset() {\n        if (this.situation) {\n          var temp = this.situation;\n          this.stop();\n          this.situation = temp;\n          this.atStart();\n        }\n\n        return this;\n      },\n      // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\n      finish: function finish() {\n        this.stop(true, false);\n\n        while (this.dequeue().situation && this.stop(true, false)) {\n        }\n\n        this.clearQueue().clearCurrent();\n        return this;\n      },\n      // set the internal animation pointer at the start position, before any loops, and updates the visualisation\n      atStart: function atStart() {\n        return this.at(0, true);\n      },\n      // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\n      atEnd: function atEnd() {\n        if (this.situation.loops === true) {\n          // If in a infinite loop, we end the current iteration\n          this.situation.loops = this.situation.loop + 1;\n        }\n\n        if (typeof this.situation.loops === 'number') {\n          // If performing a finite number of loops, we go after all the loops\n          return this.at(this.situation.loops, true);\n        } else {\n          // If no loops, we just go at the end\n          return this.at(1, true);\n        }\n      },\n      // set the internal animation pointer to the specified position and updates the visualisation\n      // if isAbsPos is true, pos is treated as an absolute position\n      at: function at(pos, isAbsPos) {\n        var durDivSpd = this.situation.duration / this._speed;\n        this.absPos = pos; // If pos is not an absolute position, we convert it into one\n\n        if (!isAbsPos) {\n          if (this.situation.reversed) this.absPos = 1 - this.absPos;\n          this.absPos += this.situation.loop;\n        }\n\n        this.situation.start = +new Date() - this.absPos * durDivSpd;\n        this.situation.finish = this.situation.start + durDivSpd;\n        return this.step(true);\n      },\n\n      /**\n      * sets or returns the speed of the animations\n      * @param speed null || Number The new speed of the animations\n      * @return Number || this\n      */\n      speed: function speed(_speed) {\n        if (_speed === 0) return this.pause();\n\n        if (_speed) {\n          this._speed = _speed; // We use an absolute position here so that speed can affect the delay before the animation\n\n          return this.at(this.absPos, true);\n        } else return this._speed;\n      },\n      // Make loopable\n      loop: function loop(times, reverse) {\n        var c = this.last(); // store total loops\n\n        c.loops = times != null ? times : true;\n        c.loop = 0;\n        if (reverse) c.reversing = true;\n        return this;\n      },\n      // pauses the animation\n      pause: function pause() {\n        this.paused = true;\n        this.stopAnimFrame();\n        return this;\n      },\n      // unpause the animation\n      play: function play() {\n        if (!this.paused) return this;\n        this.paused = false; // We use an absolute position here so that the delay before the animation can be paused\n\n        return this.at(this.absPos, true);\n      },\n\n      /**\n      * toggle or set the direction of the animation\n      * true sets direction to backwards while false sets it to forwards\n      * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\n      * @return this\n      */\n      reverse: function reverse(reversed) {\n        var c = this.last();\n        if (typeof reversed === 'undefined') c.reversed = !c.reversed;else c.reversed = reversed;\n        return this;\n      },\n\n      /**\n      * returns a float from 0-1 indicating the progress of the current animation\n      * @param eased Boolean indicating whether the returned position should be eased or not\n      * @return number\n      */\n      progress: function progress(easeIt) {\n        return easeIt ? this.situation.ease(this.pos) : this.pos;\n      },\n\n      /**\n      * adds a callback function which is called when the current animation is finished\n      * @param fn Function which should be executed as callback\n      * @return number\n      */\n      after: function after(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, c);\n            this.off('finished.fx', wrapper); // prevent memory leak\n          }\n        };\n\n        this.target().on('finished.fx', wrapper);\n        return this._callStart();\n      },\n      // adds a callback which is called whenever one animation step is performed\n      during: function during(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);\n          }\n        }; // see above\n\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.after(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      },\n      // calls after ALL animations in the queue are finished\n      afterAll: function afterAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this);\n          this.off('allfinished.fx', wrapper);\n        }; // see above\n\n\n        this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);\n        return this._callStart();\n      },\n      // calls on every animation step for all animations\n      duringAll: function duringAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation);\n        };\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.afterAll(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      },\n      last: function last() {\n        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;\n      },\n      // adds one property to the animations\n      add: function add(method, args, type) {\n        this.last()[type || 'animations'][method] = args;\n        return this._callStart();\n      },\n\n      /** perform one step of the animation\n      *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\n      *  @return this\n      */\n      step: function step(ignoreTime) {\n        // convert current time to an absolute position\n        if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position\n\n        if (this.situation.loops !== false) {\n          var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0\n\n          absPos = Math.max(this.absPos, 0);\n          absPosInt = Math.floor(absPos);\n\n          if (this.situation.loops === true || absPosInt < this.situation.loops) {\n            this.pos = absPos - absPosInt;\n            lastLoop = this.situation.loop;\n            this.situation.loop = absPosInt;\n          } else {\n            this.absPos = this.situation.loops;\n            this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed\n\n            lastLoop = this.situation.loop - 1;\n            this.situation.loop = this.situation.loops;\n          }\n\n          if (this.situation.reversing) {\n            // Toggle reversed if an odd number of loops as occured since the last call of step\n            this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);\n          }\n        } else {\n          // If there are no loop, the absolute position must not be above 1\n          this.absPos = Math.min(this.absPos, 1);\n          this.pos = this.absPos;\n        } // while the absolute position can be below 0, the position must not be below 0\n\n\n        if (this.pos < 0) this.pos = 0;\n        if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing\n\n        var eased = this.situation.ease(this.pos); // call once-callbacks\n\n        for (var i in this.situation.once) {\n          if (i > this.lastPos && i <= eased) {\n            this.situation.once[i].call(this.target(), this.pos, eased);\n            delete this.situation.once[i];\n          }\n        } // fire during callback with position, eased position and current situation as parameter\n\n\n        if (this.active) this.target().fire('during', {\n          pos: this.pos,\n          eased: eased,\n          fx: this,\n          situation: this.situation\n        }); // the user may call stop or finish in the during callback\n        // so make sure that we still have a valid situation\n\n        if (!this.situation) {\n          return this;\n        } // apply the actual animation to every property\n\n\n        this.eachAt(); // do final code when situation is finished\n\n        if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {\n          // stop animation callback\n          this.stopAnimFrame(); // fire finished callback with current situation as parameter\n\n          this.target().fire('finished', {\n            fx: this,\n            situation: this.situation\n          });\n\n          if (!this.situations.length) {\n            this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback\n\n            if (!this.situations.length) {\n              this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...\n\n              this.active = false;\n            }\n          } // start next animation\n\n\n          if (this.active) this.dequeue();else this.clearCurrent();\n        } else if (!this.paused && this.active) {\n          // we continue animating when we are not at the end\n          this.startAnimFrame();\n        } // save last eased position for once callback triggering\n\n\n        this.lastPos = eased;\n        return this;\n      },\n      // calculates the step for every property and calls block with it\n      eachAt: function eachAt() {\n        var i,\n            len,\n            at,\n            self = this,\n            target = this.target(),\n            s = this.situation; // apply animations which can be called trough a method\n\n        for (i in s.animations) {\n          at = [].concat(s.animations[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target[i].apply(target, at);\n        } // apply animation which has to be applied with attr()\n\n\n        for (i in s.attrs) {\n          at = [i].concat(s.attrs[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.attr.apply(target, at);\n        } // apply animation which has to be applied with style()\n\n\n        for (i in s.styles) {\n          at = [i].concat(s.styles[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.style.apply(target, at);\n        } // animate initialTransformation which has to be chained\n\n\n        if (s.transforms.length) {\n          // get initial initialTransformation\n          at = s.initialTransformation;\n\n          for (i = 0, len = s.transforms.length; i < len; i++) {\n            // get next transformation in chain\n            var a = s.transforms[i]; // multiply matrix directly\n\n            if (a instanceof SVG.Matrix) {\n              if (a.relative) {\n                at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));\n              } else {\n                at = at.morph(a).at(s.ease(this.pos));\n              }\n\n              continue;\n            } // when transformation is absolute we have to reset the needed transformation first\n\n\n            if (!a.relative) {\n              a.undo(at.extract());\n            } // and reapply it after\n\n\n            at = at.multiply(a.at(s.ease(this.pos)));\n          } // set new matrix on element\n\n\n          target.matrix(at);\n        }\n\n        return this;\n      },\n      // adds an once-callback which is called at a specific position and never again\n      once: function once(pos, fn, isEased) {\n        var c = this.last();\n        if (!isEased) pos = c.ease(pos);\n        c.once[pos] = fn;\n        return this;\n      },\n      _callStart: function _callStart() {\n        setTimeout(function () {\n          this.start();\n        }.bind(this), 0);\n        return this;\n      }\n    },\n    parent: SVG.Element,\n    // Add method to parent elements\n    construct: {\n      // Get fx module or create a new one, then animate with given duration and ease\n      animate: function animate(o, ease, delay) {\n        return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);\n      },\n      delay: function delay(_delay2) {\n        return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay2);\n      },\n      stop: function stop(jumpToEnd, clearQueue) {\n        if (this.fx) {\n          this.fx.stop(jumpToEnd, clearQueue);\n        }\n\n        return this;\n      },\n      finish: function finish() {\n        if (this.fx) {\n          this.fx.finish();\n        }\n\n        return this;\n      },\n      // Pause current animation\n      pause: function pause() {\n        if (this.fx) {\n          this.fx.pause();\n        }\n\n        return this;\n      },\n      // Play paused current animation\n      play: function play() {\n        if (this.fx) {\n          this.fx.play();\n        }\n\n        return this;\n      },\n      // Set/Get the speed of the animations\n      speed: function speed(_speed2) {\n        if (this.fx) {\n          if (_speed2 == null) {\n            return this.fx.speed();\n          } else {\n            this.fx.speed(_speed2);\n          }\n        }\n\n        return this;\n      }\n    }\n  }); // MorphObj is used whenever no morphable object is given\n\n  SVG.MorphObj = SVG.invent({\n    create: function create(from, to) {\n      // prepare color for morphing\n      if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values\n\n      if (SVG.regex.delimiter.test(from)) {\n        // prepare path for morphing\n        if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing\n        else return new SVG.Array(from).morph(to);\n      } // prepare number for morphing\n\n\n      if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing\n\n      this.value = from;\n      this.destination = to;\n    },\n    extend: {\n      at: function at(pos, real) {\n        return real < 1 ? this.value : this.destination;\n      },\n      valueOf: function valueOf() {\n        return this.value;\n      }\n    }\n  });\n  SVG.extend(SVG.FX, {\n    // Add animatable attributes\n    attr: function attr(a, v, relative) {\n      // apply attributes individually\n      if (_typeof(a) === 'object') {\n        for (var key in a) {\n          this.attr(key, a[key]);\n        }\n      } else {\n        this.add(a, v, 'attrs');\n      }\n\n      return this;\n    },\n    // Add animatable styles\n    style: function style(s, v) {\n      if (_typeof(s) === 'object') {\n        for (var key in s) {\n          this.style(key, s[key]);\n        }\n      } else {\n        this.add(s, v, 'styles');\n      }\n\n      return this;\n    },\n    // Animatable x-axis\n    x: function x(_x2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          x: _x2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_x2);\n      num.relative = relative;\n      return this.add('x', num);\n    },\n    // Animatable y-axis\n    y: function y(_y2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          y: _y2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_y2);\n      num.relative = relative;\n      return this.add('y', num);\n    },\n    // Animatable center x-axis\n    cx: function cx(x) {\n      return this.add('cx', new SVG.Number(x));\n    },\n    // Animatable center y-axis\n    cy: function cy(y) {\n      return this.add('cy', new SVG.Number(y));\n    },\n    // Add animatable move\n    move: function move(x, y) {\n      return this.x(x).y(y);\n    },\n    // Add animatable center\n    center: function center(x, y) {\n      return this.cx(x).cy(y);\n    },\n    // Add animatable size\n    size: function size(width, height) {\n      if (this.target() instanceof SVG.Text) {\n        // animate font size for Text elements\n        this.attr('font-size', width);\n      } else {\n        // animate bbox based size for all other elements\n        var box;\n\n        if (!width || !height) {\n          box = this.target().bbox();\n        }\n\n        if (!width) {\n          width = box.width / box.height * height;\n        }\n\n        if (!height) {\n          height = box.height / box.width * width;\n        }\n\n        this.add('width', new SVG.Number(width)).add('height', new SVG.Number(height));\n      }\n\n      return this;\n    },\n    // Add animatable width\n    width: function width(_width2) {\n      return this.add('width', new SVG.Number(_width2));\n    },\n    // Add animatable height\n    height: function height(_height2) {\n      return this.add('height', new SVG.Number(_height2));\n    },\n    // Add animatable plot\n    plot: function plot(a, b, c, d) {\n      // Lines can be plotted with 4 arguments\n      if (arguments.length == 4) {\n        return this.plot([a, b, c, d]);\n      }\n\n      return this.add('plot', new (this.target().morphArray)(a));\n    },\n    // Add leading method\n    leading: function leading(value) {\n      return this.target().leading ? this.add('leading', new SVG.Number(value)) : this;\n    },\n    // Add animatable viewbox\n    viewbox: function viewbox(x, y, width, height) {\n      if (this.target() instanceof SVG.Container) {\n        this.add('viewbox', new SVG.ViewBox(x, y, width, height));\n      }\n\n      return this;\n    },\n    update: function update(o) {\n      if (this.target() instanceof SVG.Stop) {\n        if (typeof o === 'number' || o instanceof SVG.Number) {\n          return this.update({\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          });\n        }\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', o.offset);\n      }\n\n      return this;\n    }\n  });\n  SVG.Box = SVG.invent({\n    create: function create(x, y, width, height) {\n      if (_typeof(x) === 'object' && !(x instanceof SVG.Element)) {\n        // chromes getBoundingClientRect has no x and y property\n        return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);\n      } else if (arguments.length == 4) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n      } // add center, right, bottom...\n\n\n      fullBox(this);\n    },\n    extend: {\n      // Merge rect box with another, return a new instance\n      merge: function merge(box) {\n        var b = new this.constructor(); // merge boxes\n\n        b.x = Math.min(this.x, box.x);\n        b.y = Math.min(this.y, box.y);\n        b.width = Math.max(this.x + this.width, box.x + box.width) - b.x;\n        b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;\n        return fullBox(b);\n      },\n      transform: function transform(m) {\n        var xMin = Infinity,\n            xMax = -Infinity,\n            yMin = Infinity,\n            yMax = -Infinity,\n            bbox;\n        var pts = [new SVG.Point(this.x, this.y), new SVG.Point(this.x2, this.y), new SVG.Point(this.x, this.y2), new SVG.Point(this.x2, this.y2)];\n        pts.forEach(function (p) {\n          p = p.transform(m);\n          xMin = Math.min(xMin, p.x);\n          xMax = Math.max(xMax, p.x);\n          yMin = Math.min(yMin, p.y);\n          yMax = Math.max(yMax, p.y);\n        });\n        bbox = new this.constructor();\n        bbox.x = xMin;\n        bbox.width = xMax - xMin;\n        bbox.y = yMin;\n        bbox.height = yMax - yMin;\n        fullBox(bbox);\n        return bbox;\n      }\n    }\n  });\n  SVG.BBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given\n\n      if (element instanceof SVG.Element) {\n        var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\n\n        try {\n          if (!document.documentElement.contains) {\n            // This is IE - it does not support contains() for top-level SVGs\n            var topParent = element.node;\n\n            while (topParent.parentNode) {\n              topParent = topParent.parentNode;\n            }\n\n            if (topParent != document) throw new Error('Element not in the dom');\n          } // the element is NOT in the dom, throw error\n          // disabling the check below which fixes issue #76\n          // if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\n          // find native bbox\n\n\n          box = element.node.getBBox();\n        } catch (e) {\n          if (element instanceof SVG.Shape) {\n            if (!SVG.parser.draw) {\n              // fixes apexcharts/vue-apexcharts #14\n              SVG.prepare();\n            }\n\n            var clone = element.clone(SVG.parser.draw.instance).show();\n            box = clone.node.getBBox();\n            clone.remove();\n          } else {\n            box = {\n              x: element.node.clientLeft,\n              y: element.node.clientTop,\n              width: element.node.clientWidth,\n              height: element.node.clientHeight\n            };\n          }\n        }\n\n        SVG.Box.call(this, box);\n      }\n    },\n    // Define ancestor\n    inherit: SVG.Box,\n    // Define Parent\n    parent: SVG.Element,\n    // Constructor\n    construct: {\n      // Get bounding box\n      bbox: function bbox() {\n        return new SVG.BBox(this);\n      }\n    }\n  });\n  SVG.BBox.prototype.constructor = SVG.BBox;\n  SVG.extend(SVG.Element, {\n    tbox: function tbox() {\n      console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.');\n      return this.rbox(this.doc());\n    }\n  });\n  SVG.RBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments));\n\n      if (element instanceof SVG.Element) {\n        SVG.Box.call(this, element.node.getBoundingClientRect());\n      }\n    },\n    inherit: SVG.Box,\n    // define Parent\n    parent: SVG.Element,\n    extend: {\n      addOffset: function addOffset() {\n        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n        this.x += window.pageXOffset;\n        this.y += window.pageYOffset;\n        return this;\n      }\n    },\n    // Constructor\n    construct: {\n      // Get rect box\n      rbox: function rbox(el) {\n        if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse());\n        return new SVG.RBox(this).addOffset();\n      }\n    }\n  });\n  SVG.RBox.prototype.constructor = SVG.RBox;\n  SVG.Matrix = SVG.invent({\n    // Initialize\n    create: function create(source) {\n      var i,\n          base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n      source = source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : _typeof(source) === 'object' ? source : base; // merge source\n\n      for (i = abcdef.length - 1; i >= 0; --i) {\n        this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];\n      }\n    },\n    // Add methods\n    extend: {\n      // Extract individual transformations\n      extract: function extract() {\n        // find delta transform points\n        var px = deltaTransformPoint(this, 0, 1),\n            py = deltaTransformPoint(this, 1, 0),\n            skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n        return {\n          // translation\n          x: this.e,\n          y: this.f,\n          transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),\n          transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),\n          // skew\n          skewX: -skewX,\n          skewY: 180 / Math.PI * Math.atan2(py.y, py.x),\n          // scale\n          scaleX: Math.sqrt(this.a * this.a + this.b * this.b),\n          scaleY: Math.sqrt(this.c * this.c + this.d * this.d),\n          // rotation\n          rotation: skewX,\n          a: this.a,\n          b: this.b,\n          c: this.c,\n          d: this.d,\n          e: this.e,\n          f: this.f,\n          matrix: new SVG.Matrix(this)\n        };\n      },\n      // Clone matrix\n      clone: function clone() {\n        return new SVG.Matrix(this);\n      },\n      // Morph one matrix into another\n      morph: function morph(matrix) {\n        // store new destination\n        this.destination = new SVG.Matrix(matrix);\n        return this;\n      },\n      // Get morphed matrix at a given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var matrix = new SVG.Matrix({\n          a: this.a + (this.destination.a - this.a) * pos,\n          b: this.b + (this.destination.b - this.b) * pos,\n          c: this.c + (this.destination.c - this.c) * pos,\n          d: this.d + (this.destination.d - this.d) * pos,\n          e: this.e + (this.destination.e - this.e) * pos,\n          f: this.f + (this.destination.f - this.f) * pos\n        });\n        return matrix;\n      },\n      // Multiplies by given matrix\n      multiply: function multiply(matrix) {\n        return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));\n      },\n      // Inverses matrix\n      inverse: function inverse() {\n        return new SVG.Matrix(this.native().inverse());\n      },\n      // Translate matrix\n      translate: function translate(x, y) {\n        return new SVG.Matrix(this.native().translate(x || 0, y || 0));\n      },\n      // Scale matrix\n      scale: function scale(x, y, cx, cy) {\n        // support uniformal scale\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        }\n\n        return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0));\n      },\n      // Rotate matrix\n      rotate: function rotate(r, cx, cy) {\n        // convert degrees to radians\n        r = SVG.utils.radians(r);\n        return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0));\n      },\n      // Flip matrix on x or y, at a given offset\n      flip: function flip(a, o) {\n        return a == 'x' ? this.scale(-1, 1, o, 0) : a == 'y' ? this.scale(1, -1, 0, o) : this.scale(-1, -1, a, o != null ? o : a);\n      },\n      // Skew\n      skew: function skew(x, y, cx, cy) {\n        // support uniformal skew\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        } // convert degrees to radians\n\n\n        x = SVG.utils.radians(x);\n        y = SVG.utils.radians(y);\n        return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0));\n      },\n      // SkewX\n      skewX: function skewX(x, cx, cy) {\n        return this.skew(x, 0, cx, cy);\n      },\n      // SkewY\n      skewY: function skewY(y, cx, cy) {\n        return this.skew(0, y, cx, cy);\n      },\n      // Transform around a center point\n      around: function around(cx, cy, matrix) {\n        return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0));\n      },\n      // Convert to native SVGMatrix\n      native: function native() {\n        // create new matrix\n        var matrix = SVG.parser.native.createSVGMatrix(); // update with current values\n\n        for (var i = abcdef.length - 1; i >= 0; i--) {\n          matrix[abcdef[i]] = this[abcdef[i]];\n        }\n\n        return matrix;\n      },\n      // Convert matrix to string\n      toString: function toString() {\n        // Construct the matrix directly, avoid values that are too small\n        return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';\n      }\n    },\n    // Define parent\n    parent: SVG.Element,\n    // Add parent method\n    construct: {\n      // Get current matrix\n      ctm: function ctm() {\n        return new SVG.Matrix(this.node.getCTM());\n      },\n      // Get current screen matrix\n      screenCTM: function screenCTM() {\n        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n           This is needed because FF does not return the transformation matrix\n           for the inner coordinate system when getScreenCTM() is called on nested svgs.\n           However all other Browsers do that */\n        if (this instanceof SVG.Nested) {\n          var rect = this.rect(1, 1);\n          var m = rect.node.getScreenCTM();\n          rect.remove();\n          return new SVG.Matrix(m);\n        }\n\n        return new SVG.Matrix(this.node.getScreenCTM());\n      }\n    }\n  });\n  SVG.Point = SVG.invent({\n    // Initialize\n    create: function create(x, y) {\n      var source,\n          base = {\n        x: 0,\n        y: 0 // ensure source as object\n\n      };\n      source = Array.isArray(x) ? {\n        x: x[0],\n        y: x[1]\n      } : _typeof(x) === 'object' ? {\n        x: x.x,\n        y: x.y\n      } : x != null ? {\n        x: x,\n        y: y != null ? y : x\n      } : base; // If y has no value, then x is used has its value\n      // merge source\n\n      this.x = source.x;\n      this.y = source.y;\n    },\n    // Add methods\n    extend: {\n      // Clone point\n      clone: function clone() {\n        return new SVG.Point(this);\n      },\n      // Morph one point into another\n      morph: function morph(x, y) {\n        // store new destination\n        this.destination = new SVG.Point(x, y);\n        return this;\n      },\n      // Get morphed point at a given position\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var point = new SVG.Point({\n          x: this.x + (this.destination.x - this.x) * pos,\n          y: this.y + (this.destination.y - this.y) * pos\n        });\n        return point;\n      },\n      // Convert to native SVGPoint\n      native: function native() {\n        // create new point\n        var point = SVG.parser.native.createSVGPoint(); // update with current values\n\n        point.x = this.x;\n        point.y = this.y;\n        return point;\n      },\n      // transform point with matrix\n      transform: function transform(matrix) {\n        return new SVG.Point(this.native().matrixTransform(matrix.native()));\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Get point\n    point: function point(x, y) {\n      return new SVG.Point(x, y).transform(this.screenCTM().inverse());\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Set svg element attribute\n    attr: function attr(a, v, n) {\n      // act as full getter\n      if (a == null) {\n        // get an object of attributes\n        a = {};\n        v = this.node.attributes;\n\n        for (n = v.length - 1; n >= 0; n--) {\n          a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;\n        }\n\n        return a;\n      } else if (_typeof(a) === 'object') {\n        // apply every attribute individually if an object is passed\n        for (v in a) {\n          this.attr(v, a[v]);\n        }\n      } else if (v === null) {\n        // remove value\n        this.node.removeAttribute(a);\n      } else if (v == null) {\n        // act as a getter if the first and only argument is not an object\n        v = this.node.getAttribute(a);\n        return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;\n      } else {\n        // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\n        if (a == 'stroke-width') {\n          this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);\n        } else if (a == 'stroke') {\n          this._stroke = v;\n        } // convert image fill and stroke to patterns\n\n\n        if (a == 'fill' || a == 'stroke') {\n          if (SVG.regex.isImage.test(v)) {\n            v = this.doc().defs().image(v, 0, 0);\n          }\n\n          if (v instanceof SVG.Image) {\n            v = this.doc().defs().pattern(0, 0, function () {\n              this.add(v);\n            });\n          }\n        } // ensure correct numeric values (also accepts NaN and Infinity)\n\n\n        if (typeof v === 'number') {\n          v = new SVG.Number(v);\n        } // ensure full hex color\n        else if (SVG.Color.isColor(v)) {\n            v = new SVG.Color(v);\n          } // parse array values\n          else if (Array.isArray(v)) {\n              v = new SVG.Array(v);\n            } // if the passed attribute is leading...\n\n\n        if (a == 'leading') {\n          // ... call the leading method instead\n          if (this.leading) {\n            this.leading(v);\n          }\n        } else {\n          // set given attribute on node\n          typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());\n        } // rebuild if required\n\n\n        if (this.rebuild && (a == 'font-size' || a == 'x')) {\n          this.rebuild(a, v);\n        }\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Add transformations\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this,\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // get current matrix\n\n\n      matrix = new SVG.Matrix(target); // ensure relative flag\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = relative // relative\n        ? matrix.multiply(new SVG.Matrix(o)) // absolute\n        : new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = relative // relative\n        ? matrix.rotate(o.rotation, o.cx, o.cy) // absolute\n        : matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n\n        if (!relative) {\n          // absolute; multiply inversed values\n          var e = matrix.extract();\n          o.scaleX = o.scaleX * 1 / e.scaleX;\n          o.scaleY = o.scaleY * 1 / e.scaleY;\n        }\n\n        matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skew != null || o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0;\n\n        if (!relative) {\n          // absolute; reset skew values\n          var e = matrix.extract();\n          matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse());\n        }\n\n        matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        if (relative) {\n          // relative\n          matrix = matrix.translate(o.x, o.y);\n        } else {\n          // absolute\n          if (o.x != null) matrix.e = o.x;\n          if (o.y != null) matrix.f = o.y;\n        }\n      }\n\n      return this.attr('transform', matrix);\n    }\n  });\n  SVG.extend(SVG.FX, {\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this.target(),\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // ensure relative flag\n\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = new SVG.Rotate(o.rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n        matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skewY != null ? o.skewY : 0;\n        matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        matrix = new SVG.Translate(o.x, o.y);\n      }\n\n      if (!matrix) return this;\n      matrix.relative = relative;\n      this.last().transforms.push(matrix);\n      return this._callStart();\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Reset all transformations\n    untransform: function untransform() {\n      return this.attr('transform', null);\n    },\n    // merge the whole transformation chain into one matrix and returns it\n    matrixify: function matrixify() {\n      var matrix = (this.attr('transform') || ''). // split transformations\n      split(SVG.regex.transforms).slice(0, -1).map(function (str) {\n        // generate key => value pairs\n        var kv = str.trim().split('(');\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {\n          return parseFloat(str);\n        })];\n      }) // merge every transformation into one matrix\n      .reduce(function (matrix, transform) {\n        if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));\n        return matrix[transform[0]].apply(matrix, transform[1]);\n      }, new SVG.Matrix());\n      return matrix;\n    },\n    // add an element to another parent without changing the visual representation on the screen\n    toParent: function toParent(parent) {\n      if (this == parent) return this;\n      var ctm = this.screenCTM();\n      var pCtm = parent.screenCTM().inverse();\n      this.addTo(parent).untransform().transform(pCtm.multiply(ctm));\n      return this;\n    },\n    // same as above with parent equals root-svg\n    toDoc: function toDoc() {\n      return this.toParent(this.doc());\n    }\n  });\n  SVG.Transformation = SVG.invent({\n    create: function create(source, inversed) {\n      if (arguments.length > 1 && typeof inversed !== 'boolean') {\n        return this.constructor.call(this, [].slice.call(arguments));\n      }\n\n      if (Array.isArray(source)) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[i];\n        }\n      } else if (_typeof(source) === 'object') {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[this.arguments[i]];\n        }\n      }\n\n      this.inversed = false;\n\n      if (inversed === true) {\n        this.inversed = true;\n      }\n    },\n    extend: {\n      arguments: [],\n      method: '',\n      at: function at(pos) {\n        var params = [];\n\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          params.push(this[this.arguments[i]]);\n        }\n\n        var m = this._undo || new SVG.Matrix();\n        m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          o[this.arguments[i]] = typeof this[this.arguments[i]] === 'undefined' ? 0 : o[this.arguments[i]];\n        } // The method SVG.Matrix.extract which was used before calling this\n        // method to obtain a value for the parameter o doesn't return a cx and\n        // a cy so we use the ones that were provided to this object at its creation\n\n\n        o.cx = this.cx;\n        o.cy = this.cy;\n        this._undo = new SVG[capitalize(this.method)](o, true).at(1);\n        return this;\n      }\n    }\n  });\n  SVG.Translate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['transformedX', 'transformedY'],\n      method: 'translate'\n    }\n  });\n  SVG.Rotate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['rotation', 'cx', 'cy'],\n      method: 'rotate',\n      at: function at(pos) {\n        var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        this._undo = o;\n        return this;\n      }\n    }\n  });\n  SVG.Scale = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['scaleX', 'scaleY', 'cx', 'cy'],\n      method: 'scale'\n    }\n  });\n  SVG.Skew = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['skewX', 'skewY', 'cx', 'cy'],\n      method: 'skew'\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Dynamic style generator\n    style: function style(s, v) {\n      if (arguments.length == 0) {\n        // get full style\n        return this.node.style.cssText || '';\n      } else if (arguments.length < 2) {\n        // apply every style individually if an object is passed\n        if (_typeof(s) === 'object') {\n          for (v in s) {\n            this.style(v, s[v]);\n          }\n        } else if (SVG.regex.isCss.test(s)) {\n          // parse css string\n          s = s.split(/\\s*;\\s*/) // filter out suffix ; and stuff like ;;\n          .filter(function (e) {\n            return !!e;\n          }).map(function (e) {\n            return e.split(/\\s*:\\s*/);\n          }); // apply every definition individually\n\n          while (v = s.pop()) {\n            this.style(v[0], v[1]);\n          }\n        } else {\n          // act as a getter if the first and only argument is not an object\n          return this.node.style[camelCase(s)];\n        }\n      } else {\n        this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;\n      }\n\n      return this;\n    }\n  });\n  SVG.Parent = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Element,\n    // Add class methods\n    extend: {\n      // Returns all child elements\n      children: function children() {\n        return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {\n          return SVG.adopt(node);\n        });\n      },\n      // Add given element at a position\n      add: function add(element, i) {\n        if (i == null) {\n          this.node.appendChild(element.node);\n        } else if (element.node != this.node.childNodes[i]) {\n          this.node.insertBefore(element.node, this.node.childNodes[i]);\n        }\n\n        return this;\n      },\n      // Basically does the same as `add()` but returns the added element instead\n      put: function put(element, i) {\n        this.add(element, i);\n        return element;\n      },\n      // Checks if the given element is a child\n      has: function has(element) {\n        return this.index(element) >= 0;\n      },\n      // Gets index of given element\n      index: function index(element) {\n        return [].slice.call(this.node.childNodes).indexOf(element.node);\n      },\n      // Get a element at the given index\n      get: function get(i) {\n        return SVG.adopt(this.node.childNodes[i]);\n      },\n      // Get first child\n      first: function first() {\n        return this.get(0);\n      },\n      // Get the last child\n      last: function last() {\n        return this.get(this.node.childNodes.length - 1);\n      },\n      // Iterates over all children and invokes a given block\n      each: function each(block, deep) {\n        var i,\n            il,\n            children = this.children();\n\n        for (i = 0, il = children.length; i < il; i++) {\n          if (children[i] instanceof SVG.Element) {\n            block.apply(children[i], [i, children]);\n          }\n\n          if (deep && children[i] instanceof SVG.Container) {\n            children[i].each(block, deep);\n          }\n        }\n\n        return this;\n      },\n      // Remove a given child\n      removeElement: function removeElement(element) {\n        this.node.removeChild(element.node);\n        return this;\n      },\n      // Remove all elements in this container\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs;\n        return this;\n      },\n      // Get defs\n      defs: function defs() {\n        return this.doc().defs();\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    ungroup: function ungroup(parent, depth) {\n      if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;\n      parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));\n      depth = depth || Infinity;\n      this.each(function () {\n        if (this instanceof SVG.Defs) return this;\n        if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);\n        return this.toParent(parent);\n      });\n      this.node.firstChild || this.remove();\n      return this;\n    },\n    flatten: function flatten(parent, depth) {\n      return this.ungroup(parent, depth);\n    }\n  });\n  SVG.Container = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Parent\n  });\n  SVG.ViewBox = SVG.invent({\n    create: function create(source) {\n      var base = [0, 0, 0, 0];\n      var x,\n          y,\n          width,\n          height,\n          box,\n          view,\n          we,\n          he,\n          wm = 1,\n          // width multiplier\n      hm = 1,\n          // height multiplier\n      reg = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi;\n\n      if (source instanceof SVG.Element) {\n        we = source;\n        he = source;\n        view = (source.attr('viewBox') || '').match(reg);\n        box = source.bbox; // get dimensions of current node\n\n        width = new SVG.Number(source.width());\n        height = new SVG.Number(source.height()); // find nearest non-percentual dimensions\n\n        while (width.unit == '%') {\n          wm *= width.value;\n          width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());\n          we = we.parent();\n        }\n\n        while (height.unit == '%') {\n          hm *= height.value;\n          height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());\n          he = he.parent();\n        } // ensure defaults\n\n\n        this.x = 0;\n        this.y = 0;\n        this.width = width * wm;\n        this.height = height * hm;\n        this.zoom = 1;\n\n        if (view) {\n          // get width and height from viewbox\n          x = parseFloat(view[0]);\n          y = parseFloat(view[1]);\n          width = parseFloat(view[2]);\n          height = parseFloat(view[3]); // calculate zoom accoring to viewbox\n\n          this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width; // calculate real pixel dimensions on parent SVG.Doc element\n\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        }\n      } else {\n        // ensure source as object\n        source = typeof source === 'string' ? source.match(reg).map(function (el) {\n          return parseFloat(el);\n        }) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.x, source.y, source.width, source.height] : arguments.length == 4 ? [].slice.call(arguments) : base;\n        this.x = source[0];\n        this.y = source[1];\n        this.width = source[2];\n        this.height = source[3];\n      }\n    },\n    extend: {\n      toString: function toString() {\n        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n      },\n      morph: function morph(x, y, width, height) {\n        this.destination = new SVG.ViewBox(x, y, width, height);\n        return this;\n      },\n      at: function at(pos) {\n        if (!this.destination) return this;\n        return new SVG.ViewBox([this.x + (this.destination.x - this.x) * pos, this.y + (this.destination.y - this.y) * pos, this.width + (this.destination.width - this.width) * pos, this.height + (this.destination.height - this.height) * pos]);\n      }\n    },\n    // Define parent\n    parent: SVG.Container,\n    // Add parent method\n    construct: {\n      // get/set viewbox\n      viewbox: function viewbox(x, y, width, height) {\n        if (arguments.length == 0) // act as a getter if there are no arguments\n          {\n            return new SVG.ViewBox(this);\n          } // otherwise act as a setter\n\n\n        return this.attr('viewBox', new SVG.ViewBox(x, y, width, height));\n      }\n    }\n  }) // Add events to elements\n  ;\n  ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', // , 'mouseenter' -> not supported by IE\n  // , 'mouseleave' -> not supported by IE\n  'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {\n    // add event to SVG.Element\n    SVG.Element.prototype[event] = function (f) {\n      // bind event to element rather than element node\n      SVG.on(this.node, event, f);\n      return this;\n    };\n  }); // Initialize listeners stack\n\n  SVG.listeners = [];\n  SVG.handlerMap = [];\n  SVG.listenerId = 0; // Add event binder in the SVG namespace\n\n  SVG.on = function (node, event, listener, binding, options) {\n    // create listener, get object-index\n    var l = listener.bind(binding || node.instance || node),\n        index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,\n        ev = event.split('.')[0],\n        ns = event.split('.')[1] || '*'; // ensure valid object\n\n    SVG.listeners[index] = SVG.listeners[index] || {};\n    SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};\n    SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};\n\n    if (!listener._svgjsListenerId) {\n      listener._svgjsListenerId = ++SVG.listenerId;\n    } // reference listener\n\n\n    SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l; // add listener\n\n    node.addEventListener(ev, l, options || false);\n  }; // Add event unbinder in the SVG namespace\n\n\n  SVG.off = function (node, event, listener) {\n    var index = SVG.handlerMap.indexOf(node),\n        ev = event && event.split('.')[0],\n        ns = event && event.split('.')[1],\n        namespace = '';\n    if (index == -1) return;\n\n    if (listener) {\n      if (typeof listener === 'function') listener = listener._svgjsListenerId;\n      if (!listener) return; // remove listener reference\n\n      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\n        // remove listener\n        node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false);\n        delete SVG.listeners[index][ev][ns || '*'][listener];\n      }\n    } else if (ns && ev) {\n      // remove all listeners for a namespaced event\n      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\n        for (listener in SVG.listeners[index][ev][ns]) {\n          SVG.off(node, [ev, ns].join('.'), listener);\n        }\n\n        delete SVG.listeners[index][ev][ns];\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in SVG.listeners[index]) {\n        for (namespace in SVG.listeners[index][event]) {\n          if (ns === namespace) {\n            SVG.off(node, [event, ns].join('.'));\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (SVG.listeners[index][ev]) {\n        for (namespace in SVG.listeners[index][ev]) {\n          SVG.off(node, [ev, namespace].join('.'));\n        }\n\n        delete SVG.listeners[index][ev];\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in SVG.listeners[index]) {\n        SVG.off(node, event);\n      }\n\n      delete SVG.listeners[index];\n      delete SVG.handlerMap[index];\n    }\n  }; //\n\n\n  SVG.extend(SVG.Element, {\n    // Bind given event to listener\n    on: function on(event, listener, binding, options) {\n      SVG.on(this.node, event, listener, binding, options);\n      return this;\n    },\n    // Unbind event from listener\n    off: function off(event, listener) {\n      SVG.off(this.node, event, listener);\n      return this;\n    },\n    // Fire given event\n    fire: function fire(event, data) {\n      // Dispatch event\n      if (event instanceof window.Event) {\n        this.node.dispatchEvent(event);\n      } else {\n        this.node.dispatchEvent(event = new SVG.CustomEvent(event, {\n          detail: data,\n          cancelable: true\n        }));\n      }\n\n      this._event = event;\n      return this;\n    },\n    event: function event() {\n      return this._event;\n    }\n  });\n  SVG.Defs = SVG.invent({\n    // Initialize node\n    create: 'defs',\n    // Inherit from\n    inherit: SVG.Container\n  });\n  SVG.G = SVG.invent({\n    // Initialize node\n    create: 'g',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x3) {\n        return _x3 == null ? this.transform('x') : this.transform({\n          x: _x3 - this.x()\n        }, true);\n      },\n      // Move over y-axis\n      y: function y(_y3) {\n        return _y3 == null ? this.transform('y') : this.transform({\n          y: _y3 - this.y()\n        }, true);\n      },\n      // Move by center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2);\n      },\n      // Move by center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2);\n      },\n      gbox: function gbox() {\n        var bbox = this.bbox(),\n            trans = this.transform();\n        bbox.x += trans.x;\n        bbox.x2 += trans.x;\n        bbox.cx += trans.x;\n        bbox.y += trans.y;\n        bbox.y2 += trans.y;\n        bbox.cy += trans.y;\n        return bbox;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a group element\n      group: function group() {\n        return this.put(new SVG.G());\n      }\n    }\n  });\n  SVG.Doc = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      if (element) {\n        // ensure the presence of a dom element\n        element = typeof element === 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.\n        // This allows svg.js to work with svg documents as well.\n\n        if (element.nodeName == 'svg') {\n          this.constructor.call(this, element);\n        } else {\n          this.constructor.call(this, SVG.create('svg'));\n          element.appendChild(this.node);\n          this.size('100%', '100%');\n        } // set svg element attributes and ensure defs node\n\n\n        this.namespace().defs();\n      }\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Add namespaces\n      namespace: function namespace() {\n        return this.attr({\n          xmlns: SVG.ns,\n          version: '1.1'\n        }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);\n      },\n      // Creates and returns defs element\n      defs: function defs() {\n        if (!this._defs) {\n          var defs; // Find or create a defs element in this instance\n\n          if (defs = this.node.getElementsByTagName('defs')[0]) {\n            this._defs = SVG.adopt(defs);\n          } else {\n            this._defs = new SVG.Defs();\n          } // Make sure the defs node is at the end of the stack\n\n\n          this.node.appendChild(this._defs.node);\n        }\n\n        return this._defs;\n      },\n      // custom parent method\n      parent: function parent() {\n        if (!this.node.parentNode || this.node.parentNode.nodeName == '#document') return null;\n        return this.node.parentNode;\n      },\n      // Fix for possible sub-pixel offset. See:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\n      spof: function spof() {\n        var pos = this.node.getScreenCTM();\n\n        if (pos) {\n          this.style('left', -pos.e % 1 + 'px').style('top', -pos.f % 1 + 'px');\n        }\n\n        return this;\n      },\n      // Removes the doc from the DOM\n      remove: function remove() {\n        if (this.parent()) {\n          this.parent().removeChild(this.node);\n        }\n\n        return this;\n      },\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs; // add back parser\n\n        if (SVG.parser.draw && !SVG.parser.draw.parentNode) {\n          this.node.appendChild(SVG.parser.draw);\n        }\n\n        return this;\n      },\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // get reference to node\n\n        var node = this.node; // clone element and assign new id\n\n        var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) {\n          (parent.node || parent).appendChild(clone.node);\n        } else {\n          node.parentNode.insertBefore(clone.node, node.nextSibling);\n        }\n\n        return clone;\n      }\n    }\n  }); // ### This module adds backward / forward functionality to elements.\n  //\n\n  SVG.extend(SVG.Element, {\n    // Get all siblings, including myself\n    siblings: function siblings() {\n      return this.parent().children();\n    },\n    // Get the curent position siblings\n    position: function position() {\n      return this.parent().index(this);\n    },\n    // Get the next element (will return null if there is none)\n    next: function next() {\n      return this.siblings()[this.position() + 1];\n    },\n    // Get the next element (will return null if there is none)\n    previous: function previous() {\n      return this.siblings()[this.position() - 1];\n    },\n    // Send given element one step forward\n    forward: function forward() {\n      var i = this.position() + 1,\n          p = this.parent(); // move node one step forward\n\n      p.removeElement(this).add(this, i); // make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) {\n        p.node.appendChild(p.defs().node);\n      }\n\n      return this;\n    },\n    // Send given element one step backward\n    backward: function backward() {\n      var i = this.position();\n\n      if (i > 0) {\n        this.parent().removeElement(this).add(this, i - 1);\n      }\n\n      return this;\n    },\n    // Send given element all the way to the front\n    front: function front() {\n      var p = this.parent(); // Move node forward\n\n      p.node.appendChild(this.node); // Make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) {\n        p.node.appendChild(p.defs().node);\n      }\n\n      return this;\n    },\n    // Send given element all the way to the back\n    back: function back() {\n      if (this.position() > 0) {\n        this.parent().removeElement(this).add(this, 0);\n      }\n\n      return this;\n    },\n    // Inserts a given element before the targeted element\n    before: function before(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i);\n      return this;\n    },\n    // Insters a given element after the targeted element\n    after: function after(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i + 1);\n      return this;\n    }\n  });\n  SVG.Mask = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('mask')); // keep references to masked elements\n\n      this.targets = [];\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Unmask all masked elements and remove itself\n      remove: function remove() {\n        // unmask all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) {\n            this.targets[i].unmask();\n          }\n        }\n\n        this.targets = []; // remove mask from parent\n\n        SVG.Element.prototype.remove.call(this);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create masking element\n      mask: function mask() {\n        return this.defs().put(new SVG.Mask());\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Distribute mask to svg element\n    maskWith: function maskWith(element) {\n      // use given mask or create a new one\n      this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element); // store reverence on self in mask\n\n      this.masker.targets.push(this); // apply mask\n\n      return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")');\n    },\n    // Unmask element\n    unmask: function unmask() {\n      delete this.masker;\n      return this.attr('mask', null);\n    }\n  });\n  SVG.ClipPath = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('clipPath')); // keep references to clipped elements\n\n      this.targets = [];\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Unclip all clipped elements and remove itself\n      remove: function remove() {\n        // unclip all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) {\n            this.targets[i].unclip();\n          }\n        }\n\n        this.targets = []; // remove clipPath from parent\n\n        this.parent().removeElement(this);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create clipping element\n      clip: function clip() {\n        return this.defs().put(new SVG.ClipPath());\n      }\n    }\n  }); //\n\n  SVG.extend(SVG.Element, {\n    // Distribute clipPath to svg element\n    clipWith: function clipWith(element) {\n      // use given clip or create a new one\n      this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element); // store reverence on self in mask\n\n      this.clipper.targets.push(this); // apply mask\n\n      return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")');\n    },\n    // Unclip element\n    unclip: function unclip() {\n      delete this.clipper;\n      return this.attr('clip-path', null);\n    }\n  });\n  SVG.Gradient = SVG.invent({\n    // Initialize node\n    create: function create(type) {\n      this.constructor.call(this, SVG.create(type + 'Gradient')); // store type\n\n      this.type = type;\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Add a color stop\n      at: function at(offset, color, opacity) {\n        return this.put(new SVG.Stop()).update(offset, color, opacity);\n      },\n      // Update gradient\n      update: function update(block) {\n        // remove all stops\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Return the fill id\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      },\n      // Alias string convertion to fill\n      toString: function toString() {\n        return this.fill();\n      },\n      // custom attr to handle transform\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'gradientTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create gradient element in defs\n      gradient: function gradient(type, block) {\n        return this.defs().gradient(type, block);\n      }\n    }\n  }); // Add animatable methods to both gradient and fx module\n\n  SVG.extend(SVG.Gradient, SVG.FX, {\n    // From position\n    from: function from(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        fx: new SVG.Number(x),\n        fy: new SVG.Number(y)\n      }) : this.attr({\n        x1: new SVG.Number(x),\n        y1: new SVG.Number(y)\n      });\n    },\n    // To position\n    to: function to(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        cx: new SVG.Number(x),\n        cy: new SVG.Number(y)\n      }) : this.attr({\n        x2: new SVG.Number(x),\n        y2: new SVG.Number(y)\n      });\n    }\n  }); // Base gradient generation\n\n  SVG.extend(SVG.Defs, {\n    // define gradient\n    gradient: function gradient(type, block) {\n      return this.put(new SVG.Gradient(type)).update(block);\n    }\n  });\n  SVG.Stop = SVG.invent({\n    // Initialize node\n    create: 'stop',\n    // Inherit from\n    inherit: SVG.Element,\n    // Add class methods\n    extend: {\n      // add color stops\n      update: function update(o) {\n        if (typeof o === 'number' || o instanceof SVG.Number) {\n          o = {\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          };\n        } // set attributes\n\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));\n        return this;\n      }\n    }\n  });\n  SVG.Pattern = SVG.invent({\n    // Initialize node\n    create: 'pattern',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Return the fill id\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      },\n      // Update pattern by rebuilding\n      update: function update(block) {\n        // remove content\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Alias string convertion to fill\n      toString: function toString() {\n        return this.fill();\n      },\n      // custom attr to handle transform\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'patternTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create pattern element in defs\n      pattern: function pattern(width, height, block) {\n        return this.defs().pattern(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Define gradient\n    pattern: function pattern(width, height, block) {\n      return this.put(new SVG.Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    }\n  });\n  SVG.Shape = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    },\n    // Inherit from\n    inherit: SVG.Element\n  });\n  SVG.Bare = SVG.invent({\n    // Initialize\n    create: function create(element, inherit) {\n      // construct element\n      this.constructor.call(this, SVG.create(element)); // inherit custom methods\n\n      if (inherit) {\n        for (var method in inherit.prototype) {\n          if (typeof inherit.prototype[method] === 'function') {\n            this[method] = inherit.prototype[method];\n          }\n        }\n      }\n    },\n    // Inherit from\n    inherit: SVG.Element,\n    // Add methods\n    extend: {\n      // Insert some plain text\n      words: function words(text) {\n        // remove contents\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // create text node\n\n\n        this.node.appendChild(document.createTextNode(text));\n        return this;\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    // Create an element that is not described by SVG.js\n    element: function element(_element, inherit) {\n      return this.put(new SVG.Bare(_element, inherit));\n    }\n  });\n  SVG.Symbol = SVG.invent({\n    // Initialize node\n    create: 'symbol',\n    // Inherit from\n    inherit: SVG.Container,\n    construct: {\n      // create symbol\n      symbol: function symbol() {\n        return this.put(new SVG.Symbol());\n      }\n    }\n  });\n  SVG.Use = SVG.invent({\n    // Initialize node\n    create: 'use',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Use element as a reference\n      element: function element(_element2, file) {\n        // Set lined element\n        return this.attr('href', (file || '') + '#' + _element2, SVG.xlink);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a use element\n      use: function use(element, file) {\n        return this.put(new SVG.Use()).element(element, file);\n      }\n    }\n  });\n  SVG.Rect = SVG.invent({\n    // Initialize node\n    create: 'rect',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a rect element\n      rect: function rect(width, height) {\n        return this.put(new SVG.Rect()).size(width, height);\n      }\n    }\n  });\n  SVG.Circle = SVG.invent({\n    // Initialize node\n    create: 'circle',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create circle element, based on ellipse\n      circle: function circle(size) {\n        return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Circle, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx) {\n      return this.attr('r', _rx);\n    },\n    // Alias radius x value\n    ry: function ry(_ry) {\n      return this.rx(_ry);\n    }\n  });\n  SVG.Ellipse = SVG.invent({\n    // Initialize node\n    create: 'ellipse',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create an ellipse\n      ellipse: function ellipse(width, height) {\n        return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx2) {\n      return this.attr('rx', _rx2);\n    },\n    // Radius y value\n    ry: function ry(_ry2) {\n      return this.attr('ry', _ry2);\n    }\n  }); // Add common method\n\n  SVG.extend(SVG.Circle, SVG.Ellipse, {\n    // Move over x-axis\n    x: function x(_x4) {\n      return _x4 == null ? this.cx() - this.rx() : this.cx(_x4 + this.rx());\n    },\n    // Move over y-axis\n    y: function y(_y4) {\n      return _y4 == null ? this.cy() - this.ry() : this.cy(_y4 + this.ry());\n    },\n    // Move by center over x-axis\n    cx: function cx(x) {\n      return x == null ? this.attr('cx') : this.attr('cx', x);\n    },\n    // Move by center over y-axis\n    cy: function cy(y) {\n      return y == null ? this.attr('cy') : this.attr('cy', y);\n    },\n    // Set width of element\n    width: function width(_width3) {\n      return _width3 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width3).divide(2));\n    },\n    // Set height of element\n    height: function height(_height3) {\n      return _height3 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height3).divide(2));\n    },\n    // Custom size function\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));\n    }\n  });\n  SVG.Line = SVG.invent({\n    // Initialize node\n    create: 'line',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Get array\n      array: function array() {\n        return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n      },\n      // Overwrite native plot() method\n      plot: function plot(x1, y1, x2, y2) {\n        if (x1 == null) {\n          return this.array();\n        } else if (typeof y1 !== 'undefined') {\n          x1 = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n          };\n        } else {\n          x1 = new SVG.PointArray(x1).toLine();\n        }\n\n        return this.attr(x1);\n      },\n      // Move by left top corner\n      move: function move(x, y) {\n        return this.attr(this.array().move(x, y).toLine());\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr(this.array().size(p.width, p.height).toLine());\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a line element\n      line: function line(x1, y1, x2, y2) {\n        // make sure plot is called as a setter\n        // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\n        return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);\n      }\n    }\n  });\n  SVG.Polyline = SVG.invent({\n    // Initialize node\n    create: 'polyline',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a wrapped polyline element\n      polyline: function polyline(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());\n      }\n    }\n  });\n  SVG.Polygon = SVG.invent({\n    // Initialize node\n    create: 'polygon',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add parent method\n    construct: {\n      // Create a wrapped polygon element\n      polygon: function polygon(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());\n      }\n    }\n  }); // Add polygon-specific functions\n\n  SVG.extend(SVG.Polyline, SVG.Polygon, {\n    // Get array\n    array: function array() {\n      return this._array || (this._array = new SVG.PointArray(this.attr('points')));\n    },\n    // Plot new path\n    plot: function plot(p) {\n      return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new SVG.PointArray(p));\n    },\n    // Clear array cache\n    clear: function clear() {\n      delete this._array;\n      return this;\n    },\n    // Move by left top corner\n    move: function move(x, y) {\n      return this.attr('points', this.array().move(x, y));\n    },\n    // Set element size to given width and height\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.attr('points', this.array().size(p.width, p.height));\n    }\n  }); // unify all point to point elements\n\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\n    // Define morphable array\n    morphArray: SVG.PointArray,\n    // Move by left top corner over x-axis\n    x: function x(_x5) {\n      return _x5 == null ? this.bbox().x : this.move(_x5, this.bbox().y);\n    },\n    // Move by left top corner over y-axis\n    y: function y(_y5) {\n      return _y5 == null ? this.bbox().y : this.move(this.bbox().x, _y5);\n    },\n    // Set width of element\n    width: function width(_width4) {\n      var b = this.bbox();\n      return _width4 == null ? b.width : this.size(_width4, b.height);\n    },\n    // Set height of element\n    height: function height(_height4) {\n      var b = this.bbox();\n      return _height4 == null ? b.height : this.size(b.width, _height4);\n    }\n  });\n  SVG.Path = SVG.invent({\n    // Initialize node\n    create: 'path',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Define morphable array\n      morphArray: SVG.PathArray,\n      // Get array\n      array: function array() {\n        return this._array || (this._array = new SVG.PathArray(this.attr('d')));\n      },\n      // Plot new path\n      plot: function plot(d) {\n        return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new SVG.PathArray(d));\n      },\n      // Clear array cache\n      clear: function clear() {\n        delete this._array;\n        return this;\n      },\n      // Move by left top corner\n      move: function move(x, y) {\n        return this.attr('d', this.array().move(x, y));\n      },\n      // Move by left top corner over x-axis\n      x: function x(_x6) {\n        return _x6 == null ? this.bbox().x : this.move(_x6, this.bbox().y);\n      },\n      // Move by left top corner over y-axis\n      y: function y(_y6) {\n        return _y6 == null ? this.bbox().y : this.move(this.bbox().x, _y6);\n      },\n      // Set element size to given width and height\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr('d', this.array().size(p.width, p.height));\n      },\n      // Set width of element\n      width: function width(_width5) {\n        return _width5 == null ? this.bbox().width : this.size(_width5, this.bbox().height);\n      },\n      // Set height of element\n      height: function height(_height5) {\n        return _height5 == null ? this.bbox().height : this.size(this.bbox().width, _height5);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a wrapped path element\n      path: function path(d) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Path()).plot(d || new SVG.PathArray());\n      }\n    }\n  });\n  SVG.Image = SVG.invent({\n    // Initialize node\n    create: 'image',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // (re)load image\n      load: function load(url) {\n        if (!url) return this;\n        var self = this,\n            img = new window.Image(); // preload image\n\n        SVG.on(img, 'load', function () {\n          SVG.off(img);\n          var p = self.parent(SVG.Pattern);\n          if (p === null) return; // ensure image size\n\n          if (self.width() == 0 && self.height() == 0) {\n            self.size(img.width, img.height);\n          } // ensure pattern size if not set\n\n\n          if (p && p.width() == 0 && p.height() == 0) {\n            p.size(self.width(), self.height());\n          } // callback\n\n\n          if (typeof self._loaded === 'function') {\n            self._loaded.call(self, {\n              width: img.width,\n              height: img.height,\n              ratio: img.width / img.height,\n              url: url\n            });\n          }\n        });\n        SVG.on(img, 'error', function (e) {\n          SVG.off(img);\n\n          if (typeof self._error === 'function') {\n            self._error.call(self, e);\n          }\n        });\n        return this.attr('href', img.src = this.src = url, SVG.xlink);\n      },\n      // Add loaded callback\n      loaded: function loaded(_loaded) {\n        this._loaded = _loaded;\n        return this;\n      },\n      error: function error(_error) {\n        this._error = _error;\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // create image element, load image and set its size\n      image: function image(source, width, height) {\n        return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);\n      }\n    }\n  });\n  SVG.Text = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('text'));\n      this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding\n\n      this._rebuild = true; // enable automatic updating of dy values\n\n      this._build = false; // disable build mode for adding multiple lines\n      // set default font\n\n      this.attr('font-family', SVG.defaults.attrs['font-family']);\n    },\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Move over x-axis\n      x: function x(_x7) {\n        // act as getter\n        if (_x7 == null) {\n          return this.attr('x');\n        }\n\n        return this.attr('x', _x7);\n      },\n      // Move over y-axis\n      y: function y(_y7) {\n        var oy = this.attr('y'),\n            o = typeof oy === 'number' ? oy - this.bbox().y : 0; // act as getter\n\n        if (_y7 == null) {\n          return typeof oy === 'number' ? oy - o : oy;\n        }\n\n        return this.attr('y', typeof _y7.valueOf() === 'number' ? _y7 + o : _y7);\n      },\n      // Move center over x-axis\n      cx: function cx(x) {\n        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2);\n      },\n      // Move center over y-axis\n      cy: function cy(y) {\n        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2);\n      },\n      // Set the text content\n      text: function text(_text) {\n        // act as getter\n        if (typeof _text === 'undefined') {\n          var _text = '';\n          var children = this.node.childNodes;\n\n          for (var i = 0, len = children.length; i < len; ++i) {\n            // add newline if its not the first child and newLined is set to true\n            if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {\n              _text += '\\n';\n            } // add content of this node\n\n\n            _text += children[i].textContent;\n          }\n\n          return _text;\n        } // remove existing content\n\n\n        this.clear().build(true);\n\n        if (typeof _text === 'function') {\n          // call block\n          _text.call(this, this);\n        } else {\n          // store text and make sure text is not blank\n          _text = _text.split('\\n'); // build new lines\n\n          for (var i = 0, il = _text.length; i < il; i++) {\n            this.tspan(_text[i]).newLine();\n          }\n        } // disable build mode and rebuild lines\n\n\n        return this.build(false).rebuild();\n      },\n      // Set font size\n      size: function size(_size) {\n        return this.attr('font-size', _size).rebuild();\n      },\n      // Set / get leading\n      leading: function leading(value) {\n        // act as getter\n        if (value == null) {\n          return this.dom.leading;\n        } // act as setter\n\n\n        this.dom.leading = new SVG.Number(value);\n        return this.rebuild();\n      },\n      // Get all the first level lines\n      lines: function lines() {\n        var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances\n\n        var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {\n          return SVG.adopt(el);\n        }); // return an instance of SVG.set\n\n        return new SVG.Set(lines);\n      },\n      // Rebuild appearance type\n      rebuild: function rebuild(_rebuild) {\n        // store new rebuild flag if given\n        if (typeof _rebuild === 'boolean') {\n          this._rebuild = _rebuild;\n        } // define position of all lines\n\n\n        if (this._rebuild) {\n          var self = this,\n              blankLineOffset = 0,\n              dy = this.dom.leading * new SVG.Number(this.attr('font-size'));\n          this.lines().each(function () {\n            if (this.dom.newLined) {\n              if (!self.textPath()) {\n                this.attr('x', self.attr('x'));\n              }\n\n              if (this.text() == '\\n') {\n                blankLineOffset += dy;\n              } else {\n                this.attr('dy', dy + blankLineOffset);\n                blankLineOffset = 0;\n              }\n            }\n          });\n          this.fire('rebuild');\n        }\n\n        return this;\n      },\n      // Enable / disable build mode\n      build: function build(_build) {\n        this._build = !!_build;\n        return this;\n      },\n      // overwrite method from parent to set data properly\n      setData: function setData(o) {\n        this.dom = o;\n        this.dom.leading = new SVG.Number(o.leading || 1.3);\n        return this;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create text element\n      text: function text(_text2) {\n        return this.put(new SVG.Text()).text(_text2);\n      },\n      // Create plain text element\n      plain: function plain(text) {\n        return this.put(new SVG.Text()).plain(text);\n      }\n    }\n  });\n  SVG.Tspan = SVG.invent({\n    // Initialize node\n    create: 'tspan',\n    // Inherit from\n    inherit: SVG.Shape,\n    // Add class methods\n    extend: {\n      // Set text content\n      text: function text(_text3) {\n        if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n        typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);\n        return this;\n      },\n      // Shortcut dx\n      dx: function dx(_dx) {\n        return this.attr('dx', _dx);\n      },\n      // Shortcut dy\n      dy: function dy(_dy) {\n        return this.attr('dy', _dy);\n      },\n      // Create new line\n      newLine: function newLine() {\n        // fetch text parent\n        var t = this.parent(SVG.Text); // mark new line\n\n        this.dom.newLined = true; // apply new hy¡n\n\n        return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());\n      }\n    }\n  });\n  SVG.extend(SVG.Text, SVG.Tspan, {\n    // Create plain text node\n    plain: function plain(text) {\n      // clear if build mode is disabled\n      if (this._build === false) {\n        this.clear();\n      } // create text node\n\n\n      this.node.appendChild(document.createTextNode(text));\n      return this;\n    },\n    // Create a tspan\n    tspan: function tspan(text) {\n      var node = (this.textPath && this.textPath() || this).node,\n          tspan = new SVG.Tspan(); // clear if build mode is disabled\n\n      if (this._build === false) {\n        this.clear();\n      } // add new tspan\n\n\n      node.appendChild(tspan.node);\n      return tspan.text(text);\n    },\n    // Clear all lines\n    clear: function clear() {\n      var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes\n\n      while (node.hasChildNodes()) {\n        node.removeChild(node.lastChild);\n      }\n\n      return this;\n    },\n    // Get length of text element\n    length: function length() {\n      return this.node.getComputedTextLength();\n    }\n  });\n  SVG.TextPath = SVG.invent({\n    // Initialize node\n    create: 'textPath',\n    // Inherit from\n    inherit: SVG.Parent,\n    // Define parent class\n    parent: SVG.Text,\n    // Add parent method\n    construct: {\n      morphArray: SVG.PathArray,\n      // Create path for text to run on\n      path: function path(d) {\n        // create textPath element\n        var path = new SVG.TextPath(),\n            track = this.doc().defs().path(d); // move lines to textpath\n\n        while (this.node.hasChildNodes()) {\n          path.node.appendChild(this.node.firstChild);\n        } // add textPath element as child node\n\n\n        this.node.appendChild(path.node); // link textPath to path and add content\n\n        path.attr('href', '#' + track, SVG.xlink);\n        return this;\n      },\n      // return the array of the path track element\n      array: function array() {\n        var track = this.track();\n        return track ? track.array() : null;\n      },\n      // Plot path if any\n      plot: function plot(d) {\n        var track = this.track(),\n            pathArray = null;\n\n        if (track) {\n          pathArray = track.plot(d);\n        }\n\n        return d == null ? pathArray : this;\n      },\n      // Get the path track element\n      track: function track() {\n        var path = this.textPath();\n\n        if (path) {\n          return path.reference('href');\n        }\n      },\n      // Get the textPath child\n      textPath: function textPath() {\n        if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') {\n          return SVG.adopt(this.node.firstChild);\n        }\n      }\n    }\n  });\n  SVG.Nested = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('svg'));\n      this.style('overflow', 'visible');\n    },\n    // Inherit from\n    inherit: SVG.Container,\n    // Add parent method\n    construct: {\n      // Create nested svg document\n      nested: function nested() {\n        return this.put(new SVG.Nested());\n      }\n    }\n  });\n  SVG.A = SVG.invent({\n    // Initialize node\n    create: 'a',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Link url\n      to: function to(url) {\n        return this.attr('href', url, SVG.xlink);\n      },\n      // Link show attribute\n      show: function show(target) {\n        return this.attr('show', target, SVG.xlink);\n      },\n      // Link target attribute\n      target: function target(_target2) {\n        return this.attr('target', _target2);\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a hyperlink element\n      link: function link(url) {\n        return this.put(new SVG.A()).to(url);\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Create a hyperlink element\n    linkTo: function linkTo(url) {\n      var link = new SVG.A();\n\n      if (typeof url === 'function') {\n        url.call(link, link);\n      } else {\n        link.to(url);\n      }\n\n      return this.parent().put(link).put(this);\n    }\n  });\n  SVG.Marker = SVG.invent({\n    // Initialize node\n    create: 'marker',\n    // Inherit from\n    inherit: SVG.Container,\n    // Add class methods\n    extend: {\n      // Set width of element\n      width: function width(_width6) {\n        return this.attr('markerWidth', _width6);\n      },\n      // Set height of element\n      height: function height(_height6) {\n        return this.attr('markerHeight', _height6);\n      },\n      // Set marker refX and refY\n      ref: function ref(x, y) {\n        return this.attr('refX', x).attr('refY', y);\n      },\n      // Update marker\n      update: function update(block) {\n        // remove all content\n        this.clear(); // invoke passed block\n\n        if (typeof block === 'function') {\n          block.call(this, this);\n        }\n\n        return this;\n      },\n      // Return the fill id\n      toString: function toString() {\n        return 'url(#' + this.id() + ')';\n      }\n    },\n    // Add parent method\n    construct: {\n      marker: function marker(width, height, block) {\n        // Create marker element in defs\n        return this.defs().marker(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Create marker\n    marker: function marker(width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new SVG.Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    }\n  });\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\n    // Create and attach markers\n    marker: function marker(_marker, width, height, block) {\n      var attr = ['marker']; // Build attribute name\n\n      if (_marker != 'all') attr.push(_marker);\n      attr = attr.join('-'); // Set marker attribute\n\n      _marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);\n      return this.attr(attr, _marker);\n    }\n  }); // Define list of available attributes for stroke and fill\n\n  var sugar = {\n    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n    fill: ['color', 'opacity', 'rule'],\n    prefix: function prefix(t, a) {\n      return a == 'color' ? t : t + '-' + a;\n    } // Add sugar for fill and stroke\n\n  };\n  ['fill', 'stroke'].forEach(function (m) {\n    var i,\n        extension = {};\n\n    extension[m] = function (o) {\n      if (typeof o === 'undefined') {\n        return this;\n      }\n\n      if (typeof o === 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') {\n        this.attr(m, o);\n      } else // set all attributes from sugar.fill and sugar.stroke list\n        {\n          for (i = sugar[m].length - 1; i >= 0; i--) {\n            if (o[sugar[m][i]] != null) {\n              this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n            }\n          }\n        }\n\n      return this;\n    };\n\n    SVG.extend(SVG.Element, SVG.FX, extension);\n  });\n  SVG.extend(SVG.Element, SVG.FX, {\n    // Map rotation to transform\n    rotate: function rotate(d, cx, cy) {\n      return this.transform({\n        rotation: d,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map skew to transform\n    skew: function skew(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        skew: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        skewX: x,\n        skewY: y,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map scale to transform\n    scale: function scale(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        scale: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        scaleX: x,\n        scaleY: y,\n        cx: cx,\n        cy: cy\n      });\n    },\n    // Map translate to transform\n    translate: function translate(x, y) {\n      return this.transform({\n        x: x,\n        y: y\n      });\n    },\n    // Map flip to transform\n    flip: function flip(a, o) {\n      o = typeof a === 'number' ? a : o;\n      return this.transform({\n        flip: a || 'both',\n        offset: o\n      });\n    },\n    // Map matrix to transform\n    matrix: function matrix(m) {\n      return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));\n    },\n    // Opacity\n    opacity: function opacity(value) {\n      return this.attr('opacity', value);\n    },\n    // Relative move over x axis\n    dx: function dx(x) {\n      return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);\n    },\n    // Relative move over y axis\n    dy: function dy(y) {\n      return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);\n    },\n    // Relative move over x and y axes\n    dmove: function dmove(x, y) {\n      return this.dx(x).dy(y);\n    }\n  });\n  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\n    // Add x and y radius\n    radius: function radius(x, y) {\n      var type = (this._target || this).type;\n      return type == 'radial' || type == 'circle' ? this.attr('r', new SVG.Number(x)) : this.rx(x).ry(y == null ? x : y);\n    }\n  });\n  SVG.extend(SVG.Path, {\n    // Get path length\n    length: function length() {\n      return this.node.getTotalLength();\n    },\n    // Get point at length\n    pointAt: function pointAt(length) {\n      return this.node.getPointAtLength(length);\n    }\n  });\n  SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\n    // Set font\n    font: function font(a, v) {\n      if (_typeof(a) === 'object') {\n        for (v in a) {\n          this.font(v, a[v]);\n        }\n      }\n\n      return a == 'leading' ? this.leading(v) : a == 'anchor' ? this.attr('text-anchor', v) : a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n    }\n  });\n  SVG.Set = SVG.invent({\n    // Initialize\n    create: function create(members) {\n      // Set initial state\n      Array.isArray(members) ? this.members = members : this.clear();\n    },\n    // Add class methods\n    extend: {\n      // Add element to set\n      add: function add() {\n        var i,\n            il,\n            elements = [].slice.call(arguments);\n\n        for (i = 0, il = elements.length; i < il; i++) {\n          this.members.push(elements[i]);\n        }\n\n        return this;\n      },\n      // Remove element from set\n      remove: function remove(element) {\n        var i = this.index(element); // remove given child\n\n        if (i > -1) {\n          this.members.splice(i, 1);\n        }\n\n        return this;\n      },\n      // Iterate over all members\n      each: function each(block) {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          block.apply(this.members[i], [i, this.members]);\n        }\n\n        return this;\n      },\n      // Restore to defaults\n      clear: function clear() {\n        // initialize store\n        this.members = [];\n        return this;\n      },\n      // Get the length of a set\n      length: function length() {\n        return this.members.length;\n      },\n      // Checks if a given element is present in set\n      has: function has(element) {\n        return this.index(element) >= 0;\n      },\n      // retuns index of given element in set\n      index: function index(element) {\n        return this.members.indexOf(element);\n      },\n      // Get member at given index\n      get: function get(i) {\n        return this.members[i];\n      },\n      // Get first member\n      first: function first() {\n        return this.get(0);\n      },\n      // Get last member\n      last: function last() {\n        return this.get(this.members.length - 1);\n      },\n      // Default value\n      valueOf: function valueOf() {\n        return this.members;\n      },\n      // Get the bounding box of all members included or empty box if set has no items\n      bbox: function bbox() {\n        // return an empty box of there are no members\n        if (this.members.length == 0) {\n          return new SVG.RBox();\n        } // get the first rbox and update the target bbox\n\n\n        var rbox = this.members[0].rbox(this.members[0].doc());\n        this.each(function () {\n          // user rbox for correct position and visual representation\n          rbox = rbox.merge(this.rbox(this.doc()));\n        });\n        return rbox;\n      }\n    },\n    // Add parent method\n    construct: {\n      // Create a new set\n      set: function set(members) {\n        return new SVG.Set(members);\n      }\n    }\n  });\n  SVG.FX.Set = SVG.invent({\n    // Initialize node\n    create: function create(set) {\n      // store reference to set\n      this.set = set;\n    }\n  }); // Alias methods\n\n  SVG.Set.inherit = function () {\n    var m,\n        methods = []; // gather shape methods\n\n    for (var m in SVG.Shape.prototype) {\n      if (typeof SVG.Shape.prototype[m] === 'function' && typeof SVG.Set.prototype[m] !== 'function') {\n        methods.push(m);\n      }\n    } // apply shape aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.Set.prototype[method] = function () {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          if (this.members[i] && typeof this.members[i][method] === 'function') {\n            this.members[i][method].apply(this.members[i], arguments);\n          }\n        }\n\n        return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;\n      };\n    }); // clear methods for the next round\n\n    methods = []; // gather fx methods\n\n    for (var m in SVG.FX.prototype) {\n      if (typeof SVG.FX.prototype[m] === 'function' && typeof SVG.FX.Set.prototype[m] !== 'function') {\n        methods.push(m);\n      }\n    } // apply fx aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.FX.Set.prototype[method] = function () {\n        for (var i = 0, il = this.set.members.length; i < il; i++) {\n          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);\n        }\n\n        return this;\n      };\n    });\n  };\n\n  SVG.extend(SVG.Element, {\n    // Store data values on svg nodes\n    data: function data(a, v, r) {\n      if (_typeof(a) === 'object') {\n        for (v in a) {\n          this.data(v, a[v]);\n        }\n      } else if (arguments.length < 2) {\n        try {\n          return JSON.parse(this.attr('data-' + a));\n        } catch (e) {\n          return this.attr('data-' + a);\n        }\n      } else {\n        this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Remember arbitrary data\n    remember: function remember(k, v) {\n      // remember every item in an object individually\n      if (_typeof(arguments[0]) === 'object') {\n        for (var v in k) {\n          this.remember(v, k[v]);\n        }\n      } // retrieve memory\n      else if (arguments.length == 1) {\n          return this.memory()[k];\n        } // store memory\n        else {\n            this.memory()[k] = v;\n          }\n\n      return this;\n    },\n    // Erase a given memory\n    forget: function forget() {\n      if (arguments.length == 0) {\n        this._memory = {};\n      } else {\n        for (var i = arguments.length - 1; i >= 0; i--) {\n          delete this.memory()[arguments[i]];\n        }\n      }\n\n      return this;\n    },\n    // Initialize or return local memory object\n    memory: function memory() {\n      return this._memory || (this._memory = {});\n    }\n  }); // Method for getting an element by id\n\n  SVG.get = function (id) {\n    var node = document.getElementById(idFromReference(id) || id);\n    return SVG.adopt(node);\n  }; // Select elements by query string\n\n\n  SVG.select = function (query, parent) {\n    return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {\n      return SVG.adopt(node);\n    }));\n  };\n\n  SVG.extend(SVG.Parent, {\n    // Scoped select method\n    select: function select(query) {\n      return SVG.select(query, this.node);\n    }\n  });\n\n  function pathRegReplace(a, b, c, d) {\n    return c + d.replace(SVG.regex.dots, ' .');\n  } // creates deep clone of array\n\n\n  function array_clone(arr) {\n    var clone = arr.slice(0);\n\n    for (var i = clone.length; i--;) {\n      if (Array.isArray(clone[i])) {\n        clone[i] = array_clone(clone[i]);\n      }\n    }\n\n    return clone;\n  } // tests if a given element is instance of an object\n\n\n  function _is(el, obj) {\n    return el instanceof obj;\n  } // tests if a given selector matches an element\n\n\n  function _matches(el, selector) {\n    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n  } // Convert dash-separated-string to camelCase\n\n\n  function camelCase(s) {\n    return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n      return g.toUpperCase();\n    });\n  } // Capitalize first letter of a string\n\n\n  function capitalize(s) {\n    return s.charAt(0).toUpperCase() + s.slice(1);\n  } // Ensure to six-based hex\n\n\n  function fullHex(hex) {\n    return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n  } // Component to hex value\n\n\n  function compToHex(comp) {\n    var hex = comp.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n  } // Calculate proportional width and height values when necessary\n\n\n  function proportionalSize(element, width, height) {\n    if (width == null || height == null) {\n      var box = element.bbox();\n\n      if (width == null) {\n        width = box.width / box.height * height;\n      } else if (height == null) {\n        height = box.height / box.width * width;\n      }\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  } // Delta transform point\n\n\n  function deltaTransformPoint(matrix, x, y) {\n    return {\n      x: x * matrix.a + y * matrix.c + 0,\n      y: x * matrix.b + y * matrix.d + 0\n    };\n  } // Map matrix array to object\n\n\n  function arrayToMatrix(a) {\n    return {\n      a: a[0],\n      b: a[1],\n      c: a[2],\n      d: a[3],\n      e: a[4],\n      f: a[5]\n    };\n  } // Parse matrix if required\n\n\n  function parseMatrix(matrix) {\n    if (!(matrix instanceof SVG.Matrix)) {\n      matrix = new SVG.Matrix(matrix);\n    }\n\n    return matrix;\n  } // Add centre point to transform object\n\n\n  function ensureCentre(o, target) {\n    o.cx = o.cx == null ? target.bbox().cx : o.cx;\n    o.cy = o.cy == null ? target.bbox().cy : o.cy;\n  } // PathArray Helpers\n\n\n  function arrayToString(a) {\n    for (var i = 0, il = a.length, s = ''; i < il; i++) {\n      s += a[i][0];\n\n      if (a[i][1] != null) {\n        s += a[i][1];\n\n        if (a[i][2] != null) {\n          s += ' ';\n          s += a[i][2];\n\n          if (a[i][3] != null) {\n            s += ' ';\n            s += a[i][3];\n            s += ' ';\n            s += a[i][4];\n\n            if (a[i][5] != null) {\n              s += ' ';\n              s += a[i][5];\n              s += ' ';\n              s += a[i][6];\n\n              if (a[i][7] != null) {\n                s += ' ';\n                s += a[i][7];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s + ' ';\n  } // Deep new id assignment\n\n\n  function assignNewId(node) {\n    // do the same for SVG child nodes as well\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      if (node.childNodes[i] instanceof window.SVGElement) {\n        assignNewId(node.childNodes[i]);\n      }\n    }\n\n    return SVG.adopt(node).id(SVG.eid(node.nodeName));\n  } // Add more bounding box properties\n\n\n  function fullBox(b) {\n    if (b.x == null) {\n      b.x = 0;\n      b.y = 0;\n      b.width = 0;\n      b.height = 0;\n    }\n\n    b.w = b.width;\n    b.h = b.height;\n    b.x2 = b.x + b.width;\n    b.y2 = b.y + b.height;\n    b.cx = b.x + b.width / 2;\n    b.cy = b.y + b.height / 2;\n    return b;\n  } // Get id from reference string\n\n\n  function idFromReference(url) {\n    var m = (url || '').toString().match(SVG.regex.reference);\n    if (m) return m[1];\n  } // If values like 1e-88 are passed, this is not a valid 32 bit float,\n  // but in those cases, we are so close to 0 that 0 works well!\n\n\n  function float32String(v) {\n    return Math.abs(v) > 1e-37 ? v : 0;\n  } // Create matrix array for looping\n\n\n  var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10\n\n  if (typeof window.CustomEvent !== 'function') {\n    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n    var CustomEventPoly = function CustomEventPoly(event, options) {\n      options = options || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var e = document.createEvent('CustomEvent');\n      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);\n      return e;\n    };\n\n    CustomEventPoly.prototype = window.Event.prototype;\n    SVG.CustomEvent = CustomEventPoly;\n  } else {\n    SVG.CustomEvent = window.CustomEvent;\n  } // requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\n\n\n  (function (w) {\n    var lastTime = 0;\n    var vendors = ['moz', 'webkit'];\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n      w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];\n      w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'] || w[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    w.requestAnimationFrame = w.requestAnimationFrame || function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = w.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n    w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\n  })(window);\n\n  return SVG;\n});\n\n/*! svg.filter.js - v2.0.2 - 2016-02-24\r\n* https://github.com/wout/svg.filter.js\r\n* Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n(function() {\r\n\r\n  // Main filter class\r\n  SVG.Filter = SVG.invent({\r\n    create: 'filter',\r\n    inherit: SVG.Parent,\r\n    extend: {\r\n      // Static strings\r\n      source:           'SourceGraphic',\r\n      sourceAlpha:      'SourceAlpha',\r\n      background:       'BackgroundImage',\r\n      backgroundAlpha:  'BackgroundAlpha',\r\n      fill:             'FillPaint',\r\n      stroke:           'StrokePaint',\r\n\r\n      autoSetIn: true,\r\n      // Custom put method for leaner code\r\n      put: function(element, i) {\r\n        this.add(element, i);\r\n\r\n        if(!element.attr('in') && this.autoSetIn){\r\n          element.attr('in',this.source);\r\n        }\r\n        if(!element.attr('result')){\r\n          element.attr('result',element);\r\n        }\r\n\r\n        return element\r\n      },\r\n      // Blend effect\r\n      blend: function(in1, in2, mode) {\r\n        return this.put(new SVG.BlendEffect(in1, in2, mode))\r\n      },\r\n      // ColorMatrix effect\r\n      colorMatrix: function(type, values) {\r\n        return this.put(new SVG.ColorMatrixEffect(type, values))\r\n      },\r\n      // ConvolveMatrix effect\r\n      convolveMatrix: function(matrix) {\r\n        return this.put(new SVG.ConvolveMatrixEffect(matrix))\r\n      },\r\n      // ComponentTransfer effect\r\n      componentTransfer: function(components) {\r\n        return this.put(new SVG.ComponentTransferEffect(components))\r\n      },\r\n      // Composite effect\r\n      composite: function(in1, in2, operator) {\r\n        return this.put(new SVG.CompositeEffect(in1, in2, operator))\r\n      },\r\n      // Flood effect\r\n      flood: function(color, opacity) {\r\n        return this.put(new SVG.FloodEffect(color, opacity))\r\n      },\r\n      // Offset effect\r\n      offset: function(x, y) {\r\n        return this.put(new SVG.OffsetEffect(x,y))\r\n      },\r\n      // Image effect\r\n      image: function(src) {\r\n        return this.put(new SVG.ImageEffect(src))\r\n      },\r\n      // Merge effect\r\n      merge: function() {\r\n        //pass the array of arguments to the constructor because we dont know if the user gave us an array as the first arguemnt or wether they listed the effects in the arguments\r\n        var args = [undefined];\r\n        for(var i in arguments) args.push(arguments[i]);\r\n        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect,args)))\r\n      },\r\n      // Gaussian Blur effect\r\n      gaussianBlur: function(x,y) {\r\n        return this.put(new SVG.GaussianBlurEffect(x,y))\r\n      },\r\n      // Morphology effect\r\n      morphology: function(operator,radius){\r\n        return this.put(new SVG.MorphologyEffect(operator,radius))\r\n      },\r\n      // DiffuseLighting effect\r\n      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n        return this.put(new SVG.DiffuseLightingEffect(surfaceScale,diffuseConstant,kernelUnitLength))\r\n      },\r\n      // DisplacementMap effect\r\n      displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n        return this.put(new SVG.DisplacementMapEffect(in1,in2,scale,xChannelSelector,yChannelSelector))\r\n      },\r\n      // SpecularLighting effect\r\n      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n        return this.put(new SVG.SpecularLightingEffect(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength))\r\n      },\r\n      // Tile effect\r\n      tile: function(){\r\n        return this.put(new SVG.TileEffect());\r\n      },\r\n      // Turbulence effect\r\n      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n        return this.put(new SVG.TurbulenceEffect(baseFrequency,numOctaves,seed,stitchTiles,type))\r\n      },\r\n      // Default string value\r\n      toString: function() {\r\n        return 'url(#' + this.attr('id') + ')'\r\n      }\r\n    }\r\n  });\r\n\r\n  //add .filter function\r\n  SVG.extend(SVG.Defs, {\r\n    // Define filter\r\n    filter: function(block) {\r\n      var filter = this.put(new SVG.Filter);\r\n\r\n      /* invoke passed block */\r\n      if (typeof block === 'function')\r\n        block.call(filter, filter);\r\n\r\n      return filter\r\n    }\r\n  });\r\n  SVG.extend(SVG.Container, {\r\n    // Define filter on defs\r\n    filter: function(block) {\r\n      return this.defs().filter(block)\r\n    }\r\n  });\r\n  SVG.extend(SVG.Element, SVG.G, SVG.Nested, {\r\n    // Create filter element in defs and store reference\r\n    filter: function(block) {\r\n      this.filterer = block instanceof SVG.Element ?\r\n        block : this.doc().filter(block);\r\n\r\n      if(this.doc() && this.filterer.doc() !== this.doc()){\r\n        this.doc().defs().add(this.filterer);\r\n      }\r\n\r\n      this.attr('filter', this.filterer);\r\n\r\n      return this.filterer\r\n    },\r\n    // Remove filter\r\n    unfilter: function(remove) {\r\n      /* also remove the filter node */\r\n      if (this.filterer && remove === true)\r\n        this.filterer.remove();\r\n\r\n      /* delete reference to filterer */\r\n      delete this.filterer;\r\n\r\n      /* remove filter attribute */\r\n      return this.attr('filter', null)\r\n    }\r\n  });\r\n\r\n  // Create SVG.Effect class\r\n  SVG.Effect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Element,\r\n    extend: {\r\n      // Set in attribute\r\n      in: function(effect) {\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n      },\r\n      // Named result\r\n      result: function(result) {\r\n        return result == null? this.attr('result') : this.attr('result',result)\r\n      },\r\n      // Stringification\r\n      toString: function() {\r\n        return this.result()\r\n      }\r\n    }\r\n  });\r\n\r\n  // create class for parent effects like merge\r\n  // Inherit from SVG.Parent\r\n  SVG.ParentEffect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Parent,\r\n    extend: {\r\n      // Set in attribute\r\n      in: function(effect) {\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in')+'\"]').get(0) || this.attr('in') : this.attr('in', effect)\r\n      },\r\n      // Named result\r\n      result: function(result) {\r\n        return result == null? this.attr('result') : this.attr('result',result)\r\n      },\r\n      // Stringification\r\n      toString: function() {\r\n        return this.result()\r\n      }\r\n    }\r\n  });\r\n\r\n  //chaining\r\n  var chainingEffects = {\r\n    // Blend effect\r\n    blend: function(in2, mode) {\r\n      return this.parent() && this.parent().blend(this, in2, mode) //pass this as the first input\r\n    },\r\n    // ColorMatrix effect\r\n    colorMatrix: function(type, values) {\r\n      return this.parent() && this.parent().colorMatrix(type, values).in(this)\r\n    },\r\n    // ConvolveMatrix effect\r\n    convolveMatrix: function(matrix) {\r\n      return this.parent() && this.parent().convolveMatrix(matrix).in(this)\r\n    },\r\n    // ComponentTransfer effect\r\n    componentTransfer: function(components) {\r\n      return this.parent() && this.parent().componentTransfer(components).in(this)\r\n    },\r\n    // Composite effect\r\n    composite: function(in2, operator) {\r\n      return this.parent() && this.parent().composite(this, in2, operator) //pass this as the first input\r\n    },\r\n    // Flood effect\r\n    flood: function(color, opacity) {\r\n      return this.parent() && this.parent().flood(color, opacity) //this effect dont have inputs\r\n    },\r\n    // Offset effect\r\n    offset: function(x, y) {\r\n      return this.parent() && this.parent().offset(x,y).in(this)\r\n    },\r\n    // Image effect\r\n    image: function(src) {\r\n      return this.parent() && this.parent().image(src) //this effect dont have inputs\r\n    },\r\n    // Merge effect\r\n    merge: function() {\r\n      return this.parent() && this.parent().merge.apply(this.parent(),[this].concat(arguments)) //pass this as the first argument\r\n    },\r\n    // Gaussian Blur effect\r\n    gaussianBlur: function(x,y) {\r\n      return this.parent() && this.parent().gaussianBlur(x,y).in(this)\r\n    },\r\n    // Morphology effect\r\n    morphology: function(operator,radius){\r\n      return this.parent() && this.parent().morphology(operator,radius).in(this)\r\n    },\r\n    // DiffuseLighting effect\r\n    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n      return this.parent() && this.parent().diffuseLighting(surfaceScale,diffuseConstant,kernelUnitLength).in(this)\r\n    },\r\n    // DisplacementMap effect\r\n    displacementMap: function(in2,scale,xChannelSelector,yChannelSelector){\r\n      return this.parent() && this.parent().displacementMap(this,in2,scale,xChannelSelector,yChannelSelector) //pass this as the first input\r\n    },\r\n    // SpecularLighting effect\r\n    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n      return this.parent() && this.parent().specularLighting(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength).in(this)\r\n    },\r\n    // Tile effect\r\n    tile: function(){\r\n      return this.parent() && this.parent().tile().in(this)\r\n    },\r\n    // Turbulence effect\r\n    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n      return this.parent() && this.parent().turbulence(baseFrequency,numOctaves,seed,stitchTiles,type).in(this)\r\n    }\r\n  };\r\n  SVG.extend(SVG.Effect,chainingEffects);\r\n  SVG.extend(SVG.ParentEffect,chainingEffects);\r\n\r\n  //crea class for child effects, like MergeNode, FuncR and lights\r\n  SVG.ChildEffect = SVG.invent({\r\n    create: function(){\r\n      this.constructor.call(this);\r\n    },\r\n    inherit: SVG.Element,\r\n    extend: {\r\n    in: function(effect){\r\n      this.attr('in',effect);\r\n    }\r\n    //dont include any \"result\" functions because these types of nodes dont have them\r\n    }\r\n  });\r\n\r\n  // Create all different effects\r\n  var effects = {\r\n    blend: function(in1,in2,mode){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        mode: mode || 'normal'\r\n      });\r\n    },\r\n    colorMatrix: function(type,values){\r\n      if (type == 'matrix')\r\n        values = normaliseMatrix(values);\r\n\r\n      this.attr({\r\n        type:   type\r\n      , values: typeof values == 'undefined' ? null : values\r\n      });\r\n    },\r\n    convolveMatrix: function(matrix){\r\n      matrix = normaliseMatrix(matrix);\r\n\r\n      this.attr({\r\n        order:        Math.sqrt(matrix.split(' ').length)\r\n      , kernelMatrix: matrix\r\n      });\r\n    },\r\n    composite: function(in1, in2, operator){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        operator: operator\r\n      });\r\n    },\r\n    flood: function(color,opacity){\r\n      this.attr('flood-color',color);\r\n      if(opacity != null) this.attr('flood-opacity',opacity);\r\n    },\r\n    offset: function(x,y){\r\n      this.attr({\r\n        dx: x,\r\n        dy: y\r\n      });\r\n    },\r\n    image: function(src){\r\n      this.attr('href', src, SVG.xlink);\r\n    },\r\n    displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){\r\n      this.attr({\r\n        in: in1,\r\n        in2: in2,\r\n        scale: scale,\r\n        xChannelSelector: xChannelSelector,\r\n        yChannelSelector: yChannelSelector\r\n      });\r\n    },\r\n    gaussianBlur: function(x,y){\r\n      if(x != null || y != null)\r\n        this.attr('stdDeviation', listString(Array.prototype.slice.call(arguments)));\r\n      else\r\n        this.attr('stdDeviation', '0 0');\r\n    },\r\n    morphology: function(operator,radius){\r\n      this.attr({\r\n        operator: operator,\r\n        radius: radius\r\n      });\r\n    },\r\n    tile: function(){\r\n\r\n    },\r\n    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){\r\n      this.attr({\r\n        numOctaves: numOctaves,\r\n        seed: seed,\r\n        stitchTiles: stitchTiles,\r\n        baseFrequency: baseFrequency,\r\n        type: type\r\n      });\r\n    }\r\n  };\r\n\r\n  // Create all parent effects\r\n  var parentEffects = {\r\n    merge: function(){\r\n      var children;\r\n\r\n      //test to see if we have a set\r\n      if(arguments[0] instanceof SVG.Set){\r\n        var that = this;\r\n        arguments[0].each(function(i){\r\n          if(this instanceof SVG.MergeNode)\r\n            that.put(this);\r\n          else if(this instanceof SVG.Effect || this instanceof SVG.ParentEffect)\r\n            that.put(new SVG.MergeNode(this));\r\n        });\r\n      }\r\n      else{\r\n        //if the first argument is an array use it\r\n        if(Array.isArray(arguments[0]))\r\n          children = arguments[0];\r\n        else\r\n          children = arguments;\r\n\r\n        for(var i = 0; i < children.length; i++){\r\n          if(children[i] instanceof SVG.MergeNode){\r\n            this.put(children[i]);\r\n          }\r\n          else this.put(new SVG.MergeNode(children[i]));\r\n        }\r\n      }\r\n    },\r\n    componentTransfer: function(compontents){\r\n      /* create rgb set */\r\n      this.rgb = new SVG.Set\r\n\r\n      /* create components */\r\n      ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n        /* create component */\r\n        this[c] = new SVG['Func' + c.toUpperCase()]('identity');\r\n\r\n        /* store component in set */\r\n        this.rgb.add(this[c]);\r\n\r\n        /* add component node */\r\n        this.node.appendChild(this[c].node);\r\n      }.bind(this)); //lost context in foreach\r\n\r\n      /* set components */\r\n      if (compontents) {\r\n        if (compontents.rgb) {\r\n(['r', 'g', 'b']).forEach(function(c) {\r\n            this[c].attr(compontents.rgb);\r\n          }.bind(this));\r\n\r\n          delete compontents.rgb;\r\n        }\r\n\r\n        /* set individual components */\r\n        for (var c in compontents)\r\n          this[c].attr(compontents[c]);\r\n      }\r\n    },\r\n    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){\r\n      this.attr({\r\n        surfaceScale: surfaceScale,\r\n        diffuseConstant: diffuseConstant,\r\n        kernelUnitLength: kernelUnitLength\r\n      });\r\n    },\r\n    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){\r\n      this.attr({\r\n        surfaceScale: surfaceScale,\r\n        diffuseConstant: diffuseConstant,\r\n        specularExponent: specularExponent,\r\n        kernelUnitLength: kernelUnitLength\r\n      });\r\n    },\r\n  };\r\n\r\n  // Create child effects like PointLight and MergeNode\r\n  var childEffects = {\r\n    distantLight: function(azimuth, elevation){\r\n      this.attr({\r\n        azimuth: azimuth,\r\n        elevation: elevation\r\n      });\r\n    },\r\n    pointLight: function(x,y,z){\r\n      this.attr({\r\n        x: x,\r\n        y: y,\r\n        z: z\r\n      });\r\n    },\r\n    spotLight: function(x,y,z,pointsAtX,pointsAtY,pointsAtZ){\r\n      this.attr({\r\n        x: x,\r\n        y: y,\r\n        z: z,\r\n        pointsAtX: pointsAtX,\r\n        pointsAtY: pointsAtY,\r\n        pointsAtZ: pointsAtZ\r\n      });\r\n    },\r\n    mergeNode: function(in1){\r\n      this.attr('in',in1);\r\n    }\r\n  }\r\n\r\n  // Create compontent functions\r\n  ;(['r', 'g', 'b', 'a']).forEach(function(c) {\r\n    /* create class */\r\n    childEffects['Func' + c.toUpperCase()] = function(type) {\r\n      this.attr('type',type);\r\n\r\n      // take diffent arguments based on the type\r\n      switch(type){\r\n        case 'table':\r\n          this.attr('tableValues',arguments[1]);\r\n          break\r\n        case 'linear':\r\n          this.attr('slope',arguments[1]);\r\n          this.attr('intercept',arguments[2]);\r\n          break\r\n        case 'gamma':\r\n          this.attr('amplitude',arguments[1]);\r\n          this.attr('exponent',arguments[2]);\r\n          this.attr('offset',arguments[2]);\r\n          break\r\n      }\r\n    };\r\n  });\r\n\r\n  //create effects\r\n  foreach(effects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name + 'Effect'] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n\r\n        //set the result\r\n        this.result(this.attr('id') + 'Out');\r\n      },\r\n      inherit: SVG.Effect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  //create parent effects\r\n  foreach(parentEffects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name + 'Effect'] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n\r\n        //set the result\r\n        this.result(this.attr('id') + 'Out');\r\n      },\r\n      inherit: SVG.ParentEffect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  //create child effects\r\n  foreach(childEffects,function(effect,i){\r\n\r\n    /* capitalize name */\r\n    var name = i.charAt(0).toUpperCase() + i.slice(1);\r\n    var proto = {};\r\n\r\n    /* create class */\r\n    SVG[name] = SVG.invent({\r\n      create: function() {\r\n        //call super\r\n        this.constructor.call(this, SVG.create('fe' + name));\r\n\r\n        //call constructor for this effect\r\n        effect.apply(this,arguments);\r\n      },\r\n      inherit: SVG.ChildEffect,\r\n      extend: proto\r\n    });\r\n  });\r\n\r\n  // Effect-specific extensions\r\n  SVG.extend(SVG.MergeEffect,{\r\n    in: function(effect){\r\n      if(effect instanceof SVG.MergeNode)\r\n        this.add(effect,0);\r\n      else\r\n        this.add(new SVG.MergeNode(effect),0);\r\n\r\n      return this\r\n    }\r\n  });\r\n  SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{\r\n    in2: function(effect){\r\n        return effect == null? this.parent() && this.parent().select('[result=\"'+this.attr('in2')+'\"]').get(0) || this.attr('in2') : this.attr('in2', effect)\r\n    }\r\n  });\r\n\r\n  // Presets\r\n  SVG.filter = {\r\n    sepiatone:  [ .343, .669, .119, 0, 0\r\n                , .249, .626, .130, 0, 0\r\n                , .172, .334, .111, 0, 0\r\n                , .000, .000, .000, 1, 0 ]\r\n  };\r\n\r\n  // Helpers\r\n  function normaliseMatrix(matrix) {\r\n    /* convert possible array value to string */\r\n    if (Array.isArray(matrix))\r\n      matrix = new SVG.Array(matrix);\r\n\r\n    /* ensure there are no leading, tailing or double spaces */\r\n    return matrix.toString().replace(/^\\s+/, '').replace(/\\s+$/, '').replace(/\\s+/g, ' ')\r\n  }\r\n\r\n  function listString(list) {\r\n    if (!Array.isArray(list))\r\n      return list\r\n\r\n    for (var i = 0, l = list.length, s = []; i < l; i++)\r\n      s.push(list[i]);\r\n\r\n    return s.join(' ')\r\n  }\r\n\r\n  function foreach(){ //loops through mutiple objects\r\n    var fn = function(){};\r\n    if(typeof arguments[arguments.length-1] == 'function'){\r\n      fn = arguments[arguments.length-1];\r\n      Array.prototype.splice.call(arguments,arguments.length-1,1);\r\n    }\r\n    for(var k in arguments){\r\n      for(var i in arguments[k]){\r\n        fn(arguments[k][i],i,arguments[k]);\r\n      }\r\n    }\r\n  }\r\n\r\n}).call(undefined);\n\n(function() {\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  morph: function(array) {\r\n\r\n    var startArr = this.value\r\n      ,  destArr = this.parse(array);\r\n\r\n    var startOffsetM = 0\r\n      ,  destOffsetM = 0;\r\n\r\n    var startOffsetNextM = false\r\n      ,  destOffsetNextM = false;\r\n\r\n    while(true){\r\n      // stop if there is no M anymore\r\n      if(startOffsetM === false && destOffsetM === false) break\r\n\r\n      // find the next M in path array\r\n      startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM+1);\r\n       destOffsetNextM = findNextM( destArr,  destOffsetM === false ? false :  destOffsetM+1);\r\n\r\n      // We have to add one M to the startArray\r\n      if(startOffsetM === false){\r\n        var bbox = new SVG.PathArray(result.start).bbox();\r\n\r\n        // when the last block had no bounding box we simply take the first M we got\r\n        if(bbox.height == 0 || bbox.width == 0){\r\n          startOffsetM =  startArr.push(startArr[0]) - 1;\r\n        }else{\r\n          // we take the middle of the bbox instead when we got one\r\n          startOffsetM = startArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n        }\r\n      }\r\n\r\n      // We have to add one M to the destArray\r\n      if( destOffsetM === false){\r\n        var bbox = new SVG.PathArray(result.dest).bbox();\r\n\r\n        if(bbox.height == 0 || bbox.width == 0){\r\n          destOffsetM =  destArr.push(destArr[0]) - 1;\r\n        }else{\r\n          destOffsetM =  destArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;\r\n        }\r\n      }\r\n\r\n      // handle block from M to next M\r\n      var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);\r\n\r\n      // update the arrays to their new values\r\n      startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));\r\n       destArr =  destArr.slice(0,  destOffsetM).concat(result.dest ,  destOffsetNextM === false ? [] :  destArr.slice( destOffsetNextM));\r\n\r\n      // update offsets\r\n      startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;\r\n       destOffsetM =  destOffsetNextM === false ? false :  destOffsetM + result.dest.length;\r\n\r\n    }\r\n\r\n    // copy back arrays\r\n    this.value = startArr;\r\n    this.destination = new SVG.PathArray();\r\n    this.destination.value = destArr;\r\n\r\n    return this\r\n  }\r\n});\r\n\r\n\r\n\r\n// sorry for the long declaration\r\n// slices out one block (from M to M) and syncronize it so the types and length match\r\nfunction handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM, undefined){\r\n\r\n  // slice out the block we need\r\n  var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined)\r\n    ,  destArrTemp =  destArr.slice( destOffsetM,  destOffsetNextM || undefined);\r\n\r\n  var i = 0\r\n    , posStart = {pos:[0,0], start:[0,0]}\r\n    , posDest  = {pos:[0,0], start:[0,0]};\r\n\r\n  do{\r\n\r\n    // convert shorthand types to long form\r\n    startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);\r\n     destArrTemp[i] = simplyfy.call(posDest ,  destArrTemp[i]);\r\n\r\n    // check if both shape types match\r\n    // 2 elliptical arc curve commands ('A'), are considered different if the\r\n    // flags (large-arc-flag, sweep-flag) don't match\r\n    if(startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' ||\r\n        (startArrTemp[i][0] == 'A' &&\r\n          (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])\r\n        )\r\n      ) {\r\n\r\n      // if not, convert shapes to beziere\r\n      Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));\r\n       Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));\r\n\r\n    } else {\r\n\r\n      // only update positions otherwise\r\n      startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);\r\n       destArrTemp[i] = setPosAndReflection.call(posDest ,  destArrTemp[i]);\r\n\r\n    }\r\n\r\n    // we are at the end at both arrays. stop here\r\n    if(++i == startArrTemp.length && i == destArrTemp.length) break\r\n\r\n    // destArray is longer. Add one element\r\n    if(i == startArrTemp.length){\r\n      startArrTemp.push([\r\n        'C',\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n        posStart.pos[0],\r\n        posStart.pos[1],\r\n      ]);\r\n    }\r\n\r\n    // startArr is longer. Add one element\r\n    if(i == destArrTemp.length){\r\n      destArrTemp.push([\r\n        'C',\r\n        posDest.pos[0],\r\n        posDest.pos[1],\r\n        posDest.pos[0],\r\n        posDest.pos[1],\r\n        posDest.pos[0],\r\n        posDest.pos[1]\r\n      ]);\r\n    }\r\n\r\n\r\n  }while(true)\r\n\r\n  // return the updated block\r\n  return {start:startArrTemp, dest:destArrTemp}\r\n}\r\n\r\n// converts shorthand types to long form\r\nfunction simplyfy(val){\r\n\r\n  switch(val[0]){\r\n    case 'z': // shorthand line to start\r\n    case 'Z':\r\n      val[0] = 'L';\r\n      val[1] = this.start[0];\r\n      val[2] = this.start[1];\r\n      break\r\n    case 'H': // shorthand horizontal line\r\n      val[0] = 'L';\r\n      val[2] = this.pos[1];\r\n      break\r\n    case 'V': // shorthand vertical line\r\n      val[0] = 'L';\r\n      val[2] = val[1];\r\n      val[1] = this.pos[0];\r\n      break\r\n    case 'T': // shorthand quadratic beziere\r\n      val[0] = 'Q';\r\n      val[3] = val[1];\r\n      val[4] = val[2];\r\n      val[1] = this.reflection[1];\r\n      val[2] = this.reflection[0];\r\n      break\r\n    case 'S': // shorthand cubic beziere\r\n      val[0] = 'C';\r\n      val[6] = val[4];\r\n      val[5] = val[3];\r\n      val[4] = val[2];\r\n      val[3] = val[1];\r\n      val[2] = this.reflection[1];\r\n      val[1] = this.reflection[0];\r\n      break\r\n  }\r\n\r\n  return val\r\n\r\n}\r\n\r\n// updates reflection point and current position\r\nfunction setPosAndReflection(val){\r\n\r\n  var len = val.length;\r\n\r\n  this.pos = [ val[len-2], val[len-1] ];\r\n\r\n  if('SCQT'.indexOf(val[0]) != -1)\r\n    this.reflection = [ 2 * this.pos[0] - val[len-4], 2 * this.pos[1] - val[len-3] ];\r\n\r\n  return val\r\n}\r\n\r\n// converts all types to cubic beziere\r\nfunction toBeziere(val){\r\n  var retVal = [val];\r\n\r\n  switch(val[0]){\r\n    case 'M': // special handling for M\r\n      this.pos = this.start = [val[1], val[2]];\r\n      return retVal\r\n    case 'L':\r\n      val[5] = val[3] = val[1];\r\n      val[6] = val[4] = val[2];\r\n      val[1] = this.pos[0];\r\n      val[2] = this.pos[1];\r\n      break\r\n    case 'Q':\r\n      val[6] = val[4];\r\n      val[5] = val[3];\r\n      val[4] = val[4] * 1/3 + val[2] * 2/3;\r\n      val[3] = val[3] * 1/3 + val[1] * 2/3;\r\n      val[2] = this.pos[1] * 1/3 + val[2] * 2/3;\r\n      val[1] = this.pos[0] * 1/3 + val[1] * 2/3;\r\n      break\r\n    case 'A':\r\n      retVal = arcToBeziere(this.pos, val);\r\n      val = retVal[0];\r\n      break\r\n  }\r\n\r\n  val[0] = 'C';\r\n  this.pos = [val[5], val[6]];\r\n  this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];\r\n\r\n  return retVal\r\n\r\n}\r\n\r\n// finds the next position of type M\r\nfunction findNextM(arr, offset){\r\n\r\n  if(offset === false) return false\r\n\r\n  for(var i = offset, len = arr.length;i < len;++i){\r\n\r\n    if(arr[i][0] == 'M') return i\r\n\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n\r\n\r\n// Convert an arc segment into equivalent cubic Bezier curves\r\n// Depending on the arc, up to 4 curves might be used to represent it since a\r\n// curve gives a good approximation for only a quarter of an ellipse\r\n// The curves are returned as an array of SVG curve commands:\r\n// [ ['C', x1, y1, x2, y2, x, y] ... ]\r\nfunction arcToBeziere(pos, val) {\r\n    // Parameters extraction, handle out-of-range parameters as specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters\r\n    var rx = Math.abs(val[1]), ry = Math.abs(val[2]), xAxisRotation = val[3] % 360\r\n      , largeArcFlag = val[4], sweepFlag = val[5], x = val[6], y = val[7]\r\n      , A = new SVG.Point(pos), B = new SVG.Point(x, y)\r\n      , primedCoord, lambda, mat, k, c, cSquare, t, O, OA, OB, tetaStart, tetaEnd\r\n      , deltaTeta, nbSectors, f, arcSegPoints, angle, sinAngle, cosAngle, pt, i, il\r\n      , retVal = [], x1, y1, x2, y2;\r\n\r\n    // Ensure radii are non-zero\r\n    if(rx === 0 || ry === 0 || (A.x === B.x && A.y === B.y)) {\r\n      // treat this arc as a straight line segment\r\n      return [['C', A.x, A.y, B.x, B.y, B.x, B.y]]\r\n    }\r\n\r\n    // Ensure radii are large enough using the algorithm provided in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii\r\n    primedCoord = new SVG.Point((A.x-B.x)/2, (A.y-B.y)/2).transform(new SVG.Matrix().rotate(xAxisRotation));\r\n    lambda = (primedCoord.x * primedCoord.x) / (rx * rx) + (primedCoord.y * primedCoord.y) / (ry * ry);\r\n    if(lambda > 1) {\r\n      lambda = Math.sqrt(lambda);\r\n      rx = lambda*rx;\r\n      ry = lambda*ry;\r\n    }\r\n\r\n    // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse\r\n    mat = new SVG.Matrix().rotate(xAxisRotation).scale(1/rx, 1/ry).rotate(-xAxisRotation);\r\n    A = A.transform(mat);\r\n    B = B.transform(mat);\r\n\r\n    // Calculate the horizontal and vertical distance between the initial and final point of the arc\r\n    k = [B.x-A.x, B.y-A.y];\r\n\r\n    // Find the length of the chord formed by A and B\r\n    cSquare = k[0]*k[0] + k[1]*k[1];\r\n    c = Math.sqrt(cSquare);\r\n\r\n    // Calculate the ratios of the horizontal and vertical distance on the length of the chord\r\n    k[0] /= c;\r\n    k[1] /= c;\r\n\r\n    // Calculate the distance between the circle center and the chord midpoint\r\n    // using this formula: t = sqrt(r^2 - c^2 / 4)\r\n    // where t is the distance between the cirle center and the chord midpoint,\r\n    //       r is the rayon of the circle and c is the chord length\r\n    // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php\r\n    // Because of the imprecision of floating point numbers, cSquare might end\r\n    // up being slightly above 4 which would result in a negative radicand\r\n    // To prevent that, a test is made before computing the square root\r\n    t = (cSquare < 4) ? Math.sqrt(1 - cSquare/4) : 0;\r\n\r\n    // For most situations, there are actually two different ellipses that\r\n    // satisfy the constraints imposed by the points A and B, the radii rx and ry,\r\n    // and the xAxisRotation\r\n    // When the flags largeArcFlag and sweepFlag are equal, it means that the\r\n    // second ellipse is used as a solution\r\n    // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\r\n    if(largeArcFlag === sweepFlag) {\r\n        t *= -1;\r\n    }\r\n\r\n    // Calculate the coordinates of the center of the circle from the midpoint of the chord\r\n    // This is done by multiplying the ratios calculated previously by the distance between\r\n    // the circle center and the chord midpoint and using these values to go from the midpoint\r\n    // to the center of the circle\r\n    // The negative of the vertical distance ratio is used to modify the x coordinate while\r\n    // the horizontal distance ratio is used to modify the y coordinate\r\n    // That is because the center of the circle is perpendicular to the chord and perpendicular\r\n    // lines are negative reciprocals\r\n    O = new SVG.Point((B.x+A.x)/2 + t*-k[1], (B.y+A.y)/2 + t*k[0]);\r\n    // Move the center of the circle at the origin\r\n    OA = new SVG.Point(A.x-O.x, A.y-O.y);\r\n    OB = new SVG.Point(B.x-O.x, B.y-O.y);\r\n\r\n    // Calculate the start and end angle\r\n    tetaStart = Math.acos(OA.x/Math.sqrt(OA.x*OA.x + OA.y*OA.y));\r\n    if (OA.y < 0) {\r\n      tetaStart *= -1;\r\n    }\r\n    tetaEnd = Math.acos(OB.x/Math.sqrt(OB.x*OB.x + OB.y*OB.y));\r\n    if (OB.y < 0) {\r\n      tetaEnd *= -1;\r\n    }\r\n\r\n    // If sweep-flag is '1', then the arc will be drawn in a \"positive-angle\" direction,\r\n    // make sure that the end angle is above the start angle\r\n    if (sweepFlag && tetaStart > tetaEnd) {\r\n      tetaEnd += 2*Math.PI;\r\n    }\r\n    // If sweep-flag is '0', then the arc will be drawn in a \"negative-angle\" direction,\r\n    // make sure that the end angle is below the start angle\r\n    if (!sweepFlag && tetaStart < tetaEnd) {\r\n      tetaEnd -= 2*Math.PI;\r\n    }\r\n\r\n    // Find the number of Bezier curves that are required to represent the arc\r\n    // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle\r\n    nbSectors = Math.ceil(Math.abs(tetaStart-tetaEnd) * 2/Math.PI);\r\n\r\n    // Calculate the coordinates of the points of all the Bezier curves required to represent the arc\r\n    // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic\r\n    arcSegPoints = [];\r\n    angle = tetaStart;\r\n    deltaTeta = (tetaEnd-tetaStart)/nbSectors;\r\n    f = 4*Math.tan(deltaTeta/4)/3;\r\n    for (i = 0; i <= nbSectors; i++) { // The <= is because a Bezier curve have a start and a endpoint\r\n      cosAngle = Math.cos(angle);\r\n      sinAngle = Math.sin(angle);\r\n\r\n      pt = new SVG.Point(O.x+cosAngle, O.y+sinAngle);\r\n      arcSegPoints[i] = [new SVG.Point(pt.x+f*sinAngle, pt.y-f*cosAngle), pt, new SVG.Point(pt.x-f*sinAngle, pt.y+f*cosAngle)];\r\n\r\n      angle += deltaTeta;\r\n    }\r\n\r\n    // Remove the first control point of the first segment point and remove the second control point of the last segment point\r\n    // These two control points are not used in the approximation of the arc, that is why they are removed\r\n    arcSegPoints[0][0] = arcSegPoints[0][1].clone();\r\n    arcSegPoints[arcSegPoints.length-1][2] = arcSegPoints[arcSegPoints.length-1][1].clone();\r\n\r\n    // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse\r\n    mat = new SVG.Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);\r\n    for (i = 0, il = arcSegPoints.length; i < il; i++) {\r\n      arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);\r\n      arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);\r\n      arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);\r\n    }\r\n\r\n\r\n    // Convert the segments points to SVG curve commands\r\n    for (i = 1, il = arcSegPoints.length; i < il; i++) {\r\n      pt = arcSegPoints[i-1][2];\r\n      x1 = pt.x;\r\n      y1 = pt.y;\r\n\r\n      pt = arcSegPoints[i][0];\r\n      x2 = pt.x;\r\n      y2 = pt.y;\r\n\r\n      pt = arcSegPoints[i][1];\r\n      x = pt.x;\r\n      y = pt.y;\r\n\r\n      retVal.push(['C', x1, y1, x2, y2, x, y]);\r\n    }\r\n\r\n    return retVal\r\n}\r\n}());\n\n/*! svg.draggable.js - v2.2.1 - 2016-08-25\r\n* https://github.com/wout/svg.draggable.js\r\n* Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n(function() {\r\n\r\n  // creates handler, saves it\r\n  function DragHandler(el){\r\n    el.remember('_draggable', this);\r\n    this.el = el;\r\n  }\r\n\r\n\r\n  // Sets new parameter, starts dragging\r\n  DragHandler.prototype.init = function(constraint, val){\r\n    var _this = this;\r\n    this.constraint = constraint;\r\n    this.value = val;\r\n    this.el.on('mousedown.drag', function(e){ _this.start(e); });\r\n    this.el.on('touchstart.drag', function(e){ _this.start(e); });\r\n  };\r\n\r\n  // transforms one point from screen to user coords\r\n  DragHandler.prototype.transformPoint = function(event, offset){\r\n      event = event || window.event;\r\n      var touches = event.changedTouches && event.changedTouches[0] || event;\r\n      this.p.x = touches.pageX - (offset || 0);\r\n      this.p.y = touches.pageY;\r\n      return this.p.matrixTransform(this.m)\r\n  };\r\n  \r\n  // gets elements bounding box with special handling of groups, nested and use\r\n  DragHandler.prototype.getBBox = function(){\r\n\r\n    var box = this.el.bbox();\r\n\r\n    if(this.el instanceof SVG.Nested) box = this.el.rbox();\r\n    \r\n    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\r\n      box.x = this.el.x();\r\n      box.y = this.el.y();\r\n    }\r\n\r\n    return box\r\n  };\r\n\r\n  // start dragging\r\n  DragHandler.prototype.start = function(e){\r\n\r\n    // check for left button\r\n    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\r\n      if((e.which || e.buttons) != 1){\r\n          return\r\n      }\r\n    }\r\n  \r\n    var _this = this;\r\n\r\n    // fire beforedrag event\r\n    this.el.fire('beforedrag', { event: e, handler: this });\r\n\r\n    // search for parent on the fly to make sure we can call\r\n    // draggable() even when element is not in the dom currently\r\n    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc);\r\n    this.p = this.parent.node.createSVGPoint();\r\n\r\n    // save current transformation matrix\r\n    this.m = this.el.node.getScreenCTM().inverse();\r\n\r\n    var box = this.getBBox();\r\n    \r\n    var anchorOffset;\r\n    \r\n    // fix text-anchor in text-element (#37)\r\n    if(this.el instanceof SVG.Text){\r\n      anchorOffset = this.el.node.getComputedTextLength();\r\n        \r\n      switch(this.el.attr('text-anchor')){\r\n        case 'middle':\r\n          anchorOffset /= 2;\r\n          break\r\n        case 'start':\r\n          anchorOffset = 0;\r\n          break;\r\n      }\r\n    }\r\n    \r\n    this.startPoints = {\r\n      // We take absolute coordinates since we are just using a delta here\r\n      point: this.transformPoint(e, anchorOffset),\r\n      box:   box,\r\n      transform: this.el.transform()\r\n    };\r\n    \r\n    // add drag and end events to window\r\n    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e); });\r\n    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e); });\r\n    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e); });\r\n    SVG.on(window, 'touchend.drag', function(e){ _this.end(e); });\r\n\r\n    // fire dragstart event\r\n    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this});\r\n\r\n    // prevent browser drag behavior\r\n    e.preventDefault();\r\n\r\n    // prevent propagation to a parent that might also have dragging enabled\r\n    e.stopPropagation();\r\n  };\r\n\r\n  // while dragging\r\n  DragHandler.prototype.drag = function(e){\r\n\r\n    var box = this.getBBox()\r\n      , p   = this.transformPoint(e)\r\n      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\r\n      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\r\n      , c   = this.constraint\r\n      , gx  = p.x - this.startPoints.point.x\r\n      , gy  = p.y - this.startPoints.point.y;\r\n      \r\n    var event = new CustomEvent('dragmove', {\r\n        detail: {\r\n            event: e\r\n          , p: p\r\n          , m: this.m\r\n          , handler: this\r\n        }\r\n      , cancelable: true\r\n    });\r\n      \r\n    this.el.fire(event);\r\n    \r\n    if(event.defaultPrevented) return p\r\n\r\n    // move the element to its new position, if possible by constraint\r\n    if (typeof c == 'function') {\r\n\r\n      var coord = c.call(this.el, x, y, this.m);\r\n\r\n      // bool, just show us if movement is allowed or not\r\n      if (typeof coord == 'boolean') {\r\n        coord = {\r\n          x: coord,\r\n          y: coord\r\n        };\r\n      }\r\n\r\n      // if true, we just move. If !false its a number and we move it there\r\n      if (coord.x === true) {\r\n        this.el.x(x);\r\n      } else if (coord.x !== false) {\r\n        this.el.x(coord.x);\r\n      }\r\n\r\n      if (coord.y === true) {\r\n        this.el.y(y);\r\n      } else if (coord.y !== false) {\r\n        this.el.y(coord.y);\r\n      }\r\n\r\n    } else if (typeof c == 'object') {\r\n\r\n      // keep element within constrained box\r\n      if (c.minX != null && x < c.minX)\r\n        x = c.minX;\r\n      else if (c.maxX != null && x > c.maxX - box.width){\r\n        x = c.maxX - box.width;\r\n      }if (c.minY != null && y < c.minY)\r\n        y = c.minY;\r\n      else if (c.maxY != null && y > c.maxY - box.height)\r\n        y = c.maxY - box.height;\r\n        \r\n      if(this.el instanceof SVG.G)\r\n        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true);\r\n      else\r\n        this.el.move(x, y);\r\n    }\r\n    \r\n    // so we can use it in the end-method, too\r\n    return p\r\n  };\r\n\r\n  DragHandler.prototype.end = function(e){\r\n\r\n    // final drag\r\n    var p = this.drag(e);\r\n\r\n    // fire dragend event\r\n    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this });\r\n\r\n    // unbind events\r\n    SVG.off(window, 'mousemove.drag');\r\n    SVG.off(window, 'touchmove.drag');\r\n    SVG.off(window, 'mouseup.drag');\r\n    SVG.off(window, 'touchend.drag');\r\n\r\n  };\r\n\r\n  SVG.extend(SVG.Element, {\r\n    // Make element draggable\r\n    // Constraint might be an object (as described in readme.md) or a function in the form \"function (x, y)\" that gets called before every move.\r\n    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \"False\" skips moving, true moves to raw x, y.\r\n    draggable: function(value, constraint) {\r\n\r\n      // Check the parameters and reassign if needed\r\n      if (typeof value == 'function' || typeof value == 'object') {\r\n        constraint = value;\r\n        value = true;\r\n      }\r\n\r\n      var dragHandler = this.remember('_draggable') || new DragHandler(this);\r\n\r\n      // When no parameter is given, value is true\r\n      value = typeof value === 'undefined' ? true : value;\r\n\r\n      if(value) dragHandler.init(constraint || {}, value);\r\n      else {\r\n        this.off('mousedown.drag');\r\n        this.off('touchstart.drag');\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n  });\r\n\r\n}).call(undefined);\n\n(function() {\n\nfunction SelectHandler(el) {\r\n\r\n    this.el = el;\r\n    el.remember('_selectHandler', this);\r\n    this.pointSelection = {isSelected: false};\r\n    this.rectSelection = {isSelected: false};\r\n\r\n}\r\n\r\nSelectHandler.prototype.init = function (value, options) {\r\n\r\n    var bbox = this.el.bbox();\r\n    this.options = {};\r\n\r\n    // Merging the defaults and the options-object together\r\n    for (var i in this.el.selectize.defaults) {\r\n        this.options[i] = this.el.selectize.defaults[i];\r\n        if (options[i] !== undefined) {\r\n            this.options[i] = options[i];\r\n        }\r\n    }\r\n\r\n    this.parent = this.el.parent();\r\n    this.nested = (this.nested || this.parent.group());\r\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n    // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving\r\n    if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {\r\n        this.selectPoints(value);\r\n    } else {\r\n        this.selectRect(value);\r\n    }\r\n\r\n    this.observe();\r\n    this.cleanup();\r\n\r\n};\r\n\r\nSelectHandler.prototype.selectPoints = function (value) {\r\n\r\n    this.pointSelection.isSelected = value;\r\n\r\n    // When set is already there we dont have to create one\r\n    if (this.pointSelection.set) {\r\n        return this;\r\n    }\r\n\r\n    // Create our set of elements\r\n    this.pointSelection.set = this.parent.set();\r\n    // draw the circles and mark the element as selected\r\n    this.drawCircles();\r\n\r\n    return this;\r\n\r\n};\r\n\r\n// create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon\r\nSelectHandler.prototype.getPointArray = function () {\r\n    var bbox = this.el.bbox();\r\n\r\n    return this.el.array().valueOf().map(function (el) {\r\n        return [el[0] - bbox.x, el[1] - bbox.y];\r\n    });\r\n};\r\n\r\n// The function to draw the circles\r\nSelectHandler.prototype.drawCircles = function () {\r\n\r\n    var _this = this, array = this.getPointArray();\r\n\r\n    // go through the array of points\r\n    for (var i = 0, len = array.length; i < len; ++i) {\r\n\r\n        var curriedEvent = (function (k) {\r\n            return function (ev) {\r\n                ev = ev || window.event;\r\n                ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n                ev.stopPropagation();\r\n\r\n                var x = ev.pageX || ev.touches[0].pageX;\r\n                var y = ev.pageY || ev.touches[0].pageY;\r\n                _this.el.fire('point', {x: x, y: y, i: k, event: ev});\r\n            };\r\n        })(i);\r\n\r\n        // add every point to the set\r\n        this.pointSelection.set.add(\r\n            // a circle with our css-classes and a touchstart-event which fires our event for moving points\r\n            this.nested.circle(this.options.radius)\r\n                .center(array[i][0], array[i][1])\r\n                .addClass(this.options.classPoints)\r\n                .addClass(this.options.classPoints + '_point')\r\n                .on('touchstart', curriedEvent)\r\n                .on('mousedown', curriedEvent)\r\n        );\r\n    }\r\n\r\n};\r\n\r\n// every time a circle is moved, we have to update the positions of our circle\r\nSelectHandler.prototype.updatePointSelection = function () {\r\n    var array = this.getPointArray();\r\n\r\n    this.pointSelection.set.each(function (i) {\r\n        if (this.cx() === array[i][0] && this.cy() === array[i][1]) {\r\n            return;\r\n        }\r\n        this.center(array[i][0], array[i][1]);\r\n    });\r\n};\r\n\r\nSelectHandler.prototype.updateRectSelection = function () {\r\n    var bbox = this.el.bbox();\r\n\r\n    this.rectSelection.set.get(0).attr({\r\n        width: bbox.width,\r\n        height: bbox.height\r\n    });\r\n\r\n    // set.get(1) is always in the upper left corner. no need to move it\r\n    if (this.options.points) {\r\n        this.rectSelection.set.get(2).center(bbox.width, 0);\r\n        this.rectSelection.set.get(3).center(bbox.width, bbox.height);\r\n        this.rectSelection.set.get(4).center(0, bbox.height);\r\n\r\n        this.rectSelection.set.get(5).center(bbox.width / 2, 0);\r\n        this.rectSelection.set.get(6).center(bbox.width, bbox.height / 2);\r\n        this.rectSelection.set.get(7).center(bbox.width / 2, bbox.height);\r\n        this.rectSelection.set.get(8).center(0, bbox.height / 2);\r\n    }\r\n\r\n    if (this.options.rotationPoint) {\r\n        if (this.options.points) {\r\n            this.rectSelection.set.get(9).center(bbox.width / 2, 20);\r\n        } else {\r\n            this.rectSelection.set.get(1).center(bbox.width / 2, 20);\r\n        }\r\n    }\r\n};\r\n\r\nSelectHandler.prototype.selectRect = function (value) {\r\n\r\n    var _this = this, bbox = this.el.bbox();\r\n\r\n    this.rectSelection.isSelected = value;\r\n\r\n    // when set is already p\r\n    this.rectSelection.set = this.rectSelection.set || this.parent.set();\r\n\r\n    // helperFunction to create a mouse-down function which triggers the event specified in `eventName`\r\n    function getMoseDownFunc(eventName) {\r\n        return function (ev) {\r\n            ev = ev || window.event;\r\n            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n            ev.stopPropagation();\r\n\r\n            var x = ev.pageX || ev.touches[0].pageX;\r\n            var y = ev.pageY || ev.touches[0].pageY;\r\n            _this.el.fire(eventName, {x: x, y: y, event: ev});\r\n        };\r\n    }\r\n\r\n    // create the selection-rectangle and add the css-class\r\n    if (!this.rectSelection.set.get(0)) {\r\n        this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));\r\n    }\r\n\r\n    // Draw Points at the edges, if enabled\r\n    if (this.options.points && !this.rectSelection.set.get(1)) {\r\n        var ename =\"touchstart\", mname = \"mousedown\";\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', this.options.classPoints + '_lt').on(mname, getMoseDownFunc('lt')).on(ename, getMoseDownFunc('lt')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, 0).attr('class', this.options.classPoints + '_rt').on(mname, getMoseDownFunc('rt')).on(ename, getMoseDownFunc('rt')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height).attr('class', this.options.classPoints + '_rb').on(mname, getMoseDownFunc('rb')).on(ename, getMoseDownFunc('rb')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height).attr('class', this.options.classPoints + '_lb').on(mname, getMoseDownFunc('lb')).on(ename, getMoseDownFunc('lb')));\r\n\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 0).attr('class', this.options.classPoints + '_t').on(mname, getMoseDownFunc('t')).on(ename, getMoseDownFunc('t')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height / 2).attr('class', this.options.classPoints + '_r').on(mname, getMoseDownFunc('r')).on(ename, getMoseDownFunc('r')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, bbox.height).attr('class', this.options.classPoints + '_b').on(mname, getMoseDownFunc('b')).on(ename, getMoseDownFunc('b')));\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height / 2).attr('class', this.options.classPoints + '_l').on(mname, getMoseDownFunc('l')).on(ename, getMoseDownFunc('l')));\r\n\r\n        this.rectSelection.set.each(function () {\r\n            this.addClass(_this.options.classPoints);\r\n        });\r\n    }\r\n\r\n    // draw rotationPint, if enabled\r\n    if (this.options.rotationPoint && ((this.options.points && !this.rectSelection.set.get(9)) || (!this.options.points && !this.rectSelection.set.get(1)))) {\r\n\r\n        var curriedEvent = function (ev) {\r\n            ev = ev || window.event;\r\n            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\r\n            ev.stopPropagation();\r\n\r\n            var x = ev.pageX || ev.touches[0].pageX;\r\n            var y = ev.pageY || ev.touches[0].pageY;\r\n            _this.el.fire('rot', {x: x, y: y, event: ev});\r\n        };\r\n        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 20).attr('class', this.options.classPoints + '_rot')\r\n            .on(\"touchstart\", curriedEvent).on(\"mousedown\", curriedEvent));\r\n\r\n    }\r\n\r\n};\r\n\r\nSelectHandler.prototype.handler = function () {\r\n\r\n    var bbox = this.el.bbox();\r\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\r\n\r\n    if (this.rectSelection.isSelected) {\r\n        this.updateRectSelection();\r\n    }\r\n\r\n    if (this.pointSelection.isSelected) {\r\n        this.updatePointSelection();\r\n    }\r\n\r\n};\r\n\r\nSelectHandler.prototype.observe = function () {\r\n    var _this = this;\r\n\r\n    if (MutationObserver) {\r\n        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n            this.observerInst = this.observerInst || new MutationObserver(function () {\r\n                _this.handler();\r\n            });\r\n            this.observerInst.observe(this.el.node, {attributes: true});\r\n        } else {\r\n            try {\r\n                this.observerInst.disconnect();\r\n                delete this.observerInst;\r\n            } catch (e) {\r\n            }\r\n        }\r\n    } else {\r\n        this.el.off('DOMAttrModified.select');\r\n\r\n        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\r\n            this.el.on('DOMAttrModified.select', function () {\r\n                _this.handler();\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nSelectHandler.prototype.cleanup = function () {\r\n\r\n    //var _this = this;\r\n\r\n    if (!this.rectSelection.isSelected && this.rectSelection.set) {\r\n        // stop watching the element, remove the selection\r\n        this.rectSelection.set.each(function () {\r\n            this.remove();\r\n        });\r\n\r\n        this.rectSelection.set.clear();\r\n        delete this.rectSelection.set;\r\n    }\r\n\r\n    if (!this.pointSelection.isSelected && this.pointSelection.set) {\r\n        // Remove all points, clear the set, stop watching the element\r\n        this.pointSelection.set.each(function () {\r\n            this.remove();\r\n        });\r\n\r\n        this.pointSelection.set.clear();\r\n        delete this.pointSelection.set;\r\n    }\r\n\r\n    if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {\r\n        this.nested.remove();\r\n        delete this.nested;\r\n\r\n    }\r\n};\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n    // Select element with mouse\r\n    selectize: function (value, options) {\r\n\r\n        // Check the parameters and reassign if needed\r\n        if (typeof value === 'object') {\r\n            options = value;\r\n            value = true;\r\n        }\r\n\r\n        var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);\r\n\r\n        selectHandler.init(value === undefined ? true : value, options || {});\r\n\r\n        return this;\r\n\r\n    }\r\n});\r\n\r\nSVG.Element.prototype.selectize.defaults = {\r\n    points: true,                            // If true, points at the edges are drawn. Needed for resize!\r\n    classRect: 'svg_select_boundingRect',    // Css-class added to the rect\r\n    classPoints: 'svg_select_points',        // Css-class added to the points\r\n    radius: 7,                               // radius of the points\r\n    rotationPoint: true,                     // If true, rotation point is drawn. Needed for rotation!\r\n    deepSelect: false                        // If true, moving of single points is possible (only line, polyline, polyon)\r\n};\n}());\n\n(function() {\n(function () {\r\n\r\n    function ResizeHandler(el) {\r\n\r\n        el.remember('_resizeHandler', this);\r\n\r\n        this.el = el;\r\n        this.parameters = {};\r\n        this.lastUpdateCall = null;\r\n        this.p = el.doc().node.createSVGPoint();\r\n    }\r\n\r\n    ResizeHandler.prototype.transformPoint = function(x, y, m){\r\n\r\n        this.p.x = x - (this.offset.x - window.pageXOffset);\r\n        this.p.y = y - (this.offset.y - window.pageYOffset);\r\n\r\n        return this.p.matrixTransform(m || this.m);\r\n\r\n    };\r\n\r\n    ResizeHandler.prototype._extractPosition = function(event) {\r\n        // Extract a position from a mouse/touch event.\r\n        // Returns { x: .., y: .. }\r\n        return {\r\n            x: event.clientX != null ? event.clientX : event.touches[0].clientX,\r\n            y: event.clientY != null ? event.clientY : event.touches[0].clientY\r\n        }\r\n    };\r\n\r\n    ResizeHandler.prototype.init = function (options) {\r\n\r\n        var _this = this;\r\n\r\n        this.stop();\r\n\r\n        if (options === 'stop') {\r\n            return;\r\n        }\r\n\r\n        this.options = {};\r\n\r\n        // Merge options and defaults\r\n        for (var i in this.el.resize.defaults) {\r\n            this.options[i] = this.el.resize.defaults[i];\r\n            if (typeof options[i] !== 'undefined') {\r\n                this.options[i] = options[i];\r\n            }\r\n        }\r\n\r\n        // We listen to all these events which are specifying different edges\r\n        this.el.on('lt.resize', function(e){ _this.resize(e || window.event); });  // Left-Top\r\n        this.el.on('rt.resize', function(e){ _this.resize(e || window.event); });  // Right-Top\r\n        this.el.on('rb.resize', function(e){ _this.resize(e || window.event); });  // Right-Bottom\r\n        this.el.on('lb.resize', function(e){ _this.resize(e || window.event); });  // Left-Bottom\r\n\r\n        this.el.on('t.resize', function(e){ _this.resize(e || window.event); });   // Top\r\n        this.el.on('r.resize', function(e){ _this.resize(e || window.event); });   // Right\r\n        this.el.on('b.resize', function(e){ _this.resize(e || window.event); });   // Bottom\r\n        this.el.on('l.resize', function(e){ _this.resize(e || window.event); });   // Left\r\n\r\n        this.el.on('rot.resize', function(e){ _this.resize(e || window.event); }); // Rotation\r\n\r\n        this.el.on('point.resize', function(e){ _this.resize(e || window.event); }); // Point-Moving\r\n\r\n        // This call ensures, that the plugin reacts to a change of snapToGrid immediately\r\n        this.update();\r\n\r\n    };\r\n\r\n    ResizeHandler.prototype.stop = function(){\r\n        this.el.off('lt.resize');\r\n        this.el.off('rt.resize');\r\n        this.el.off('rb.resize');\r\n        this.el.off('lb.resize');\r\n\r\n        this.el.off('t.resize');\r\n        this.el.off('r.resize');\r\n        this.el.off('b.resize');\r\n        this.el.off('l.resize');\r\n\r\n        this.el.off('rot.resize');\r\n\r\n        this.el.off('point.resize');\r\n\r\n        return this;\r\n    };\r\n\r\n    ResizeHandler.prototype.resize = function (event) {\r\n\r\n        var _this = this;\r\n\r\n        this.m = this.el.node.getScreenCTM().inverse();\r\n        this.offset = { x: window.pageXOffset, y: window.pageYOffset };\r\n\r\n        var txPt = this._extractPosition(event.detail.event);\r\n        this.parameters = {\r\n            type: this.el.type, // the type of element\r\n            p: this.transformPoint(txPt.x, txPt.y),\r\n            x: event.detail.x,      // x-position of the mouse when resizing started\r\n            y: event.detail.y,      // y-position of the mouse when resizing started\r\n            box: this.el.bbox(),    // The bounding-box of the element\r\n            rotation: this.el.transform().rotation  // The current rotation of the element\r\n        };\r\n\r\n        // Add font-size parameter if the element type is text\r\n        if (this.el.type === \"text\") {\r\n            this.parameters.fontSize = this.el.attr()[\"font-size\"];\r\n        }\r\n\r\n        // the i-param in the event holds the index of the point which is moved, when using `deepSelect`\r\n        if (event.detail.i !== undefined) {\r\n\r\n            // get the point array\r\n            var array = this.el.array().valueOf();\r\n\r\n            // Save the index and the point which is moved\r\n            this.parameters.i = event.detail.i;\r\n            this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];\r\n        }\r\n\r\n        // Lets check which edge of the bounding-box was clicked and resize the this.el according to this\r\n        switch (event.type) {\r\n\r\n            // Left-Top-Edge\r\n            case 'lt':\r\n                // We build a calculating function for every case which gives us the new position of the this.el\r\n                this.calc = function (diffX, diffY) {\r\n                    // The procedure is always the same\r\n                    // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)\r\n                    var snap = this.snapToGrid(diffX, diffY);\r\n\r\n                    // Now we check if the new height and width still valid (> 0)\r\n                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                        // ...if valid, we resize the this.el (which can include moving because the coord-system starts at the left-top and this edge is moving sometimes when resized)\r\n\r\n                        /*\r\n                         * but first check if the element is text box, so we can change the font size instead of\r\n                         * the width and height\r\n                         */\r\n\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1]).size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right-Top\r\n            case 'rt':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right-Bottom\r\n            case 'rb':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Left-Bottom\r\n            case 'lb':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1);\r\n                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\r\n                            this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\r\n                            return;\r\n                        }\r\n\r\n                        snap = this.checkAspectRatio(snap);\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Top\r\n            case 't':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);\r\n                    if (this.parameters.box.height - snap[1] > 0) {\r\n                        // Disable the font-resizing if it is not from the corner of bounding-box\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).height(this.parameters.box.height - snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Right\r\n            case 'r':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.width + snap[0] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + snap[0]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Bottom\r\n            case 'b':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 0);\r\n                    if (this.parameters.box.height + snap[1] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + snap[1]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Left\r\n            case 'l':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n                    var snap = this.snapToGrid(diffX, diffY, 1);\r\n                    if (this.parameters.box.width - snap[0] > 0) {\r\n                        if (this.parameters.type === \"text\") {\r\n                            return;\r\n                        }\r\n\r\n                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).width(this.parameters.box.width - snap[0]);\r\n                    }\r\n                };\r\n                break;\r\n\r\n            // Rotation\r\n            case 'rot':\r\n                // s.a.\r\n                this.calc = function (diffX, diffY) {\r\n\r\n                    // yes this is kinda stupid but we need the mouse coords back...\r\n                    var current = {x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y};\r\n\r\n                    // start minus middle\r\n                    var sAngle = Math.atan2((this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2), (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                    // end minus middle\r\n                    var pAngle = Math.atan2((current.y - this.parameters.box.y - this.parameters.box.height / 2), (current.x - this.parameters.box.x - this.parameters.box.width / 2));\r\n\r\n                    var angle = (pAngle - sAngle) * 180 / Math.PI;\r\n\r\n                    // We have to move the element to the center of the box first and change the rotation afterwards\r\n                    // because rotation always works around a rotation-center, which is changed when moving the element\r\n                    // We also set the new rotation center to the center of the box.\r\n                    this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(this.parameters.rotation + angle - angle % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);\r\n                };\r\n                break;\r\n\r\n            // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)\r\n            case 'point':\r\n                this.calc = function (diffX, diffY) {\r\n\r\n                    // Snapping the point to the grid\r\n                    var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);\r\n\r\n                    // Get the point array\r\n                    var array = this.el.array().valueOf();\r\n\r\n                    // Changing the moved point in the array\r\n                    array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];\r\n                    array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];\r\n\r\n                    // And plot the new this.el\r\n                    this.el.plot(array);\r\n                };\r\n        }\r\n\r\n        this.el.fire('resizestart', {dx: this.parameters.x, dy: this.parameters.y, event: event});\r\n        // When resizing started, we have to register events for...\r\n        // Touches.\r\n        SVG.on(window, 'touchmove.resize', function(e) {\r\n            _this.update(e || window.event);\r\n        });\r\n        SVG.on(window, 'touchend.resize', function() {\r\n            _this.done();\r\n        });\r\n        // Mouse.\r\n        SVG.on(window, 'mousemove.resize', function (e) {\r\n            _this.update(e || window.event);\r\n        });\r\n        SVG.on(window, 'mouseup.resize', function () {\r\n            _this.done();\r\n        });\r\n\r\n    };\r\n\r\n    // The update-function redraws the element every time the mouse is moving\r\n    ResizeHandler.prototype.update = function (event) {\r\n\r\n        if (!event) {\r\n            if (this.lastUpdateCall) {\r\n                this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Calculate the difference between the mouseposition at start and now\r\n        var txPt = this._extractPosition(event);\r\n        var p = this.transformPoint(txPt.x, txPt.y);\r\n\r\n        var diffX = p.x - this.parameters.p.x,\r\n            diffY = p.y - this.parameters.p.y;\r\n\r\n        this.lastUpdateCall = [diffX, diffY];\r\n\r\n        // Calculate the new position and height / width of the element\r\n        this.calc(diffX, diffY);\r\n\r\n       // Emit an event to say we have changed.\r\n        this.el.fire('resizing', {dx: diffX, dy: diffY, event: event});\r\n    };\r\n\r\n    // Is called on mouseup.\r\n    // Removes the update-function from the mousemove event\r\n    ResizeHandler.prototype.done = function () {\r\n        this.lastUpdateCall = null;\r\n        SVG.off(window, 'mousemove.resize');\r\n        SVG.off(window, 'mouseup.resize');\r\n        SVG.off(window, 'touchmove.resize');\r\n        SVG.off(window, 'touchend.resize');\r\n        this.el.fire('resizedone');\r\n    };\r\n\r\n    // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)\r\n    // In this cases the temp-values are calculated differently\r\n    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {\r\n\r\n        var temp;\r\n\r\n        // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value\r\n        if (typeof pointCoordsY !== 'undefined') {\r\n            // Note that flag = pointCoordsX in this case\r\n            temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];\r\n        } else {\r\n            // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)\r\n            flag = flag == null ? 1 | 1 << 1 : flag;\r\n            temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid];\r\n        }\r\n\r\n\r\n        diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2 ?\r\n                  temp[0] :\r\n                  temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n        diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2 ?\r\n                  temp[1] :\r\n                  temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));\r\n\r\n        return this.constraintToBox(diffX, diffY, flag, pointCoordsY);\r\n\r\n    };\r\n\r\n    // keep element within constrained box\r\n    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {\r\n        //return [diffX, diffY]\r\n        var c = this.options.constraint || {};\r\n        var orgX, orgY;\r\n\r\n        if (typeof pointCoordsY !== 'undefined') {\r\n          orgX = flag;\r\n          orgY = pointCoordsY;\r\n        } else {\r\n          orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);\r\n          orgY = this.parameters.box.y + (flag & (1<<1) ? 0 : this.parameters.box.height);\r\n        }\r\n\r\n        if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {\r\n          diffX = c.minX - orgX;\r\n        }\r\n\r\n        if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {\r\n          diffX = c.maxX - orgX;\r\n        }\r\n\r\n        if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {\r\n          diffY = c.minY - orgY;\r\n        }\r\n\r\n        if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {\r\n          diffY = c.maxY - orgY;\r\n        }\r\n\r\n        return [diffX, diffY];\r\n    };\r\n\r\n    ResizeHandler.prototype.checkAspectRatio = function (snap) {\r\n        if (!this.options.saveAspectRatio) {\r\n            return snap;\r\n        }\r\n\r\n        var updatedSnap = snap.slice();\r\n        var aspectRatio = this.parameters.box.width / this.parameters.box.height;\r\n        var newW = this.parameters.box.width + snap[0];\r\n        var newH = this.parameters.box.height - snap[1];\r\n        var newAspectRatio = newW / newH;\r\n\r\n        if (newAspectRatio < aspectRatio) {\r\n            // Height is too big. Adapt it\r\n            updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;\r\n        } else if (newAspectRatio > aspectRatio) {\r\n            // Width is too big. Adapt it\r\n            updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;\r\n        }\r\n\r\n        return updatedSnap;\r\n\r\n    };\r\n\r\n    SVG.extend(SVG.Element, {\r\n        // Resize element with mouse\r\n        resize: function (options) {\r\n\r\n            (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n    });\r\n\r\n    SVG.Element.prototype.resize.defaults = {\r\n        snapToAngle: 0.1,       // Specifies the speed the rotation is happening when moving the mouse\r\n        snapToGrid: 1,          // Snaps to a grid of `snapToGrid` Pixels\r\n        constraint: {},         // keep element within constrained box\r\n        saveAspectRatio: false  // Save aspect ratio when resizing using lt, rt, rb or lb points\r\n    };\r\n\r\n}).call(this);\n}());\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".apexcharts-canvas {\\n  position: relative;\\n  user-select: none;\\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\\n}\\n\\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\\n.apexcharts-canvas ::-webkit-scrollbar {\\n  -webkit-appearance: none;\\n  width: 6px;\\n}\\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\\n  border-radius: 4px;\\n  background-color: rgba(0,0,0,.5);\\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\\n}\\n\\n.apexcharts-inner {\\n  position: relative;\\n}\\n\\n.legend-mouseover-inactive {\\n  transition: 0.15s ease all;\\n  opacity: 0.20;\\n}\\n\\n.apexcharts-series-collapsed {\\n  opacity: 0;\\n}\\n\\n.apexcharts-gridline, .apexcharts-text {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-tooltip {\\n  border-radius: 5px;\\n  box-shadow: 2px 2px 6px -4px #999;\\n  cursor: default;\\n  font-size: 14px;\\n  left: 62px;\\n  opacity: 0;\\n  pointer-events: none;\\n  position: absolute;\\n  top: 20px;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  z-index: 12;\\n  transition: 0.15s ease all;\\n}\\n.apexcharts-tooltip.light {\\n  border: 1px solid #e3e3e3;\\n  background: rgba(255, 255, 255, 0.96);\\n}\\n.apexcharts-tooltip.dark {\\n  color: #fff;\\n  background: rgba(30,30,30, 0.8);\\n}\\n.apexcharts-tooltip * {\\n  font-family: inherit;\\n}\\n\\n.apexcharts-tooltip .apexcharts-marker,\\n.apexcharts-area-series .apexcharts-area,\\n.apexcharts-line {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-tooltip.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-tooltip-title {\\n  padding: 6px;\\n  font-size: 15px;\\n  margin-bottom: 4px;\\n}\\n.apexcharts-tooltip.light .apexcharts-tooltip-title {\\n  background: #ECEFF1;\\n  border-bottom: 1px solid #ddd;\\n}\\n.apexcharts-tooltip.dark .apexcharts-tooltip-title {\\n  background: rgba(0, 0, 0, 0.7);\\n  border-bottom: 1px solid #222;\\n}\\n\\n.apexcharts-tooltip-text-value,\\n.apexcharts-tooltip-text-z-value {\\n  display: inline-block;\\n  font-weight: 600;\\n  margin-left: 5px;\\n}\\n\\n.apexcharts-tooltip-text-z-label:empty,\\n.apexcharts-tooltip-text-z-value:empty {\\n  display: none;\\n}\\n\\n.apexcharts-tooltip-text-value, \\n.apexcharts-tooltip-text-z-value {\\n  font-weight: 600;\\n}\\n\\n.apexcharts-tooltip-marker {\\n  width: 12px;\\n  height: 12px;\\n  position: relative;\\n  top: 0px;\\n  margin-right: 10px;\\n  border-radius: 50%;\\n}\\n\\n.apexcharts-tooltip-series-group {\\n  padding: 0 10px;\\n  display: none;\\n  text-align: left;\\n  justify-content: left;\\n  align-items: center;\\n}\\n\\n.apexcharts-tooltip-series-group.active .apexcharts-tooltip-marker {\\n  opacity: 1;\\n}\\n.apexcharts-tooltip-series-group.active, .apexcharts-tooltip-series-group:last-child {\\n  padding-bottom: 4px;\\n}\\n.apexcharts-tooltip-y-group {\\n  padding: 6px 0 5px;\\n}\\n.apexcharts-tooltip-candlestick {\\n  padding: 4px 8px;\\n}\\n.apexcharts-tooltip-candlestick > div {\\n  margin: 4px 0;\\n}\\n.apexcharts-tooltip-candlestick span.value {\\n  font-weight: bold;\\n}\\n\\n.apexcharts-xaxistooltip {\\n  opacity: 0;\\n  padding: 9px 10px;\\n  pointer-events: none;\\n  color: #373d3f;\\n  font-size: 13px;\\n  text-align: center;\\n  border-radius: 2px;\\n  position: absolute;\\n  z-index: 10;\\n\\tbackground: #ECEFF1;\\n  border: 1px solid #90A4AE;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\\n\\tleft: 50%;\\n\\tborder: solid transparent;\\n\\tcontent: \\\" \\\";\\n\\theight: 0;\\n\\twidth: 0;\\n\\tposition: absolute;\\n\\tpointer-events: none;\\n}\\n\\n.apexcharts-xaxistooltip:after {\\n\\tborder-color: rgba(236, 239, 241, 0);\\n\\tborder-width: 6px;\\n\\tmargin-left: -6px;\\n}\\n.apexcharts-xaxistooltip:before {\\n\\tborder-color: rgba(144, 164, 174, 0);\\n\\tborder-width: 7px;\\n\\tmargin-left: -7px;\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\\n  bottom: 100%;\\n}\\n\\n.apexcharts-xaxistooltip-bottom:after {\\n  border-bottom-color: #ECEFF1;\\n}\\n.apexcharts-xaxistooltip-bottom:before {\\n  border-bottom-color: #90A4AE;\\n}\\n\\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\\n  top: 100%;\\n}\\n.apexcharts-xaxistooltip-top:after {\\n  border-top-color: #ECEFF1;\\n}\\n.apexcharts-xaxistooltip-top:before {\\n  border-top-color: #90A4AE;\\n}\\n\\n.apexcharts-xaxistooltip.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-yaxistooltip {\\n  opacity: 0;\\n  padding: 4px 10px;\\n  pointer-events: none;\\n  color: #373d3f;\\n  font-size: 13px;\\n  text-align: center;\\n  border-radius: 2px;\\n  position: absolute;\\n  z-index: 10;\\n\\tbackground: #ECEFF1;\\n  border: 1px solid #90A4AE;\\n}\\n\\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\\n\\ttop: 50%;\\n\\tborder: solid transparent;\\n\\tcontent: \\\" \\\";\\n\\theight: 0;\\n\\twidth: 0;\\n\\tposition: absolute;\\n\\tpointer-events: none;\\n}\\n.apexcharts-yaxistooltip:after {\\n\\tborder-color: rgba(236, 239, 241, 0);\\n\\tborder-width: 6px;\\n\\tmargin-top: -6px;\\n}\\n.apexcharts-yaxistooltip:before {\\n\\tborder-color: rgba(144, 164, 174, 0);\\n\\tborder-width: 7px;\\n\\tmargin-top: -7px;\\n}\\n\\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\\n  left: 100%;\\n}\\n.apexcharts-yaxistooltip-left:after {\\n  border-left-color: #ECEFF1;\\n}\\n.apexcharts-yaxistooltip-left:before {\\n  border-left-color: #90A4AE;\\n}\\n\\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\\n  right: 100%;\\n}\\n.apexcharts-yaxistooltip-right:after {\\n  border-right-color: #ECEFF1;\\n}\\n.apexcharts-yaxistooltip-right:before {\\n  border-right-color: #90A4AE;\\n}\\n\\n.apexcharts-yaxistooltip.active {\\n  opacity: 1;\\n}\\n\\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\\n  pointer-events: none;\\n  opacity: 0;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-xcrosshairs.active, .apexcharts-ycrosshairs.active {\\n  opacity: 1;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-ycrosshairs-hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-zoom-rect {\\n  pointer-events: none;\\n}\\n.apexcharts-selection-rect {\\n  cursor: move;\\n}\\n\\n.svg_select_points, .svg_select_points_rot {\\n  opacity: 0;\\n  visibility: hidden;\\n}\\n.svg_select_points_l, .svg_select_points_r {\\n  cursor: ew-resize;\\n  opacity: 1;\\n  visibility: visible;\\n  fill: #888;\\n}\\n.apexcharts-canvas.zoomable .hovering-zoom {\\n  cursor: crosshair\\n}\\n.apexcharts-canvas.zoomable .hovering-pan {\\n  cursor: move\\n}\\n\\n.apexcharts-xaxis,\\n.apexcharts-yaxis {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-zoom-icon, \\n.apexcharts-zoom-in-icon,\\n.apexcharts-zoom-out-icon,\\n.apexcharts-reset-zoom-icon, \\n.apexcharts-pan-icon, \\n.apexcharts-selection-icon,\\n.apexcharts-menu-icon, \\n.apexcharts-toolbar-custom-icon {\\n  cursor: pointer;\\n  width: 20px;\\n  height: 20px;\\n  line-height: 24px;\\n  color: #6E8192;\\n  text-align: center;\\n}\\n\\n.apexcharts-zoom-icon svg, \\n.apexcharts-zoom-in-icon svg,\\n.apexcharts-zoom-out-icon svg,\\n.apexcharts-reset-zoom-icon svg,\\n.apexcharts-menu-icon svg {\\n  fill: #6E8192;\\n}\\n.apexcharts-selection-icon svg {\\n  fill: #444;\\n  transform: scale(0.76)\\n}\\n.apexcharts-zoom-icon.selected svg, \\n.apexcharts-selection-icon.selected svg, \\n.apexcharts-reset-zoom-icon.selected svg {\\n  fill: #008FFB;\\n}\\n.apexcharts-selection-icon:not(.selected):hover svg,\\n.apexcharts-zoom-icon:not(.selected):hover svg, \\n.apexcharts-zoom-in-icon:hover svg, \\n.apexcharts-zoom-out-icon:hover svg, \\n.apexcharts-reset-zoom-icon:hover svg, \\n.apexcharts-menu-icon:hover svg {\\n  fill: #333;\\n}\\n\\n.apexcharts-selection-icon, .apexcharts-menu-icon {\\n  position: relative;\\n}\\n.apexcharts-reset-zoom-icon {\\n  margin-left: 5px;\\n}\\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\\n  transform: scale(0.85);\\n}\\n\\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\\n  transform: scale(0.7)\\n}\\n\\n.apexcharts-zoom-out-icon {\\n  margin-right: 3px;\\n}\\n\\n.apexcharts-pan-icon {\\n  transform: scale(0.62);\\n  position: relative;\\n  left: 1px;\\n  top: 0px;\\n}\\n.apexcharts-pan-icon svg {\\n  fill: #fff;\\n  stroke: #6E8192;\\n  stroke-width: 2;\\n}\\n.apexcharts-pan-icon.selected svg {\\n  stroke: #008FFB;\\n}\\n.apexcharts-pan-icon:not(.selected):hover svg {\\n  stroke: #333;\\n}\\n\\n.apexcharts-toolbar {\\n  position: absolute;\\n  z-index: 11;\\n  top: 0px;\\n  right: 3px;\\n  max-width: 176px;\\n  text-align: right;\\n  border-radius: 3px;\\n  padding: 0px 6px 2px 6px;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center; \\n}\\n\\n.apexcharts-toolbar svg {\\n  pointer-events: none;\\n}\\n\\n.apexcharts-menu {\\n  background: #fff;\\n  position: absolute;\\n  top: 100%;\\n  border: 1px solid #ddd;\\n  border-radius: 3px;\\n  padding: 3px;\\n  right: 10px;\\n  opacity: 0;\\n  min-width: 110px;\\n  transition: 0.15s ease all;\\n  pointer-events: none;\\n}\\n\\n.apexcharts-menu.open {\\n  opacity: 1;\\n  pointer-events: all;\\n  transition: 0.15s ease all;\\n}\\n\\n.apexcharts-menu-item {\\n  padding: 6px 7px;\\n  font-size: 12px;\\n  cursor: pointer;\\n}\\n.apexcharts-menu-item:hover {\\n  background: #eee;\\n}\\n\\n@media screen and (min-width: 768px) {\\n  .apexcharts-toolbar {\\n    /*opacity: 0;*/\\n  }\\n\\n  .apexcharts-canvas:hover .apexcharts-toolbar {\\n    opacity: 1;\\n  } \\n}\\n\\n.apexcharts-datalabel.hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-pie-label,\\n.apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\\n  cursor: default;\\n  pointer-events: none;\\n}\\n\\n.apexcharts-pie-label-delay {\\n  opacity: 0;\\n  animation-name: opaque;\\n  animation-duration: 0.3s;\\n  animation-fill-mode: forwards;\\n  animation-timing-function: ease;\\n}\\n\\n.apexcharts-canvas .hidden {\\n  opacity: 0;\\n}\\n\\n.apexcharts-hide .apexcharts-series-points {\\n  opacity: 0;\\n}\\n\\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\\n  pointer-events: none;\\n}\\n\\n/* markers */\\n\\n.apexcharts-marker {\\n  transition: 0.15s ease all;\\n}\\n\\n@keyframes opaque {\\n  0% {\\n    opacity: 0;\\n  }\\n  100% {\\n    opacity: 1;\\n  }\\n}\";\nstyleInject(css);\n\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 1.2.20171210\n *\n * By Eli Grey, http://eligrey.com\n * License: Dedicated to the public domain.\n *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\nif (\"document\" in self) {\n  // Full polyfill for browsers with no classList support\n  // Including IE < Edge missing SVGElement.classList\n  if (!(\"classList\" in document.createElement(\"_\")) || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"))) {\n    (function (view) {\n\n      if (!('Element' in view)) return;\n\n      var classListProp = \"classList\",\n          protoProp = \"prototype\",\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          strTrim = String[protoProp].trim || function () {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n      },\n          arrIndexOf = Array[protoProp].indexOf || function (item) {\n        var i = 0,\n            len = this.length;\n\n        for (; i < len; i++) {\n          if (i in this && this[i] === item) {\n            return i;\n          }\n        }\n\n        return -1;\n      } // Vendors: please allow content code to instantiate DOMExceptions\n      ,\n          DOMEx = function DOMEx(type, message) {\n        this.name = type;\n        this.code = DOMException[type];\n        this.message = message;\n      },\n          checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {\n        if (token === \"\") {\n          throw new DOMEx(\"SYNTAX_ERR\", \"The token must not be empty.\");\n        }\n\n        if (/\\s/.test(token)) {\n          throw new DOMEx(\"INVALID_CHARACTER_ERR\", \"The token must not contain space characters.\");\n        }\n\n        return arrIndexOf.call(classList, token);\n      },\n          ClassList = function ClassList(elem) {\n        var trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\"),\n            classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : [],\n            i = 0,\n            len = classes.length;\n\n        for (; i < len; i++) {\n          this.push(classes[i]);\n        }\n\n        this._updateClassName = function () {\n          elem.setAttribute(\"class\", this.toString());\n        };\n      },\n          classListProto = ClassList[protoProp] = [],\n          classListGetter = function classListGetter() {\n        return new ClassList(this);\n      }; // Most DOMException implementations don't allow calling DOMException's toString()\n      // on non-DOMExceptions. Error's toString() is sufficient here.\n\n\n      DOMEx[protoProp] = Error[protoProp];\n\n      classListProto.item = function (i) {\n        return this[i] || null;\n      };\n\n      classListProto.contains = function (token) {\n        return ~checkTokenAndGetIndex(this, token + \"\");\n      };\n\n      classListProto.add = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false;\n\n        do {\n          token = tokens[i] + \"\";\n\n          if (!~checkTokenAndGetIndex(this, token)) {\n            this.push(token);\n            updated = true;\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n\n      classListProto.remove = function () {\n        var tokens = arguments,\n            i = 0,\n            l = tokens.length,\n            token,\n            updated = false,\n            index;\n\n        do {\n          token = tokens[i] + \"\";\n          index = checkTokenAndGetIndex(this, token);\n\n          while (~index) {\n            this.splice(index, 1);\n            updated = true;\n            index = checkTokenAndGetIndex(this, token);\n          }\n        } while (++i < l);\n\n        if (updated) {\n          this._updateClassName();\n        }\n      };\n\n      classListProto.toggle = function (token, force) {\n        var result = this.contains(token),\n            method = result ? force !== true && \"remove\" : force !== false && \"add\";\n\n        if (method) {\n          this[method](token);\n        }\n\n        if (force === true || force === false) {\n          return force;\n        } else {\n          return !result;\n        }\n      };\n\n      classListProto.replace = function (token, replacement_token) {\n        var index = checkTokenAndGetIndex(token + \"\");\n\n        if (~index) {\n          this.splice(index, 1, replacement_token);\n\n          this._updateClassName();\n        }\n      };\n\n      classListProto.toString = function () {\n        return this.join(\" \");\n      };\n\n      if (objCtr.defineProperty) {\n        var classListPropDesc = {\n          get: classListGetter,\n          enumerable: true,\n          configurable: true\n        };\n\n        try {\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        } catch (ex) {\n          // IE 8 doesn't support enumerable:true\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          }\n        }\n      } else if (objCtr[protoProp].__defineGetter__) {\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\n      }\n    })(self);\n  } // There is full or partial native classList support, so just check if we need\n  // to normalize the add/remove and toggle APIs.\n\n\n  (function () {\n\n    var testElement = document.createElement(\"_\");\n    testElement.classList.add(\"c1\", \"c2\"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and\n    // classList.remove exist but support only one argument at a time.\n\n    if (!testElement.classList.contains(\"c2\")) {\n      var createMethod = function createMethod(method) {\n        var original = DOMTokenList.prototype[method];\n\n        DOMTokenList.prototype[method] = function (token) {\n          var i,\n              len = arguments.length;\n\n          for (i = 0; i < len; i++) {\n            token = arguments[i];\n            original.call(this, token);\n          }\n        };\n      };\n\n      createMethod('add');\n      createMethod('remove');\n    }\n\n    testElement.classList.toggle(\"c3\", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n    // support the second argument.\n\n    if (testElement.classList.contains(\"c3\")) {\n      var _toggle = DOMTokenList.prototype.toggle;\n\n      DOMTokenList.prototype.toggle = function (token, force) {\n        if (1 in arguments && !this.contains(token) === !force) {\n          return force;\n        } else {\n          return _toggle.call(this, token);\n        }\n      };\n    } // replace() polyfill\n\n\n    if (!(\"replace\" in document.createElement(\"_\").classList)) {\n      DOMTokenList.prototype.replace = function (token, replacement_token) {\n        var tokens = this.toString().split(\" \"),\n            index = tokens.indexOf(token + \"\");\n\n        if (~index) {\n          tokens = tokens.slice(index);\n          this.remove.apply(this, tokens);\n          this.add(replacement_token);\n          this.add.apply(this, tokens.slice(1));\n        }\n      };\n    }\n\n    testElement = null;\n  })();\n}\n\n/**\n* Detect Element Resize\n*\n* https://github.com/sdecima/javascript-detect-element-resize\n* Sebastian Decima\n*\n* version: 0.5.3\n**/\n(function () {\n  var stylesCreated = false;\n\n  function resetTriggers(element) {\n    var triggers = element.__resizeTriggers__,\n        expand = triggers.firstElementChild,\n        contract = triggers.lastElementChild,\n        expandChild = expand.firstElementChild;\n    contract.scrollLeft = contract.scrollWidth;\n    contract.scrollTop = contract.scrollHeight;\n    expandChild.style.width = expand.offsetWidth + 1 + 'px';\n    expandChild.style.height = expand.offsetHeight + 1 + 'px';\n    expand.scrollLeft = expand.scrollWidth;\n    expand.scrollTop = expand.scrollHeight;\n  }\n\n  function checkTriggers(element) {\n    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;\n  }\n\n  function scrollListener(e) {\n    var element = this;\n    resetTriggers(this);\n    if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);\n    this.__resizeRAF__ = requestFrame(function () {\n      if (checkTriggers(element)) {\n        element.__resizeLast__.width = element.offsetWidth;\n        element.__resizeLast__.height = element.offsetHeight;\n\n        element.__resizeListeners__.forEach(function (fn) {\n          fn.call(e);\n        });\n      }\n    });\n  }\n\n  function createStyles() {\n    if (!stylesCreated) {\n      // opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\n      var css = (animationKeyframes || '') + '.resize-triggers { ' + (animationStyle || '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \\\" \\\"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n          head = document.head || document.getElementsByTagName('head')[0],\n          style = document.createElement('style');\n      style.type = 'text/css';\n\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(document.createTextNode(css));\n      }\n\n      head.appendChild(style);\n      stylesCreated = true;\n    }\n  }\n\n  var requestFrame = function () {\n    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n      return window.setTimeout(fn, 20);\n    };\n\n    return function (fn) {\n      return raf(fn);\n    };\n  }();\n\n  var cancelFrame = function () {\n    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;\n    return function (id) {\n      return cancel(id);\n    };\n  }();\n  /* Detect CSS Animations support to detect element display/re-attach */\n\n\n  var animation = false,\n      keyframeprefix = '',\n      animationstartevent = 'animationstart',\n      domPrefixes = 'Webkit Moz O ms'.split(' '),\n      startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),\n      pfx = '';\n  {\n    var elm = document.createElement('fakeelement');\n\n    if (elm.style.animationName !== undefined) {\n      animation = true;\n    }\n\n    if (animation === false) {\n      for (var i = 0; i < domPrefixes.length; i++) {\n        if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {\n          pfx = domPrefixes[i];\n          keyframeprefix = '-' + pfx.toLowerCase() + '-';\n          animationstartevent = startEvents[i];\n          break;\n        }\n      }\n    }\n  }\n  var animationName = 'resizeanim';\n  var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';\n  var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';\n\n  window.addResizeListener = function (element, fn) {\n    if (!element.__resizeTriggers__) {\n      if (getComputedStyle(element).position == 'static') element.style.position = 'relative';\n      createStyles();\n      element.__resizeLast__ = {};\n      element.__resizeListeners__ = [];\n      (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';\n      element.__resizeTriggers__.innerHTML = '<div class=\"expand-trigger\"><div></div></div>' + '<div class=\"contract-trigger\"></div>';\n      element.appendChild(element.__resizeTriggers__);\n      resetTriggers(element);\n      element.addEventListener('scroll', scrollListener, true);\n      /* Listen for a css animation to detect element display/re-attach */\n\n      animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function (e) {\n        if (e.animationName == animationName) {\n          resetTriggers(element);\n        }\n      });\n    }\n\n    element.__resizeListeners__.push(fn);\n  };\n\n  window.removeResizeListener = function (element, fn) {\n    if (element) {\n      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n\n      if (!element.__resizeListeners__.length) {\n        element.removeEventListener('scroll', scrollListener);\n        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);\n      }\n    }\n  };\n})();\n\nwindow.Apex = {};\n/**\n *\n * @module ApexCharts\n **/\n\nvar ApexCharts$1 =\n/*#__PURE__*/\nfunction () {\n  function ApexCharts(el, opts) {\n    _classCallCheck(this, ApexCharts);\n\n    this.opts = opts;\n    this.ctx = this; // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.\n\n    this.w = new Base(opts).init();\n    this.el = el;\n    this.w.globals.cuid = (Math.random() + 1).toString(36).substring(4);\n    this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid;\n    this.initModules();\n    this.create = Utils.bind(this.create, this);\n    this.windowResizeHandler = this.windowResize.bind(this);\n  }\n  /**\n   * The primary method user will call to render the chart.\n   */\n\n\n  _createClass(ApexCharts, [{\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      // main method\n      return new Promise$1(function (resolve, reject) {\n        // only draw chart, if element found\n        if (_this.el !== null) {\n          if (typeof Apex._chartInstances === 'undefined') {\n            Apex._chartInstances = [];\n          }\n\n          if (_this.w.config.chart.id) {\n            Apex._chartInstances.push({\n              id: _this.w.globals.chartID,\n              group: _this.w.config.chart.group,\n              chart: _this\n            });\n          } // set the locale here\n\n\n          _this.setLocale(_this.w.config.chart.defaultLocale);\n\n          var beforeMount = _this.w.config.chart.events.beforeMount;\n\n          if (typeof beforeMount === 'function') {\n            beforeMount(_this, _this.w);\n          }\n\n          _this.fireEvent('beforeMount', [_this, _this.w]);\n\n          window.addEventListener('resize', _this.windowResizeHandler);\n          window.addResizeListener(_this.el.parentNode, _this.parentResizeCallback.bind(_this));\n\n          var graphData = _this.create(_this.w.config.series, {});\n\n          if (!graphData) return resolve(_this);\n\n          _this.mount(graphData).then(function () {\n            resolve(graphData);\n\n            if (typeof _this.w.config.chart.events.mounted === 'function') {\n              _this.w.config.chart.events.mounted(_this, _this.w);\n            }\n\n            _this.fireEvent('mounted', [_this, _this.w]);\n          }).catch(function (e) {\n            reject(e); // handle error in case no data or element not found\n          });\n        } else {\n          reject(new Error('Element not found'));\n        }\n      });\n    }\n  }, {\n    key: \"initModules\",\n    value: function initModules() {\n      this.animations = new Animations(this.ctx);\n      this.annotations = new Annotations(this.ctx);\n      this.core = new Core(this.el, this);\n      this.grid = new Grid(this);\n      this.coreUtils = new CoreUtils(this);\n      this.config = new Config({});\n      this.crosshairs = new Crosshairs(this.ctx);\n      this.options = new Options();\n      this.responsive = new Responsive(this.ctx);\n      this.series = new Series(this.ctx);\n      this.theme = new Theme(this.ctx);\n      this.formatters = new Formatters(this.ctx);\n      this.titleSubtitle = new TitleSubtitle(this.ctx);\n      this.legend = new Legend(this.ctx);\n      this.toolbar = new Toolbar(this.ctx);\n      this.dimensions = new Dimensions(this.ctx);\n      this.zoomPanSelection = new ZoomPanSelection(this.ctx);\n      this.w.globals.tooltip = new Tooltip(this.ctx);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(name$$1, handler) {\n      var w = this.w;\n\n      if (w.globals.events.hasOwnProperty(name$$1)) {\n        w.globals.events[name$$1].push(handler);\n      } else {\n        w.globals.events[name$$1] = [handler];\n      }\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name$$1, handler) {\n      var w = this.w;\n\n      if (!w.globals.events.hasOwnProperty(name$$1)) {\n        return;\n      }\n\n      var index = w.globals.events[name$$1].indexOf(handler);\n\n      if (index !== -1) {\n        w.globals.events[name$$1].splice(index, 1);\n      }\n    }\n  }, {\n    key: \"fireEvent\",\n    value: function fireEvent(name$$1, args) {\n      var w = this.w;\n\n      if (!w.globals.events.hasOwnProperty(name$$1)) {\n        return;\n      }\n\n      if (!args || !args.length) {\n        args = [];\n      }\n\n      var evs = w.globals.events[name$$1];\n      var l = evs.length;\n\n      for (var i = 0; i < l; i++) {\n        evs[i].apply(null, args);\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(ser, opts) {\n      var w = this.w;\n      this.initModules();\n      var gl = this.w.globals;\n      gl.noData = false;\n      gl.animationEnded = false;\n      this.responsive.checkResponsiveConfig(opts);\n\n      if (this.el === null) {\n        gl.animationEnded = true;\n        return null;\n      }\n\n      this.core.setupElements();\n\n      if (gl.svgWidth === 0) {\n        // if the element is hidden, skip drawing\n        gl.animationEnded = true;\n        return null;\n      }\n\n      var combo = CoreUtils.checkComboSeries(ser);\n      gl.comboCharts = combo.comboCharts;\n      gl.comboChartsHasBars = combo.comboChartsHasBars;\n\n      if (ser.length === 0 || ser.length === 1 && ser[0].data && ser[0].data.length === 0) {\n        this.series.handleNoData();\n      }\n\n      this.setupEventHandlers();\n      this.core.parseData(ser); // this is a good time to set theme colors first\n\n      this.theme.init(); // labelFormatters should be called before dimensions as in dimensions we need text labels width\n      // as markers accepts array, we need to setup global markers for easier access\n\n      var markers = new Markers(this);\n      markers.setGlobalMarkerSize();\n      this.formatters.setLabelFormatters();\n      this.titleSubtitle.draw(); // legend is calculated here before coreCalculations because it affects the plottable area\n\n      this.legend.init(); // check whether in multiple series, all series share the same X\n\n      this.series.hasAllSeriesEqualX(); // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals\n\n      if (gl.axisCharts) {\n        this.core.coreCalculations();\n\n        if (w.config.xaxis.type !== 'category') {\n          // as we have minX and maxX values, determine the default DateTimeFormat for time series\n          this.formatters.setLabelFormatters();\n        }\n      } // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function\n      // Also we need to do this before calcuting Dimentions plotCoords() method of Dimensions\n\n\n      this.formatters.heatmapLabelFormatters(); // We got plottable area here, next task would be to calculate axis areas\n\n      this.dimensions.plotCoords();\n      var xyRatios = this.core.xySettings();\n      this.grid.createGridMask();\n      var elGraph = this.core.plotChartType(ser, xyRatios); // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends\n\n      this.core.shiftGraphPosition();\n      var dim = {\n        plot: {\n          left: w.globals.translateX,\n          top: w.globals.translateY,\n          width: w.globals.gridWidth,\n          height: w.globals.gridHeight\n        }\n      };\n      return {\n        elGraph: elGraph,\n        xyRatios: xyRatios,\n        elInner: w.globals.dom.elGraphical,\n        dimensions: dim\n      };\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var me = this;\n      var w = me.w;\n      return new Promise$1(function (resolve, reject) {\n        // no data to display\n        if (me.el === null) {\n          return reject(new Error('Not enough data to display or target element not found'));\n        } else if (graphData === null || w.globals.allSeriesCollapsed) {\n          me.series.handleNoData();\n        }\n\n        me.core.drawAxis(w.config.chart.type, graphData.xyRatios);\n        me.grid = new Grid(me);\n\n        if (w.config.grid.position === 'back') {\n          me.grid.drawGrid();\n        }\n\n        if (w.config.annotations.position === 'back') {\n          me.annotations.drawAnnotations();\n        }\n\n        if (graphData.elGraph instanceof Array) {\n          for (var g = 0; g < graphData.elGraph.length; g++) {\n            w.globals.dom.elGraphical.add(graphData.elGraph[g]);\n          }\n        } else {\n          w.globals.dom.elGraphical.add(graphData.elGraph);\n        }\n\n        if (w.config.grid.position === 'front') {\n          me.grid.drawGrid();\n        }\n\n        if (w.config.xaxis.crosshairs.position === 'front') {\n          me.crosshairs.drawXCrosshairs();\n        }\n\n        if (w.config.yaxis[0].crosshairs.position === 'front') {\n          me.crosshairs.drawYCrosshairs();\n        }\n\n        if (w.config.annotations.position === 'front') {\n          me.annotations.drawAnnotations();\n        }\n\n        if (!w.globals.noData) {\n          // draw tooltips at the end\n          if (w.config.tooltip.enabled && !w.globals.noData) {\n            me.w.globals.tooltip.drawTooltip(graphData.xyRatios);\n          }\n\n          if (w.globals.axisCharts && w.globals.isXNumeric) {\n            if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {\n              me.zoomPanSelection.init({\n                xyRatios: graphData.xyRatios\n              });\n            }\n          } else {\n            var tools = w.config.chart.toolbar.tools;\n            tools.zoom = false;\n            tools.zoomin = false;\n            tools.zoomout = false;\n            tools.selection = false;\n            tools.pan = false;\n            tools.reset = false;\n          }\n\n          if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {\n            me.toolbar.createToolbar();\n          }\n        }\n\n        if (w.globals.memory.methodsToExec.length > 0) {\n          w.globals.memory.methodsToExec.forEach(function (fn) {\n            fn.method(fn.params, false, fn.context);\n          });\n        }\n\n        resolve(me);\n      });\n    }\n  }, {\n    key: \"clearPreviousPaths\",\n    value: function clearPreviousPaths() {\n      var w = this.w;\n      w.globals.previousPaths = [];\n      w.globals.allSeriesCollapsed = false;\n      w.globals.collapsedSeries = [];\n      w.globals.collapsedSeriesIndices = [];\n    }\n    /**\n     * Allows users to update Options after the chart has rendered.\n     *\n     * @param {object} options - A new config object can be passed which will be merged with the existing config object\n     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n     * @param {boolean} animate - should animate or not on updating Options\n     */\n\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(options$$1) {\n      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var w = this.w;\n\n      if (options$$1.series) {\n        if (options$$1.series[0].data) {\n          options$$1.series = options$$1.series.map(function (s, i) {\n            return _objectSpread({}, w.config.series[i], {\n              name: s.name ? s.name : w.config.series[i].name,\n              type: s.type,\n              data: s.data\n            });\n          });\n        } // user updated the series via updateOptions() function.\n        // Hence, we need to reset axis min/max to avoid zooming issues\n\n\n        this.revertDefaultAxisMinMax();\n      } // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max\n\n\n      if (options$$1.xaxis) {\n        if (options$$1.xaxis.min || options$$1.xaxis.max) {\n          this.forceXAxisUpdate(options$$1);\n        }\n        /* fixes apexcharts.js#369 and react-apexcharts#46 */\n\n\n        if (options$$1.xaxis.categories && options$$1.xaxis.categories.length && w.config.xaxis.convertedCatToNumeric) {\n          options$$1 = Defaults.convertCatToNumeric(options$$1);\n        }\n      }\n\n      if (w.globals.collapsedSeriesIndices.length > 0) {\n        this.clearPreviousPaths();\n      }\n\n      return this._updateOptions(options$$1, redraw, animate, overwriteInitialConfig);\n    }\n    /**\n     * private method to update Options.\n     *\n     * @param {object} options - A new config object can be passed which will be merged with the existing config object\n     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there\n     * @param {boolean} animate - should animate or not on updating Options\n     * @param {boolean} overwriteInitialConfig - should update the initial config or not\n     */\n\n  }, {\n    key: \"_updateOptions\",\n    value: function _updateOptions(options$$1) {\n      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var charts = this.getSyncedCharts();\n      charts.forEach(function (ch) {\n        var w = ch.w;\n        w.globals.shouldAnimate = animate;\n\n        if (!redraw) {\n          w.globals.resized = true;\n          w.globals.dataChanged = true;\n\n          if (animate) {\n            ch.series.getPreviousPaths();\n          }\n        }\n\n        if (options$$1 && _typeof(options$$1) === 'object') {\n          ch.config = new Config(options$$1);\n          options$$1 = CoreUtils.extendArrayProps(ch.config, options$$1);\n          w.config = Utils.extend(w.config, options$$1);\n\n          if (overwriteInitialConfig) {\n            // we need to forget the lastXAxis and lastYAxis is user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.\n            w.globals.lastXAxis = [];\n            w.globals.lastYAxis = []; // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries\n\n            w.globals.initialConfig = Utils.extend({}, w.config);\n            w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));\n          }\n        }\n\n        return ch.update(options$$1);\n      });\n    }\n    /**\n     * Allows users to update Series after the chart has rendered.\n     *\n     * @param {array} series - New series which will override the existing\n     */\n\n  }, {\n    key: \"updateSeries\",\n    value: function updateSeries() {\n      var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      this.revertDefaultAxisMinMax();\n      return this._updateSeries(newSeries, animate, overwriteInitialSeries);\n    }\n    /**\n     * Allows users to append a new series after the chart has rendered.\n     *\n     * @param {array} newSerie - New serie which will be appended to the existing series\n     */\n\n  }, {\n    key: \"appendSeries\",\n    value: function appendSeries(newSerie) {\n      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var newSeries = this.w.config.series.slice();\n      newSeries.push(newSerie);\n      this.revertDefaultAxisMinMax();\n      return this._updateSeries(newSeries, animate);\n    }\n    /**\n     * Private method to update Series.\n     *\n     * @param {array} series - New series which will override the existing\n     */\n\n  }, {\n    key: \"_updateSeries\",\n    value: function _updateSeries(newSeries, animate) {\n      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var w = this.w;\n      this.w.globals.shouldAnimate = animate;\n      w.globals.dataChanged = true; // if user has collapsed some series with legend, we need to clear those\n\n      if (w.globals.allSeriesCollapsed) {\n        w.globals.allSeriesCollapsed = false;\n      }\n\n      if (animate) {\n        this.series.getPreviousPaths();\n      }\n\n      var existingSeries; // axis charts\n\n      if (newSeries[0].data) {\n        existingSeries = newSeries.map(function (s, i) {\n          return _objectSpread({}, w.config.series[i], {\n            name: s.name ? s.name : w.config.series[i].name,\n            type: s.type,\n            data: s.data\n          });\n        });\n        w.config.series = existingSeries;\n      } else {\n        // non-axis chart (pie/radialbar)\n        w.config.series = newSeries.slice();\n      }\n\n      if (overwriteInitialSeries) {\n        w.globals.initialConfig.series = JSON.parse(JSON.stringify(w.config.series));\n        w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));\n      }\n\n      return this.update();\n    }\n    /**\n     * Get all charts in the same \"group\" (including the instance which is called upon) to sync them when user zooms in/out or pan.\n     */\n\n  }, {\n    key: \"getSyncedCharts\",\n    value: function getSyncedCharts() {\n      var chartGroups = this.getGroupedCharts();\n      var allCharts = [this];\n\n      if (chartGroups.length) {\n        allCharts = [];\n        chartGroups.forEach(function (ch) {\n          allCharts.push(ch);\n        });\n      }\n\n      return allCharts;\n    }\n    /**\n     * Get charts in the same \"group\" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)\n     */\n\n  }, {\n    key: \"getGroupedCharts\",\n    value: function getGroupedCharts() {\n      var _this2 = this;\n\n      return Apex._chartInstances.filter(function (ch) {\n        if (ch.group) {\n          return true;\n        }\n      }).map(function (ch) {\n        return _this2.w.config.chart.group === ch.group ? ch.chart : _this2;\n      });\n    }\n    /**\n     * Allows users to append Data to series.\n     *\n     * @param {array} newData - New data in the same format as series\n     */\n\n  }, {\n    key: \"appendData\",\n    value: function appendData(newData) {\n      var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var me = this;\n      me.w.globals.dataChanged = true;\n      me.series.getPreviousPaths();\n      var newSeries = me.w.config.series.slice();\n\n      for (var i = 0; i < newSeries.length; i++) {\n        if (typeof newData[i] !== 'undefined') {\n          for (var j = 0; j < newData[i].data.length; j++) {\n            newSeries[i].data.push(newData[i].data[j]);\n          }\n        }\n      }\n\n      me.w.config.series = newSeries;\n\n      if (overwriteInitialSeries) {\n        me.w.globals.initialSeries = JSON.parse(JSON.stringify(me.w.config.series));\n      }\n\n      return this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update(options$$1) {\n      var _this3 = this;\n\n      return new Promise$1(function (resolve, reject) {\n        _this3.clear();\n\n        var graphData = _this3.create(_this3.w.config.series, options$$1);\n\n        if (!graphData) return resolve(_this3);\n\n        _this3.mount(graphData).then(function () {\n          if (typeof _this3.w.config.chart.events.updated === 'function') {\n            _this3.w.config.chart.events.updated(_this3, _this3.w);\n          }\n\n          _this3.fireEvent('updated', [_this3, _this3.w]);\n\n          _this3.w.globals.isDirty = true;\n          resolve(_this3);\n        }).catch(function (e) {\n          reject(e);\n        });\n      });\n    }\n  }, {\n    key: \"forceXAxisUpdate\",\n    value: function forceXAxisUpdate(options$$1) {\n      var w = this.w;\n\n      if (typeof options$$1.xaxis.min !== 'undefined') {\n        w.config.xaxis.min = options$$1.xaxis.min;\n        w.globals.lastXAxis.min = options$$1.xaxis.min;\n      }\n\n      if (typeof options$$1.xaxis.max !== 'undefined') {\n        w.config.xaxis.max = options$$1.xaxis.max;\n        w.globals.lastXAxis.max = options$$1.xaxis.max;\n      }\n    }\n    /**\n     * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.\n     * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max\n     * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally\n     */\n\n  }, {\n    key: \"revertDefaultAxisMinMax\",\n    value: function revertDefaultAxisMinMax() {\n      var w = this.w;\n      w.config.xaxis.min = w.globals.lastXAxis.min;\n      w.config.xaxis.max = w.globals.lastXAxis.max;\n      w.config.yaxis.map(function (yaxe, index) {\n        if (w.globals.zoomed) {\n          // if user has zoomed, and this function is called\n          // then we need to get the lastAxis min and max\n          if (typeof w.globals.lastYAxis[index] !== 'undefined') {\n            yaxe.min = w.globals.lastYAxis[index].min;\n            yaxe.max = w.globals.lastYAxis[index].max;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.zoomPanSelection) {\n        this.zoomPanSelection.destroy();\n      }\n\n      if (this.toolbar) {\n        this.toolbar.destroy();\n      }\n\n      this.animations = null;\n      this.annotations = null;\n      this.core = null;\n      this.grid = null;\n      this.series = null;\n      this.responsive = null;\n      this.theme = null;\n      this.formatters = null;\n      this.titleSubtitle = null;\n      this.legend = null;\n      this.dimensions = null;\n      this.options = null;\n      this.crosshairs = null;\n      this.zoomPanSelection = null;\n      this.toolbar = null;\n      this.w.globals.tooltip = null;\n      this.clearDomElements();\n    }\n  }, {\n    key: \"killSVG\",\n    value: function killSVG(draw) {\n      return new Promise$1(function (resolve, reject) {\n        draw.each(function (i, children) {\n          this.removeClass('*');\n          this.off();\n          this.stop();\n        }, true);\n        draw.ungroup();\n        draw.clear();\n        resolve('done');\n      });\n    }\n  }, {\n    key: \"clearDomElements\",\n    value: function clearDomElements() {\n      var domEls = this.w.globals.dom;\n\n      if (this.el !== null) {\n        // remove all child elements - resetting the whole chart\n        while (this.el.firstChild) {\n          this.el.removeChild(this.el.firstChild);\n        }\n      }\n\n      this.killSVG(domEls.Paper);\n      domEls.Paper.remove();\n      domEls.elWrap = null;\n      domEls.elGraphical = null;\n      domEls.elLegendWrap = null;\n      domEls.baseEl = null;\n      domEls.elGridRect = null;\n      domEls.elGridRectMask = null;\n      domEls.elGridRectMarkerMask = null;\n      domEls.elDefs = null;\n    }\n    /**\n     * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clear(); // remove the chart's instance from the global Apex._chartInstances\n\n      var chartID = this.w.config.chart.id;\n\n      if (chartID) {\n        Apex._chartInstances.forEach(function (c, i) {\n          if (c.id === chartID) {\n            Apex._chartInstances.splice(i, 1);\n          }\n        });\n      }\n\n      window.removeEventListener('resize', this.windowResizeHandler);\n      window.removeResizeListener(this.el.parentNode, this.parentResizeCallback.bind(this));\n    }\n    /**\n     * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute\n     */\n\n  }, {\n    key: \"toggleSeries\",\n    value: function toggleSeries(seriesName) {\n      var targetElement = this.series.getSeriesByName(seriesName);\n      var seriesCnt = parseInt(targetElement.getAttribute('data:realIndex'));\n      var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');\n      this.legend.toggleDataSeries(seriesCnt, isHidden);\n    }\n  }, {\n    key: \"resetToggleSeries\",\n    value: function resetToggleSeries() {\n      this.legend.resetToggleDataSeries();\n    }\n  }, {\n    key: \"setupEventHandlers\",\n    value: function setupEventHandlers() {\n      var w = this.w;\n      var me = this;\n      var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);\n      var eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];\n      eventList.forEach(function (event) {\n        clickableArea.addEventListener(event, function (e) {\n          if (e.type === 'mousedown' && e.which === 1) ; else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {\n            if (typeof w.config.chart.events.click === 'function') {\n              w.config.chart.events.click(e, me, w);\n            }\n\n            me.fireEvent('click', [e, me, w]);\n          }\n        }, {\n          capture: false,\n          passive: true\n        });\n      });\n      this.core.setupBrushHandler();\n    }\n  }, {\n    key: \"addXaxisAnnotation\",\n    value: function addXaxisAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"addYaxisAnnotation\",\n    value: function addYaxisAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"addPointAnnotation\",\n    value: function addPointAnnotation(opts) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);\n    }\n  }, {\n    key: \"clearAnnotations\",\n    value: function clearAnnotations() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.clearAnnotations(me);\n    } // This method is never used internally and will be only called externally on the chart instance.\n    // Hence, we need to keep all these elements in memory when the chart gets updated and redraw again\n\n  }, {\n    key: \"addText\",\n    value: function addText(options$$1) {\n      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var me = this;\n\n      if (context) {\n        me = context;\n      }\n\n      me.annotations.addText(options$$1, pushToMemory, me);\n    }\n  }, {\n    key: \"getChartArea\",\n    value: function getChartArea() {\n      var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');\n      return el;\n    }\n  }, {\n    key: \"getSeriesTotalXRange\",\n    value: function getSeriesTotalXRange(minX, maxX) {\n      return this.coreUtils.getSeriesTotalsXRange(minX, maxX);\n    }\n  }, {\n    key: \"getHighestValueInSeries\",\n    value: function getHighestValueInSeries() {\n      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var range = new Range$1(this.ctx);\n      var minYmaxY = range.getMinYMaxY(seriesIndex);\n      return minYmaxY.highestY;\n    }\n  }, {\n    key: \"getLowestValueInSeries\",\n    value: function getLowestValueInSeries() {\n      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var range = new Range$1(this.ctx);\n      var minYmaxY = range.getMinYMaxY(seriesIndex);\n      return minYmaxY.lowestY;\n    }\n  }, {\n    key: \"getSeriesTotal\",\n    value: function getSeriesTotal() {\n      return this.w.globals.seriesTotals;\n    }\n  }, {\n    key: \"setLocale\",\n    value: function setLocale(localeName) {\n      this.setCurrentLocaleValues(localeName);\n    }\n  }, {\n    key: \"setCurrentLocaleValues\",\n    value: function setCurrentLocaleValues(localeName) {\n      var locales = this.w.config.chart.locales; // check if user has specified locales in global Apex variable\n      // if yes - then extend those with local chart's locale\n\n      if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {\n        locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);\n      } // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)\n\n\n      var selectedLocale = locales.filter(function (c) {\n        return c.name === localeName;\n      })[0];\n\n      if (selectedLocale) {\n        // create a complete locale object by extending defaults so you don't get undefined errors.\n        var ret = Utils.extend(en, selectedLocale); // store these locale options in global var for ease access\n\n        this.w.globals.locale = ret.options;\n      } else {\n        throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');\n      }\n    }\n  }, {\n    key: \"svgUrl\",\n    value: function svgUrl() {\n      var exp = new Exports(this.ctx);\n      return exp.svgUrl();\n    }\n  }, {\n    key: \"dataURI\",\n    value: function dataURI() {\n      var exp = new Exports(this.ctx);\n      return exp.dataURI();\n    }\n  }, {\n    key: \"paper\",\n    value: function paper() {\n      return this.w.globals.dom.Paper;\n    }\n  }, {\n    key: \"parentResizeCallback\",\n    value: function parentResizeCallback() {\n      if (this.w.globals.animationEnded) {\n        this.windowResize();\n      }\n    }\n    /**\n     * Handle window resize and re-draw the whole chart.\n     */\n\n  }, {\n    key: \"windowResize\",\n    value: function windowResize() {\n      var _this4 = this;\n\n      clearTimeout(this.w.globals.resizeTimer);\n      this.w.globals.resizeTimer = window.setTimeout(function () {\n        _this4.w.globals.resized = true;\n        _this4.w.globals.dataChanged = false; // we need to redraw the whole chart on window resize (with a small delay).\n\n        _this4.update();\n      }, 150);\n    }\n  }], [{\n    key: \"initOnLoad\",\n    value: function initOnLoad() {\n      var els = document.querySelectorAll('[data-apexcharts]');\n\n      for (var i = 0; i < els.length; i++) {\n        var el = els[i];\n        var options$$1 = JSON.parse(els[i].getAttribute('data-options'));\n        var apexChart = new ApexCharts(el, options$$1);\n        apexChart.render();\n      }\n    }\n    /**\n     * This static method allows users to call chart methods without necessarily from the\n     * instance of the chart in case user has assigned chartID to the targetted chart.\n     * The chartID is used for mapping the instance stored in Apex._chartInstances global variable\n     *\n     * This is helpful in cases when you don't have reference of the chart instance\n     * easily and need to call the method from anywhere.\n     * For eg, in React/Vue applications when you have many parent/child components,\n     * and need easy reference to other charts for performing dynamic operations\n     *\n     * @param {string} chartID - The unique identifier which will be used to call methods\n     * on that chart instance\n     * @param {function} fn - The method name to call\n     * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(chartID, fn) {\n      var chart = this.getChartByID(chartID);\n      if (!chart) return;\n\n      for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        opts[_key - 2] = arguments[_key];\n      }\n\n      switch (fn) {\n        case 'updateOptions':\n          {\n            return chart.updateOptions.apply(chart, opts);\n          }\n\n        case 'updateSeries':\n          {\n            return chart.updateSeries.apply(chart, opts);\n          }\n\n        case 'appendData':\n          {\n            return chart.appendData.apply(chart, opts);\n          }\n\n        case 'addXaxisAnnotation':\n          {\n            return chart.addXaxisAnnotation.apply(chart, opts);\n          }\n\n        case 'addYaxisAnnotation':\n          {\n            return chart.addYaxisAnnotation.apply(chart, opts);\n          }\n\n        case 'addPointAnnotation':\n          {\n            return chart.addPointAnnotation.apply(chart, opts);\n          }\n\n        case 'clearAnnotations':\n          {\n            return chart.clearAnnotations.apply(chart, opts);\n          }\n\n        case 'destroy':\n          {\n            return chart.destroy();\n          }\n      }\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(target, source) {\n      return Utils.extend(target, source);\n    }\n  }, {\n    key: \"getChartByID\",\n    value: function getChartByID(chartID) {\n      var c = Apex._chartInstances.filter(function (ch) {\n        return ch.id === chartID;\n      })[0];\n\n      return c.chart;\n    }\n  }]);\n\n  return ApexCharts;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ApexCharts$1);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBleGNoYXJ0cy9kaXN0L2FwZXhjaGFydHMuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FwZXhjaGFydHMvZGlzdC9hcGV4Y2hhcnRzLmVzbS5qcz9lMTIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQXBleENoYXJ0cyB2My42LjJcbiAqIChjKSAyMDE4LTIwMTkgSnVuZWQgQ2hoaXBhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG4vKlxuICoqIEdlbmVyaWMgZnVuY3Rpb25zIHdoaWNoIGFyZSBub3QgZGVwZW5kZW50IG9uIEFwZXhDaGFydHNcbiAqL1xudmFyIFV0aWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVdGlscywgW3tcbiAgICBrZXk6IFwic2hhZGVSR0JDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZVJHQkNvbG9yKHBlcmNlbnQsIGNvbG9yKSB7XG4gICAgICB2YXIgZiA9IGNvbG9yLnNwbGl0KCcsJyksXG4gICAgICAgICAgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NSxcbiAgICAgICAgICBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50LFxuICAgICAgICAgIFIgPSBwYXJzZUludChmWzBdLnNsaWNlKDQpKSxcbiAgICAgICAgICBHID0gcGFyc2VJbnQoZlsxXSksXG4gICAgICAgICAgQiA9IHBhcnNlSW50KGZbMl0pO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIChNYXRoLnJvdW5kKCh0IC0gUikgKiBwKSArIFIpICsgJywnICsgKE1hdGgucm91bmQoKHQgLSBHKSAqIHApICsgRykgKyAnLCcgKyAoTWF0aC5yb3VuZCgodCAtIEIpICogcCkgKyBCKSArICcpJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hhZGVIZXhDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZUhleENvbG9yKHBlcmNlbnQsIGNvbG9yKSB7XG4gICAgICB2YXIgZiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNiksXG4gICAgICAgICAgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NSxcbiAgICAgICAgICBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50LFxuICAgICAgICAgIFIgPSBmID4+IDE2LFxuICAgICAgICAgIEcgPSBmID4+IDggJiAweDAwZmYsXG4gICAgICAgICAgQiA9IGYgJiAweDAwMDBmZjtcbiAgICAgIHJldHVybiAnIycgKyAoMHgxMDAwMDAwICsgKE1hdGgucm91bmQoKHQgLSBSKSAqIHApICsgUikgKiAweDEwMDAwICsgKE1hdGgucm91bmQoKHQgLSBHKSAqIHApICsgRykgKiAweDEwMCArIChNYXRoLnJvdW5kKCh0IC0gQikgKiBwKSArIEIpKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfSAvLyBiZWF1dGlmdWwgY29sb3Igc2hhZGluZyBibGVuZGluZyBjb2RlXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3Itb3ItcmdiLWFuZC1ibGVuZC1jb2xvcnNcblxuICB9LCB7XG4gICAga2V5OiBcInNoYWRlQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hhZGVDb2xvcihwLCBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA+IDcpIHJldHVybiB0aGlzLnNoYWRlUkdCQ29sb3IocCwgY29sb3IpO2Vsc2UgcmV0dXJuIHRoaXMuc2hhZGVIZXhDb2xvcihwLCBjb2xvcik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiYmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKGZuLCBtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gJiYgX3R5cGVvZihpdGVtKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgaXRlbSAhPSBudWxsO1xuICAgIH0gLy8gdG8gZXh0ZW5kIGRlZmF1bHRzIHdpdGggdXNlciBvcHRpb25zXG4gICAgLy8gY3JlZGl0OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3OTM2NzcyL2RlZXAtb2JqZWN0LW1lcmdpbmctaW4tZXM2LWVzNyNhbnN3ZXItMzQ3NDk4NzNcblxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgX3NvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgICAgaWYgKF9zb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBfc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBfc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3NvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBfc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpO1xuXG4gICAgICBpZiAodGhpcy5pc09iamVjdCh0YXJnZXQpICYmIHRoaXMuaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgc291cmNlW2tleV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gX3RoaXMuZXh0ZW5kKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgc291cmNlW2tleV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRBcnJheShhcnJUb0V4dGVuZCwgcmVzdWx0QXJyKSB7XG4gICAgICB2YXIgZXh0ZW5kZWRBcnIgPSBbXTtcbiAgICAgIGFyclRvRXh0ZW5kLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBleHRlbmRlZEFyci5wdXNoKFV0aWxzLmV4dGVuZChyZXN1bHRBcnIsIGl0ZW0pKTtcbiAgICAgIH0pO1xuICAgICAgYXJyVG9FeHRlbmQgPSBleHRlbmRlZEFycjtcbiAgICAgIHJldHVybiBhcnJUb0V4dGVuZDtcbiAgICB9IC8vIElmIG1vbnRoIGNvdW50ZXIgZXhjZWVkcyAxMiwgaXQgc3RhcnRzIGFnYWluIGZyb20gMVxuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhNb2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhNb2QobW9udGgpIHtcbiAgICAgIHJldHVybiBtb250aCAlIDEyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9wcyhvYmosIGFyciwgdmFsKSB7XG4gICAgICBpZiAodHlwZW9mIGFyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXJyID0gYXJyLnNwbGl0KCcuJyk7XG4gICAgICB9XG5cbiAgICAgIG9ialthcnJbMF1dID0gb2JqW2FyclswXV0gfHwge307XG4gICAgICB2YXIgdG1wT2JqID0gb2JqW2FyclswXV07XG5cbiAgICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICBhcnIuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wcyh0bXBPYmosIGFyciwgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialthcnJbMF1dID0gdmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc291cmNlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB2YXIgY2xvbmVSZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNsb25lUmVzdWx0W2ldID0gdGhpcy5jbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lUmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHNvdXJjZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBfY2xvbmVSZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIF9jbG9uZVJlc3VsdFtwcm9wXSA9IHRoaXMuY2xvbmUoc291cmNlW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2Nsb25lUmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nMTBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFRvQmFzZTEwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kVG9CYXNlMTAoeCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAoeCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRUb0Jhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmRUb0Jhc2UoeCwgYmFzZSkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KGJhc2UsIE1hdGguZmxvb3IoTWF0aC5sb2coeCkgLyBNYXRoLmxvZyhiYXNlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU51bWJlcih2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwpIHJldHVybiB2YWw7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWwpIHtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgZWxlbWVudEhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBlbGVtZW50V2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgLT0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgICAgZWxlbWVudFdpZHRoIC09IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgIHJldC5wdXNoKGVsZW1lbnRXaWR0aCk7XG4gICAgICByZXQucHVzaChlbGVtZW50SGVpZ2h0KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20sXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgeTogcmVjdC55XG4gICAgICB9O1xuICAgIH0gLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2IjYW5zd2VyLTEyMzQyMjc1XG5cbiAgfSwge1xuICAgIGtleTogXCJoZXhUb1JnYmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGV4VG9SZ2JhKCkge1xuICAgICAgdmFyIGhleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyM5OTk5OTknO1xuICAgICAgdmFyIG9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDAuNjtcblxuICAgICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMSkgIT09ICcjJykge1xuICAgICAgICBoZXggPSAnIzk5OTk5OSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gaGV4LnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICBoID0gaC5tYXRjaChuZXcgUmVnRXhwKCcoLnsnICsgaC5sZW5ndGggLyAzICsgJ30pJywgJ2cnKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBoW2ldID0gcGFyc2VJbnQoaFtpXS5sZW5ndGggPT09IDEgPyBoW2ldICsgaFtpXSA6IGhbaV0sIDE2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykgaC5wdXNoKG9wYWNpdHkpO1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBoLmpvaW4oJywnKSArICcpJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3BhY2l0eUZyb21SR0JBXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wYWNpdHlGcm9tUkdCQShyZ2JhKSB7XG4gICAgICByZ2JhID0gcmdiYS5tYXRjaCgvXnJnYmE/W1xccytdP1xcKFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/L2kpO1xuICAgICAgcmV0dXJuIHJnYmFbM107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJnYjJoZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgICAgIHJnYiA9IHJnYi5tYXRjaCgvXnJnYmE/W1xccytdP1xcKFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/LFtcXHMrXT8oXFxkKylbXFxzK10/L2kpO1xuICAgICAgcmV0dXJuIHJnYiAmJiByZ2IubGVuZ3RoID09PSA0ID8gJyMnICsgKCcwJyArIHBhcnNlSW50KHJnYlsxXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKCcwJyArIHBhcnNlSW50KHJnYlsyXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKCcwJyArIHBhcnNlSW50KHJnYlszXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpIDogJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ29sb3JIZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDb2xvckhleChjb2xvcikge1xuICAgICAgcmV0dXJuIC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGNvbG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9sYXJUb0NhcnRlc2lhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb2xhclRvQ2FydGVzaWFuKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgYW5nbGVJbkRlZ3JlZXMpIHtcbiAgICAgIHZhciBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyksXG4gICAgICAgIHk6IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucylcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzY2FwZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgICB2YXIgZXNjYXBlV2l0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gnO1xuICAgICAgdmFyIG5ld1N0ciA9IHN0ci50b1N0cmluZygpLnNsaWNlKCk7XG4gICAgICBuZXdTdHIgPSBuZXdTdHIucmVwbGFjZSgvW2AgfiFAIyQlXiYqKClffCtcXC09Pzs6J1wiLC48Plxce1xcfVxcW1xcXVxcXFxcXC9dL2dpLCBlc2NhcGVXaXRoKTtcbiAgICAgIHJldHVybiBuZXdTdHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lZ1RvWmVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWdUb1plcm8odmFsKSB7XG4gICAgICByZXR1cm4gdmFsIDwgMCA/IDAgOiB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVJbmRleEluQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUluZGV4SW5BcnJheShhcnIsIG9sZF9pbmRleCwgbmV3X2luZGV4KSB7XG4gICAgICBpZiAobmV3X2luZGV4ID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGsgPSBuZXdfaW5kZXggLSBhcnIubGVuZ3RoICsgMTtcblxuICAgICAgICB3aGlsZSAoay0tKSB7XG4gICAgICAgICAgYXJyLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcnIuc3BsaWNlKG5ld19pbmRleCwgMCwgYXJyLnNwbGljZShvbGRfaW5kZXgsIDEpWzBdKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3ROdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdE51bWJlcihzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnJlcGxhY2UoL1teXFxkXFwuXSovZywgJycpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZG9tU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW4pIHtcbiAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcG9zc2libGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGV4dCArPSBwb3NzaWJsZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc2libGUubGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQW5jZXN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFuY2VzdG9yKGVsLCBjbHMpIHtcbiAgICAgIHdoaWxlICgoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpIHtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRFTHN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFTHN0eWxlcyhlbCwgc3R5bGVzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGVsLnN0eWxlLmtleSA9IHN0eWxlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiBwYXJzZUZsb2F0KE51bWJlcih2YWx1ZSkpID09PSB2YWx1ZSAmJiAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRmxvYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGbG9hdChuKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG4pID09PSBuICYmIG4gJSAxICE9PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1NhZmFyaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICAgIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpcmVmb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJRTExXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSUUxMSgpIHtcbiAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgIT09IC0xIHx8IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSUVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJRSgpIHtcbiAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgdmFyIG1zaWUgPSB1YS5pbmRleE9mKCdNU0lFICcpO1xuXG4gICAgICBpZiAobXNpZSA+IDApIHtcbiAgICAgICAgLy8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyaWRlbnQgPSB1YS5pbmRleE9mKCdUcmlkZW50LycpO1xuXG4gICAgICBpZiAodHJpZGVudCA+IDApIHtcbiAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpO1xuXG4gICAgICBpZiAoZWRnZSA+IDApIHtcbiAgICAgICAgLy8gRWRnZSAoSUUgMTIrKSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhlZGdlICsgNSwgdWEuaW5kZXhPZignLicsIGVkZ2UpKSwgMTApO1xuICAgICAgfSAvLyBvdGhlciBicm93c2VyXG5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVdGlscztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEZpbHRlcnMgQ2xhc3MgZm9yIHNldHRpbmcgaG92ZXIvYWN0aXZlIHN0YXRlcyBvbiB0aGUgcGF0aHMuXG4gKlxuICogQG1vZHVsZSBGb3JtYXR0ZXJzXG4gKiovXG5cbnZhciBGaWx0ZXJzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsdGVycyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVycyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfSAvLyBjcmVhdGUgYSByZS11c2FibGUgZmlsdGVyIHdoaWNoIGNhbiBiZSBhcHBlbmRlZCBvdGhlciBmaWx0ZXIgZWZmZWN0cyBhbmQgYXBwbGllZCB0byBtdWx0aXBsZSBlbGVtZW50c1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZpbHRlcnMsIFt7XG4gICAga2V5OiBcImdldERlZmF1bHRGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbHRlcihlbCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBlbC51bmZpbHRlcih0cnVlKTtcbiAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgIGZpbHRlci5zaXplKCcxMjAlJywgJzE4MCUnLCAnLTUlJywgJy00MCUnKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcihlbCwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudHlwZSwgdy5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuZHJvcFNoYWRvdyhlbCwgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9ybWFsRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vcm1hbEZpbHRlcihlbCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kcm9wU2hhZG93KGVsLCB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRGVzYXR1cmF0ZUZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREZXNhdHVyYXRlRmlsdGVyKGVsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyB3aW5kb3cuU1ZHLkZpbHRlcigpO1xuICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuICAgICAgZWwuZmlsdGVyKGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgdmFyIHNoYWRvd0F0dHIgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuXG4gICAgICAgIGlmIChzaGFkb3dBdHRyLmVuYWJsZWQpIHtcbiAgICAgICAgICBmaWx0ZXIgPSBfdGhpcy5hZGRTaGFkb3coYWRkLCBzaGFkb3dBdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIgPSBhZGQ7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXIuY29sb3JNYXRyaXgoJ21hdHJpeCcsIFswLCAwLCAwLCAwLCAwLjUsIDAsIDAsIDAsIDAsIDAuNSwgMCwgMCwgMCwgMCwgMC41LCAwLCAwLCAwLCAxLjAsIDBdKS5jb2xvck1hdHJpeCgnc2F0dXJhdGUnLCAwKTtcbiAgICAgIH0pO1xuICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgfSAvLyBhcHBlbmRzIGRyb3BTaGFkb3cgdG8gdGhlIGZpbHRlciBvYmplY3Qgd2hpY2ggY2FuIGJlIGNoYWluZWQgd2l0aCBvdGhlciBmaWx0ZXIgZWZmZWN0c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTGlnaHRlbkZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMaWdodGVuRmlsdGVyKGVsLCBhdHRycykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGludGVuc2l0eSA9IGF0dHJzLmludGVuc2l0eTtcblxuICAgICAgaWYgKFV0aWxzLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICBmaWx0ZXIuc2l6ZSgnMTIwJScsICcxODAlJywgJy01JScsICctNDAlJyk7XG4gICAgICBlbC5maWx0ZXIoZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICB2YXIgc2hhZG93QXR0ciA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG5cbiAgICAgICAgaWYgKHNoYWRvd0F0dHIuZW5hYmxlZCkge1xuICAgICAgICAgIGZpbHRlciA9IF90aGlzMi5hZGRTaGFkb3coYWRkLCBzaGFkb3dBdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIgPSBhZGQ7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXIuY29tcG9uZW50VHJhbnNmZXIoe1xuICAgICAgICAgIHJnYjoge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgICBzbG9wZTogMS41LFxuICAgICAgICAgICAgaW50ZXJjZXB0OiBpbnRlbnNpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBlbC5maWx0ZXJlci5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB9IC8vIGFwcGVuZHMgZHJvcFNoYWRvdyB0byB0aGUgZmlsdGVyIG9iamVjdCB3aGljaCBjYW4gYmUgY2hhaW5lZCB3aXRoIG90aGVyIGZpbHRlciBlZmZlY3RzXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGREYXJrZW5GaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGFya2VuRmlsdGVyKGVsLCBhdHRycykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGludGVuc2l0eSA9IGF0dHJzLmludGVuc2l0eTtcblxuICAgICAgaWYgKFV0aWxzLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICBmaWx0ZXIuc2l6ZSgnMTIwJScsICcxODAlJywgJy01JScsICctNDAlJyk7XG4gICAgICBlbC5maWx0ZXIoZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICB2YXIgc2hhZG93QXR0ciA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG5cbiAgICAgICAgaWYgKHNoYWRvd0F0dHIuZW5hYmxlZCkge1xuICAgICAgICAgIGZpbHRlciA9IF90aGlzMy5hZGRTaGFkb3coYWRkLCBzaGFkb3dBdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXIgPSBhZGQ7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXIuY29tcG9uZW50VHJhbnNmZXIoe1xuICAgICAgICAgIHJnYjoge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgICBzbG9wZTogaW50ZW5zaXR5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWwuZmlsdGVyZXIubm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5RmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RmlsdGVyKGVsLCBmaWx0ZXIpIHtcbiAgICAgIHZhciBpbnRlbnNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDAuNTtcblxuICAgICAgc3dpdGNoIChmaWx0ZXIpIHtcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGROb3JtYWxGaWx0ZXIoZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2xpZ2h0ZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlnaHRlbkZpbHRlcihlbCwge1xuICAgICAgICAgICAgICBpbnRlbnNpdHk6IGludGVuc2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGFya2VuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZERhcmtlbkZpbHRlcihlbCwge1xuICAgICAgICAgICAgICBpbnRlbnNpdHk6IGludGVuc2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGVzYXR1cmF0ZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGREZXNhdHVyYXRlRmlsdGVyKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIGFwcGVuZHMgZHJvcFNoYWRvdyB0byB0aGUgZmlsdGVyIG9iamVjdCB3aGljaCBjYW4gYmUgY2hhaW5lZCB3aXRoIG90aGVyIGZpbHRlciBlZmZlY3RzXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2hhZG93KGFkZCwgYXR0cnMpIHtcbiAgICAgIHZhciBibHVyID0gYXR0cnMuYmx1cixcbiAgICAgICAgICB0b3AgPSBhdHRycy50b3AsXG4gICAgICAgICAgbGVmdCA9IGF0dHJzLmxlZnQsXG4gICAgICAgICAgY29sb3IgPSBhdHRycy5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5ID0gYXR0cnMub3BhY2l0eTtcbiAgICAgIHZhciBzaGFkb3dCbHVyID0gYWRkLmZsb29kKGNvbG9yLCBvcGFjaXR5KS5jb21wb3NpdGUoYWRkLnNvdXJjZUFscGhhLCAnaW4nKS5vZmZzZXQobGVmdCwgdG9wKS5nYXVzc2lhbkJsdXIoYmx1cikubWVyZ2UoYWRkLnNvdXJjZSk7XG4gICAgICByZXR1cm4gYWRkLmJsZW5kKGFkZC5zb3VyY2UsIHNoYWRvd0JsdXIpO1xuICAgIH0gLy8gZGlyZWN0bHkgYWRkcyBkcm9wU2hhZG93IHRvIHRoZSBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSBzYW1lIGVsZW1lbnQuXG4gICAgLy8gdGhlIG9ubHkgd2F5IGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhZGRTaGFkb3coKSBmdW5jdGlvbiBpcyB0aGF0IGFkZFNoYWRvdyBpcyBjaGFpbmFibGUgdG8gb3RoZXIgZmlsdGVycywgd2hpbGUgdGhpcyBmdW5jdGlvbiBkaXNjYXJkcyBhbGwgZmlsdGVycyBhbmQgYWRkIGRyb3BTaGFkb3dcblxuICB9LCB7XG4gICAga2V5OiBcImRyb3BTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJvcFNoYWRvdyhlbCwgYXR0cnMpIHtcbiAgICAgIHZhciB0b3AgPSBhdHRycy50b3AsXG4gICAgICAgICAgbGVmdCA9IGF0dHJzLmxlZnQsXG4gICAgICAgICAgYmx1ciA9IGF0dHJzLmJsdXIsXG4gICAgICAgICAgY29sb3IgPSBhdHRycy5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5ID0gYXR0cnMub3BhY2l0eSxcbiAgICAgICAgICBub1VzZXJTcGFjZU9uVXNlID0gYXR0cnMubm9Vc2VyU3BhY2VPblVzZTtcbiAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyB3aW5kb3cuU1ZHLkZpbHRlcigpO1xuICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuICAgICAgZWwuZmlsdGVyKGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgdmFyIHNoYWRvd0JsdXIgPSBudWxsO1xuXG4gICAgICAgIGlmIChVdGlscy5pc1NhZmFyaSgpIHx8IFV0aWxzLmlzRmlyZWZveCgpIHx8IFV0aWxzLmlzSUUoKSkge1xuICAgICAgICAgIC8vIHNhZmFyaS9maXJlZm94IGhhcyBzb21lIGFsdGVybmF0aXZlIHdheSB0byB1c2UgdGhpcyBmaWx0ZXJcbiAgICAgICAgICBzaGFkb3dCbHVyID0gYWRkLmZsb29kKGNvbG9yLCBvcGFjaXR5KS5jb21wb3NpdGUoYWRkLnNvdXJjZUFscGhhLCAnaW4nKS5vZmZzZXQobGVmdCwgdG9wKS5nYXVzc2lhbkJsdXIoYmx1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhZG93Qmx1ciA9IGFkZC5mbG9vZChjb2xvciwgb3BhY2l0eSkuY29tcG9zaXRlKGFkZC5zb3VyY2VBbHBoYSwgJ2luJykub2Zmc2V0KGxlZnQsIHRvcCkuZ2F1c3NpYW5CbHVyKGJsdXIpLm1lcmdlKGFkZC5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkLmJsZW5kKGFkZC5zb3VyY2UsIHNoYWRvd0JsdXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghbm9Vc2VyU3BhY2VPblVzZSkge1xuICAgICAgICBlbC5maWx0ZXJlci5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZWxlY3Rpb25GaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uRmlsdGVyKGVsLCByZWFsSW5kZXgsIGRhdGFQb2ludEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW3JlYWxJbmRleF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW3JlYWxJbmRleF0uaW5kZXhPZihkYXRhUG9pbnRJbmRleCkgPiAtMSkge1xuICAgICAgICAgIGVsLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAgIHZhciBhY3RpdmVGaWx0ZXIgPSB3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlcjtcblxuICAgICAgICAgIGlmIChhY3RpdmVGaWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlcihlbCwgYWN0aXZlRmlsdGVyLnR5cGUsIGFjdGl2ZUZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbHRlcnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBBbmltYXRpb24gQ2xhc3MuXG4gKlxuICogQG1vZHVsZSBBbmltYXRpb25zXG4gKiovXG5cbnZhciBBbmltYXRpb25zID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9ucyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0aW9ucyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLnNldEVhc2luZ0Z1bmN0aW9ucygpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFuaW1hdGlvbnMsIFt7XG4gICAga2V5OiBcInNldEVhc2luZ0Z1bmN0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFYXNpbmdGdW5jdGlvbnMoKSB7XG4gICAgICB2YXIgZWFzaW5nO1xuICAgICAgdmFyIHVzZXJEZWZpbmVkRWFzaW5nID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVhc2luZztcblxuICAgICAgc3dpdGNoICh1c2VyRGVmaW5lZEVhc2luZykge1xuICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlYXNlaW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9ICc8JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlYXNlb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSAnPic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZWFzZWlub3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSAnPD4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3N3aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmcgPSBmdW5jdGlvbiBlYXNpbmcocG9zKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgICAgcmV0dXJuIChwb3MgLT0gMSkgKiBwb3MgKiAoKHMgKyAxKSAqIHBvcyArIHMpICsgMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdib3VuY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGZ1bmN0aW9uIGVhc2luZyhwb3MpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IDEgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHBvcyAqIHBvcztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAocG9zIC09IDEuNSAvIDIuNzUpICogcG9zICsgMC43NTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChwb3MgLT0gMi4yNSAvIDIuNzUpICogcG9zICsgMC45Mzc1O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAocG9zIC09IDIuNjI1IC8gMi43NSkgKiBwb3MgKyAwLjk4NDM3NTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2VsYXN0aWMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGZ1bmN0aW9uIGVhc2luZyhwb3MpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gISFwb3MpIHJldHVybiBwb3M7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBwb3MpICogTWF0aC5zaW4oKHBvcyAtIDAuMDc1KSAqICgyICogTWF0aC5QSSkgLyAwLjMpICsgMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9ICc8Pic7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLncuZ2xvYmFscy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVMaW5lKGVsLCBmcm9tLCB0bywgc3BlZWQpIHtcbiAgICAgIGVsLmF0dHIoZnJvbSkuYW5pbWF0ZShzcGVlZCkuYXR0cih0byk7XG4gICAgfVxuICAgIC8qXG4gICAgICoqIEFuaW1hdGUgcmFkaXVzIG9mIGEgY2lyY2xlIGVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVDaXJjbGVSYWRpdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUNpcmNsZVJhZGl1cyhlbCwgZnJvbSwgdG8sIHNwZWVkLCBlYXNpbmcpIHtcbiAgICAgIGlmICghZnJvbSkgZnJvbSA9IDA7XG4gICAgICBlbC5hdHRyKHtcbiAgICAgICAgcjogZnJvbVxuICAgICAgfSkuYW5pbWF0ZShzcGVlZCwgZWFzaW5nKS5hdHRyKHtcbiAgICAgICAgcjogdG9cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqKiBBbmltYXRlIHJhZGl1cyBhbmQgcG9zaXRpb24gb2YgYSBjaXJjbGUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQ2lyY2xlKGVsLCBmcm9tLCB0bywgc3BlZWQsIGVhc2luZykge1xuICAgICAgZWwuYXR0cih7XG4gICAgICAgIHI6IGZyb20ucixcbiAgICAgICAgY3g6IGZyb20uY3gsXG4gICAgICAgIGN5OiBmcm9tLmN5XG4gICAgICB9KS5hbmltYXRlKHNwZWVkLCBlYXNpbmcpLmF0dHIoe1xuICAgICAgICByOiB0by5yLFxuICAgICAgICBjeDogdG8uY3gsXG4gICAgICAgIGN5OiB0by5jeVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICoqIEFuaW1hdGUgcmVjdCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlUmVjdChlbCwgZnJvbSwgdG8sIHNwZWVkLCBmbikge1xuICAgICAgZWwuYXR0cihmcm9tKS5hbmltYXRlKHNwZWVkKS5hdHRyKHRvKS5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVBhdGhzR3JhZHVhbGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVQYXRoc0dyYWR1YWxseShwYXJhbXMpIHtcbiAgICAgIHZhciBlbCA9IHBhcmFtcy5lbCxcbiAgICAgICAgICBqID0gcGFyYW1zLmosXG4gICAgICAgICAgcGF0aEZyb20gPSBwYXJhbXMucGF0aEZyb20sXG4gICAgICAgICAgcGF0aFRvID0gcGFyYW1zLnBhdGhUbyxcbiAgICAgICAgICBzcGVlZCA9IHBhcmFtcy5zcGVlZCxcbiAgICAgICAgICBkZWxheSA9IHBhcmFtcy5kZWxheSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHBhcmFtcy5zdHJva2VXaWR0aDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBkZWxheUZhY3RvciA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZW5hYmxlZCkge1xuICAgICAgICBkZWxheUZhY3RvciA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuYW5pbWF0ZUdyYWR1YWxseS5kZWxheTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkICYmIHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICBkZWxheUZhY3RvciA9IDA7XG4gICAgICB9XG5cbiAgICAgIG1lLm1vcnBoU1ZHKGVsLCBqLCBwYXRoRnJvbSwgcGF0aFRvLCBzcGVlZCwgc3Ryb2tlV2lkdGgsIGRlbGF5ICogZGVsYXlGYWN0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93RGVsYXllZEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dEZWxheWVkRWxlbWVudHMoKSB7XG4gICAgICB0aGlzLncuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZWxlID0gZC5lbDtcbiAgICAgICAgZWxlLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgfSk7XG4gICAgfSAvLyBTVkcuanMgYW5pbWF0aW9uIGZvciBtb3JwaGluZyBvbmUgcGF0aCB0byBhbm90aGVyXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3JwaFNWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3JwaFNWRyhlbCwgaiwgcGF0aEZyb20sIHBhdGhUbywgc3BlZWQsIHN0cm9rZVdpZHRoLCBkZWxheSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICghcGF0aEZyb20pIHtcbiAgICAgICAgcGF0aEZyb20gPSBlbC5hdHRyKCdwYXRoRnJvbScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhdGhUbykge1xuICAgICAgICBwYXRoVG8gPSBlbC5hdHRyKCdwYXRoVG8nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXRoRnJvbSB8fCBwYXRoRnJvbS5pbmRleE9mKCd1bmRlZmluZWQnKSA+IC0xIHx8IHBhdGhGcm9tLmluZGV4T2YoJ05hTicpID4gLTEpIHtcbiAgICAgICAgcGF0aEZyb20gPSBcIk0gMCBcIi5jb25jYXQody5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICBzcGVlZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoVG8uaW5kZXhPZigndW5kZWZpbmVkJykgPiAtMSB8fCBwYXRoVG8uaW5kZXhPZignTmFOJykgPiAtMSkge1xuICAgICAgICBwYXRoVG8gPSBcIk0gMCBcIi5jb25jYXQody5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICBzcGVlZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgc3BlZWQgPSAxO1xuICAgICAgfVxuXG4gICAgICBlbC5wbG90KHBhdGhGcm9tKS5hbmltYXRlKDEsIHcuZ2xvYmFscy5lYXNpbmcsIGRlbGF5KS5wbG90KHBhdGhGcm9tKS5hbmltYXRlKHNwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nLCBkZWxheSkucGxvdChwYXRoVG8pLmFmdGVyQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIG9yaWdpbmFsIG1vdW50IGZ1bmN0aW9uIGNhbiByZXR1cm4gdHJ1ZSBub3cgYXMgYW5pbWF0aW9uIGZpbmlzaGVkIGhlcmVcbiAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKGopKSB7XG4gICAgICAgICAgaWYgKGogPT09IHcuZ2xvYmFscy5zZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aCAtIDIgJiYgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5zaG91bGRBbmltYXRlKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmFuaW1hdGlvbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmFuaW1hdGlvbkVuZChfdGhpcy5jdHgsIHcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNob3dEZWxheWVkRWxlbWVudHMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgR3JhcGhpY3MgQ2xhc3MgZm9yIGFsbCBkcmF3aW5nIG9wZXJhdGlvbnMuXG4gKlxuICogQG1vZHVsZSBHcmFwaGljc1xuICoqL1xuXG52YXIgR3JhcGhpY3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcmFwaGljcyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3MpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR3JhcGhpY3MsIFt7XG4gICAga2V5OiBcImRyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICB2YXIgbGluZUNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAnI2E4YThhOCc7XG4gICAgICB2YXIgZGFzaEFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGluZSA9IHcuZ2xvYmFscy5kb20uUGFwZXIubGluZSgpLmF0dHIoe1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHN0cm9rZTogbGluZUNvbG9yLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGRhc2hBcnJheSxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UmVjdCgpIHtcbiAgICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgY29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6ICcjZmVmZWZlJztcbiAgICAgIHZhciBvcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAxO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBudWxsO1xuICAgICAgdmFyIHN0cm9rZUNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiBudWxsO1xuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ICYmIGFyZ3VtZW50c1s5XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzldIDogMDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJlY3QgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnJlY3QoKTtcbiAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgIHg6IHgxLFxuICAgICAgICB5OiB5MSxcbiAgICAgICAgd2lkdGg6IHgyID4gMCA/IHgyIDogMCxcbiAgICAgICAgaGVpZ2h0OiB5MiA+IDAgPyB5MiA6IDAsXG4gICAgICAgIHJ4OiByYWRpdXMsXG4gICAgICAgIHJ5OiByYWRpdXMsXG4gICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGggIT09IG51bGwgPyBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IgIT09IG51bGwgPyBzdHJva2VDb2xvciA6ICdub25lJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBzdHJva2VEYXNoQXJyYXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQb2x5Z29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2x5Z29uKHBvbHlnb25TdHJpbmcpIHtcbiAgICAgIHZhciBzdHJva2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcjZTFlMWUxJztcbiAgICAgIHZhciBmaWxsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbm9uZSc7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwb2x5Z29uID0gdy5nbG9iYWxzLmRvbS5QYXBlci5wb2x5Z29uKHBvbHlnb25TdHJpbmcpLmF0dHIoe1xuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2lyY2xlKHJhZGl1cykge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuY2lyY2xlKHJhZGl1cyAqIDIpO1xuXG4gICAgICBpZiAoYXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgYy5hdHRyKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQYXRoKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmJGQgPSBfcmVmLmQsXG4gICAgICAgICAgZCA9IF9yZWYkZCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGQsXG4gICAgICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdm9pZCAwID8gJyNhOGE4YTgnIDogX3JlZiRzdHJva2UsXG4gICAgICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB2b2lkIDAgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgICAgICBmaWxsID0gX3JlZi5maWxsLFxuICAgICAgICAgIF9yZWYkZmlsbE9wYWNpdHkgPSBfcmVmLmZpbGxPcGFjaXR5LFxuICAgICAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZiRmaWxsT3BhY2l0eSA9PT0gdm9pZCAwID8gMSA6IF9yZWYkZmlsbE9wYWNpdHksXG4gICAgICAgICAgX3JlZiRzdHJva2VPcGFjaXR5ID0gX3JlZi5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmJHN0cm9rZU9wYWNpdHkgPT09IHZvaWQgMCA/IDEgOiBfcmVmJHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgY2xhc3NlcyA9IF9yZWYuY2xhc3NlcyxcbiAgICAgICAgICBfcmVmJHN0cm9rZUxpbmVjYXAgPSBfcmVmLnN0cm9rZUxpbmVjYXAsXG4gICAgICAgICAgc3Ryb2tlTGluZWNhcCA9IF9yZWYkc3Ryb2tlTGluZWNhcCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgICBfcmVmJHN0cm9rZURhc2hBcnJheSA9IF9yZWYuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IF9yZWYkc3Ryb2tlRGFzaEFycmF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRzdHJva2VEYXNoQXJyYXk7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHN0cm9rZUxpbmVjYXAgPT09IG51bGwpIHtcbiAgICAgICAgc3Ryb2tlTGluZWNhcCA9IHcuY29uZmlnLnN0cm9rZS5saW5lQ2FwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZC5pbmRleE9mKCd1bmRlZmluZWQnKSA+IC0xIHx8IGQuaW5kZXhPZignTmFOJykgPiAtMSkge1xuICAgICAgICBkID0gXCJNIDAgXCIuY29uY2F0KHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnBhdGgoZCkuYXR0cih7XG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiBmaWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6IHN0cm9rZU9wYWNpdHksXG4gICAgICAgICdzdHJva2UtbGluZWNhcCc6IHN0cm9rZUxpbmVjYXAsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBzdHJva2VEYXNoQXJyYXksXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGcgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmdyb3VwKCk7XG5cbiAgICAgIGlmIChhdHRycyAhPT0gbnVsbCkge1xuICAgICAgICBnLmF0dHIoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgIHZhciBtb3ZlID0gWydNJywgeCwgeV0uam9pbignICcpO1xuICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZSh4LCB5KSB7XG4gICAgICB2YXIgaE9SdiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciBsaW5lID0gbnVsbDtcblxuICAgICAgaWYgKGhPUnYgPT09IG51bGwpIHtcbiAgICAgICAgbGluZSA9IFsnTCcsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSBpZiAoaE9SdiA9PT0gJ0gnKSB7XG4gICAgICAgIGxpbmUgPSBbJ0gnLCB4XS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2UgaWYgKGhPUnYgPT09ICdWJykge1xuICAgICAgICBsaW5lID0gWydWJywgeV0uam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VydmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmUoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IFsnQycsIHgxLCB5MSwgeDIsIHkyLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInF1YWRyYXRpY0N1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlKHgxLCB5MSwgeCwgeSkge1xuICAgICAgdmFyIGN1cnZlID0gWydRJywgeDEsIHkxLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFyY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcmMocngsIHJ5LCBheGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gICAgICB2YXIgcmVsYXRpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IGZhbHNlO1xuICAgICAgdmFyIGNvb3JkID0gJ0EnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBjb29yZCA9ICdhJztcbiAgICAgIHZhciBhcmMgPSBbY29vcmQsIHJ4LCByeSwgYXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeV0uam9pbignICcpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEdyYXBoaWNzXG4gICAgICogQHBhcmFtIHtvYmplY3R9XG4gICAgICogIGkgPSBzZXJpZXMncyBpbmRleFxuICAgICAqICByZWFsSW5kZXggPSByZWFsSW5kZXggaXMgc2VyaWVzJ3MgYWN0dWFsIGluZGV4IHdoZW4gaXQgd2FzIGRyYXduIHRpbWUuIEFmdGVyIHNldmVyYWwgcmVkcmF3cywgdGhlIGl0ZXJhdGluZyBcImlcIiBtYXkgY2hhbmdlIGluIGxvb3BzLCBidXQgcmVhbEluZGV4IGRvZXNuJ3RcbiAgICAgKiAgcGF0aEZyb20gPSBleGlzdGluZyBwYXRoRnJvbSB0byBhbmltYXRlVG9cbiAgICAgKiAgcGF0aFRvID0gbmV3IFBhdGggdG8gd2hpY2ggZCBhdHRyIHdpbGwgYmUgYW5pbWF0ZWQgZnJvbSBwYXRoRnJvbSB0byBwYXRoVG9cbiAgICAgKiAgc3Ryb2tlID0gbGluZSBDb2xvclxuICAgICAqICBzdHJva2VXaWR0aCA9IHdpZHRoIG9mIHBhdGggTGluZVxuICAgICAqICBmaWxsID0gaXQgY2FuIGJlIGdyYWRpZW50LCBzaW5nbGUgY29sb3IsIHBhdHRlcm4gb3IgaW1hZ2VcbiAgICAgKiAgYW5pbWF0aW9uRGVsYXkgPSBob3cgbXVjaCB0byBkZWxheSB3aGVuIHN0YXJ0aW5nIGFuaW1hdGlvbiAoaW4gbWlsbGlzZWNvbmRzKVxuICAgICAqICBkYXRhQ2hhbmdlU3BlZWQgPSBmb3IgZHluYW1pYyBhbmltYXRpb25zLCB3aGVuIGRhdGEgY2hhbmdlc1xuICAgICAqICBjbGFzc05hbWUgPSBjbGFzcyBhdHRyaWJ1dGUgdG8gYWRkXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBzdmcuanMgcGF0aCBvYmplY3RcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQYXRocyhfcmVmMikge1xuICAgICAgdmFyIGkgPSBfcmVmMi5pLFxuICAgICAgICAgIGogPSBfcmVmMi5qLFxuICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWYyLnJlYWxJbmRleCxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYyLnBhdGhGcm9tLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYyLnBhdGhUbyxcbiAgICAgICAgICBzdHJva2UgPSBfcmVmMi5zdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBzdHJva2VMaW5lY2FwID0gX3JlZjIuc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgICBmaWxsID0gX3JlZjIuZmlsbCxcbiAgICAgICAgICBhbmltYXRpb25EZWxheSA9IF9yZWYyLmFuaW1hdGlvbkRlbGF5LFxuICAgICAgICAgIGluaXRpYWxTcGVlZCA9IF9yZWYyLmluaXRpYWxTcGVlZCxcbiAgICAgICAgICBkYXRhQ2hhbmdlU3BlZWQgPSBfcmVmMi5kYXRhQ2hhbmdlU3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgICAgIGlkID0gX3JlZjIuaWQsXG4gICAgICAgICAgX3JlZjIkc2hvdWxkQ2xpcFRvR3JpID0gX3JlZjIuc2hvdWxkQ2xpcFRvR3JpZCxcbiAgICAgICAgICBzaG91bGRDbGlwVG9HcmlkID0gX3JlZjIkc2hvdWxkQ2xpcFRvR3JpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkc2hvdWxkQ2xpcFRvR3JpLFxuICAgICAgICAgIF9yZWYyJGJpbmRFdmVudHNPblBhdCA9IF9yZWYyLmJpbmRFdmVudHNPblBhdGhzLFxuICAgICAgICAgIGJpbmRFdmVudHNPblBhdGhzID0gX3JlZjIkYmluZEV2ZW50c09uUGF0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkYmluZEV2ZW50c09uUGF0O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBhbmltID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgdmFyIGluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgICB2YXIgZHluYW1pY0FuaW0gPSBpbml0aWFsQW5pbSAmJiB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkO1xuICAgICAgdmFyIGQ7XG4gICAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9ICEhKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCB8fCBkeW5hbWljQW5pbSAmJiB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgJiYgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUpO1xuXG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICBkID0gcGF0aEZyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gcGF0aFRvO1xuICAgICAgICB0aGlzLncuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VEYXNoQXJyYXlPcHQgPSB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5O1xuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IDA7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0cm9rZURhc2hBcnJheU9wdCkpIHtcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gc3Ryb2tlRGFzaEFycmF5T3B0W3JlYWxJbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5O1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSB0aGlzLmRyYXdQYXRoKHtcbiAgICAgICAgZDogZCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgIGNsYXNzZXM6IGNsYXNzTmFtZSxcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiBzdHJva2VEYXNoQXJyYXlcbiAgICAgIH0pO1xuICAgICAgZWwuYXR0cignaWQnLCBcIlwiLmNvbmNhdChpZCwgXCItXCIpLmNvbmNhdChpKSk7XG4gICAgICBlbC5hdHRyKCdpbmRleCcsIHJlYWxJbmRleCk7XG5cbiAgICAgIGlmIChzaG91bGRDbGlwVG9HcmlkKSB7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgICdjbGlwLXBhdGgnOiBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIilcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIGNvbnN0IGRlZmF1bHRGaWx0ZXIgPSBlbC5maWx0ZXJlclxuXG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKGVsLCB3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlci50eXBlLCB3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlci52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgaWYgKCF3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWRTZXJpZXMgfHwgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkU2VyaWVzICYmIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZFNlcmllcy5pbmRleE9mKHJlYWxJbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbCwgc2hhZG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJpbmRFdmVudHNPblBhdGhzKSB7XG4gICAgICAgIGVsLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMucGF0aE1vdXNlRW50ZXIuYmluZCh0aGlzLCBlbCkpO1xuICAgICAgICBlbC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnBhdGhNb3VzZUxlYXZlLmJpbmQodGhpcywgZWwpKTtcbiAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCBlbCkpO1xuICAgICAgfVxuXG4gICAgICBlbC5hdHRyKHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbVxuICAgICAgfSk7XG4gICAgICB2YXIgZGVmYXVsdEFuaW1hdGVPcHRzID0ge1xuICAgICAgICBlbDogZWwsXG4gICAgICAgIGo6IGosXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgfTtcblxuICAgICAgaWYgKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIGFuaW0uYW5pbWF0ZVBhdGhzR3JhZHVhbGx5KF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRBbmltYXRlT3B0cywge1xuICAgICAgICAgIHNwZWVkOiBpbml0aWFsU3BlZWQsXG4gICAgICAgICAgZGVsYXk6IGFuaW1hdGlvbkRlbGF5XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMucmVzaXplZCB8fCAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgYW5pbS5zaG93RGVsYXllZEVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCAmJiBkeW5hbWljQW5pbSAmJiBzaG91bGRBbmltYXRlKSB7XG4gICAgICAgIGFuaW0uYW5pbWF0ZVBhdGhzR3JhZHVhbGx5KF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRBbmltYXRlT3B0cywge1xuICAgICAgICAgIHNwZWVkOiBkYXRhQ2hhbmdlU3BlZWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQYXR0ZXJuKHN0eWxlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgc3Ryb2tlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnI2E4YThhOCc7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwID0gdy5nbG9iYWxzLmRvbS5QYXBlci5wYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgaWYgKHN0eWxlID09PSAnaG9yaXpvbnRhbExpbmVzJykge1xuICAgICAgICAgIGFkZC5saW5lKDAsIDAsIGhlaWdodCwgMCkuc3Ryb2tlKHtcbiAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGggKyAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICd2ZXJ0aWNhbExpbmVzJykge1xuICAgICAgICAgIGFkZC5saW5lKDAsIDAsIDAsIHdpZHRoKS5zdHJva2Uoe1xuICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aCArIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ3NsYW50ZWRMaW5lcycpIHtcbiAgICAgICAgICBhZGQubGluZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5zdHJva2Uoe1xuICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnc3F1YXJlcycpIHtcbiAgICAgICAgICBhZGQucmVjdCh3aWR0aCwgaGVpZ2h0KS5maWxsKCdub25lJykuc3Ryb2tlKHtcbiAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2NpcmNsZXMnKSB7XG4gICAgICAgICAgYWRkLmNpcmNsZSh3aWR0aCkuZmlsbCgnbm9uZScpLnN0cm9rZSh7XG4gICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdHcmFkaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JhZGllbnQoc3R5bGUsIGdmcm9tLCBndG8sIG9wYWNpdHlGcm9tLCBvcGFjaXR5VG8pIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuICAgICAgdmFyIHN0b3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBudWxsO1xuICAgICAgdmFyIGNvbG9yU3RvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IG51bGw7XG4gICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogMDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGc7XG4gICAgICBnZnJvbSA9IFV0aWxzLmhleFRvUmdiYShnZnJvbSwgb3BhY2l0eUZyb20pO1xuICAgICAgZ3RvID0gVXRpbHMuaGV4VG9SZ2JhKGd0bywgb3BhY2l0eVRvKTtcbiAgICAgIHZhciBzdG9wMSA9IDA7XG4gICAgICB2YXIgc3RvcDIgPSAxO1xuICAgICAgdmFyIHN0b3AzID0gMTtcbiAgICAgIHZhciBzdG9wNCA9IG51bGw7XG5cbiAgICAgIGlmIChzdG9wcyAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wMSA9IHR5cGVvZiBzdG9wc1swXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdG9wc1swXSAvIDEwMCA6IDA7XG4gICAgICAgIHN0b3AyID0gdHlwZW9mIHN0b3BzWzFdICE9PSAndW5kZWZpbmVkJyA/IHN0b3BzWzFdIC8gMTAwIDogMTtcbiAgICAgICAgc3RvcDMgPSB0eXBlb2Ygc3RvcHNbMl0gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbMl0gLyAxMDAgOiAxO1xuICAgICAgICBzdG9wNCA9IHR5cGVvZiBzdG9wc1szXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdG9wc1szXSAvIDEwMCA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYWRpYWwgPSAhISh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdidWJibGUnKTtcblxuICAgICAgaWYgKGNvbG9yU3RvcHMgPT09IG51bGwgfHwgY29sb3JTdG9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuZ3JhZGllbnQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICBzdG9wLmF0KHN0b3AxLCBnZnJvbSwgb3BhY2l0eUZyb20pO1xuICAgICAgICAgIHN0b3AuYXQoc3RvcDIsIGd0bywgb3BhY2l0eVRvKTtcbiAgICAgICAgICBzdG9wLmF0KHN0b3AzLCBndG8sIG9wYWNpdHlUbyk7XG5cbiAgICAgICAgICBpZiAoc3RvcDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3AuYXQoc3RvcDQsIGdmcm9tLCBvcGFjaXR5RnJvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGcgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLmdyYWRpZW50KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgdmFyIHN0b3BzID0gQXJyYXkuaXNBcnJheShjb2xvclN0b3BzW2ldKSA/IGNvbG9yU3RvcHNbaV0gOiBjb2xvclN0b3BzO1xuICAgICAgICAgIHN0b3BzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHN0b3AuYXQocy5vZmZzZXQgLyAxMDAsIHMuY29sb3IsIHMub3BhY2l0eSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJhZGlhbCkge1xuICAgICAgICBpZiAoc3R5bGUgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICBnLmZyb20oMCwgMCkudG8oMCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdkaWFnb25hbCcpIHtcbiAgICAgICAgICBnLmZyb20oMCwgMCkudG8oMSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIGcuZnJvbSgwLCAxKS50bygxLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2RpYWdvbmFsMicpIHtcbiAgICAgICAgICBnLmZyb20oMCwgMSkudG8oMiwgMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvZmZ4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICAgIHZhciBvZmZ5ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnYnViYmxlJykge1xuICAgICAgICAgIGcuYXR0cih7XG4gICAgICAgICAgICBncmFkaWVudFVuaXRzOiAndXNlclNwYWNlT25Vc2UnLFxuICAgICAgICAgICAgY3g6IG9mZngsXG4gICAgICAgICAgICBjeTogb2ZmeSxcbiAgICAgICAgICAgIHI6IHNpemVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnLmF0dHIoe1xuICAgICAgICAgICAgY3g6IDAuNSxcbiAgICAgICAgICAgIGN5OiAwLjUsXG4gICAgICAgICAgICByOiAwLjgsXG4gICAgICAgICAgICBmeDogMC4yLFxuICAgICAgICAgICAgZnk6IDAuMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGV4dChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgdGV4dCA9IG9wdHMudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gb3B0cy50ZXh0QW5jaG9yLFxuICAgICAgICAgIGZvbnRTaXplID0gb3B0cy5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gb3B0cy5mb250RmFtaWx5LFxuICAgICAgICAgIGZvcmVDb2xvciA9IG9wdHMuZm9yZUNvbG9yLFxuICAgICAgICAgIG9wYWNpdHkgPSBvcHRzLm9wYWNpdHk7XG5cbiAgICAgIGlmICghdGV4dEFuY2hvcikge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3JlQ29sb3IpIHtcbiAgICAgICAgZm9yZUNvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBmb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgdmFyIGVsVGV4dDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgZWxUZXh0ID0gdy5nbG9iYWxzLmRvbS5QYXBlci50ZXh0KGZ1bmN0aW9uIChhZGQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZC50c3Bhbih0ZXh0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxUZXh0ID0gdy5nbG9iYWxzLmRvbS5QYXBlci5wbGFpbih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgZWxUZXh0LmF0dHIoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICAndGV4dC1hbmNob3InOiB0ZXh0QW5jaG9yLFxuICAgICAgICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnY2VudHJhbCcsXG4gICAgICAgICdmb250LXNpemUnOiBmb250U2l6ZSxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICAgZmlsbDogZm9yZUNvbG9yLFxuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdGV4dCAnICsgb3B0cy5jc3NDbGFzcyA/IG9wdHMuY3NzQ2xhc3MgOiAnJ1xuICAgICAgfSk7XG4gICAgICBlbFRleHQubm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIGVsVGV4dC5ub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgcmV0dXJuIGVsVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVHNwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVHNwYW4odGV4dEVsLCB0ZXh0LCBmb250RmFtaWx5KSB7XG4gICAgICB2YXIgdHNwYW4gPSB0ZXh0RWwudHNwYW4odGV4dCk7XG5cbiAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICBmb250RmFtaWx5ID0gdGhpcy53LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgfVxuXG4gICAgICB0c3Bhbi5ub2RlLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TWFya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdNYXJrZXIoeCwgeSwgb3B0cykge1xuICAgICAgeCA9IHggfHwgMDtcbiAgICAgIHZhciBzaXplID0gb3B0cy5wU2l6ZSB8fCAwO1xuICAgICAgdmFyIGVsUG9pbnQgPSBudWxsO1xuXG4gICAgICBpZiAob3B0cy5zaGFwZSA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IG9wdHMucFJhZGl1cyA9PT0gdW5kZWZpbmVkID8gc2l6ZSAvIDIgOiBvcHRzLnBSYWRpdXM7XG5cbiAgICAgICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgICAgICBzaXplID0gMDtcbiAgICAgICAgICByYWRpdXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5TaXplID0gc2l6ZSAqIDEuMiArIHJhZGl1cztcbiAgICAgICAgdmFyIHAgPSB0aGlzLmRyYXdSZWN0KG5TaXplLCBuU2l6ZSwgblNpemUsIG5TaXplLCByYWRpdXMpO1xuICAgICAgICBwLmF0dHIoe1xuICAgICAgICAgIHg6IHggLSBuU2l6ZSAvIDIsXG4gICAgICAgICAgeTogeSAtIG5TaXplIC8gMixcbiAgICAgICAgICBjeDogeCxcbiAgICAgICAgICBjeTogeSxcbiAgICAgICAgICBjbGFzczogb3B0cy5jbGFzcyA/IG9wdHMuY2xhc3MgOiAnJyxcbiAgICAgICAgICBmaWxsOiBvcHRzLnBvaW50RmlsbENvbG9yLFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcHRzLnBvaW50RmlsbE9wYWNpdHkgPyBvcHRzLnBvaW50RmlsbE9wYWNpdHkgOiAxLFxuICAgICAgICAgIHN0cm9rZTogb3B0cy5wb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBvcHRzLnBXaWR0aCA/IG9wdHMucFdpZHRoIDogMCxcbiAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA/IG9wdHMucG9pbnRTdHJva2VPcGFjaXR5IDogMVxuICAgICAgICB9KTtcbiAgICAgICAgZWxQb2ludCA9IHA7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICBzaXplID0gMDtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSAvLyBsZXQgblNpemUgPSBzaXplIC0gb3B0cy5wUmFkaXVzIC8gMiA8IDAgPyAwIDogc2l6ZSAtIG9wdHMucFJhZGl1cyAvIDJcblxuXG4gICAgICAgIGVsUG9pbnQgPSB0aGlzLmRyYXdDaXJjbGUoc2l6ZSwge1xuICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgIGNsYXNzOiBvcHRzLmNsYXNzID8gb3B0cy5jbGFzcyA6ICcnLFxuICAgICAgICAgIHN0cm9rZTogb3B0cy5wb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICAgIGZpbGw6IG9wdHMucG9pbnRGaWxsQ29sb3IsXG4gICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA/IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA6IDEsXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG9wdHMucFdpZHRoID8gb3B0cy5wV2lkdGggOiAwLFxuICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IG9wdHMucG9pbnRTdHJva2VPcGFjaXR5ID8gb3B0cy5wb2ludFN0cm9rZU9wYWNpdHkgOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxQb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aE1vdXNlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aE1vdXNlRW50ZXIocGF0aCwgZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSk7XG4gICAgICB2YXIgaiA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2onKSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludE1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludE1vdXNlRW50ZXIoZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2RhdGFQb2ludE1vdXNlRW50ZXInLCBbZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9XSk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLmhvdmVyLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyLnR5cGUgIT09ICdub25lJyAmJiAhdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UpIHtcbiAgICAgICAgICB2YXIgaG92ZXJGaWx0ZXIgPSB3LmNvbmZpZy5zdGF0ZXMuaG92ZXIuZmlsdGVyO1xuICAgICAgICAgIGZpbHRlcnMuYXBwbHlGaWx0ZXIocGF0aCwgaG92ZXJGaWx0ZXIudHlwZSwgaG92ZXJGaWx0ZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhNb3VzZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhNb3VzZUxlYXZlKHBhdGgsIGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuICAgICAgdmFyIGogPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdqJykpO1xuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRNb3VzZUxlYXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRNb3VzZUxlYXZlKGUsIHRoaXMuY3R4LCB7XG4gICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguZmlyZUV2ZW50KCdkYXRhUG9pbnRNb3VzZUxlYXZlJywgW2UsIHRoaXMuY3R4LCB7XG4gICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfV0pO1xuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmIChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdzZWxlY3RlZCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXIudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aE1vdXNlRG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTW91c2VEb3duKHBhdGgsIGUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuICAgICAgdmFyIGogPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdqJykpO1xuICAgICAgdmFyIHNlbGVjdGVkID0gJ2ZhbHNlJztcblxuICAgICAgaWYgKHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICBwYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdmYWxzZScpO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldLmluZGV4T2YoaikgPiAtMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0uaW5kZXhPZihqKTtcbiAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdy5jb25maWcuc3RhdGVzLmFjdGl2ZS5hbGxvd011bHRpcGxlRGF0YVBvaW50c1NlbGVjdGlvbiAmJiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzID0gW107XG4gICAgICAgICAgdmFyIGVsUGF0aHMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdCgnLmFwZXhjaGFydHMtc2VyaWVzIHBhdGgnKS5tZW1iZXJzO1xuICAgICAgICAgIHZhciBlbENpcmNsZXMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdCgnLmFwZXhjaGFydHMtc2VyaWVzIGNpcmNsZSwgLmFwZXhjaGFydHMtc2VyaWVzIHJlY3QnKS5tZW1iZXJzO1xuICAgICAgICAgIGVsUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoZWxQYXRoKSB7XG4gICAgICAgICAgICBlbFBhdGgubm9kZS5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIoZWxQYXRoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbENpcmNsZXMuZm9yRWFjaChmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgICAgICBjaXJjbGUubm9kZS5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIoY2lyY2xlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgubm9kZS5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgc2VsZWN0ZWQgPSAndHJ1ZSc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0ucHVzaChqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkID09PSAndHJ1ZScpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUZpbHRlciA9IHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyO1xuXG4gICAgICAgIGlmIChhY3RpdmVGaWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICAgIGZpbHRlcnMuYXBwbHlGaWx0ZXIocGF0aCwgYWN0aXZlRmlsdGVyLnR5cGUsIGFjdGl2ZUZpbHRlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRTZWxlY3Rpb24oZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMsXG4gICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgdzogd1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguZmlyZUV2ZW50KCdkYXRhUG9pbnRTZWxlY3Rpb24nLCBbZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgc2VsZWN0ZWREYXRhUG9pbnRzOiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLFxuICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH1dKTsgLy8gaWYgKHRoaXMudy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnNlbGVjdGVkUG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICAgdGhpcy53LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uc2VsZWN0ZWRQb2ludHMody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cylcbiAgICAgIC8vIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlQXJvdW5kQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZENlbnRlcihlbCkge1xuICAgICAgdmFyIGNvb3JkID0gZWwuZ2V0QkJveCgpO1xuICAgICAgdmFyIHggPSBjb29yZC54ICsgY29vcmQud2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSBjb29yZC55ICsgY29vcmQuaGVpZ2h0IC8gMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRleHRSZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0UmVjdHModGV4dCwgZm9udFNpemUsIGZvbnRGYW1pbHksIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHVzZUJCb3ggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB2aXJ0dWFsVGV4dCA9IHRoaXMuZHJhd1RleHQoe1xuICAgICAgICB4OiAtMjAwLFxuICAgICAgICB5OiAtMjAwLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogJyNmZmYnLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB2aXJ0dWFsVGV4dC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMuZG9tLlBhcGVyLmFkZCh2aXJ0dWFsVGV4dCk7XG4gICAgICB2YXIgcmVjdCA9IHZpcnR1YWxUZXh0LmJib3goKTtcblxuICAgICAgaWYgKCF1c2VCQm94KSB7XG4gICAgICAgIHJlY3QgPSB2aXJ0dWFsVGV4dC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICB2aXJ0dWFsVGV4dC5yZW1vdmUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgLi4uIHRvIGxvbmcgdGV4dFxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTI0MTMxNS90cmltbWluZy10ZXh0LXRvLWEtZ2l2ZW4tcGl4ZWwtd2lkdGgtaW4tc3ZnXG4gICAgICogQG1lbWJlcm9mIEdyYXBoaWNzXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxhY2VUZXh0V2l0aEVsbGlwc2lzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYWNlVGV4dFdpdGhFbGxpcHNpcyh0ZXh0T2JqLCB0ZXh0U3RyaW5nLCB3aWR0aCkge1xuICAgICAgdGV4dE9iai50ZXh0Q29udGVudCA9IHRleHRTdHJpbmc7XG5cbiAgICAgIGlmICh0ZXh0U3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZWxsaXBzaXMgaXMgbmVlZGVkXG4gICAgICAgIGlmICh0ZXh0T2JqLmdldFN1YlN0cmluZ0xlbmd0aCgwLCB0ZXh0U3RyaW5nLmxlbmd0aCkgPj0gd2lkdGgpIHtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gdGV4dFN0cmluZy5sZW5ndGggLSAzOyB4ID4gMDsgeCAtPSAzKSB7XG4gICAgICAgICAgICBpZiAodGV4dE9iai5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgeCkgPD0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgdGV4dE9iai50ZXh0Q29udGVudCA9IHRleHRTdHJpbmcuc3Vic3RyaW5nKDAsIHgpICsgJy4uLic7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0T2JqLnRleHRDb250ZW50ID0gJy4uLic7IC8vIGNhbid0IHBsYWNlIGF0IGFsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwic2V0QXR0cnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cnMoZWwsIGF0dHJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcmFwaGljcztcbn0oKTtcblxuY29uc3QgbmFtZSA9IFwiZW5cIjtcbmNvbnN0IG9wdGlvbnMgPSB7XG5cdG1vbnRoczogW1xuXHRcdFwiSmFudWFyeVwiLFxuXHRcdFwiRmVicnVhcnlcIixcblx0XHRcIk1hcmNoXCIsXG5cdFx0XCJBcHJpbFwiLFxuXHRcdFwiTWF5XCIsXG5cdFx0XCJKdW5lXCIsXG5cdFx0XCJKdWx5XCIsXG5cdFx0XCJBdWd1c3RcIixcblx0XHRcIlNlcHRlbWJlclwiLFxuXHRcdFwiT2N0b2JlclwiLFxuXHRcdFwiTm92ZW1iZXJcIixcblx0XHRcIkRlY2VtYmVyXCJcblx0XSxcblx0c2hvcnRNb250aHM6IFtcblx0XHRcIkphblwiLFxuXHRcdFwiRmViXCIsXG5cdFx0XCJNYXJcIixcblx0XHRcIkFwclwiLFxuXHRcdFwiTWF5XCIsXG5cdFx0XCJKdW5cIixcblx0XHRcIkp1bFwiLFxuXHRcdFwiQXVnXCIsXG5cdFx0XCJTZXBcIixcblx0XHRcIk9jdFwiLFxuXHRcdFwiTm92XCIsXG5cdFx0XCJEZWNcIlxuXHRdLFxuXHRkYXlzOiBbXG5cdFx0XCJTdW5kYXlcIixcblx0XHRcIk1vbmRheVwiLFxuXHRcdFwiVHVlc2RheVwiLFxuXHRcdFwiV2VkbmVzZGF5XCIsXG5cdFx0XCJUaHVyc2RheVwiLFxuXHRcdFwiRnJpZGF5XCIsXG5cdFx0XCJTYXR1cmRheVwiXG5cdF0sXG5cdHNob3J0RGF5czogW1xuXHRcdFwiU3VuXCIsXG5cdFx0XCJNb25cIixcblx0XHRcIlR1ZVwiLFxuXHRcdFwiV2VkXCIsXG5cdFx0XCJUaHVcIixcblx0XHRcIkZyaVwiLFxuXHRcdFwiU2F0XCJcblx0XSxcblx0dG9vbGJhcjoge1xuXHRcdGV4cG9ydFRvU1ZHOiBcIkRvd25sb2FkIFNWR1wiLFxuXHRcdGV4cG9ydFRvUE5HOiBcIkRvd25sb2FkIFBOR1wiLFxuXHRcdG1lbnU6IFwiTWVudVwiLFxuXHRcdHNlbGVjdGlvbjogXCJTZWxlY3Rpb25cIixcblx0XHRzZWxlY3Rpb25ab29tOiBcIlNlbGVjdGlvbiBab29tXCIsXG5cdFx0em9vbUluOiBcIlpvb20gSW5cIixcblx0XHR6b29tT3V0OiBcIlpvb20gT3V0XCIsXG5cdFx0cGFuOiBcIlBhbm5pbmdcIixcblx0XHRyZXNldDogXCJSZXNldCBab29tXCJcblx0fVxufTtcbnZhciBlbiA9IHtcblx0bmFtZTogbmFtZSxcblx0b3B0aW9uczogb3B0aW9uc1xufTtcblxudmFyIE9wdGlvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPcHRpb25zKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25zKTtcblxuICAgIHRoaXMueUF4aXMgPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgc2hvd0Fsd2F5czogZmFsc2UsXG4gICAgICBzZXJpZXNOYW1lOiB1bmRlZmluZWQsXG4gICAgICBvcHBvc2l0ZTogZmFsc2UsXG4gICAgICByZXZlcnNlZDogZmFsc2UsXG4gICAgICBsb2dhcml0aG1pYzogZmFsc2UsXG4gICAgICB0aWNrQW1vdW50OiB1bmRlZmluZWQsXG4gICAgICBmb3JjZU5pY2VTY2FsZTogZmFsc2UsXG4gICAgICBtYXg6IHVuZGVmaW5lZCxcbiAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgZGVjaW1hbHNJbkZsb2F0OiAyLFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICBtYXhXaWR0aDogMTYwLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICByb3RhdGU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDIwLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGNvbG9yczogW10sXG4gICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgY29sb3I6ICcjNzg5MDlDJyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSxcbiAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgY29sb3I6ICcjNzg5MDlDJyxcbiAgICAgICAgd2lkdGg6IDYsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDBcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHJvdGF0ZTogOTAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogJydcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIG9mZnNldFg6IDBcbiAgICAgIH0sXG4gICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAnZnJvbnQnLFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICBjb2xvcjogJyNiNmI2YjYnLFxuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGRhc2hBcnJheTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnhBeGlzQW5ub3RhdGlvbiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB4MjogbnVsbCxcbiAgICAgIHN0cm9rZURhc2hBcnJheTogMSxcbiAgICAgIGZpbGxDb2xvcjogJyNjMmMyYzInLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgIG9wYWNpdHk6IDAuMyxcbiAgICAgIG9mZnNldFg6IDAsXG4gICAgICBvZmZzZXRZOiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgY3NzQ2xhc3M6ICcnLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgICByaWdodDogNSxcbiAgICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICAgIGJvdHRvbTogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy55QXhpc0Fubm90YXRpb24gPSB7XG4gICAgICB5OiAwLFxuICAgICAgeTI6IG51bGwsXG4gICAgICBzdHJva2VEYXNoQXJyYXk6IDEsXG4gICAgICBmaWxsQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICBvcGFjaXR5OiAwLjMsXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcbiAgICAgIHlBeGlzSW5kZXg6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICB0ZXh0QW5jaG9yOiAnZW5kJyxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IC0zLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucG9pbnRBbm5vdGF0aW9uID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IG51bGwsXG4gICAgICB5QXhpc0luZGV4OiAwLFxuICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgZmlsbENvbG9yOiAnI2ZmZicsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICBzdHJva2VDb2xvcjogJyMzMzMnLFxuICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHJhZGl1czogMixcbiAgICAgICAgY3NzQ2xhc3M6ICcnXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IC0xNSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogJycsXG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VzdG9tU1ZHOiB7XG4gICAgICAgIFNWRzogdW5kZWZpbmVkLFxuICAgICAgICBjc3NDbGFzczogdW5kZWZpbmVkLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPcHRpb25zLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbm5vdGF0aW9uczoge1xuICAgICAgICAgIHBvc2l0aW9uOiAnZnJvbnQnLFxuICAgICAgICAgIHlheGlzOiBbdGhpcy55QXhpc0Fubm90YXRpb25dLFxuICAgICAgICAgIHhheGlzOiBbdGhpcy54QXhpc0Fubm90YXRpb25dLFxuICAgICAgICAgIHBvaW50czogW3RoaXMucG9pbnRBbm5vdGF0aW9uXVxuICAgICAgICB9LFxuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlaW5vdXQnLFxuICAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlb3V0LCBlYXNlaW4sIGVhc2Vpbm91dCwgc3dpbmcsIGJvdW5jZSwgZWxhc3RpY1xuICAgICAgICAgICAgc3BlZWQ6IDgwMCxcbiAgICAgICAgICAgIGFuaW1hdGVHcmFkdWFsbHk6IHtcbiAgICAgICAgICAgICAgZGVsYXk6IDE1MCxcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR5bmFtaWNBbmltYXRpb246IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3BlZWQ6IDM1MFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICBsb2NhbGVzOiBbZW5dLFxuICAgICAgICAgIGRlZmF1bHRMb2NhbGU6ICdlbicsXG4gICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBlbmFibGVkU2VyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgICBsZWZ0OiAyLFxuICAgICAgICAgICAgYmx1cjogNCxcbiAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjM1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkVuZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmVmb3JlTW91bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1vdW50ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsZWdlbmRDbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhUG9pbnRTZWxlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFQb2ludE1vdXNlRW50ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFQb2ludE1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJlZm9yZVpvb206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHpvb21lZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2Nyb2xsZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9yZUNvbG9yOiAnIzM3M2QzZicsXG4gICAgICAgICAgZm9udEZhbWlseTogJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgZ3JvdXA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6ICd4JyxcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkUG9pbnRzOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQgZGF0YXBvaW50cyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnIzI0MjkyZScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgY29sb3I6ICcjMjQyOTJlJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgICAgICBkYXNoQXJyYXk6IDNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNwYXJrbGluZToge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJydXNoOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9TY2FsZVlheGlzOiBmYWxzZSxcbiAgICAgICAgICAgIHRhcmdldDogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICBzdGFja1R5cGU6ICdub3JtYWwnLFxuICAgICAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICB0b29sczoge1xuICAgICAgICAgICAgICBkb3dubG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICB6b29tOiB0cnVlLFxuICAgICAgICAgICAgICB6b29taW46IHRydWUsXG4gICAgICAgICAgICAgIHpvb21vdXQ6IHRydWUsXG4gICAgICAgICAgICAgIHBhbjogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVzZXQ6IHRydWUsXG4gICAgICAgICAgICAgIGN1c3RvbUljb25zOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF1dG9TZWxlY3RlZDogJ3pvb20nIC8vIGFjY2VwdHMgLT4gem9vbSwgcGFuLCBzZWxlY3Rpb25cblxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6ICd4JyxcbiAgICAgICAgICAgIC8vIGF1dG9TY2FsZVlheGlzOiBmYWxzZSwgLy8gVE9ETzogcmV3cml0ZSB0aGUgYXV0b1NjYWxlWSBmdW5jdGlvblxuICAgICAgICAgICAgem9vbWVkQXJlYToge1xuICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjOTBDQUY5JyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMEQ0N0ExJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgZW5kaW5nU2hhcGU6ICdmbGF0JyxcbiAgICAgICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZSBpbiA0LjBcbiAgICAgICAgICAgIGNvbHVtbldpZHRoOiAnNzAlJyxcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbiBwZXJjZW50IDAgLSAxMDBcbiAgICAgICAgICAgIGJhckhlaWdodDogJzcwJScsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW4gcGVyY2VudCAwIC0gMTAwXG4gICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgcmFuZ2VzOiBbXSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZEJhckNvbG9yczogW10sXG4gICAgICAgICAgICAgIGJhY2tncm91bmRCYXJPcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ3RvcCcgLy8gdG9wLCBjZW50ZXIsIGJvdHRvbVxuICAgICAgICAgICAgICAvLyBUT0RPOiBwcm92aWRlIHN0YWNrZWRMYWJlbHMgZm9yIHN0YWNrZWQgY2hhcnRzIHdoaWNoIGdpdmVzIGFkZGl0aW9ucyBvZiB2YWx1ZXNcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuZGxlc3RpY2s6IHtcbiAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICB1cHdhcmQ6ICcjMDBCNzQ2JyxcbiAgICAgICAgICAgICAgZG93bndhcmQ6ICcjRUY0MDNDJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpY2s6IHtcbiAgICAgICAgICAgICAgdXNlRmlsbENvbG9yOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWF0bWFwOiB7XG4gICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICBlbmFibGVTaGFkZXM6IHRydWUsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC41LFxuICAgICAgICAgICAgZGlzdHJpYnV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3JTY2FsZToge1xuICAgICAgICAgICAgICBpbnZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmFuZ2VzOiBbXSxcbiAgICAgICAgICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByYWRpYWxCYXI6IHtcbiAgICAgICAgICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGludmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgICAgZW5kQW5nbGU6IDM2MCxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgaG9sbG93OiB7XG4gICAgICAgICAgICAgIG1hcmdpbjogNSxcbiAgICAgICAgICAgICAgc2l6ZTogJzUwJScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgIGltYWdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGltYWdlV2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgaW1hZ2VIZWlnaHQ6IDE1MCxcbiAgICAgICAgICAgICAgaW1hZ2VPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICBpbWFnZU9mZnNldFk6IDAsXG4gICAgICAgICAgICAgIGltYWdlQ2xpcHBlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdmcm9udCcsXG4gICAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICBibHVyOiAzLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZjJmMmYyJyxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICc5NyUnLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICBtYXJnaW46IDUsXG4gICAgICAgICAgICAgIC8vIG1hcmdpbiBpcyBpbiBwaXhlbHNcbiAgICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIGJsdXI6IDMsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IDE2LFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCArICclJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdUb3RhbCcsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzczZDNmJyxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih3KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc1RvdGFscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICAgICAgICAgICAgfSwgMCkgLyB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCArICclJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBpZToge1xuICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3VzdG9tU2NhbGU6IDEsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGV4cGFuZE9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudGFnZSB2YWx1ZXMgd2hpY2ggYXJlIGRpc3BsYXllZCBvbiBzbGljZVxuICAgICAgICAgICAgICBvZmZzZXQ6IDAgLy8gb2Zmc2V0IGJ5IHdoaWNoIGxhYmVscyB3aWxsIG1vdmUgb3V0c2lkZVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9udXQ6IHtcbiAgICAgICAgICAgICAgc2l6ZTogJzY1JScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgaW5uZXIgbGFiZWxzIGFwcGVhcmluZyBpbnNpZGUgZG9udXRcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBvZmZzZXRZOiAtMTBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBvZmZzZXRZOiAxMCxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG90YWw6IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6ICdUb3RhbCcsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJyMzNzNkM2YnLFxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc1RvdGFscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmFkYXI6IHtcbiAgICAgICAgICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgcG9seWdvbnM6IHtcbiAgICAgICAgICAgICAgLy8gc3Ryb2tlQ29sb3I6ICcjZThlOGU4JywgLy8gc2hvdWxkIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG1pbm9yIHZlcnNpb24gaS5lIDMuMlxuICAgICAgICAgICAgICBzdHJva2VDb2xvcnM6ICcjZThlOGU4JyxcbiAgICAgICAgICAgICAgY29ubmVjdG9yQ29sb3JzOiAnI2U4ZThlOCcsXG4gICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgZW5hYmxlZE9uU2VyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdG9wOiAxLFxuICAgICAgICAgICAgbGVmdDogMSxcbiAgICAgICAgICAgIGJsdXI6IDEsXG4gICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgb3BhY2l0eTogMC40NVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgLy8gYXJyYXkgb2YgY29sb3JzXG4gICAgICAgICAgb3BhY2l0eTogMC44NSxcbiAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgc2hhZGU6ICdkYXJrJyxcbiAgICAgICAgICAgIHR5cGU6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjUsXG4gICAgICAgICAgICBncmFkaWVudFRvQ29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiB0cnVlLFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDEsXG4gICAgICAgICAgICBvcGFjaXR5VG86IDEsXG4gICAgICAgICAgICBzdG9wczogWzAsIDUwLCAxMDBdLFxuICAgICAgICAgICAgY29sb3JTdG9wczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICBzcmM6IFtdLFxuICAgICAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCAvLyBvcHRpb25hbFxuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBzdHlsZTogJ3NxYXVyZXMnLFxuICAgICAgICAgICAgLy8gU3RyaW5nIHwgQXJyYXkgb2YgU3RyaW5nc1xuICAgICAgICAgICAgd2lkdGg6IDYsXG4gICAgICAgICAgICBoZWlnaHQ6IDYsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZTBlMGUwJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXk6IDAsXG4gICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgbGluZXM6IHtcbiAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgIGFuaW1hdGU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgbGluZXM6IHtcbiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcm93OiB7XG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIHRha2VzIGFzIGFycmF5IHdoaWNoIHdpbGwgYmUgcmVwZWF0ZWQgb24gcm93c1xuICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2x1bW46IHtcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gdGFrZXMgYW4gYXJyYXkgd2hpY2ggd2lsbCBiZSByZXBlYXRlZCBvbiBjb2x1bW5zXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IDEyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgIHNob3dGb3JTaW5nbGVTZXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHNob3dGb3JOdWxsU2VyaWVzOiB0cnVlLFxuICAgICAgICAgIHNob3dGb3JaZXJvU2VyaWVzOiB0cnVlLFxuICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgLy8gd2hldGhlciB0byBwb3NpdGlvbiBsZWdlbmRzIGluIDEgb2YgNFxuICAgICAgICAgIC8vIGRpcmVjdGlvbiAtIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodFxuICAgICAgICAgIGhvcml6b250YWxBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgLy8gd2hlbiBwb3NpdGlvbiB0b3AvYm90dG9tLCB5b3UgY2FuIHNwZWNpZnkgd2hldGhlciB0byBhbGlnbiBsZWdlbmRzIGxlZnQsIHJpZ2h0IG9yIGNlbnRlclxuICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgb2Zmc2V0WDogLTIwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVzZVNlcmllc0NvbG9yczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMixcbiAgICAgICAgICAgIGhlaWdodDogMTIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICByYWRpdXM6IDEyLFxuICAgICAgICAgICAgY3VzdG9tSFRNTDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBvbkNsaWNrOiB1bmRlZmluZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1NYXJnaW46IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbDogNVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25JdGVtQ2xpY2s6IHtcbiAgICAgICAgICAgIHRvZ2dsZURhdGFTZXJpZXM6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uSXRlbUhvdmVyOiB7XG4gICAgICAgICAgICBoaWdobGlnaHREYXRhU2VyaWVzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgZGlzY3JldGU6IFtdLFxuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgLy9zdHJva2VDb2xvcjogJyNmZmYnLCAvLyBUT0RPOiBkZXByZWNhdGUgaW4gbWFqb3IgdmVyc2lvbiA0LjBcbiAgICAgICAgICBzdHJva2VDb2xvcnM6ICcjZmZmJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjksXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICAgIHJhZGl1czogMixcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemVPZmZzZXQ6IDNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vRGF0YToge1xuICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2l2ZTogW10sXG4gICAgICAgIC8vIGJyZWFrcG9pbnRzIHNob3VsZCBmb2xsb3cgYXNjZW5kaW5nIG9yZGVyIDQwMCwgdGhlbiA3MDAsIHRoZW4gMTAwMFxuICAgICAgICBzZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ25vbmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnbGlnaHRlbicsXG4gICAgICAgICAgICAgIHZhbHVlOiAwLjE1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgIGFsbG93TXVsdGlwbGVEYXRhUG9pbnRzU2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnZGFya2VuJyxcbiAgICAgICAgICAgICAgdmFsdWU6IDAuNjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgbWFyZ2luOiAxMCxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICBtYXJnaW46IDEwLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMzAsXG4gICAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICBjdXJ2ZTogJ3Ntb290aCcsXG4gICAgICAgICAgLy8gXCJzbW9vdGhcIiAvIFwic3RyYWlnaHRcIiAvIFwic3RlcGxpbmVcIlxuICAgICAgICAgIGxpbmVDYXA6ICdidXR0JyxcbiAgICAgICAgICAvLyByb3VuZCwgYnV0dCAsIHNxdWFyZVxuICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIGFycmF5IG9mIGNvbG9yc1xuICAgICAgICAgIGRhc2hBcnJheTogMCAvLyBzaW5nbGUgdmFsdWUgb3IgYXJyYXkgb2YgdmFsdWVzXG5cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgc2hhcmVkOiB0cnVlLFxuICAgICAgICAgIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gICAgICAgICAgLy8gd2hlbiBkaXNhYmxlZCwgdGhlIHRvb2x0aXAgd2lsbCBzaG93IG9uIHRvcCBvZiB0aGUgc2VyaWVzIGluc3RlYWQgb2YgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxuICAgICAgICAgIC8vIHdoZW4gZW5hYmxlZCwgdG9vbHRpcCB3aWxsIG9ubHkgc2hvdyB3aGVuIHVzZXIgZGlyZWN0bHkgaG92ZXJzIG92ZXIgcG9pbnRcbiAgICAgICAgICBpbnZlcnNlT3JkZXI6IGZhbHNlLFxuICAgICAgICAgIGN1c3RvbTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogZmFsc2UsXG4gICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRGF0YXNldEhvdmVyOiB7XG4gICAgICAgICAgICBoaWdobGlnaHREYXRhU2VyaWVzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeDoge1xuICAgICAgICAgICAgLy8geCB2YWx1ZVxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdDogJ2RkIE1NTScsXG4gICAgICAgICAgICAvLyBkZC9NTSwgZGQgTU1NIHl5LCBkZCBNTU0geXl5eVxuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQgLy8gYSBjdXN0b20gdXNlciBzdXBwbGllZCBmb3JtYXR0ZXIgZnVuY3Rpb25cblxuICAgICAgICAgIH0sXG4gICAgICAgICAgeToge1xuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihzZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc05hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHo6IHtcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGl0bGU6ICdTaXplOiAnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpeGVkOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wUmlnaHQnLFxuICAgICAgICAgICAgLy8gdG9wUmlnaHQsIHRvcExlZnQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0XG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICAgIGNhdGVnb3JpZXM6IFtdLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICByb3RhdGU6IC00NSxcbiAgICAgICAgICAgIHJvdGF0ZUFsd2F5czogZmFsc2UsXG4gICAgICAgICAgICBoaWRlT3ZlcmxhcHBpbmdMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICB0cmltOiB0cnVlLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IDEyMCxcbiAgICAgICAgICAgIHNob3dEdXBsaWNhdGVzOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjc3NDbGFzczogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGZvcm1hdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZ1bmN0aW9uIHdoaWNoIHdpbGwgb3ZlcnJpZGUgZm9ybWF0XG4gICAgICAgICAgICBkYXRldGltZUZvcm1hdHRlcjoge1xuICAgICAgICAgICAgICB5ZWFyOiAneXl5eScsXG4gICAgICAgICAgICAgIG1vbnRoOiBcIk1NTSAneXlcIixcbiAgICAgICAgICAgICAgZGF5OiAnZGQgTU1NJyxcbiAgICAgICAgICAgICAgaG91cjogJ0hIOm1tJyxcbiAgICAgICAgICAgICAgbWludXRlOiAnSEg6bW06c3MnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBheGlzQm9yZGVyOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6ICcjNzg5MDlDJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXhpc1RpY2tzOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6ICcjNzg5MDlDJyxcbiAgICAgICAgICAgIGhlaWdodDogNixcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrQW1vdW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgdGlja1BsYWNlbWVudDogJ29uJyxcbiAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICBtYXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICByYW5nZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjc3NDbGFzczogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIC8vIHRpY2tXaWR0aC9iYXJXaWR0aCBvciBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JhY2snLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45LFxuICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnI2I2YjZiNicsXG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBkYXNoQXJyYXk6IDNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgICAgIC8vIHNvbGlkLCBncmFkaWVudFxuICAgICAgICAgICAgICBjb2xvcjogJyNCMUI5QzQnLFxuICAgICAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgICAgIGNvbG9yRnJvbTogJyNEOEUzRjAnLFxuICAgICAgICAgICAgICAgIGNvbG9yVG86ICcjQkVEMUU2JyxcbiAgICAgICAgICAgICAgICBzdG9wczogWzAsIDEwMF0sXG4gICAgICAgICAgICAgICAgb3BhY2l0eUZyb206IDAuNCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5VG86IDAuNVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICBibHVyOiAxLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHlheGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICB0aGVtZToge1xuICAgICAgICAgIHBhbGV0dGU6ICdwYWxldHRlMScsXG4gICAgICAgICAgLy8gSWYgZGVmaW5lZCwgaXQgd2lsbCBvdmVyd3JpdGUgZ2xvYmFscy5jb2xvcnMgdmFyaWFibGVcbiAgICAgICAgICBtb25vY2hyb21lOiB7XG4gICAgICAgICAgICAvLyBtb25vY2hyb21lIGFsbG93cyB5b3UgdG8gc2VsZWN0IGp1c3QgMSBjb2xvciBhbmQgZmlsbCBvdXQgdGhlIHJlc3Qgd2l0aCBsaWdodC9kYXJrIHNoYWRlIChpbnRlbnNpdHkgY2FuIGJlIHNlbGVjdGVkKVxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcjogJyMwMDhGRkInLFxuICAgICAgICAgICAgc2hhZGVUbzogJ2xpZ2h0JyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjY1XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcHRpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQW5ub3RhdGlvbnMgQ2xhc3MgZm9yIGRyYXdpbmcgbGluZXMvcmVjdHMgb24gYm90aCB4YXhpcyBhbmQgeWF4aXMuXG4gKlxuICogQG1vZHVsZSBBbm5vdGF0aW9uc1xuICoqL1xuXG52YXIgQW5ub3RhdGlvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbm5vdGF0aW9ucyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG5cbiAgICBpZiAodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKSB7XG4gICAgICB0aGlzLmludmVydEF4aXMgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMueERpdmlzaW9uID0gdGhpcy53Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGhpcy53Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbm5vdGF0aW9ucywgW3tcbiAgICBrZXk6IFwiZHJhd0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdmFyIHlBbm5vdGF0aW9ucyA9IHRoaXMuZHJhd1lBeGlzQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgdmFyIHhBbm5vdGF0aW9ucyA9IHRoaXMuZHJhd1hBeGlzQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgdmFyIHBvaW50QW5ub3RhdGlvbnMgPSB0aGlzLmRyYXdQb2ludEFubm90YXRpb25zKCk7XG4gICAgICAgIHZhciBpbml0aWFsQW5pbSA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgdmFyIGFubm9BcnJheSA9IFt5QW5ub3RhdGlvbnMsIHhBbm5vdGF0aW9ucywgcG9pbnRBbm5vdGF0aW9uc107XG4gICAgICAgIHZhciBhbm5vRWxBcnJheSA9IFt4QW5ub3RhdGlvbnMubm9kZSwgeUFubm90YXRpb25zLm5vZGUsIHBvaW50QW5ub3RhdGlvbnMubm9kZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChhbm5vQXJyYXlbaV0pO1xuXG4gICAgICAgICAgaWYgKGluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICBhbm5vRWxBcnJheVtpXS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuZGVsYXllZEVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZWw6IGFubm9FbEFycmF5W2ldLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhZnRlciBwbGFjaW5nIHRoZSBhbm5vdGF0aW9ucyBvbiBzdmcsIHNldCBhbnkgdmVydGljYWxseSBwbGFjZWQgYW5ub3RhdGlvbnNcblxuXG4gICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb25zKHcuY29uZmlnLmFubm90YXRpb25zLnhheGlzKTsgLy8gYmFja2dyb3VuZCBzaXplcyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIGFmdGVyIHRleHQgaXMgZHJhd24sIHNvIGNhbGxpbmcgdGhlbSBsYXN0XG5cbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uc0JhY2tncm91bmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWGF4aXNBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtaW4gPSB0aGlzLmludmVydEF4aXMgPyB3Lmdsb2JhbHMubWluWSA6IHcuZ2xvYmFscy5taW5YO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5pbnZlcnRBeGlzID8gdy5nbG9iYWxzLnlSYW5nZVswXSA6IHcuZ2xvYmFscy54UmFuZ2U7XG4gICAgICB2YXIgeDEgPSAoYW5uby54IC0gbWluKSAvIChyYW5nZSAvIHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgdmFyIGNhdEluZGV4ID0gdy5nbG9iYWxzLmxhYmVscy5pbmRleE9mKGFubm8ueCk7XG4gICAgICAgIHZhciB4TGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nIHRleHQ6bnRoLWNoaWxkKCcgKyAoY2F0SW5kZXggKyAxKSArICcpJyk7XG4gICAgICAgIHgxID0gcGFyc2VGbG9hdCh4TGFiZWwuZ2V0QXR0cmlidXRlKCd4JykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gYW5uby5zdHJva2VEYXNoQXJyYXk7XG4gICAgICBpZiAoeDEgPCAwIHx8IHgxID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkgcmV0dXJuO1xuXG4gICAgICBpZiAoYW5uby54MiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JhcGhpY3MuZHJhd0xpbmUoeDEgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIDAgKyBhbm5vLm9mZnNldFksIC8vIHkxXG4gICAgICAgIHgxICsgYW5uby5vZmZzZXRYLCAvLyB4MlxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gbGluZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvL2Rhc2hBcnJheVxuICAgICAgICApO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobGluZS5ub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4MiA9IChhbm5vLngyIC0gbWluKSAvIChyYW5nZSAvIHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuXG4gICAgICAgIGlmICh4MiA8IHgxKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB4MTtcbiAgICAgICAgICB4MSA9IHgyO1xuICAgICAgICAgIHgyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCh4MSArIGFubm8ub2Zmc2V0WCwgLy8geDFcbiAgICAgICAgMCArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgeDIgLSB4MSwgLy8geDJcbiAgICAgICAgdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyBhbm5vLm9mZnNldFksIC8vIHkyXG4gICAgICAgIDAsIC8vIHJhZGl1c1xuICAgICAgICBhbm5vLmZpbGxDb2xvciwgLy8gY29sb3JcbiAgICAgICAgYW5uby5vcGFjaXR5LCAvLyBvcGFjaXR5LFxuICAgICAgICAxLCAvLyBzdHJva2VXaWR0aFxuICAgICAgICBhbm5vLmJvcmRlckNvbG9yLCAvLyBzdHJva2VDb2xvclxuICAgICAgICBzdHJva2VEYXNoQXJyYXkgLy8gc3Rva2VEYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlY3Qubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0WSA9IGFubm8ubGFiZWwucG9zaXRpb24gPT09ICd0b3AnID8gLTMgOiB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgIHZhciB0ZXh0ID0gYW5uby5sYWJlbC50ZXh0ID8gYW5uby5sYWJlbC50ZXh0IDogJyc7XG4gICAgICB2YXIgZWxUZXh0ID0gdGhpcy5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgIHg6IHgxICsgYW5uby5sYWJlbC5vZmZzZXRYLFxuICAgICAgICB5OiB0ZXh0WSArIGFubm8ubGFiZWwub2Zmc2V0WSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGV4dEFuY2hvcjogYW5uby5sYWJlbC50ZXh0QW5jaG9yLFxuICAgICAgICBmb250U2l6ZTogYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogYW5uby5sYWJlbC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IGFubm8ubGFiZWwuc3R5bGUuY29sb3IsXG4gICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9uLWxhYmVsICcgKyBhbm5vLmxhYmVsLnN0eWxlLmNzc0NsYXNzXG4gICAgICB9KTtcbiAgICAgIGVsVGV4dC5hdHRyKHtcbiAgICAgICAgcmVsOiBpbmRleFxuICAgICAgfSk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxUZXh0Lm5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WEF4aXNBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WEF4aXNBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsZyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbnMnXG4gICAgICB9KTtcbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnhheGlzLm1hcChmdW5jdGlvbiAoYW5ubywgaW5kZXgpIHtcbiAgICAgICAgX3RoaXMuYWRkWGF4aXNBbm5vdGF0aW9uKGFubm8sIGVsZy5ub2RlLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFlheGlzQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRZYXhpc0Fubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gYW5uby5zdHJva2VEYXNoQXJyYXk7XG4gICAgICB2YXIgeTE7XG4gICAgICB2YXIgeTI7XG5cbiAgICAgIGlmICh0aGlzLmludmVydEF4aXMpIHtcbiAgICAgICAgdmFyIGNhdEluZGV4ID0gdy5nbG9iYWxzLmxhYmVscy5pbmRleE9mKGFubm8ueSk7XG4gICAgICAgIHZhciB4TGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nIHRleHQ6bnRoLWNoaWxkKCcgKyAoY2F0SW5kZXggKyAxKSArICcpJyk7XG4gICAgICAgIHkxID0gcGFyc2VGbG9hdCh4TGFiZWwuZ2V0QXR0cmlidXRlKCd5JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICB5MSA9IChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcblxuICAgICAgaWYgKGFubm8ueTIgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyYXBoaWNzLmRyYXdMaW5lKDAgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIHkxICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgYW5uby5vZmZzZXRYLCAvLyB4MlxuICAgICAgICB5MSArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gbGluZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvLyBkYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgICAgdmFyIF9jYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLnkyKTtcblxuICAgICAgICAgIHZhciBfeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKF9jYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICAgIHkyID0gcGFyc2VGbG9hdChfeExhYmVsLmdldEF0dHJpYnV0ZSgneScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5MiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gKGFubm8ueTIgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICAgICAgeTIgPSAoYW5uby55MiAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeTIgPiB5MSkge1xuICAgICAgICAgIHZhciB0ZW1wID0geTE7XG4gICAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgICB5MiA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCArIGFubm8ub2Zmc2V0WCwgLy8geDFcbiAgICAgICAgeTIgKyBhbm5vLm9mZnNldFksIC8vIHkxXG4gICAgICAgIHcuZ2xvYmFscy5ncmlkV2lkdGggKyBhbm5vLm9mZnNldFgsIC8vIHgyXG4gICAgICAgIHkxIC0geTIsIC8vIHkyXG4gICAgICAgIDAsIC8vIHJhZGl1c1xuICAgICAgICBhbm5vLmZpbGxDb2xvciwgLy8gY29sb3JcbiAgICAgICAgYW5uby5vcGFjaXR5LCAvLyBvcGFjaXR5LFxuICAgICAgICAxLCAvLyBzdHJva2VXaWR0aFxuICAgICAgICBhbm5vLmJvcmRlckNvbG9yLCAvLyBzdHJva2VDb2xvclxuICAgICAgICBzdHJva2VEYXNoQXJyYXkgLy8gc3Rva2VEYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlY3Qubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0WCA9IGFubm8ubGFiZWwucG9zaXRpb24gPT09ICdyaWdodCcgPyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIDogMDtcbiAgICAgIHZhciBlbFRleHQgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogdGV4dFggKyBhbm5vLmxhYmVsLm9mZnNldFgsXG4gICAgICAgIHk6ICh5MiB8fCB5MSkgKyBhbm5vLmxhYmVsLm9mZnNldFkgLSAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiBhbm5vLmxhYmVsLnRleHRBbmNob3IsXG4gICAgICAgIGZvbnRTaXplOiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogYW5uby5sYWJlbC5zdHlsZS5jb2xvcixcbiAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLWFubm90YXRpb24tbGFiZWwgJyArIGFubm8ubGFiZWwuc3R5bGUuY3NzQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZWxUZXh0LmF0dHIoe1xuICAgICAgICByZWw6IGluZGV4XG4gICAgICB9KTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbFRleHQubm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZQXhpc0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZQXhpc0Fubm90YXRpb25zKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsZyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtYW5ub3RhdGlvbnMnXG4gICAgICB9KTtcbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnlheGlzLm1hcChmdW5jdGlvbiAoYW5ubywgaW5kZXgpIHtcbiAgICAgICAgX3RoaXMyLmFkZFlheGlzQW5ub3RhdGlvbihhbm5vLCBlbGcubm9kZSwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbnMoY3R4KSB7XG4gICAgICB2YXIgdyA9IGN0eC53O1xuICAgICAgdmFyIGFubm9zID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteWF4aXMtYW5ub3RhdGlvbnMsIC5hcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb25zLCAuYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucycpO1xuICAgICAgYW5ub3MuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICB3aGlsZSAoYS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciBwb2ludFkgPSAwO1xuXG4gICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUG9pbnQgYW5ub3RhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGhvcml6b250YWwgYmFyIGNoYXJ0cy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhbm5vLnggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLngpO1xuICAgICAgICB2YXIgeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKGNhdEluZGV4ICsgMSkgKyAnKScpO1xuICAgICAgICB2YXIgeFBvcyA9IHBhcnNlRmxvYXQoeExhYmVsLmdldEF0dHJpYnV0ZSgneCcpKTtcbiAgICAgICAgeCA9IHhQb3M7XG4gICAgICAgIHZhciBhbm5vWSA9IGFubm8ueTtcblxuICAgICAgICBpZiAoYW5uby55ID09PSBudWxsKSB7XG4gICAgICAgICAgYW5ub1kgPSB3Lmdsb2JhbHMuc2VyaWVzW2Fubm8uc2VyaWVzSW5kZXhdW2NhdEluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vWSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSAtIHBhcnNlSW50KGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUpIC0gYW5uby5tYXJrZXIuc2l6ZTtcbiAgICAgICAgcG9pbnRZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAoYW5ub1kgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICB5ID0gKGFubm9ZIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpICsgcGFyc2VJbnQoYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSkgKyBhbm5vLm1hcmtlci5zaXplO1xuICAgICAgICAgIHBvaW50WSA9IChhbm5vWSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IChhbm5vLnggLSB3Lmdsb2JhbHMubWluWCkgLyAody5nbG9iYWxzLnhSYW5nZSAvIHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuICAgICAgICB5ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAocGFyc2VGbG9hdChhbm5vLnkpIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIC0gcGFyc2VJbnQoYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSkgLSBhbm5vLm1hcmtlci5zaXplO1xuICAgICAgICBwb2ludFkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICB5ID0gKHBhcnNlRmxvYXQoYW5uby55KSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSAtIHBhcnNlSW50KGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUpIC0gYW5uby5tYXJrZXIuc2l6ZTtcbiAgICAgICAgICBwb2ludFkgPSAoYW5uby55IC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMCB8fCB4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkgcmV0dXJuO1xuICAgICAgdmFyIG9wdHNQb2ludHMgPSB7XG4gICAgICAgIHBTaXplOiBhbm5vLm1hcmtlci5zaXplLFxuICAgICAgICBwV2lkdGg6IGFubm8ubWFya2VyLnN0cm9rZVdpZHRoLFxuICAgICAgICBwb2ludEZpbGxDb2xvcjogYW5uby5tYXJrZXIuZmlsbENvbG9yLFxuICAgICAgICBwb2ludFN0cm9rZUNvbG9yOiBhbm5vLm1hcmtlci5zdHJva2VDb2xvcixcbiAgICAgICAgc2hhcGU6IGFubm8ubWFya2VyLnNoYXBlLFxuICAgICAgICByYWRpdXM6IGFubm8ubWFya2VyLnJhZGl1cyxcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXBvaW50LWFubm90YXRpb24tbWFya2VyICcgKyBhbm5vLm1hcmtlci5jc3NDbGFzc1xuICAgICAgfTtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuZ3JhcGhpY3MuZHJhd01hcmtlcih4ICsgYW5uby5tYXJrZXIub2Zmc2V0WCwgcG9pbnRZICsgYW5uby5tYXJrZXIub2Zmc2V0WSwgb3B0c1BvaW50cyk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocG9pbnQubm9kZSk7XG4gICAgICB2YXIgdGV4dCA9IGFubm8ubGFiZWwudGV4dCA/IGFubm8ubGFiZWwudGV4dCA6ICcnO1xuICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICB4OiB4ICsgYW5uby5sYWJlbC5vZmZzZXRYLFxuICAgICAgICB5OiB5ICsgYW5uby5sYWJlbC5vZmZzZXRZLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiBhbm5vLmxhYmVsLnRleHRBbmNob3IsXG4gICAgICAgIGZvbnRTaXplOiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICBmb250RmFtaWx5OiBhbm5vLmxhYmVsLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogYW5uby5sYWJlbC5zdHlsZS5jb2xvcixcbiAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXBvaW50LWFubm90YXRpb24tbGFiZWwgJyArIGFubm8ubGFiZWwuc3R5bGUuY3NzQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZWxUZXh0LmF0dHIoe1xuICAgICAgICByZWw6IGluZGV4XG4gICAgICB9KTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbFRleHQubm9kZSk7XG5cbiAgICAgIGlmIChhbm5vLmN1c3RvbVNWRy5TVkcpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbnMtY3VzdG9tLXN2ZyAnICsgYW5uby5jdXN0b21TVkcuY3NzQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgICAgIGcuYXR0cih7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoeCArIGFubm8uY3VzdG9tU1ZHLm9mZnNldFgsIFwiLCBcIikuY29uY2F0KHkgKyBhbm5vLmN1c3RvbVNWRy5vZmZzZXRZLCBcIilcIilcbiAgICAgICAgfSk7XG4gICAgICAgIGcubm9kZS5pbm5lckhUTUwgPSBhbm5vLmN1c3RvbVNWRy5TVkc7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChnLm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UG9pbnRBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9pbnRBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbGcgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXBvaW50LWFubm90YXRpb25zJ1xuICAgICAgfSk7XG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb2ludHMubWFwKGZ1bmN0aW9uIChhbm5vLCBpbmRleCkge1xuICAgICAgICBfdGhpczMuYWRkUG9pbnRBbm5vdGF0aW9uKGFubm8sIGVsZy5ub2RlLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9yaWVudGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmllbnRhdGlvbnMoYW5ub3MpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgYW5ub0luZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBhbm5vcy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgIGlmIChhbm5vLmxhYmVsLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgdmFyIGkgPSBhbm5vSW5kZXggIT09IG51bGwgPyBhbm5vSW5kZXggOiBpbmRleDtcbiAgICAgICAgICB2YXIgeEFubm8gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbnMgLmFwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbi1sYWJlbFtyZWw9J1wiLmNvbmNhdChpLCBcIiddXCIpKTtcblxuICAgICAgICAgIGlmICh4QW5ubyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHhBbm5vQ29vcmQgPSB4QW5uby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHhBbm5vLnNldEF0dHJpYnV0ZSgneCcsIHBhcnNlRmxvYXQoeEFubm8uZ2V0QXR0cmlidXRlKCd4JykpIC0geEFubm9Db29yZC5oZWlnaHQgKyA0KTtcblxuICAgICAgICAgICAgaWYgKGFubm8ubGFiZWwucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgIHhBbm5vLnNldEF0dHJpYnV0ZSgneScsIHBhcnNlRmxvYXQoeEFubm8uZ2V0QXR0cmlidXRlKCd5JykpICsgeEFubm9Db29yZC53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3knLCBwYXJzZUZsb2F0KHhBbm5vLmdldEF0dHJpYnV0ZSgneScpKSAtIHhBbm5vQ29vcmQud2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5ub1JvdGF0aW5nQ2VudGVyID0gX3RoaXM0LmdyYXBoaWNzLnJvdGF0ZUFyb3VuZENlbnRlcih4QW5ubyk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gYW5ub1JvdGF0aW5nQ2VudGVyLng7XG4gICAgICAgICAgICB2YXIgeSA9IGFubm9Sb3RhdGluZ0NlbnRlci55O1xuICAgICAgICAgICAgeEFubm8uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZSgtOTAgXCIuY29uY2F0KHgsIFwiIFwiKS5jb25jYXQoeSwgXCIpXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRCYWNrZ3JvdW5kVG9Bbm5vXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJhY2tncm91bmRUb0Fubm8oYW5ub0VsLCBhbm5vKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbEdyaWRSZWN0ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZ3JpZCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNvb3JkcyA9IGFubm9FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBwbGVmdCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5sZWZ0O1xuICAgICAgdmFyIHByaWdodCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5yaWdodDtcbiAgICAgIHZhciBwdG9wID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLnRvcDtcbiAgICAgIHZhciBwYm90dG9tID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLmJvdHRvbTtcblxuICAgICAgaWYgKGFubm8ubGFiZWwub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgcHRvcCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5sZWZ0O1xuICAgICAgICBwYm90dG9tID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLnJpZ2h0O1xuICAgICAgICBwbGVmdCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy50b3A7XG4gICAgICAgIHByaWdodCA9IGFubm8ubGFiZWwuc3R5bGUucGFkZGluZy5ib3R0b207XG4gICAgICB9XG5cbiAgICAgIHZhciB4MSA9IGNvb3Jkcy5sZWZ0IC0gZWxHcmlkUmVjdC5sZWZ0IC0gcGxlZnQ7XG4gICAgICB2YXIgeTEgPSBjb29yZHMudG9wIC0gZWxHcmlkUmVjdC50b3AgLSBwdG9wO1xuICAgICAgdmFyIGVsUmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCBjb29yZHMud2lkdGggKyBwbGVmdCArIHByaWdodCwgY29vcmRzLmhlaWdodCArIHB0b3AgKyBwYm90dG9tLCAwLCBhbm5vLmxhYmVsLnN0eWxlLmJhY2tncm91bmQsIDEsIGFubm8ubGFiZWwuYm9yZGVyV2lkdGgsIGFubm8ubGFiZWwuYm9yZGVyQ29sb3IsIDApO1xuICAgICAgcmV0dXJuIGVsUmVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5ub3RhdGlvbnNCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFubm90YXRpb25zQmFja2dyb3VuZCgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChhbm5vLCBpLCB0eXBlKSB7XG4gICAgICAgIHZhciBhbm5vTGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb25zIC5hcGV4Y2hhcnRzLVwiKS5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbi1sYWJlbFtyZWw9J1wiKS5jb25jYXQoaSwgXCInXVwiKSk7XG5cbiAgICAgICAgaWYgKGFubm9MYWJlbCkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBhbm5vTGFiZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHZhciBlbFJlY3QgPSBfdGhpczUuYWRkQmFja2dyb3VuZFRvQW5ubyhhbm5vTGFiZWwsIGFubm8pO1xuXG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbFJlY3Qubm9kZSwgYW5ub0xhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMueGF4aXMubWFwKGZ1bmN0aW9uIChhbm5vLCBpKSB7XG4gICAgICAgIGFkZChhbm5vLCBpLCAneGF4aXMnKTtcbiAgICAgIH0pO1xuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMueWF4aXMubWFwKGZ1bmN0aW9uIChhbm5vLCBpKSB7XG4gICAgICAgIGFkZChhbm5vLCBpLCAneWF4aXMnKTtcbiAgICAgIH0pO1xuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMucG9pbnRzLm1hcChmdW5jdGlvbiAoYW5ubywgaSkge1xuICAgICAgICBhZGQoYW5ubywgaSwgJ3BvaW50Jyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0KHBhcmFtcywgcHVzaFRvTWVtb3J5LCBjb250ZXh0KSB7XG4gICAgICB2YXIgeCA9IHBhcmFtcy54LFxuICAgICAgICAgIHkgPSBwYXJhbXMueSxcbiAgICAgICAgICB0ZXh0ID0gcGFyYW1zLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvciA9IHBhcmFtcy50ZXh0QW5jaG9yLFxuICAgICAgICAgIF9wYXJhbXMkYXBwZW5kVG8gPSBwYXJhbXMuYXBwZW5kVG8sXG4gICAgICAgICAgYXBwZW5kVG8gPSBfcGFyYW1zJGFwcGVuZFRvID09PSB2b2lkIDAgPyAnLmFwZXhjaGFydHMtaW5uZXInIDogX3BhcmFtcyRhcHBlbmRUbyxcbiAgICAgICAgICBmb3JlQ29sb3IgPSBwYXJhbXMuZm9yZUNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBwYXJhbXMuZm9udEZhbWlseSxcbiAgICAgICAgICBjc3NDbGFzcyA9IHBhcmFtcy5jc3NDbGFzcyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoID0gcGFyYW1zLmJvcmRlcldpZHRoLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHBhcmFtcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgcmFkaXVzID0gcGFyYW1zLnJhZGl1cyxcbiAgICAgICAgICBib3JkZXJDb2xvciA9IHBhcmFtcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICBfcGFyYW1zJHBhZGRpbmdMZWZ0ID0gcGFyYW1zLnBhZGRpbmdMZWZ0LFxuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gX3BhcmFtcyRwYWRkaW5nTGVmdCA9PT0gdm9pZCAwID8gNCA6IF9wYXJhbXMkcGFkZGluZ0xlZnQsXG4gICAgICAgICAgX3BhcmFtcyRwYWRkaW5nUmlnaHQgPSBwYXJhbXMucGFkZGluZ1JpZ2h0LFxuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IF9wYXJhbXMkcGFkZGluZ1JpZ2h0ID09PSB2b2lkIDAgPyA0IDogX3BhcmFtcyRwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgX3BhcmFtcyRwYWRkaW5nQm90dG9tID0gcGFyYW1zLnBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbSA9IF9wYXJhbXMkcGFkZGluZ0JvdHRvbSA9PT0gdm9pZCAwID8gMiA6IF9wYXJhbXMkcGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICBfcGFyYW1zJHBhZGRpbmdUb3AgPSBwYXJhbXMucGFkZGluZ1RvcCxcbiAgICAgICAgICBwYWRkaW5nVG9wID0gX3BhcmFtcyRwYWRkaW5nVG9wID09PSB2b2lkIDAgPyAyIDogX3BhcmFtcyRwYWRkaW5nVG9wO1xuICAgICAgdmFyIG1lID0gY29udGV4dDtcbiAgICAgIHZhciB3ID0gbWUudztcbiAgICAgIHZhciBwYXJlbnROb2RlID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihhcHBlbmRUbyk7XG4gICAgICB2YXIgZWxUZXh0ID0gdGhpcy5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IgfHwgJ3N0YXJ0JyxcbiAgICAgICAgZm9udFNpemU6IGZvbnRTaXplIHx8ICcxMnB4JyxcbiAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvciB8fCB3LmNvbmZpZy5jaGFydC5mb3JlQ29sb3IsXG4gICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy10ZXh0ICcgKyBjc3NDbGFzcyA/IGNzc0NsYXNzIDogJydcbiAgICAgIH0pO1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbFRleHQubm9kZSk7XG4gICAgICB2YXIgdGV4dFJlY3QgPSBlbFRleHQuYmJveCgpO1xuICAgICAgdmFyIGVsUmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGV4dFJlY3QueCAtIHBhZGRpbmdMZWZ0LCB0ZXh0UmVjdC55IC0gcGFkZGluZ1RvcCwgdGV4dFJlY3Qud2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCwgdGV4dFJlY3QuaGVpZ2h0ICsgcGFkZGluZ0JvdHRvbSArIHBhZGRpbmdUb3AsIHJhZGl1cywgYmFja2dyb3VuZENvbG9yLCAxLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG4gICAgICBlbFRleHQuYmVmb3JlKGVsUmVjdCk7XG5cbiAgICAgIGlmIChwdXNoVG9NZW1vcnkpIHtcbiAgICAgICAgdy5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgIG1ldGhvZDogbWUuYWRkVGV4dCxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICBhcHBlbmRUbzogYXBwZW5kVG8sXG4gICAgICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvcixcbiAgICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiBjc3NDbGFzcyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGJvcmRlcldpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiBzdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBwYWRkaW5nTGVmdCxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogcGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IHBhZGRpbmdUb3BcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uRXh0ZXJuYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgIHRoaXMuYWRkQW5ub3RhdGlvbkV4dGVybmFsKHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFBvaW50QW5ub3RhdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWWF4aXNBbm5vdGF0aW9uRXh0ZXJuYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgIHRoaXMuYWRkQW5ub3RhdGlvbkV4dGVybmFsKHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB0eXBlOiAneWF4aXMnLFxuICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFlheGlzQW5ub3RhdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9IC8vIFRoZSBhZGRYYXhpc0Fubm90YXRpb24gbWV0aG9kIHJlcXVpcmVzIGEgcGFyZW50IGNsYXNzLCBhbmQgdXNlciBjYWxsaW5nIHRoaXMgbWV0aG9kIGV4dGVybmFsbHkgb24gdGhlIGNoYXJ0IGluc3RhbmNlIG1heSBub3Qgc3BlY2lmeSBwYXJlbnQsIGhlbmNlIGEgZGlmZmVyZW50IG1ldGhvZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWGF4aXNBbm5vdGF0aW9uRXh0ZXJuYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWGF4aXNBbm5vdGF0aW9uRXh0ZXJuYWwocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgIHRoaXMuYWRkQW5ub3RhdGlvbkV4dGVybmFsKHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHB1c2hUb01lbW9yeTogcHVzaFRvTWVtb3J5LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB0eXBlOiAneGF4aXMnLFxuICAgICAgICBjb250ZXh0TWV0aG9kOiBjb250ZXh0LmFkZFhheGlzQW5ub3RhdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQW5ub3RhdGlvbkV4dGVybmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFubm90YXRpb25FeHRlcm5hbChfcmVmKSB7XG4gICAgICB2YXIgcGFyYW1zID0gX3JlZi5wYXJhbXMsXG4gICAgICAgICAgcHVzaFRvTWVtb3J5ID0gX3JlZi5wdXNoVG9NZW1vcnksXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgICAgICB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgIGNvbnRleHRNZXRob2QgPSBfcmVmLmNvbnRleHRNZXRob2Q7XG4gICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgdmFyIHcgPSBtZS53O1xuICAgICAgdmFyIHBhcmVudCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbnNcIikpO1xuICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoICsgMTtcbiAgICAgIHZhciBvcHQgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgdmFyIGF4ZXNBbm5vID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZSA9PT0gJ3hheGlzJyA/IG9wdC54QXhpc0Fubm90YXRpb24gOiB0eXBlID09PSAneWF4aXMnID8gb3B0LnlBeGlzQW5ub3RhdGlvbiA6IG9wdC5wb2ludEFubm90YXRpb24pO1xuICAgICAgdmFyIGFubm8gPSBVdGlscy5leHRlbmQoYXhlc0Fubm8sIHBhcmFtcyk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd4YXhpcyc6XG4gICAgICAgICAgdGhpcy5hZGRYYXhpc0Fubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAneWF4aXMnOlxuICAgICAgICAgIHRoaXMuYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgICB0aGlzLmFkZFBvaW50QW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gYWRkIGJhY2tncm91bmRcblxuXG4gICAgICB2YXIgYXhlc0Fubm9MYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbnMgLmFwZXhjaGFydHMtXCIpLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9uLWxhYmVsW3JlbD0nXCIpLmNvbmNhdChpbmRleCwgXCInXVwiKSk7XG4gICAgICB2YXIgZWxSZWN0ID0gdGhpcy5hZGRCYWNrZ3JvdW5kVG9Bbm5vKGF4ZXNBbm5vTGFiZWwsIGFubm8pO1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbFJlY3Qubm9kZSwgYXhlc0Fubm9MYWJlbCk7XG5cbiAgICAgIGlmIChwdXNoVG9NZW1vcnkpIHtcbiAgICAgICAgdy5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgIG1ldGhvZDogY29udGV4dE1ldGhvZCxcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFubm90YXRpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRGVmYXVsdCBDbGFzcyBmb3Igc2V0dGluZyBkZWZhdWx0IG9wdGlvbnMgZm9yIGFsbCBjaGFydCB0eXBlcy5cbiAqXG4gKiBAbW9kdWxlIERlZmF1bHRzXG4gKiovXG5cbnZhciBEZWZhdWx0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlZmF1bHRzKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdHMpO1xuXG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZWZhdWx0cywgW3tcbiAgICBrZXk6IFwibGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBlYXNpbmc6ICdzd2luZydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogNSxcbiAgICAgICAgICBjdXJ2ZTogJ3N0cmFpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgc2l6ZU9mZnNldDogNlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BhcmtsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwYXJrbGluZShkZWZhdWx0cykge1xuICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5zaG93ID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdHMueWF4aXNbMF0uZmxvYXRpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXhpc0JvcmRlcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHJldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGVhc2luZzogJ3N3aW5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdjZW50ZXInXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjg1XG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNoYXBlOiAnc3F1YXJlJyxcbiAgICAgICAgICAgIHJhZGl1czogMixcbiAgICAgICAgICAgIHNpemU6IDhcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnYmFyV2lkdGgnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdiYWNrJyxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyYWRpZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmRsZXN0aWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmRsZXN0aWNrKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgY29sb3JzOiBbJyMzMzMnXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShfcmVmKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBfcmVmLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFQb2ludEluZGV4ID0gX3JlZi5kYXRhUG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICB3ID0gX3JlZi53O1xuICAgICAgICAgICAgdmFyIG8gPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlT1tzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGggPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlSFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGwgPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlTFtzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGMgPSB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlQ1tzZXJpZXNJbmRleF1bZGF0YVBvaW50SW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiYXBleGNoYXJ0cy10b29sdGlwLWNhbmRsZXN0aWNrXCI+JyArICc8ZGl2Pk9wZW46IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgbyArICc8L3NwYW4+PC9kaXY+JyArICc8ZGl2PkhpZ2g6IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgaCArICc8L3NwYW4+PC9kaXY+JyArICc8ZGl2PkxvdzogPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPicgKyBsICsgJzwvc3Bhbj48L2Rpdj4nICsgJzxkaXY+Q2xvc2U6IDxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgYyArICc8L3NwYW4+PC9kaXY+JyArICc8L2Rpdj4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFyZWEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogNFxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgdHlwZTogJ2dyYWRpZW50JyxcbiAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgIHR5cGU6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICBvcGFjaXR5RnJvbTogMC42NSxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMC41LFxuICAgICAgICAgICAgc3RvcHM6IFswLCAxMDAsIDEwMF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBzaXplT2Zmc2V0OiA2XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZm9sbG93Q3Vyc29yOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJicnVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBicnVzaChkZWZhdWx0cykge1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBhdXRvU2VsZWN0ZWQ6ICdzZWxlY3Rpb24nLFxuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCByZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFja2VkMTAwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YWNrZWQxMDAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLm9wdHMuZGF0YUxhYmVscyA9IHRoaXMub3B0cy5kYXRhTGFiZWxzIHx8IHt9O1xuICAgICAgdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyID0gdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgIHZhciBleGlzdGluZ0RhdGFMYWJlbEZvcm1hdHRlciA9IHRoaXMub3B0cy5kYXRhTGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgIHRoaXMub3B0cy55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBfdGhpcy5vcHRzLnlheGlzW2luZGV4XS5taW4gPSAwO1xuICAgICAgICBfdGhpcy5vcHRzLnlheGlzW2luZGV4XS5tYXggPSAxMDA7XG4gICAgICB9KTtcbiAgICAgIHZhciBpc0JhciA9IHRoaXMub3B0cy5jaGFydC50eXBlID09PSAnYmFyJztcblxuICAgICAgaWYgKGlzQmFyKSB7XG4gICAgICAgIHRoaXMub3B0cy5kYXRhTGFiZWxzLmZvcm1hdHRlciA9IGV4aXN0aW5nRGF0YUxhYmVsRm9ybWF0dGVyIHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPyB2YWwudG9GaXhlZCgwKSArICclJyA6IHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRoZSBsZWZ0IGFuZCByaWdodCBzcGFjaW5nIGluIGNoYXJ0IGZvciBsaW5lL2FyZWEvc2NhdHRlciBpZiB4YXhpcyB0eXBlID0gY2F0ZWdvcnkgZm9yIHRob3NlIGNoYXJ0cyBieSBjb252ZXJ0aW5nIHhheGlzID0gbnVtZXJpYy4gTnVtZXJpYy9EYXRldGltZSB4YXhpcyBwcmV2ZW50cyB0aGUgdW5uZWNlc3Nhcnkgc3BhY2luZyBpbiB0aGUgbGVmdC9yaWdodCBvZiB0aGUgY2hhcnQgYXJlYVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnViYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgaW50ZXJzZWN0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBzaGFkZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgIGludmVyc2U6IHRydWUsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC41NSxcbiAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjQsXG4gICAgICAgICAgICBvcGFjaXR5VG86IDAuOFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NhdHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2F0dGVyKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgc2l6ZTogNixcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgc2l6ZU9mZnNldDogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhdG1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWF0bWFwKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICB6b29tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBmb2xsb3dDdXJzb3I6IHRydWUsXG4gICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgICBzaGFwZTogJ3NxdWFyZScsXG4gICAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICByaWdodDogMjBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBpZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgIHBpZToge1xuICAgICAgICAgICAgZG9udXQ6IHtcbiAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDEpICsgJyUnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnZGFyaycsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC4zNSxcbiAgICAgICAgICAgIGludmVyc2VDb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcHM6IFswLCAxMDAsIDEwMF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICB0aGVtZTogJ2RhcmsnLFxuICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb251dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb251dCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgxKSArICclJztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNCxcbiAgICAgICAgICAgIGludmVyc2VDb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAxLFxuICAgICAgICAgICAgb3BhY2l0eVRvOiAxLFxuICAgICAgICAgICAgc3RvcHM6IFs3MCwgOTgsIDEwMF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICB0aGVtZTogJ2RhcmsnLFxuICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYWRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWRhcigpIHtcbiAgICAgIHRoaXMub3B0cy55YXhpc1swXS5sYWJlbHMuc3R5bGUuZm9udFNpemUgPSAnMTNweCc7XG4gICAgICB0aGlzLm9wdHMueWF4aXNbMF0ubGFiZWxzLm9mZnNldFkgPSA2O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjYThhOGE4J10sXG4gICAgICAgICAgICBmb250U2l6ZTogJzExcHgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgaW50ZXJzZWN0OiB0cnVlLFxuICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGlhbEJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWRpYWxCYXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGR5bmFtaWNBbmltYXRpb246IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3BlZWQ6IDgwMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgc2hhZGU6ICdkYXJrJyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjQsXG4gICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6ICdkaWFnb25hbDInLFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDEsXG4gICAgICAgICAgICBvcGFjaXR5VG86IDEsXG4gICAgICAgICAgICBzdG9wczogWzcwLCA5OCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGZpbGxTZXJpZXNDb2xvcjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbnZlcnRDYXRUb051bWVyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydENhdFRvTnVtZXJpYyhvcHRzKSB7XG4gICAgICBvcHRzLnhheGlzLnR5cGUgPSAnbnVtZXJpYyc7XG4gICAgICBvcHRzLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYyA9IHRydWU7XG4gICAgICBvcHRzLnhheGlzLmxhYmVscyA9IG9wdHMueGF4aXMubGFiZWxzIHx8IHt9O1xuXG4gICAgICBvcHRzLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgPSBvcHRzLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgfHwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgb3B0cy5jaGFydCA9IG9wdHMuY2hhcnQgfHwge307XG4gICAgICBvcHRzLmNoYXJ0Lnpvb20gPSBvcHRzLmNoYXJ0Lnpvb20gfHwgd2luZG93LkFwZXguY2hhcnQgJiYgd2luZG93LkFwZXguY2hhcnQuem9vbSB8fCB7fTtcbiAgICAgIHZhciBkZWZhdWx0Rm9ybWF0dGVyID0gb3B0cy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgdmFyIGxhYmVscyA9IG9wdHMueGF4aXMuY2F0ZWdvcmllcyAmJiBvcHRzLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID8gb3B0cy54YXhpcy5jYXRlZ29yaWVzIDogb3B0cy5sYWJlbHM7XG5cbiAgICAgIGlmIChsYWJlbHMgJiYgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICBvcHRzLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXIobGFiZWxzW3ZhbCAtIDFdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3B0cy54YXhpcy5jYXRlZ29yaWVzID0gW107XG4gICAgICBvcHRzLmxhYmVscyA9IFtdO1xuICAgICAgb3B0cy5jaGFydC56b29tLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWZhdWx0cztcbn0oKTtcblxuLypcbiAqKiBVdGlsIGZ1bmN0aW9ucyB3aGljaCBhcmUgZGVwZW5kZW50IG9uIEFwZXhDaGFydHMgaW5zdGFuY2VcbiAqL1xudmFyIENvcmVVdGlscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvcmVVdGlscyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZVV0aWxzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvcmVVdGlscywgW3tcbiAgICBrZXk6IFwiZ2V0U3RhY2tlZFNlcmllc1RvdGFsc1wiLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIENvcmVVdGlsc1xuICAgICAqIHJldHVybnMgdGhlIHN1bSBvZiBhbGwgaW5kaXZpZHVhbCB2YWx1ZXMgaW4gYSBtdWx0aXBsZSBzdGFja2VkIHNlcmllc1xuICAgICAqIEVnLiB3Lmdsb2JhbHMuc2VyaWVzID0gW1szMiwzMyw0MywxMl0sIFsyLDMsNSwxXV1cbiAgICAgKiAgQHJldHVybiBbMzQsMzYsNDgsMTNdXG4gICAgICoqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGFja2VkU2VyaWVzVG90YWxzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdG90YWwgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmdsb2JhbHMuc2VyaWVzW3cuZ2xvYmFscy5tYXhWYWxzSW5BcnJheUluZGV4XS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdCArPSB3Lmdsb2JhbHMuc2VyaWVzW2pdW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdG90YWwucHVzaCh0KTtcbiAgICAgIH1cblxuICAgICAgdy5nbG9iYWxzLnN0YWNrZWRTZXJpZXNUb3RhbHMgPSB0b3RhbDtcbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9IC8vIGdldCB0b3RhbCBvZiB0aGUgYWxsIHZhbHVlcyBpbnNpZGUgYWxsIHNlcmllc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VyaWVzVG90YWxCeUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc1RvdGFsQnlJbmRleCgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5vbi1wbG90IGNoYXJ0IHR5cGVzIC0gcGllIC8gZG9udXQgLyBjaXJjbGVcbiAgICAgICAgcmV0dXJuIHRoaXMudy5jb25maWcuc2VyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgICAgICByZXR1cm4gYWNjICsgY3VyO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF4aXMgY2hhcnRzIC0gc3VwcG9ydGluZyBtdWx0aXBsZSBzZXJpZXNcbiAgICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLnNlcmllc1tpbmRleF0ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1Nlcmllc051bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZXJpZXNOdWxsKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHIgPSBbXTtcblxuICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5vbi1wbG90IGNoYXJ0IHR5cGVzIC0gcGllIC8gZG9udXQgLyBjaXJjbGVcbiAgICAgICAgciA9IHRoaXMudy5jb25maWcuc2VyaWVzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkICE9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF4aXMgY2hhcnRzIC0gc3VwcG9ydGluZyBtdWx0aXBsZSBzZXJpZXNcbiAgICAgICAgciA9IHRoaXMudy5nbG9iYWxzLnNlcmllc1tpbmRleF0uZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gci5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmllc0hhdmVTYW1lVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmllc0hhdmVTYW1lVmFsdWVzKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5ldmVyeShmdW5jdGlvbiAodmFsLCBpLCBhcnIpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gYXJyWzBdO1xuICAgICAgfSk7XG4gICAgfSAvLyBtYXhWYWxzSW5BcnJheUluZGV4IGlzIHRoZSBpbmRleCBvZiBzZXJpZXNbXSB3aGljaCBoYXMgdGhlIGxhcmdlc3QgbnVtYmVyIG9mIGl0ZW1zXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYXJnZXN0U2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RTZXJpZXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5tYXhWYWxzSW5BcnJheUluZGV4ID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoO1xuICAgICAgfSkuaW5kZXhPZihNYXRoLm1heC5hcHBseShNYXRoLCB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYXJnZXN0TWFya2VyU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXJnZXN0TWFya2VyU2l6ZSgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCBtKTtcbiAgICAgIH0pO1xuICAgICAgdy5nbG9iYWxzLm1hcmtlcnMubGFyZ2VzdFNpemUgPSBzaXplO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlXG4gICAgICogcmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgaW4gYSBzZXJpZXNcbiAgICAgKiBFZy4gdy5nbG9iYWxzLnNlcmllcyA9IFtbMzIsMzMsNDMsMTJdLCBbMiwzLDUsMV1dXG4gICAgICogIEByZXR1cm4gWzEyMCwgMTFdXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VyaWVzVG90YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc1RvdGFscygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnNlcmllc1RvdGFscyA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyKSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBzZXJbal07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZvciBwaWUvZG9udXRzL2dhdWdlc1xuICAgICAgICAgIHRvdGFsICs9IHNlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbHNYUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxzWFJhbmdlKG1pblgsIG1heFgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNlcmllc1RvdGFsc1hSYW5nZSA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllc1hbaW5kZXhdW2pdID4gbWluWCAmJiB3Lmdsb2JhbHMuc2VyaWVzWFtpbmRleF1bal0gPCBtYXhYKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBzZXJbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VyaWVzVG90YWxzWFJhbmdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVV0aWxzXG4gICAgICogcmV0dXJucyB0aGUgcGVyY2VudGFnZSB2YWx1ZSBvZiBhbGwgaW5kaXZpZHVhbCB2YWx1ZXMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYSAxMDAlIHN0YWNrZWQgc2VyaWVzXG4gICAgICogRWcuIHcuZ2xvYmFscy5zZXJpZXMgPSBbWzMyLCAzMywgNDMsIDEyXSwgWzIsIDMsIDUsIDFdXVxuICAgICAqICBAcmV0dXJuIFtbOTQuMTEsIDkxLjY2LCA4OS41OCwgOTIuMzBdLCBbNS44OCwgOC4zMywgMTAuNDEsIDcuN11dXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGVyY2VudFNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQZXJjZW50U2VyaWVzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMuc2VyaWVzUGVyY2VudCA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgIHZhciBzZXJpZXNQZXJjZW50ID0gW107XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyKSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSB3Lmdsb2JhbHMuc3RhY2tlZFNlcmllc1RvdGFsc1tqXTtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gMTAwICogc2VyW2pdIC8gdG90YWw7XG4gICAgICAgICAgICBzZXJpZXNQZXJjZW50LnB1c2gocGVyY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdG90YWwgPSB3Lmdsb2JhbHMuc2VyaWVzVG90YWxzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyB2YWw7XG4gICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICB2YXIgX3BlcmNlbnQgPSAxMDAgKiBzZXIgLyBfdG90YWw7XG5cbiAgICAgICAgICBzZXJpZXNQZXJjZW50LnB1c2goX3BlcmNlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc1BlcmNlbnQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsY3VsYXRlZFJhdGlvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkUmF0aW9zKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgeVJhdGlvID0gW107XG4gICAgICB2YXIgaW52ZXJ0ZWRZUmF0aW8gPSAwO1xuICAgICAgdmFyIHhSYXRpbyA9IDA7XG4gICAgICB2YXIgaW5pdGlhbFhSYXRpbyA9IDA7XG4gICAgICB2YXIgaW52ZXJ0ZWRYUmF0aW8gPSAwO1xuICAgICAgdmFyIHpSYXRpbyA9IDA7XG4gICAgICB2YXIgYmFzZUxpbmVZID0gW107XG4gICAgICB2YXIgYmFzZUxpbmVJbnZlcnRlZFkgPSAwLjE7XG4gICAgICB2YXIgYmFzZUxpbmVYID0gMDtcbiAgICAgIGdsLnlSYW5nZSA9IFtdO1xuXG4gICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2wubWluWUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdsLnlSYW5nZS5wdXNoKE1hdGguYWJzKGdsLm1pbllBcnJbaV0gLSBnbC5tYXhZQXJyW2ldKSk7XG4gICAgICAgICAgYmFzZUxpbmVZLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnlSYW5nZS5wdXNoKE1hdGguYWJzKGdsLm1pblkgLSBnbC5tYXhZKSk7XG4gICAgICB9XG5cbiAgICAgIGdsLnhSYW5nZSA9IE1hdGguYWJzKGdsLm1heFggLSBnbC5taW5YKTtcbiAgICAgIGdsLnpSYW5nZSA9IE1hdGguYWJzKGdsLm1heFogLSBnbC5taW5aKTsgLy8gbXVsdGlwbGUgeSBheGlzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBnbC55UmFuZ2UubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHlSYXRpby5wdXNoKGdsLnlSYW5nZVtfaV0gLyBnbC5ncmlkSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgeFJhdGlvID0gZ2wueFJhbmdlIC8gZ2wuZ3JpZFdpZHRoO1xuICAgICAgaW5pdGlhbFhSYXRpbyA9IE1hdGguYWJzKGdsLmluaXRpYWxtYXhYIC0gZ2wuaW5pdGlhbG1pblgpIC8gZ2wuZ3JpZFdpZHRoO1xuICAgICAgaW52ZXJ0ZWRZUmF0aW8gPSBnbC55UmFuZ2UgLyBnbC5ncmlkV2lkdGg7XG4gICAgICBpbnZlcnRlZFhSYXRpbyA9IGdsLnhSYW5nZSAvIGdsLmdyaWRIZWlnaHQ7XG4gICAgICB6UmF0aW8gPSBnbC56UmFuZ2UgLyBnbC5ncmlkSGVpZ2h0ICogMTY7XG5cbiAgICAgIGlmIChnbC5taW5ZICE9PSBOdW1iZXIuTUlOX1ZBTFVFICYmIE1hdGguYWJzKGdsLm1pblkpICE9PSAwKSB7XG4gICAgICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgcHJlc2VudCBpbiBzZXJpZXNcbiAgICAgICAgZ2wuaGFzTmVncyA9IHRydWU7XG4gICAgICAgIGJhc2VMaW5lWSA9IFtdOyAvLyBiYXNlbGluZSB2YXJpYWJsZXMgaXMgdGhlIDAgb2YgdGhlIHlheGlzIHdoaWNoIHdpbGwgYmUgbmVlZGVkIHdoZW4gdGhlcmUgYXJlIG5lZ2F0aXZlc1xuXG4gICAgICAgIGlmIChnbC5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB5UmF0aW8ubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgYmFzZUxpbmVZLnB1c2goLWdsLm1pbllBcnJbX2kyXSAvIHlSYXRpb1tfaTJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUxpbmVZLnB1c2goLWdsLm1pblkgLyB5UmF0aW9bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZUxpbmVJbnZlcnRlZFkgPSAtZ2wubWluWSAvIGludmVydGVkWVJhdGlvOyAvLyB0aGlzIGlzIGZvciBiYXIgY2hhcnRcblxuICAgICAgICBiYXNlTGluZVggPSBnbC5taW5YIC8geFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUxpbmVZLnB1c2goMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHlSYXRpbzogeVJhdGlvLFxuICAgICAgICBpbnZlcnRlZFlSYXRpbzogaW52ZXJ0ZWRZUmF0aW8sXG4gICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICB4UmF0aW86IHhSYXRpbyxcbiAgICAgICAgaW5pdGlhbFhSYXRpbzogaW5pdGlhbFhSYXRpbyxcbiAgICAgICAgaW52ZXJ0ZWRYUmF0aW86IGludmVydGVkWFJhdGlvLFxuICAgICAgICBiYXNlTGluZUludmVydGVkWTogYmFzZUxpbmVJbnZlcnRlZFksXG4gICAgICAgIGJhc2VMaW5lWTogYmFzZUxpbmVZLFxuICAgICAgICBiYXNlTGluZVg6IGJhc2VMaW5lWFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvZ1NlcmllcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnNlcmllc0xvZyA9IHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2ldICYmIHcuY29uZmlnLnlheGlzW2ldLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgcmV0dXJuIHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbG9nVmFsID0gKE1hdGgubG9nKGQpIC0gTWF0aC5sb2cody5nbG9iYWxzLm1pbllBcnJbaV0pKSAvIChNYXRoLmxvZyh3Lmdsb2JhbHMubWF4WUFycltpXSkgLSBNYXRoLmxvZyh3Lmdsb2JhbHMubWluWUFycltpXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ1ZhbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc0xvZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nWVJhdGlvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dZUmF0aW9zKHlSYXRpbykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIGdsLnlMb2dSYXRpbyA9IHlSYXRpby5zbGljZSgpO1xuICAgICAgZ2wubG9nWVJhbmdlID0gZ2wueVJhbmdlLm1hcChmdW5jdGlvbiAoeVJhbmdlLCBpKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tpXSAmJiBfdGhpcy53LmNvbmZpZy55YXhpc1tpXS5sb2dhcml0aG1pYykge1xuICAgICAgICAgIHZhciBtYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgIHZhciByYW5nZSA9IDE7XG4gICAgICAgICAgZ2wuc2VyaWVzTG9nLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3NpXSAmJiB3LmNvbmZpZy55YXhpc1tzaV0ubG9nYXJpdGhtaWMpIHtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgodiwgbWF4WSk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKHYsIG1pblkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByYW5nZSA9IE1hdGgucG93KGdsLnlSYW5nZVtpXSwgTWF0aC5hYnMobWluWSAtIG1heFkpIC8gZ2wueVJhbmdlW2ldKTtcbiAgICAgICAgICBnbC55TG9nUmF0aW9baV0gPSByYW5nZSAvIGdsLmdyaWRIZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnbC55TG9nUmF0aW87XG4gICAgfSAvLyBTb21lIGNvbmZpZyBvYmplY3RzIGNhbiBiZSBhcnJheSAtIGFuZCB3ZSBuZWVkIHRvIGV4dGVuZCB0aGVtIGNvcnJlY3RseVxuXG4gIH1dLCBbe1xuICAgIGtleTogXCJjaGVja0NvbWJvU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29tYm9TZXJpZXMoc2VyaWVzKSB7XG4gICAgICB2YXIgY29tYm9DaGFydHMgPSBmYWxzZTtcbiAgICAgIHZhciBjb21ib0NoYXJ0c0hhc0JhcnMgPSBmYWxzZTsgLy8gaWYgdXNlciBzcGVjaWZpZWQgYSB0eXBlIGluIHNlcmllcyB0b28sIHR1cm4gb24gY29tYm9DaGFydHMgZmxhZ1xuXG4gICAgICBpZiAoc2VyaWVzLmxlbmd0aCAmJiB0eXBlb2Ygc2VyaWVzWzBdLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbWJvQ2hhcnRzID0gdHJ1ZTtcbiAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBpZiAocy50eXBlID09PSAnYmFyJyB8fCBzLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBjb21ib0NoYXJ0c0hhc0JhcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbWJvQ2hhcnRzOiBjb21ib0NoYXJ0cyxcbiAgICAgICAgY29tYm9DaGFydHNIYXNCYXJzOiBjb21ib0NoYXJ0c0hhc0JhcnNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZEFycmF5UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQXJyYXlQcm9wcyhjb25maWdJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMueWF4aXMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ0luc3RhbmNlLmV4dGVuZFlBeGlzKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucy55YXhpcykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5ub3RhdGlvbnMueGF4aXMpIHtcbiAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb25zLnBvaW50cykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRQb2ludEFubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlVXRpbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDb25maWcgQ2xhc3MgZm9yIGV4dGVuZGluZyB1c2VyIG9wdGlvbnMgd2l0aCBwcmUtZGVmaW5lZCBBcGV4Q2hhcnRzIGNvbmZpZy5cbiAqXG4gKiBAbW9kdWxlIENvbmZpZ1xuICoqL1xuXG52YXIgQ29uZmlnID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZmlnKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlnKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29uZmlnLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyhvcHRzKTtcbiAgICAgIHRoaXMuY2hhcnRUeXBlID0gb3B0cy5jaGFydC50eXBlO1xuXG4gICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdoaXN0b2dyYW0nKSB7XG4gICAgICAgIC8vIHRlY2huaWNhbGx5LCBhIGhpc3RvZ3JhbSBjYW4gYmUgZHJhd24gYnkgYSBjb2x1bW4gY2hhcnQgd2l0aCBubyBzcGFjZXMgaW4gYmV0d2VlblxuICAgICAgICBvcHRzLmNoYXJ0LnR5cGUgPSAnYmFyJztcbiAgICAgICAgb3B0cyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICBjb2x1bW5XaWR0aDogJzk5Ljk5JSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBvcHRzLnNlcmllcyA9IHRoaXMuY2hlY2tFbXB0eVNlcmllcyhvcHRzLnNlcmllcyk7XG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpcyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZEFubm90YXRpb25zKG9wdHMpO1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdGlvbnMuaW5pdCgpO1xuICAgICAgdmFyIG5ld0RlZmF1bHRzID0ge307XG5cbiAgICAgIGlmIChvcHRzICYmIF90eXBlb2Yob3B0cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBjaGFydERlZmF1bHRzID0ge307XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJ0VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmxpbmUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYXJlYSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmJhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjYW5kbGVzdGljayc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuY2FuZGxlc3RpY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaGlzdG9ncmFtJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5iYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYnViYmxlJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5idWJibGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2NhdHRlcic6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuc2NhdHRlcigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoZWF0bWFwJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5oZWF0bWFwKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BpZSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMucGllKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2RvbnV0JzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5kb251dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyYWRhcic6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMucmFkYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkaWFsQmFyJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5yYWRpYWxCYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5saW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5icnVzaCAmJiBvcHRzLmNoYXJ0LmJydXNoLmVuYWJsZWQpIHtcbiAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYnJ1c2goY2hhcnREZWZhdWx0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5zdGFja2VkICYmIG9wdHMuY2hhcnQuc3RhY2tUeXBlID09PSAnMTAwJScpIHtcbiAgICAgICAgICBkZWZhdWx0cy5zdGFja2VkMTAwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnhheGlzID0gb3B0cy54YXhpcyB8fCB3aW5kb3cuQXBleC54YXhpcyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbWJvID0gQ29yZVV0aWxzLmNoZWNrQ29tYm9TZXJpZXMob3B0cy5zZXJpZXMpO1xuXG4gICAgICAgIGlmICgob3B0cy5jaGFydC50eXBlID09PSAnbGluZScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnYXJlYScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnc2NhdHRlcicpICYmICFjb21iby5jb21ib0NoYXJ0c0hhc0JhcnMgJiYgb3B0cy54YXhpcy50eXBlICE9PSAnZGF0ZXRpbWUnICYmIG9wdHMueGF4aXMudGlja1BsYWNlbWVudCAhPT0gJ2JldHdlZW4nKSB7XG4gICAgICAgICAgb3B0cyA9IERlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWMob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5zcGFya2xpbmUgJiYgb3B0cy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZCB8fCB3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC5zcGFya2xpbmUgJiYgd2luZG93LkFwZXguY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQpIHtcbiAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuc3BhcmtsaW5lKGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGVmYXVsdHMgPSBVdGlscy5leHRlbmQoY29uZmlnLCBjaGFydERlZmF1bHRzKTtcbiAgICAgIH0gLy8gY29uZmlnIHNob3VsZCBjYXNjYWRlIGluIHRoaXMgZmFzaGlvblxuICAgICAgLy8gZGVmYXVsdC1jb25maWcgPCBnbG9iYWwtYXBleC12YXJpYWJsZS1jb25maWcgPCB1c2VyLWRlZmluZWQtY29uZmlnXG4gICAgICAvLyBnZXQgR0xPQkFMTFkgZGVmaW5lZCBvcHRpb25zIGFuZCBtZXJnZSB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ1xuXG5cbiAgICAgIHZhciBtZXJnZWRXaXRoRGVmYXVsdENvbmZpZyA9IFV0aWxzLmV4dGVuZChuZXdEZWZhdWx0cywgd2luZG93LkFwZXgpOyAvLyBnZXQgdGhlIG1lcmdlZCBjb25maWcgYW5kIGV4dGVuZCB3aXRoIHVzZXIgZGVmaW5lZCBjb25maWdcblxuICAgICAgY29uZmlnID0gVXRpbHMuZXh0ZW5kKG1lcmdlZFdpdGhEZWZhdWx0Q29uZmlnLCBvcHRzKTsgLy8gc29tZSBmZWF0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC4gdGhvc2UgbWlzbWF0Y2hlcyBzaG91bGQgYmUgaGFuZGxlZFxuXG4gICAgICBjb25maWcgPSB0aGlzLmhhbmRsZVVzZXJJbnB1dEVycm9ycyhjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kWUF4aXMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdHMueWF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdHMueWF4aXMgPSB7fTtcbiAgICAgIH0gLy8gZXh0ZW5kIGdsb2JhbCB5YXhpcyBjb25maWcgKG9ubHkgaWYgb2JqZWN0IGlzIHByb3ZpZGVkIC8gbm90IGFuIGFycmF5KVxuXG5cbiAgICAgIGlmIChvcHRzLnlheGlzLmNvbnN0cnVjdG9yICE9PSBBcnJheSAmJiB3aW5kb3cuQXBleC55YXhpcyAmJiB3aW5kb3cuQXBleC55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZChvcHRzLnlheGlzLCB3aW5kb3cuQXBleC55YXhpcyk7XG4gICAgICB9IC8vIGFzIHdlIGNhbid0IGV4dGVuZCBuZXN0ZWQgb2JqZWN0J3MgYXJyYXkgd2l0aCBleHRlbmQsIHdlIG5lZWQgdG8gZG8gaXQgZmlyc3RcbiAgICAgIC8vIHVzZXIgY2FuIHByb3ZpZGUgZWl0aGVyIGFuIGFycmF5IG9yIG9iamVjdCBpbiB5YXhpcyBjb25maWdcblxuXG4gICAgICBpZiAob3B0cy55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgeWF4aXMgdG8gYXJyYXkgaWYgdXNlciBzdXBwbGllZCBvYmplY3RcbiAgICAgICAgb3B0cy55YXhpcyA9IFtVdGlscy5leHRlbmQob3B0aW9ucy55QXhpcywgb3B0cy55YXhpcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KG9wdHMueWF4aXMsIG9wdGlvbnMueUF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9IC8vIGFubm90YXRpb25zIGFsc28gYWNjZXB0cyBhcnJheSwgc28gd2UgbmVlZCB0byBleHRlbmQgdGhlbSBtYW51YWxseVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmFubm90YXRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRzLmFubm90YXRpb25zID0ge307XG4gICAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBbXTtcbiAgICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFtdO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpO1xuICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZFBvaW50QW5ub3RhdGlvbnMob3B0cyk7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBVdGlscy5leHRlbmRBcnJheSh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucy55YXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnlheGlzIDogW10sIG9wdGlvbnMueUF4aXNBbm5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRYQXhpc0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFhBeGlzQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnhheGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuYW5ub3RhdGlvbnMueGF4aXMgOiBbXSwgb3B0aW9ucy54QXhpc0Fubm90YXRpb24pO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZFBvaW50QW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kUG9pbnRBbm5vdGF0aW9ucyhvcHRzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnBvaW50cyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnBvaW50cyA6IFtdLCBvcHRpb25zLnBvaW50QW5ub3RhdGlvbik7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tFbXB0eVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VtcHR5U2VyaWVzKHNlcikge1xuICAgICAgaWYgKHNlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVVzZXJJbnB1dEVycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVc2VySW5wdXRFcnJvcnMob3B0cykge1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdHM7IC8vIGNvbmZsaWN0aW5nIHRvb2x0aXAgb3B0aW9uLiBpbnRlcnNlY3QgbWFrZXMgc3VyZSB0byBmb2N1cyBvbiAxIHBvaW50IGF0IGEgdGltZS4gU2hhcmVkIGNhbm5vdCBiZSB1c2VkIGFsb25nIHdpdGggaXRcblxuICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCAmJiBjb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sdGlwLnNoYXJlZCBjYW5ub3QgYmUgZW5hYmxlZCB3aGVuIHRvb2x0aXAuaW50ZXJzZWN0IGlzIHRydWUuIFR1cm4gb2ZmIGFueSBvdGhlciBvcHRpb24gYnkgc2V0dGluZyBpdCB0byBmYWxzZS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5jaGFydC5zY3JvbGxlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjIuMC4wLiBQbGVhc2UgcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uIGZvciBjaGFydC5zY3JvbGxlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBObyB0aW1lIHNlcmllcyBmb3IgaG9yaXpvbnRhbCBiYXJzXG4gICAgICAgIGlmIChjb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZWxpbmVzIG9uIGJhcnMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LiBTd2l0Y2ggdG8gY29sdW1uIGNoYXJ0IGJ5IHNldHRpbmcgcGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw9ZmFsc2UnKTtcbiAgICAgICAgfSAvLyBObyBtdWx0aXBsZSB5YXhpcyBmb3IgYmFyc1xuXG5cbiAgICAgICAgaWYgKGNvbmZpZy55YXhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBZIEF4aXMgZm9yIGJhcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFN3aXRjaCB0byBjb2x1bW4gY2hhcnQgYnkgc2V0dGluZyBwbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbD1mYWxzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS5vcHBvc2l0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcueGF4aXMudG9vbHRpcC5lbmFibGVkID0gZmFsc2U7IC8vIG5vIHhheGlzIHRvb2x0aXAgZm9yIGhvcml6b250YWwgYmFyXG5cbiAgICAgICAgY29uZmlnLnlheGlzWzBdLnRvb2x0aXAuZW5hYmxlZCA9IGZhbHNlOyAvLyBubyB4YXhpcyB0b29sdGlwIGZvciBob3Jpem9udGFsIGJhclxuXG4gICAgICAgIGNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8gem9vbWluZyBmb3IgaG9yeiBiYXJzXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIGlmIChjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJyAmJiBjb25maWcuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY3Jvc3NoYWlycy53aWR0aCA9IFwiYmFyV2lkdGhcIiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzaW5nbGUgc2VyaWVzLCBub3QgaW4gYSBtdWx0aS1zZXJpZXMgYmFyQ2hhcnQuJyk7XG4gICAgICAgICAgICBjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9ICd0aWNrV2lkdGgnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zdGF0ZXMuaG92ZXIudHlwZSA9ICdub25lJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmb2xsb3dDdXJzb3Igb3B0aW9uIGluIHNoYXJlZCBjb2x1bW5zIGNhbm5vdCBiZSB0dXJuZWQgb2ZmLicpO1xuICAgICAgICAgICAgY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgIGlmIChjb25maWcueWF4aXNbMF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1JldmVyc2VkIHktYXhpcyBpbiBjYW5kbGVzdGljayBjaGFydCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQuZ3JvdXAgJiYgY29uZmlnLnlheGlzWzBdLmxhYmVscy5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0l0IGxvb2tzIGxpa2UgeW91IGhhdmUgbXVsdGlwbGUgY2hhcnRzIGluIHN5bmNocm9uaXphdGlvbi4gWW91IG11c3QgcHJvdmlkZSB5YXhpcy5sYWJlbHMubWluV2lkdGggd2hpY2ggbXVzdCBiZSBFUVVBTCBmb3IgYWxsIGdyb3VwZWQgY2hhcnRzIHRvIHByZXZlbnQgaW5jb3JyZWN0IGJlaGF2aW91ci4nKTtcbiAgICAgIH0gLy8gaWYgdXNlciBzdXBwbGllZCBhcnJheSBmb3Igc3Ryb2tlIHdpZHRoLCBpdCB3aWxsIG9ubHkgYmUgYXBwbGljYWJsZSB0byBsaW5lL2FyZWEgY2hhcnRzLCBmb3IgYW55IG90aGVyIGNoYXJ0cywgcmV2ZXJ0IGJhY2sgdG8gTnVtYmVyXG5cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnN0cm9rZS53aWR0aCkpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5jaGFydC50eXBlICE9PSAnbGluZScgJiYgY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc3Ryb2tlLndpZHRoIG9wdGlvbiBhY2NlcHRzIGFycmF5IG9ubHkgZm9yIGxpbmUgYW5kIGFyZWEgY2hhcnRzLiBSZXZlcnRlZCBiYWNrIHRvIE51bWJlcicpO1xuICAgICAgICAgIGNvbmZpZy5zdHJva2Uud2lkdGggPSBjb25maWcuc3Ryb2tlLndpZHRoWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmZpZztcbn0oKTtcblxudmFyIEdsb2JhbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHbG9iYWxzLCBbe1xuICAgIGtleTogXCJnbG9iYWxWYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdsb2JhbFZhcnMoY29uZmlnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydElEOiBudWxsLFxuICAgICAgICAvLyBjaGFydCBJRCAtIGFwZXhjaGFydHMtY3VpZFxuICAgICAgICBjdWlkOiBudWxsLFxuICAgICAgICAvLyBjaGFydCBJRCAtIHJhbmRvbSBudW1iZXJzIGV4Y2x1ZGluZyBcImFwZXhjaGFydHNcIiBwYXJ0XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGJlZm9yZU1vdW50OiBbXSxcbiAgICAgICAgICBtb3VudGVkOiBbXSxcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBjbGlja2VkOiBbXSxcbiAgICAgICAgICBzZWxlY3Rpb246IFtdLFxuICAgICAgICAgIGRhdGFQb2ludFNlbGVjdGlvbjogW10sXG4gICAgICAgICAgem9vbWVkOiBbXSxcbiAgICAgICAgICBzY3JvbGxlZDogW11cbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgY29sb3JzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhZGFyUG9seWdvbnM6IHtcbiAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFtdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICBzaXplOiBjb25maWcubWFya2Vycy5zaXplLFxuICAgICAgICAgIGxhcmdlc3RTaXplOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbkVuZGVkOiBmYWxzZSxcbiAgICAgICAgaXNUb3VjaERldmljZTogJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLFxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgLy8gY2hhcnQgaGFzIGJlZW4gdXBkYXRlZCBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gZGF0YUNoYW5nZWQgcHJvcGVydHkuIGlzRGlydHkgbWVhbnMgdXNlciBtYW51YWxseSBjYWxsZWQgc29tZSBtZXRob2QgdG8gdXBkYXRlXG4gICAgICAgIGluaXRpYWxDb25maWc6IG51bGwsXG4gICAgICAgIC8vIHdlIHdpbGwgc3RvcmUgdGhlIGZpcnN0IGNvbmZpZyB1c2VyIGhhcyBzZXQgdG8gZ28gYmFjayB3aGVuIHVzZXIgZmluaXNoZXMgaW50ZXJhY3Rpb25zIGxpa2Ugem9vbWluZyBhbmQgY29tZSBvdXQgb2YgaXRcbiAgICAgICAgbGFzdFhBeGlzOiBbXSxcbiAgICAgICAgbGFzdFlBeGlzOiBbXSxcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgLy8gdGhlIE1BSU4gc2VyaWVzIGFycmF5ICh5IHZhbHVlcylcbiAgICAgICAgc2VyaWVzUGVyY2VudDogW10sXG4gICAgICAgIC8vIHRoZSBwZXJjZW50YWdlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc2VyaWVzXG4gICAgICAgIHNlcmllc1RvdGFsczogW10sXG4gICAgICAgIHN0YWNrZWRTZXJpZXNUb3RhbHM6IFtdLFxuICAgICAgICBzZXJpZXNYOiBbXSxcbiAgICAgICAgLy8gc3RvcmUgdGhlIG51bWVyaWMgeCB2YWx1ZXMgaW4gdGhpcyBhcnJheSAoeCB2YWx1ZXMpXG4gICAgICAgIHNlcmllc1o6IFtdLFxuICAgICAgICAvLyBUaGUgM3JkIFwiWlwiIGRpbWVuc2lvbiBmb3IgYnViYmxlcyBjaGFydCAoeiB2YWx1ZXMpXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSB0ZXh0IHRvIGRyYXcgb24geCBheGlzXG4gICAgICAgIC8vIERvbid0IG11dGF0ZSB0aGUgbGFiZWxzLCBtYW55IHRoaW5ncyBpbmNsdWRpbmcgdG9vbHRpcHMgZGVwZW5kcyBvbiBpdCFcbiAgICAgICAgdGltZWxpbmVMYWJlbHM6IFtdLFxuICAgICAgICAvLyBzdG9yZSB0aGUgdGltZWxpbmUgTGFiZWxzIGluIGFub3RoZXIgdmFyaWFibGVcbiAgICAgICAgc2VyaWVzTmFtZXM6IFtdLFxuICAgICAgICAvLyBzYW1lIGFzIGxhYmVscywgdXNlZCBpbiBub24gYXhpcyBjaGFydHNcbiAgICAgICAgbm9MYWJlbHNQcm92aWRlZDogZmFsc2UsXG4gICAgICAgIC8vIGlmIHVzZXIgZGlkbid0IHByb3ZpZGUgYW55IGNhdGVnb3JpZXMvbGFiZWxzIG9yIHggdmFsdWVzLCBmYWxsYmFjayB0byAxLDIsMyw0Li4uXG4gICAgICAgIGFsbFNlcmllc0NvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgIGNvbGxhcHNlZFNlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciBjb2xsYXBzZXMgYSBzZXJpZXMsIGl0IGdvZXMgaW50byB0aGlzIGFycmF5XG4gICAgICAgIGNvbGxhcHNlZFNlcmllc0luZGljZXM6IFtdLFxuICAgICAgICAvLyB0aGlzIHN0b3JlcyB0aGUgaW5kZXggb2YgdGhlIGNvbGxhcHNlZFNlcmllcyBpbnN0ZWFkIG9mIHdob2xlIG9iamVjdCBmb3IgcXVpY2sgYWNjZXNzXG4gICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciBjb2xsYXBzZXMgYW4gXCJhbHdheXNWaXNpYmxlXCIgc2VyaWVzLCBpdCBnb2VzIGludG8gdGhpcyBhcnJheVxuICAgICAgICBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzOiBbXSxcbiAgICAgICAgLy8gdGhpcyBzdG9yZXMgdGhlIGluZGV4IG9mIHRoZSBjb2xsYXBzZWRTZXJpZXMgd2hvc2UgeS1heGlzIGlzIGFsd2F5cyB2aXNpYmxlXG4gICAgICAgIHJpc2luZ1NlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciByZS1vcGVucyBhIGNvbGxhcHNlZCBzZXJpZXMsIGl0IGdvZXMgaGVyZVxuICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IFtdLFxuICAgICAgICBpZ25vcmVZQXhpc0luZGV4ZXM6IFtdLFxuICAgICAgICAvLyB3aGVuIHNlcmllcyBhcmUgYmVpbmcgY29sbGFwc2VkIGluIG11bHRpcGxlIHkgYXhlcywgaWdub3JlIGNlcnRhaW4gaW5kZXhcbiAgICAgICAgcGFkSG9yaXpvbnRhbDogMCxcbiAgICAgICAgbWF4VmFsc0luQXJyYXlJbmRleDogMCxcbiAgICAgICAgem9vbUVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3pvb20nICYmIGNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzLnpvb20gJiYgY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCxcbiAgICAgICAgcGFuRW5hYmxlZDogY29uZmlnLmNoYXJ0LnRvb2xiYXIuYXV0b1NlbGVjdGVkID09PSAncGFuJyAmJiBjb25maWcuY2hhcnQudG9vbGJhci50b29scy5wYW4sXG4gICAgICAgIHNlbGVjdGlvbkVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3NlbGVjdGlvbicgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMuc2VsZWN0aW9uLFxuICAgICAgICB5YXhpczogbnVsbCxcbiAgICAgICAgbWluWTogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgLy8gIGlzIDVlLTMyNCwgaS5lLiB0aGUgc21hbGxlc3QgcG9zaXRpdmUgbnVtYmVyXG4gICAgICAgIC8vIE5PVEU6IElmIHRoZXJlIGFyZSBtdWx0aXBsZSB5IGF4aXMsIHRoZSBmaXJzdCB5YXhpcyBhcnJheSBlbGVtZW50IHdpbGwgYmUgY29uc2lkZXJlZCBmb3IgYWxsIHkgdmFsdWVzIGNhbGN1bGF0aW9ucy4gUmVzdCBhbGwgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoYXRcbiAgICAgICAgbWF4WTogLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIC8vIGlzIC0xLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAgICAvLyBOT1RFOiBUaGUgYWJvdmUgbm90ZSBmb3IgbWluWSBhcHBsaWVzIGhlcmUgYXMgd2VsbFxuICAgICAgICBtaW5ZQXJyOiBbXSxcbiAgICAgICAgbWF4WUFycjogW10sXG4gICAgICAgIG1heFg6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAvLyBpcyAtMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgICAgaW5pdGlhbG1heFg6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBtaW5YOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAvLyAgaXMgNWUtMzI0LCBpLmUuIHRoZSBzbWFsbGVzdCBwb3NpdGl2ZSBudW1iZXJcbiAgICAgICAgaW5pdGlhbG1pblg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIG1pblo6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIC8vIE1heCBaIHZhbHVlIGluIGNoYXJ0cyB3aXRoIFogYXhpc1xuICAgICAgICBtYXhaOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgLy8gTWF4IFogdmFsdWUgaW4gY2hhcnRzIHdpdGggWiBheGlzXG4gICAgICAgIG1vdXNlZG93bjogZmFsc2UsXG4gICAgICAgIGxhc3RDbGllbnRQb3NpdGlvbjoge30sXG4gICAgICAgIC8vIGRvbid0IHJlc2V0IHRoaXMgdmFyaWFibGUgdGhpcyB0aGUgY2hhcnQgaXMgZGVzdHJveWVkLiBJdCBpcyB1c2VkIHRvIGRldGVjdCByaWdodCBvciBsZWZ0IG1vdXNlbW92ZSBpbiBwYW5uaW5nXG4gICAgICAgIHZpc2libGVYUmFuZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgeVJhbmdlOiBbXSxcbiAgICAgICAgLy8gdGhpcyBwcm9wZXJ0eSBpcyB0aGUgYWJzb2x1dGUgc3VtIG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgW2VnICgtMTAwICsgMjAwID0gMzAwKV0gLSB5QXhpc1xuICAgICAgICB6UmFuZ2U6IDAsXG4gICAgICAgIC8vIHpBeGlzIFJhbmdlIChmb3IgYnViYmxlIGNoYXJ0cylcbiAgICAgICAgeFJhbmdlOiAwLFxuICAgICAgICAvLyB4QXhpcyByYW5nZVxuICAgICAgICB5VmFsdWVEZWNpbWFsOiAwLFxuICAgICAgICAvLyBhcmUgdGhlcmUgZmxvYXRpbmcgbnVtYmVycyBpbiB0aGUgc2VyaWVzLiBJZiB5ZXMsIHRoaXMgcmVwcmVzZW50IHRoZSBsZW4gb2YgdGhlIGRlY2ltYWxzXG4gICAgICAgIHRvdGFsOiAwLFxuICAgICAgICBTVkdOUzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgLy8gc3ZnIG5hbWVzcGFjZVxuICAgICAgICBzdmdXaWR0aDogMCxcbiAgICAgICAgLy8gdGhlIHdob2xlIHN2ZyB3aWR0aFxuICAgICAgICBzdmdIZWlnaHQ6IDAsXG4gICAgICAgIC8vIHRoZSB3aG9sZSBzdmcgaGVpZ2h0XG4gICAgICAgIG5vRGF0YTogZmFsc2UsXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgaXMgYW55IGRhdGEgdG8gZGlzcGxheSBvciBub3RcbiAgICAgICAgbG9jYWxlOiB7fSxcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgbG9jYWxlIHZhbHVlcyB3aWxsIGJlIHByZXNlcnZlZCBoZXJlIGZvciBnbG9iYWwgYWNjZXNzXG4gICAgICAgIGRvbToge30sXG4gICAgICAgIC8vIGZvciBzdG9yaW5nIGFsbCBkb20gbm9kZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5XG4gICAgICAgIC8vIGVsV3JhcDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgdGhhdCB3cmFwcyBldmVyeXRoaW5nXG4gICAgICAgIC8vIGVsR3JhcGhpY2FsOiBudWxsLCAvLyB0aGlzIGNvbnRhaW5zIGxpbmVzL2FyZWFzL2JhcnMvcGllc1xuICAgICAgICAvLyBlbEdyaWRSZWN0OiBudWxsLCAvLyBwYXRocyBnb2luZyBvdXRzaWRlIHRoaXMgYXJlYSB3aWxsIGJlIGNsaXBwZWRcbiAgICAgICAgLy8gZWxHcmlkUmVjdE1hc2s6IG51bGwsIC8vIGNsaXBwaW5nIHdpbGwgaGFwcGVuIHdpdGggdGhpcyBtYXNrXG4gICAgICAgIC8vIGVsR3JpZFJlY3RNYXJrZXJNYXNrOiBudWxsLCAvLyBjbGlwcGluZyB3aWxsIGhhcHBlbiB3aXRoIHRoaXMgbWFza1xuICAgICAgICAvLyBlbExlZ2VuZFdyYXA6IG51bGwsIC8vIHRoZSB3aG9sZSBsZWdlbmQgYXJlYVxuICAgICAgICAvLyBlbERlZnM6IG51bGwsIC8vIFtkZWZzXSBlbGVtZW50XG4gICAgICAgIG1lbW9yeToge1xuICAgICAgICAgIG1ldGhvZHNUb0V4ZWM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEFuaW1hdGU6IHRydWUsXG4gICAgICAgIGRlbGF5ZWRFbGVtZW50czogW10sXG4gICAgICAgIC8vIGVsZW1lbnQgd2hpY2ggYXBwZWFyIGFmdGVyIGFuaW1hdGlvbiBoYXMgZmluaXNoZWRcbiAgICAgICAgYXhpc0NoYXJ0czogdHJ1ZSxcbiAgICAgICAgLy8gY2hhcnQgdHlwZSA9IGxpbmUgb3IgYXJlYSBvciBiYXJcbiAgICAgICAgLy8gKHJlZmVyIHRoZW0gYWxzbyBhcyBwbG90IGNoYXJ0cyBpbiB0aGUgY29kZSlcbiAgICAgICAgaXNYTnVtZXJpYzogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IGRhdGEgd2FzIHByb3ZpZGVkIGluIGEge1t4LHldLCBbeCx5XX0gcGF0dGVyblxuICAgICAgICBpc0RhdGFYWVo6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiBkYXRhIHdhcyBwcm92aWRlZCBpbiBhIHtbeCx5LHpdfSBwYXR0ZXJuXG4gICAgICAgIHJlc2l6ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiB1c2VyIGhhcyByZXNpemVkXG4gICAgICAgIHJlc2l6ZVRpbWVyOiBudWxsLFxuICAgICAgICAvLyB0aW1lb3V0IGZ1bmN0aW9uIHRvIG1ha2UgYSBzbWFsbCBkZWxheSBiZWZvcmVcbiAgICAgICAgLy8gZHJhd2luZyB3aGVuIHVzZXIgcmVzaXplZFxuICAgICAgICBjb21ib0NoYXJ0czogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHdoZXRoZXIgaXQncyBhIGNvbWJpbmF0aW9uIG9mIGxpbmUvY29sdW1uXG4gICAgICAgIGNvbWJvQ2hhcnRzSGFzQmFyczogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHdoZXRoZXIgaXQncyBhIGNvbWJpbmF0aW9uIG9mIGxpbmUvY29sdW1uXG4gICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgLy8gYm9vbDogaGFzIGRhdGEgY2hhbmdlZCBkeW5hbWljYWxseVxuICAgICAgICBwcmV2aW91c1BhdGhzOiBbXSxcbiAgICAgICAgLy8gYXJyYXk6IHdoZW4gZGF0YSBpcyBjaGFuZ2VkLCBpdCB3aWxsIGFuaW1hdGUgZnJvbVxuICAgICAgICAvLyBwcmV2aW91cyBwYXRoc1xuICAgICAgICBzZXJpZXNYdmFsdWVzOiBbXSxcbiAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRoaXMgaW4gdG9vbHRpcCAoaXQncyB4IHBvc2l0aW9uKVxuICAgICAgICAvLyB3aGVuIHdlIHdpbGwgaGF2ZSB1bmVxdWFsIHggdmFsdWVzLCB3ZSB3aWxsIG5lZWRcbiAgICAgICAgLy8gc29tZSB3YXkgdG8gZ2V0IHggdmFsdWUgZGVwZW5kaW5nIG9uIG1vdXNlIHBvaW50ZXJcbiAgICAgICAgc2VyaWVzWXZhbHVlczogW10sXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0aGlzIHdoZW4gZGVjaWRpbmcgd2hpY2ggc2VyaWVzXG4gICAgICAgIC8vIHVzZXIgaG92ZXJlZCBvblxuICAgICAgICBzZXJpZXNDYW5kbGVPOiBbXSxcbiAgICAgICAgLy8gY2FuZGxlIHN0aWNrIG9wZW4gdmFsdWVzXG4gICAgICAgIHNlcmllc0NhbmRsZUg6IFtdLFxuICAgICAgICAvLyBjYW5kbGUgc3RpY2sgaGlnaCB2YWx1ZXNcbiAgICAgICAgc2VyaWVzQ2FuZGxlTDogW10sXG4gICAgICAgIC8vIGNhbmRsZSBzdGljayBsb3cgdmFsdWVzXG4gICAgICAgIHNlcmllc0NhbmRsZUM6IFtdLFxuICAgICAgICAvLyBjYW5kbGUgc3RpY2sgY2xvc2UgdmFsdWVzXG4gICAgICAgIGFsbFNlcmllc0hhc0VxdWFsWDogdHJ1ZSxcbiAgICAgICAgZGF0YVBvaW50czogMCxcbiAgICAgICAgLy8gdGhlIGxvbmdlc3Qgc2VyaWVzIGxlbmd0aFxuICAgICAgICBwb2ludHNBcnJheTogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwb2ludHMgcG9zaXRpb25zIGhlcmUgdG8gZHJhdyBsYXRlciBvbiBob3ZlclxuICAgICAgICAvLyBmb3JtYXQgaXMgLSBbW3gseV0sW3gseV0uLi4gW3gseV1dXG4gICAgICAgIGRhdGFMYWJlbHNSZWN0czogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwb3NpdGlvbnMgb2YgZGF0YWxhYmVscyB0byBwcmV2ZW50IGNvbGxpc2lvblxuICAgICAgICBsYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlczogW10sXG4gICAgICAgIGhhc051bGxWYWx1ZXM6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiB3aGV0aGVyIHNlcmllcyBjb250YWlucyBudWxsIHZhbHVlc1xuICAgICAgICBlYXNpbmc6IG51bGwsXG4gICAgICAgIC8vIGZ1bmN0aW9uOiBhbmltYXRpb24gZWZmZWN0IHRvIGFwcGx5XG4gICAgICAgIHpvb21lZDogZmFsc2UsXG4gICAgICAgIC8vIHdoZXRoZXIgdXNlciBoYXMgem9vbWVkIG9yIG5vdFxuICAgICAgICBncmlkV2lkdGg6IDAsXG4gICAgICAgIC8vIGRyYXdhYmxlIHdpZHRoIG9mIGFjdHVhbCBncmFwaHMgKHNlcmllcyBwYXRocylcbiAgICAgICAgZ3JpZEhlaWdodDogMCxcbiAgICAgICAgLy8gZHJhd2FibGUgaGVpZ2h0IG9mIGFjdHVhbCBncmFwaHMgKHNlcmllcyBwYXRocylcbiAgICAgICAgeUF4aXNTY2FsZTogW10sXG4gICAgICAgIHhBeGlzU2NhbGU6IG51bGwsXG4gICAgICAgIHhBeGlzVGlja3NQb3NpdGlvbnM6IFtdLFxuICAgICAgICB0aW1lc2NhbGVUaWNrczogW10sXG4gICAgICAgIHJvdGF0ZVhMYWJlbHM6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgeExhYmVsRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIGxhYmVsc1xuICAgICAgICB5TGFiZWxGb3JtYXR0ZXJzOiBbXSxcbiAgICAgICAgeGF4aXNUb29sdGlwRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIHRvb2x0aXBcbiAgICAgICAgdHRLZXlGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgdHRWYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgdHRaRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIExJTkVfSEVJR0hUX1JBVElPOiAxLjYxOCxcbiAgICAgICAgeEF4aXNMYWJlbHNIZWlnaHQ6IDAsXG4gICAgICAgIHlBeGlzTGFiZWxzV2lkdGg6IDAsXG4gICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgc2NhbGVZOiAxLFxuICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICB0cmFuc2xhdGVZQXhpc1g6IFtdLFxuICAgICAgICB5TGFiZWxzQ29vcmRzOiBbXSxcbiAgICAgICAgeVRpdGxlQ29vcmRzOiBbXSxcbiAgICAgICAgeUF4aXNXaWR0aHM6IFtdLFxuICAgICAgICB0cmFuc2xhdGVYQXhpc1k6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVhBeGlzWDogMCxcbiAgICAgICAgdG9vbHRpcDogbnVsbCxcbiAgICAgICAgdG9vbHRpcE9wdHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcbiAgICAgIHZhciBnbG9iYWxzID0gdGhpcy5nbG9iYWxWYXJzKGNvbmZpZyk7XG4gICAgICBnbG9iYWxzLmluaXRpYWxDb25maWcgPSBVdGlscy5leHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICBnbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdsb2JhbHMuaW5pdGlhbENvbmZpZy5zZXJpZXMpKTtcbiAgICAgIGdsb2JhbHMubGFzdFhBeGlzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnbG9iYWxzLmluaXRpYWxDb25maWcueGF4aXMpKTtcbiAgICAgIGdsb2JhbHMubGFzdFlBeGlzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnbG9iYWxzLmluaXRpYWxDb25maWcueWF4aXMpKTtcbiAgICAgIHJldHVybiBnbG9iYWxzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHbG9iYWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQmFzZSBDbGFzcyBmb3IgZXh0ZW5kaW5nIHVzZXIgb3B0aW9ucyB3aXRoIHByZS1kZWZpbmVkIEFwZXhDaGFydHMgY29uZmlnLlxuICpcbiAqIEBtb2R1bGUgQmFzZVxuICoqL1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2Uob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBDb25maWcodGhpcy5vcHRzKS5pbml0KCk7XG4gICAgICB2YXIgZ2xvYmFscyA9IG5ldyBHbG9iYWxzKCkuaW5pdChjb25maWcpO1xuICAgICAgdmFyIHcgPSB7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBnbG9iYWxzOiBnbG9iYWxzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBGaWxsIENsYXNzIGZvciBzZXR0aW5nIGZpbGwgb3B0aW9ucyBvZiB0aGUgcGF0aHMuXG4gKlxuICogQG1vZHVsZSBGaWxsXG4gKiovXG5cbnZhciBGaWxsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsbChjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsbCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm9wdHMgPSBudWxsO1xuICAgIHRoaXMuc2VyaWVzSW5kZXggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGwsIFt7XG4gICAga2V5OiBcImNsaXBwZWRJbWdBcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaXBwZWRJbWdBcmVhKHBhcmFtcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICB2YXIgc3ZnVyA9IHBhcnNlSW50KHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuICAgICAgdmFyIHN2Z0ggPSBwYXJzZUludCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICB2YXIgc2l6ZSA9IHN2Z1cgPiBzdmdIID8gc3ZnVyA6IHN2Z0g7XG4gICAgICB2YXIgZmlsbEltZyA9IHBhcmFtcy5pbWFnZTtcbiAgICAgIHZhciBpbWdXaWR0aCA9IDA7XG4gICAgICB2YXIgaW1nSGVpZ2h0ID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMud2lkdGggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMuaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoY25mLmZpbGwuaW1hZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjbmYuZmlsbC5pbWFnZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGltZ1dpZHRoID0gY25mLmZpbGwuaW1hZ2Uud2lkdGggKyAxO1xuICAgICAgICAgIGltZ0hlaWdodCA9IGNuZi5maWxsLmltYWdlLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWdXaWR0aCA9IHNpemUgKyAxO1xuICAgICAgICAgIGltZ0hlaWdodCA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZ1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBpbWdIZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxQYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3BhdHRlcm4nKTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsUGF0dGVybiwge1xuICAgICAgICBpZDogcGFyYW1zLnBhdHRlcm5JRCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiBwYXJhbXMucGF0dGVyblVuaXRzID8gcGFyYW1zLnBhdHRlcm5Vbml0cyA6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgIHdpZHRoOiBpbWdXaWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaW1nSGVpZ2h0ICsgJ3B4J1xuICAgICAgfSk7XG4gICAgICB2YXIgZWxJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICdpbWFnZScpO1xuICAgICAgZWxQYXR0ZXJuLmFwcGVuZENoaWxkKGVsSW1hZ2UpO1xuICAgICAgZWxJbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgZmlsbEltZyk7XG4gICAgICBHcmFwaGljcy5zZXRBdHRycyhlbEltYWdlLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdub25lJyxcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBpbWdIZWlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIGVsSW1hZ2Uuc3R5bGUub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5O1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbERlZnMubm9kZS5hcHBlbmRDaGlsZChlbFBhdHRlcm4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNJbmRleChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IG9wdHMuc2VyaWVzTnVtYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IG9wdHMuc2VyaWVzTnVtYmVyICUgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNlcmllc0luZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWxsUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUGF0aChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBwYXRoRmlsbDtcbiAgICAgIHZhciBwYXR0ZXJuRmlsbCwgZ3JhZGllbnRGaWxsO1xuICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuZ2V0U2VyaWVzSW5kZXgob3B0cyk7XG4gICAgICB2YXIgZmlsbENvbG9ycyA9IHRoaXMuZ2V0RmlsbENvbG9ycygpO1xuICAgICAgdmFyIGZpbGxDb2xvciA9IGZpbGxDb2xvcnNbdGhpcy5zZXJpZXNJbmRleF07XG4gICAgICB2YXIgZmlsbFR5cGUgPSB0aGlzLmdldEZpbGxUeXBlKHRoaXMuc2VyaWVzSW5kZXgpO1xuICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gQXJyYXkuaXNBcnJheShjbmYuZmlsbC5vcGFjaXR5KSA/IGNuZi5maWxsLm9wYWNpdHlbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuZmlsbC5vcGFjaXR5O1xuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgICAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICAgICAgZmlsbENvbG9yID0gb3B0cy5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxDb2xvci5pbmRleE9mKCdyZ2InKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdENvbG9yID0gVXRpbHMuaGV4VG9SZ2JhKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbGxDb2xvci5pbmRleE9mKCdyZ2JhJykgPiAtMSkge1xuICAgICAgICAgIGZpbGxPcGFjaXR5ID0gMCArICcuJyArIFV0aWxzLmdldE9wYWNpdHlGcm9tUkdCQShmaWxsQ29sb3JzW3RoaXMuc2VyaWVzSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbFR5cGUgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICBwYXR0ZXJuRmlsbCA9IHRoaXMuaGFuZGxlUGF0dGVybkZpbGwocGF0dGVybkZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIGRlZmF1bHRDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsVHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICBncmFkaWVudEZpbGwgPSB0aGlzLmhhbmRsZUdyYWRpZW50RmlsbChncmFkaWVudEZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIHRoaXMuc2VyaWVzSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY25mLmZpbGwuaW1hZ2Uuc3JjLmxlbmd0aCA+IDAgJiYgZmlsbFR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgaWYgKG9wdHMuc2VyaWVzTnVtYmVyIDwgY25mLmZpbGwuaW1hZ2Uuc3JjLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2xpcHBlZEltZ0FyZWEoe1xuICAgICAgICAgICAgb3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgICAgICAgICBpbWFnZTogY25mLmZpbGwuaW1hZ2Uuc3JjW29wdHMuc2VyaWVzTnVtYmVyXSxcbiAgICAgICAgICAgIHBhdHRlcm5Vbml0czogb3B0cy5wYXR0ZXJuVW5pdHMsXG4gICAgICAgICAgICBwYXR0ZXJuSUQ6IFwicGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KG9wdHMuc2VyaWVzTnVtYmVyICsgMSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoRmlsbCA9IFwidXJsKCNwYXR0ZXJuXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkKS5jb25jYXQob3B0cy5zZXJpZXNOdW1iZXIgKyAxLCBcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgcGF0aEZpbGwgPSBncmFkaWVudEZpbGw7XG4gICAgICB9IGVsc2UgaWYgKGZpbGxUeXBlID09PSAncGF0dGVybicpIHtcbiAgICAgICAgcGF0aEZpbGwgPSBwYXR0ZXJuRmlsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhGaWxsID0gZGVmYXVsdENvbG9yO1xuICAgICAgfSAvLyBvdmVycmlkZSBwYXR0ZXJuL2dyYWRpZW50IGlmIG9wdHMuc29saWQgaXMgdHJ1ZVxuXG5cbiAgICAgIGlmIChvcHRzLnNvbGlkKSB7XG4gICAgICAgIHBhdGhGaWxsID0gZGVmYXVsdENvbG9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aEZpbGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGxUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGxUeXBlKHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuZmlsbC50eXBlKSkge1xuICAgICAgICByZXR1cm4gdy5jb25maWcuZmlsbC50eXBlW3Nlcmllc0luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3LmNvbmZpZy5maWxsLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGxDb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbENvbG9ycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICB2YXIgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbdGhpcy5zZXJpZXNJbmRleF0udHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbENvbG9ycy5wdXNoKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5maWxsLmNvbG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzID0gdy5nbG9iYWxzLmZpbGwuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLmZpbGwuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjbmYuY2hhcnQudHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbENvbG9ycy5wdXNoKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5maWxsLmNvbG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzID0gdy5nbG9iYWxzLmZpbGwuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLmZpbGwuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29sb3JzIHBhc3NlZCBpbiBhcmd1bWVudHNcblxuXG4gICAgICBpZiAodHlwZW9mIG9wdHMuZmlsbENvbG9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChvcHRzLmZpbGxDb2xvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGZpbGxDb2xvcnMgPSBvcHRzLmZpbGxDb2xvcnMuc2xpY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gob3B0cy5maWxsQ29sb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsbENvbG9ycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUGF0dGVybkZpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUGF0dGVybkZpbGwocGF0dGVybkZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIGRlZmF1bHRDb2xvcikge1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcGF0dGVyblN0cm9rZVdpZHRoID0gY25mLmZpbGwucGF0dGVybi5zdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gQXJyYXkuaXNBcnJheShjbmYuc3Ryb2tlLndpZHRoKSA/IGNuZi5zdHJva2Uud2lkdGhbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuc3Ryb2tlLndpZHRoIDogQXJyYXkuaXNBcnJheShjbmYuZmlsbC5wYXR0ZXJuLnN0cm9rZVdpZHRoKSA/IGNuZi5maWxsLnBhdHRlcm4uc3Ryb2tlV2lkdGhbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuZmlsbC5wYXR0ZXJuLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIHBhdHRlcm5MaW5lQ29sb3IgPSBmaWxsQ29sb3I7XG5cbiAgICAgIGlmIChjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlW29wdHMuc2VyaWVzTnVtYmVyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgcGYgPSBncmFwaGljcy5kcmF3UGF0dGVybihjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlW29wdHMuc2VyaWVzTnVtYmVyXSwgY25mLmZpbGwucGF0dGVybi53aWR0aCwgY25mLmZpbGwucGF0dGVybi5oZWlnaHQsIHBhdHRlcm5MaW5lQ29sb3IsIHBhdHRlcm5TdHJva2VXaWR0aCwgZmlsbE9wYWNpdHkpO1xuICAgICAgICAgIHBhdHRlcm5GaWxsID0gcGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybkZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm5GaWxsID0gZ3JhcGhpY3MuZHJhd1BhdHRlcm4oY25mLmZpbGwucGF0dGVybi5zdHlsZSwgY25mLmZpbGwucGF0dGVybi53aWR0aCwgY25mLmZpbGwucGF0dGVybi5oZWlnaHQsIHBhdHRlcm5MaW5lQ29sb3IsIHBhdHRlcm5TdHJva2VXaWR0aCwgZmlsbE9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0dGVybkZpbGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUdyYWRpZW50RmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVHcmFkaWVudEZpbGwoZ3JhZGllbnRGaWxsLCBmaWxsQ29sb3IsIGZpbGxPcGFjaXR5LCBpKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1dGlscyA9IG5ldyBVdGlscygpO1xuICAgICAgdmFyIHR5cGUgPSBjbmYuZmlsbC5ncmFkaWVudC50eXBlO1xuICAgICAgdmFyIGdyYWRpZW50RnJvbSwgZ3JhZGllbnRUbztcbiAgICAgIHZhciBvcGFjaXR5RnJvbSA9IGNuZi5maWxsLmdyYWRpZW50Lm9wYWNpdHlGcm9tID09PSB1bmRlZmluZWQgPyBmaWxsT3BhY2l0eSA6IEFycmF5LmlzQXJyYXkoY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eUZyb20pID8gY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eUZyb21baV0gOiBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5RnJvbTtcbiAgICAgIHZhciBvcGFjaXR5VG8gPSBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG8gPT09IHVuZGVmaW5lZCA/IGZpbGxPcGFjaXR5IDogQXJyYXkuaXNBcnJheShjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG8pID8gY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eVRvW2ldIDogY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eVRvO1xuICAgICAgZ3JhZGllbnRGcm9tID0gZmlsbENvbG9yO1xuXG4gICAgICBpZiAoY25mLmZpbGwuZ3JhZGllbnQuZ3JhZGllbnRUb0NvbG9ycyA9PT0gdW5kZWZpbmVkIHx8IGNuZi5maWxsLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChjbmYuZmlsbC5ncmFkaWVudC5zaGFkZSA9PT0gJ2RhcmsnKSB7XG4gICAgICAgICAgZ3JhZGllbnRUbyA9IHV0aWxzLnNoYWRlQ29sb3IocGFyc2VGbG9hdChjbmYuZmlsbC5ncmFkaWVudC5zaGFkZUludGVuc2l0eSkgKiAtMSwgZmlsbENvbG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudFRvID0gdXRpbHMuc2hhZGVDb2xvcihwYXJzZUZsb2F0KGNuZi5maWxsLmdyYWRpZW50LnNoYWRlSW50ZW5zaXR5KSwgZmlsbENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhZGllbnRUbyA9IGNuZi5maWxsLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnNbb3B0cy5zZXJpZXNOdW1iZXJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY25mLmZpbGwuZ3JhZGllbnQuaW52ZXJzZUNvbG9ycykge1xuICAgICAgICB2YXIgdCA9IGdyYWRpZW50RnJvbTtcbiAgICAgICAgZ3JhZGllbnRGcm9tID0gZ3JhZGllbnRUbztcbiAgICAgICAgZ3JhZGllbnRUbyA9IHQ7XG4gICAgICB9XG5cbiAgICAgIGdyYWRpZW50RmlsbCA9IGdyYXBoaWNzLmRyYXdHcmFkaWVudCh0eXBlLCBncmFkaWVudEZyb20sIGdyYWRpZW50VG8sIG9wYWNpdHlGcm9tLCBvcGFjaXR5VG8sIG9wdHMuc2l6ZSwgY25mLmZpbGwuZ3JhZGllbnQuc3RvcHMsIGNuZi5maWxsLmdyYWRpZW50LmNvbG9yU3RvcHMsIGkpO1xuICAgICAgcmV0dXJuIGdyYWRpZW50RmlsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsbDtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIE1hcmtlcnMgQ2xhc3MgZm9yIGRyYXdpbmcgcG9pbnRzIG9uIHkgdmFsdWVzIGluIGF4ZXMgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgTWFya2Vyc1xuICoqL1xuXG52YXIgTWFya2VycyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcmtlcnMoY3R4LCBvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtlcnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya2VycywgW3tcbiAgICBrZXk6IFwic2V0R2xvYmFsTWFya2VyU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHbG9iYWxNYXJrZXJTaXplKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5tYXJrZXJzLnNpemUpID8gdy5jb25maWcubWFya2Vycy5zaXplIDogW3cuY29uZmlnLm1hcmtlcnMuc2l6ZV07XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5zaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemUubGVuZ3RoIDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplLnB1c2gody5nbG9iYWxzLm1hcmtlcnMuc2l6ZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplID0gdy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiB3LmNvbmZpZy5tYXJrZXJzLnNpemU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbG90Q2hhcnRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3RDaGFydE1hcmtlcnMocG9pbnRzUG9zLCBzZXJpZXNJbmRleCwgaikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcCA9IHBvaW50c1BvcztcbiAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBudWxsO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBwb2ludDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCkge1xuICAgICAgICBlbFBvaW50c1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxQb2ludHNXcmFwLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLnggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChxKSB7XG4gICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajsgLy8gYSBzbWFsbCBoYWNrIGFzIHdlIGhhdmUgMiBwb2ludHMgZm9yIHRoZSBmaXJzdCB2YWwgdG8gY29ubmVjdCBpdFxuXG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMCkgZGF0YVBvaW50SW5kZXggPSAwO1xuICAgICAgICAgIGlmIChqID09PSAxICYmIHEgPT09IDEpIGRhdGFQb2ludEluZGV4ID0gMTtcbiAgICAgICAgICB2YXIgUG9pbnRDbGFzc2VzID0gJ2FwZXhjaGFydHMtbWFya2VyJztcblxuICAgICAgICAgIGlmICgody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdhcmVhJykgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSAnIG5vLXBvaW50ZXItZXZlbnRzJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2hvdWxkTWFya2VyRHJhdyA9IEFycmF5LmlzQXJyYXkody5jb25maWcubWFya2Vycy5zaXplKSA/IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCA6IHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA+IDA7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTWFya2VyRHJhdykge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHAueVtxXSkpIHtcbiAgICAgICAgICAgICAgUG9pbnRDbGFzc2VzICs9IFwiIHdcIi5jb25jYXQoKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFBvaW50Q2xhc3NlcyA9ICdhcGV4Y2hhcnRzLW51bGxwb2ludCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuZ2V0TWFya2VyQ29uZmlnKFBvaW50Q2xhc3Nlcywgc2VyaWVzSW5kZXgpOyAvLyBkaXNjcmV0ZSBtYXJrZXJzIGlzIGFuIG9wdGlvbiB3aGVyZSB1c2VyIGNhbiBzcGVjaWZ5IGEgcGFydGljdWxhciBtYXJrZXIgd2l0aCBkaWZmZXJlbnQgc2l6ZSBhbmQgY29sb3JcblxuXG4gICAgICAgICAgICB3LmNvbmZpZy5tYXJrZXJzLmRpc2NyZXRlLm1hcChmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXJrZXIuc2VyaWVzSW5kZXggPT09IHNlcmllc0luZGV4ICYmIG1hcmtlci5kYXRhUG9pbnRJbmRleCA9PT0gZGF0YVBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvaW50U3Ryb2tlQ29sb3IgPSBtYXJrZXIuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wb2ludEZpbGxDb2xvciA9IG1hcmtlci5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wU2l6ZSA9IG1hcmtlci5zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50ID0gZ3JhcGhpY3MuZHJhd01hcmtlcihwLnhbcV0sIHAueVtxXSwgb3B0cyk7XG4gICAgICAgICAgICBwb2ludC5hdHRyKCdyZWwnLCBkYXRhUG9pbnRJbmRleCk7XG4gICAgICAgICAgICBwb2ludC5hdHRyKCdqJywgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgcG9pbnQuYXR0cignaW5kZXgnLCBzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIG9wdHMucFNpemUpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyhfdGhpcy5jdHgpO1xuICAgICAgICAgICAgZmlsdGVycy5zZXRTZWxlY3Rpb25GaWx0ZXIocG9pbnQsIHNlcmllc0luZGV4LCBkYXRhUG9pbnRJbmRleCk7XG5cbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmIChlbFBvaW50c1dyYXApIHtcbiAgICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYXJyYXkgY3JlYXRpb24gLSBtdWx0aWRpbWVuc2lvbmFsXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5wb2ludHNBcnJheVtzZXJpZXNJbmRleF0gPT09ICd1bmRlZmluZWQnKSB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdID0gW107XG4gICAgICAgICAgICB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdLnB1c2goW3AueFtxXSwgcC55W3FdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcC54Lmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgX2xvb3AocSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsUG9pbnRzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2VyQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlckNvbmZpZyhjc3NDbGFzcywgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoc2VyaWVzSW5kZXgpO1xuICAgICAgdmFyIHBTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtzZXJpZXNJbmRleF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwU2l6ZTogcFNpemUsXG4gICAgICAgIHBSYWRpdXM6IHcuY29uZmlnLm1hcmtlcnMucmFkaXVzLFxuICAgICAgICBwV2lkdGg6IHcuY29uZmlnLm1hcmtlcnMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHBvaW50U3Ryb2tlQ29sb3I6IHBTdHlsZS5wb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICBwb2ludEZpbGxDb2xvcjogcFN0eWxlLnBvaW50RmlsbENvbG9yLFxuICAgICAgICBzaGFwZTogdy5jb25maWcubWFya2Vycy5zaGFwZSBpbnN0YW5jZW9mIEFycmF5ID8gdy5jb25maWcubWFya2Vycy5zaGFwZVtzZXJpZXNJbmRleF0gOiB3LmNvbmZpZy5tYXJrZXJzLnNoYXBlLFxuICAgICAgICBjbGFzczogY3NzQ2xhc3MsXG4gICAgICAgIHBvaW50U3Ryb2tlT3BhY2l0eTogdy5jb25maWcubWFya2Vycy5zdHJva2VPcGFjaXR5LFxuICAgICAgICBwb2ludEZpbGxPcGFjaXR5OiB3LmNvbmZpZy5tYXJrZXJzLmZpbGxPcGFjaXR5LFxuICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudHMoY2lyY2xlKSB7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcy5jdHgsIGNpcmNsZSkpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlLmJpbmQodGhpcy5jdHgsIGNpcmNsZSkpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZ3JhcGhpY3MucGF0aE1vdXNlRG93bi5iaW5kKHRoaXMuY3R4LCBjaXJjbGUpKTtcbiAgICAgIGNpcmNsZS5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcy5jdHgsIGNpcmNsZSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlclN0eWxlKHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjb2xvcnMgPSB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnM7XG4gICAgICB2YXIgc3Ryb2tlQ29sb3JzID0gdy5jb25maWcubWFya2Vycy5zdHJva2VDb2xvciB8fCB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZUNvbG9ycztcbiAgICAgIHZhciBwb2ludFN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBzdHJva2VDb2xvcnNbc2VyaWVzSW5kZXhdIDogc3Ryb2tlQ29sb3JzO1xuICAgICAgdmFyIHBvaW50RmlsbENvbG9yID0gY29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBjb2xvcnNbc2VyaWVzSW5kZXhdIDogY29sb3JzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnRTdHJva2VDb2xvcjogcG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgcG9pbnRGaWxsQ29sb3I6IHBvaW50RmlsbENvbG9yXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrZXJzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgU2NhdHRlciBDbGFzcy5cbiAqIFRoaXMgQ2xhc3MgYWxzbyBoYW5kbGVzIGJ1YmJsZXMgY2hhcnQgYXMgY3VycmVudGx5IHRoZXJlIGlzIG5vIG1ham9yIGRpZmZlcmVuY2UgaW4gZHJhd2luZyB0aGVtLFxuICogQG1vZHVsZSBTY2F0dGVyXG4gKiovXG5cbnZhciBTY2F0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NhdHRlcihjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhdHRlcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMuaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDsgLy8gdGhpcyBhcnJheSB3aWxsIGhlbHAgaW4gY2VudGVyaW5nIHRoZSBsYWJlbCBpbiBidWJibGVzXG5cbiAgICB0aGlzLnJhZGl1c1NpemVzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NhdHRlciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGVsU2VyaWVzLCBqLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gb3B0cy5yZWFsSW5kZXg7XG4gICAgICB2YXIgcG9pbnRzUG9zID0gb3B0cy5wb2ludHNQb3M7XG4gICAgICB2YXIgelJhdGlvID0gb3B0cy56UmF0aW87XG4gICAgICB2YXIgZWxQb2ludHNNYWluID0gb3B0cy5lbFBhcmVudDtcbiAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgYXBleGNoYXJ0cy1zZXJpZXMtXCIuY29uY2F0KHcuY29uZmlnLmNoYXJ0LnR5cGUpXG4gICAgICB9KTtcbiAgICAgIGVsUG9pbnRzV3JhcC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXJrZXJNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuXG4gICAgICBpZiAocG9pbnRzUG9zLnggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHBvaW50c1Bvcy54Lmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gaiArIDE7XG4gICAgICAgICAgdmFyIHNob3VsZERyYXcgPSB0cnVlOyAvLyBhIHNtYWxsIGhhY2sgYXMgd2UgaGF2ZSAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IHZhbCB0byBjb25uZWN0IGl0XG5cbiAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKGogPT09IDAgJiYgcSA9PT0gMSkgZGF0YVBvaW50SW5kZXggPSAxO1xuICAgICAgICAgIHZhciByYWRpdXMgPSAwO1xuICAgICAgICAgIHZhciBmaW5pc2hSYWRpdXMgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW3JlYWxJbmRleF07XG5cbiAgICAgICAgICBpZiAoelJhdGlvICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLy8gbWVhbnMgd2UgaGF2ZSBhIGJ1YmJsZVxuICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gdy5nbG9iYWxzLnNlcmllc1pbcmVhbEluZGV4XVtkYXRhUG9pbnRJbmRleF0gLyB6UmF0aW87XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yYWRpdXNTaXplc1tyZWFsSW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0aGlzLnJhZGl1c1NpemVzLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJhZGl1c1NpemVzW3JlYWxJbmRleF0ucHVzaChmaW5pc2hSYWRpdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBmaW5pc2hSYWRpdXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHggPSBwb2ludHNQb3MueFtxXTtcbiAgICAgICAgICB2YXIgeSA9IHBvaW50c1Bvcy55W3FdO1xuICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAwO1xuXG4gICAgICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCB8fCB5ID09PSBudWxsIHx8IHR5cGVvZiB3Lmdsb2JhbHMuc2VyaWVzW3JlYWxJbmRleF1bZGF0YVBvaW50SW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2hvdWxkRHJhdyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGREcmF3KSB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5kcmF3UG9pbnQoeCwgeSwgcmFkaXVzLCBmaW5pc2hSYWRpdXMsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgsIGopO1xuICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChjaXJjbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsUG9pbnRzTWFpbi5hZGQoZWxQb2ludHNXcmFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BvaW50KHgsIHksIHJhZGl1cywgZmluaXNoUmFkaXVzLCByZWFsSW5kZXgsIGRhdGFQb2ludEluZGV4LCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBhbmltID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcGF0aEZpbGxDaXJjbGUgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ29iamVjdEJvdW5kaW5nQm94J1xuICAgICAgfSk7XG4gICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShyYWRpdXMpO1xuICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICBjeDogeCxcbiAgICAgICAgY3k6IHksXG4gICAgICAgIGZpbGw6IHBhdGhGaWxsQ2lyY2xlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coY2lyY2xlLCB7XG4gICAgICAgICAgdG9wOiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LnRvcCxcbiAgICAgICAgICBsZWZ0OiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmxlZnQsXG4gICAgICAgICAgYmx1cjogdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyLFxuICAgICAgICAgIGNvbG9yOiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cub3BhY2l0eVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgc3BlZWQgPSAxO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLnJlc2l6ZWQpIHtcbiAgICAgICAgICBzcGVlZCA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltLmFuaW1hdGVDaXJjbGVSYWRpdXMoY2lyY2xlLCAwLCBmaW5pc2hSYWRpdXMsIHNwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljQW5pbSkge1xuICAgICAgICAgIHZhciBfc3BlZWQgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQ7XG4gICAgICAgICAgdmFyIHByZXZYLCBwcmV2WSwgcHJldlI7XG4gICAgICAgICAgdmFyIHByZXZQYXRoSiA9IG51bGw7XG4gICAgICAgICAgcHJldlBhdGhKID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcmVhbEluZGV4XSAmJiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tyZWFsSW5kZXhdW2pdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmV2UGF0aEogIT09ICd1bmRlZmluZWQnICYmIHByZXZQYXRoSiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gc2VyaWVzIGNvbnRhaW5pbmcgbGVzcyBlbGVtZW50cyB3aWxsIGlnbm9yZSB0aGVzZSB2YWx1ZXMgYW5kIHJldmVydCB0byAwXG4gICAgICAgICAgICBwcmV2WCA9IHByZXZQYXRoSi54O1xuICAgICAgICAgICAgcHJldlkgPSBwcmV2UGF0aEoueTtcbiAgICAgICAgICAgIHByZXZSID0gdHlwZW9mIHByZXZQYXRoSi5yICE9PSAndW5kZWZpbmVkJyA/IHByZXZQYXRoSi5yIDogZmluaXNoUmFkaXVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGNzID0gMDsgY3MgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgY3MrKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY3NdLmluZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgX3NwZWVkID0gMTtcbiAgICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSBmaW5pc2hSYWRpdXMgPSAwO1xuICAgICAgICAgIGFuaW0uYW5pbWF0ZUNpcmNsZShjaXJjbGUsIHtcbiAgICAgICAgICAgIGN4OiBwcmV2WCxcbiAgICAgICAgICAgIGN5OiBwcmV2WSxcbiAgICAgICAgICAgIHI6IHByZXZSXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgICBjeTogeSxcbiAgICAgICAgICAgIHI6IGZpbmlzaFJhZGl1c1xuICAgICAgICAgIH0sIF9zcGVlZCwgdy5nbG9iYWxzLmVhc2luZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgcjogZmluaXNoUmFkaXVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICByZWw6IGRhdGFQb2ludEluZGV4LFxuICAgICAgICBqOiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgJ2RlZmF1bHQtbWFya2VyLXNpemUnOiBmaW5pc2hSYWRpdXNcbiAgICAgIH0pO1xuICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG4gICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihjaXJjbGUsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgbWFya2Vycy5hZGRFdmVudHMoY2lyY2xlKTtcbiAgICAgIGNpcmNsZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZW50ZXJUZXh0SW5CdWJibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VudGVyVGV4dEluQnViYmxlKHkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgeSA9IHkgKyBwYXJzZUludCh3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2F0dGVyO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRGF0YUxhYmVscyBDbGFzcyBmb3IgZHJhd2luZyBkYXRhTGFiZWxzIG9uIEF4ZXMgYmFzZWQgQ2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgRGF0YUxhYmVsc1xuICoqL1xuXG52YXIgRGF0YUxhYmVscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFMYWJlbHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFMYWJlbHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH0gLy8gV2hlbiB0aGVyZSBhcmUgbWFueSBkYXRhbGFiZWxzIHRvIGJlIHByaW50ZWQsIGFuZCBzb21lIG9mIHRoZW0gb3ZlcmxhcHMgZWFjaCBvdGhlciBpbiB0aGUgc2FtZSBzZXJpZXMsIHRoaXMgbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcbiAgLy8gQWxzbywgd2hlbiBkYXRhbGFiZWxzIGV4Y2VlZHMgdGhlIGRyYXdhYmxlIGFyZWEgYW5kIGdldCBjbGlwcGVkIG9mZiwgd2UgbmVlZCB0byBhZGp1c3QgYW5kIG1vdmUgc29tZSBwaXhlbHMgdG8gbWFrZSB0aGVtIHZpc2libGUgYWdhaW5cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhTGFiZWxzLCBbe1xuICAgIGtleTogXCJkYXRhTGFiZWxzQ29ycmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB2YWwsIGksIGRhdGFQb2ludEluZGV4LCBhbHdheXNEcmF3RGF0YUxhYmVsLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGRyYXduZXh0TGFiZWwgPSBmYWxzZTsgLy9cblxuICAgICAgdmFyIHRleHRSZWN0cyA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIGZvbnRTaXplKTtcbiAgICAgIHZhciB3aWR0aCA9IHRleHRSZWN0cy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0ZXh0UmVjdHMuaGVpZ2h0OyAvLyBmaXJzdCB2YWx1ZSBpbiBzZXJpZXMsIHNvIHB1c2ggYW4gZW1wdHkgYXJyYXlcblxuICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldID09PSAndW5kZWZpbmVkJykgdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXSA9IFtdOyAvLyB0aGVuIHN0YXJ0IHB1c2hpbmcgYWN0dWFsIHJlY3RzIGluIHRoYXQgc3ViLWFycmF5XG5cbiAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ubGVuZ3RoIC0gMjtcbiAgICAgIHZhciBsYXN0RHJhd25JbmRleCA9IHR5cGVvZiB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldW3cuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXS5sZW5ndGggLSAxXSA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXVtsZW5dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbGFzdERhdGFMYWJlbFJlY3QgPSB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldW2xhc3REcmF3bkluZGV4XTtcblxuICAgICAgICBpZiAoIC8vIG5leHQgbGFiZWwgZm9yd2FyZCBhbmQgeCBub3QgaW50ZXJzZWN0aW5nXG4gICAgICAgIHggPiBsYXN0RGF0YUxhYmVsUmVjdC54ICsgbGFzdERhdGFMYWJlbFJlY3Qud2lkdGggKyAyIHx8IHkgPiBsYXN0RGF0YUxhYmVsUmVjdC55ICsgbGFzdERhdGFMYWJlbFJlY3QuaGVpZ2h0ICsgMiB8fCB4ICsgd2lkdGggPCBsYXN0RGF0YUxhYmVsUmVjdC54IC8vIG5leHQgbGFiZWwgaXMgZ29pbmcgdG8gYmUgZHJhd24gYmFja3dhcmRzXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gdGhlIDIgaW5kZXhlcyBkb24ndCBvdmVycmlkZSwgc28gT0sgdG8gZHJhdyBuZXh0IGxhYmVsXG4gICAgICAgICAgICBkcmF3bmV4dExhYmVsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhUG9pbnRJbmRleCA9PT0gMCB8fCBhbHdheXNEcmF3RGF0YUxhYmVsKSB7XG4gICAgICAgIGRyYXduZXh0TGFiZWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBkcmF3bmV4dExhYmVsOiBkcmF3bmV4dExhYmVsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RGF0YUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdEYXRhTGFiZWwocG9zLCBpLCBqKSB7XG4gICAgICAvLyB0aGlzIG1ldGhvZCBoYW5kbGVzIGxpbmUsIGFyZWEsIGJ1YmJsZSwgc2NhdHRlciBjaGFydHMgYXMgdGhvc2UgY2hhcnRzIGNvbnRhaW5zIG1hcmtlcnMvcG9pbnRzIHdoaWNoIGhhdmUgcHJlLWRlZmluZWQgeC95IHBvc2l0aW9uc1xuICAgICAgLy8gYWxsIG90aGVyIGNoYXJ0cyBsaWtlIGJhcnMgLyBoZWF0bWFwcyB3aWxsIGRlZmluZSB0aGVpciBvd24gZHJhd0RhdGFMYWJlbCByb3V0aW5lXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF0YUxhYmVsc0NvbmZpZyA9IHcuY29uZmlnLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB2YXIgZGF0YVBvaW50SW5kZXggPSBqO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuXG4gICAgICBpZiAoIWRhdGFMYWJlbHNDb25maWcuZW5hYmxlZCB8fCBwb3MueCBpbnN0YW5jZW9mIEFycmF5ICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgICAgfVxuXG4gICAgICBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YS1sYWJlbHMnXG4gICAgICB9KTtcbiAgICAgIGVsRGF0YUxhYmVsc1dyYXAuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcblxuICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBwb3MueC5sZW5ndGg7IHErKykge1xuICAgICAgICB4ID0gcG9zLnhbcV0gKyBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgIHkgPSBwb3MueVtxXSArIGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WSAtIHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaV0gLSA1O1xuXG4gICAgICAgIGlmICghaXNOYU4oeCkpIHtcbiAgICAgICAgICAvLyBhIHNtYWxsIGhhY2sgYXMgd2UgaGF2ZSAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IHZhbCB0byBjb25uZWN0IGl0XG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMCkgZGF0YVBvaW50SW5kZXggPSAwO1xuICAgICAgICAgIGlmIChqID09PSAxICYmIHEgPT09IDEpIGRhdGFQb2ludEluZGV4ID0gMTtcbiAgICAgICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJykge1xuICAgICAgICAgICAgdGV4dCA9IHcuZ2xvYmFscy5zZXJpZXNaW2ldW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgICAgIHkgPSBwb3MueVtxXSArIHcuY29uZmlnLmRhdGFMYWJlbHMub2Zmc2V0WTtcbiAgICAgICAgICAgIHZhciBzY2F0dGVyID0gbmV3IFNjYXR0ZXIodGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclRleHRJbkJ1YmJsZUNvb3JkcyA9IHNjYXR0ZXIuY2VudGVyVGV4dEluQnViYmxlKHksIGksIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgIHkgPSBjZW50ZXJUZXh0SW5CdWJibGVDb29yZHMueTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcih2YWwsIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBvZmZzZXRDb3JyZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgZGF0YUxhYmVsc0NvbmZpZzogdy5jb25maWcuZGF0YUxhYmVsc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbG90RGF0YUxhYmVsc1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdERhdGFMYWJlbHNUZXh0KG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgaSA9IG9wdHMuaSxcbiAgICAgICAgICBqID0gb3B0cy5qLFxuICAgICAgICAgIHRleHQgPSBvcHRzLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvciA9IG9wdHMudGV4dEFuY2hvcixcbiAgICAgICAgICBwYXJlbnQgPSBvcHRzLnBhcmVudCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5kYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGFsd2F5c0RyYXdEYXRhTGFiZWwgPSBvcHRzLmFsd2F5c0RyYXdEYXRhTGFiZWwsXG4gICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbiA9IG9wdHMub2Zmc2V0Q29ycmVjdGlvbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkT25TZXJpZXMpKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmVuYWJsZWRPblNlcmllcy5pbmRleE9mKGkpID4gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvcnJlY3RlZExhYmVscyA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgZHJhd25leHRMYWJlbDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKG9mZnNldENvcnJlY3Rpb24pIHtcbiAgICAgICAgY29ycmVjdGVkTGFiZWxzID0gdGhpcy5kYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB0ZXh0LCBpLCBqLCBhbHdheXNEcmF3RGF0YUxhYmVsLCBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICB9IC8vIHdoZW4gem9vbWVkLCB3ZSBkb24ndCBuZWVkIHRvIGNvcnJlY3QgbGFiZWxzIG9mZnNldHMsXG4gICAgICAvLyBidXQgaWYgbm9ybWFsbHksIGxhYmVscyBnZXQgY3JvcHBlZCwgY29ycmVjdCB0aGVtXG5cblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbWVkKSB7XG4gICAgICAgIHggPSBjb3JyZWN0ZWRMYWJlbHMueDtcbiAgICAgICAgeSA9IGNvcnJlY3RlZExhYmVscy55O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ycmVjdGVkTGFiZWxzLmRyYXduZXh0TGFiZWwpIHtcbiAgICAgICAgdmFyIGRhdGFMYWJlbFRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBmb3JlQ29sb3I6IHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9yc1tpXSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIHx8IGRhdGFMYWJlbHNDb25maWcudGV4dEFuY2hvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udEZhbWlseVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YUxhYmVsVGV4dC5hdHRyKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVsJyxcbiAgICAgICAgICBjeDogeCxcbiAgICAgICAgICBjeTogeVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgdGV4dFNoYWRvdyA9IGRhdGFMYWJlbHNDb25maWcuZHJvcFNoYWRvdztcbiAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZGF0YUxhYmVsVGV4dCwgdGV4dFNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuYWRkKGRhdGFMYWJlbFRleHQpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHcuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldLnB1c2goaik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFMYWJlbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBCYXIgQ2xhc3MgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgYm90aCBDb2x1bW5zIGFuZCBCYXJzLlxuICpcbiAqIEBtb2R1bGUgQmFyXG4gKiovXG5cbnZhciBEQVRBX0xBQkVMU19XQVJOSU5HX1RIUkVTSE9MRCA9IDUwO1xuXG52YXIgQmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKGN0eCwgeHlSYXRpb3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMuYmFyT3B0aW9ucyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhcjtcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IHRoaXMuYmFyT3B0aW9ucy5ob3Jpem9udGFsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB3LmNvbmZpZy5zdHJva2Uud2lkdGg7XG4gICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcblxuICAgIGlmICh0aGlzLnh5UmF0aW9zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnhSYXRpbyA9IHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFhSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWFJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFlSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWVJhdGlvO1xuICAgICAgdGhpcy5iYXNlTGluZVkgPSB4eVJhdGlvcy5iYXNlTGluZVk7XG4gICAgICB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZID0geHlSYXRpb3MuYmFzZUxpbmVJbnZlcnRlZFk7XG4gICAgfVxuXG4gICAgdGhpcy5taW5YRGlmZiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy55YXhpc0luZGV4ID0gMDtcbiAgICB0aGlzLnNlcmllc0xlbiA9IDA7XG4gIH1cbiAgLyoqIHByaW1hcnkgZHJhdyBtZXRob2Qgd2hpY2ggaXMgY2FsbGVkIG9uIGJhciBvYmplY3RcbiAgICogQG1lbWJlcm9mIEJhclxuICAgKiBAcGFyYW0ge2FycmF5fSBzZXJpZXMgLSB1c2VyIHN1cHBsaWVkIHNlcmllcyB2YWx1ZXNcbiAgICogQHBhcmFtIHtpbnR9IHNlcmllc0luZGV4IC0gdGhlIGluZGV4IGJ5IHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduIG9uIHRoZSBzdmdcbiAgICogQHJldHVybiB7bm9kZX0gZWxlbWVudCB3aGljaCBpcyBzdXBwbGllZCB0byBwYXJlbnQgY2hhcnQgZHJhdyBtZXRob2QgZm9yIGFwcGVuZGluZ1xuICAgKiovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCwgdyk7XG4gICAgICB0aGlzLnNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICB0aGlzLmluaXRWYXJpYWJsZXMoc2VyaWVzKTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsSXRlbXMgPiBEQVRBX0xBQkVMU19XQVJOSU5HX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogRGF0YUxhYmVscyBhcmUgZW5hYmxlZCBidXQgdGhlcmUgYXJlIHRvbyBtYW55IHRvIGRpc3BsYXkuIFRoaXMgbWF5IGNhdXNlIHBlcmZvcm1hbmNlIGlzc3VlIHdoZW4gcmVuZGVyaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGksIGJjKSB7XG4gICAgICAgIHZhciBwYXRoVG8gPSB2b2lkIDAsXG4gICAgICAgICAgICBwYXRoRnJvbSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgICAgeERpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8geERpdmlzaW9uIGlzIHRoZSBHUklEV0lEVEggZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoY29sdW1ucylcbiAgICAgICAgeURpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8geURpdmlzaW9uIGlzIHRoZSBHUklESEVJR0hUIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGJhcnMpXG4gICAgICAgIHplcm9IID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG4gICAgICAgIHplcm9XID0gdm9pZCAwOyAvLyB6ZXJvVyBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB4IGF4aXNcblxuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tyZWFsSW5kZXhdKSksXG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiByZWFsSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuY3R4LnNlcmllcy5hZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCByZWFsSW5kZXgpO1xuXG4gICAgICAgIGlmIChzZXJpZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLnZpc2libGVJID0gX3RoaXMudmlzaWJsZUkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgX3RoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZDtcblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IF90aGlzLmluaXRpYWxQb3NpdGlvbnMoKTtcblxuICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgIHplcm9XID0gaW5pdFBvc2l0aW9ucy56ZXJvVztcbiAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IO1xuXG4gICAgICAgIGlmICghX3RoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7XG4gICAgICAgIH0gLy8gZWxkYXRhbGFiZWxzXG5cblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihqLCB0aikge1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLmlzTnVsbFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuaXNOdWxsVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuc3Ryb2tlLnNob3cpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc051bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkoX3RoaXMuc3Ryb2tlV2lkdGgpID8gX3RoaXMuc3Ryb2tlV2lkdGhbcmVhbEluZGV4XSA6IF90aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBwYXRocyA9IF90aGlzLmRyYXdCYXJQYXRocyh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIHplcm9XOiB6ZXJvVyxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeURpdmlzaW9uOiB5RGl2aXNpb24sXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd0NvbHVtblBhdGhzKHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aFRvID0gcGF0aHMucGF0aFRvO1xuICAgICAgICAgIHBhdGhGcm9tID0gcGF0aHMucGF0aEZyb207XG4gICAgICAgICAgeSA9IHBhdGhzLnk7XG4gICAgICAgICAgeCA9IHBhdGhzLng7IC8vIHB1c2ggY3VycmVudCBYXG5cbiAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeUFycmoucHVzaCh5KTtcbiAgICAgICAgICB2YXIgc2VyaWVzTnVtYmVyID0gX3RoaXMuYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IGogOiBpO1xuICAgICAgICAgIHZhciBmaWxsQ29sb3IgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKF90aGlzLmJhck9wdGlvbnMuY29sb3JzLnJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JSYW5nZSA9IF90aGlzLmJhck9wdGlvbnMuY29sb3JzLnJhbmdlcztcbiAgICAgICAgICAgIGNvbG9yUmFuZ2UubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAoc2VyaWVzW2ldW2pdID49IHJhbmdlLmZyb20gJiYgc2VyaWVzW2ldW2pdIDw9IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gcmFuZ2UuY29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiBfdGhpcy5iYXJPcHRpb25zLmRpc3RyaWJ1dGVkID8gc2VyaWVzTnVtYmVyIDogcmVhbEluZGV4LFxuICAgICAgICAgICAgY29sb3I6IGZpbGxDb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsU2VyaWVzID0gX3RoaXMucmVuZGVyU2VyaWVzKHtcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgcGF0aEZpbGw6IHBhdGhGaWxsLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllcyxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXA6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICB2aXNpYmxlU2VyaWVzOiBfdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdiYXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHRqID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrLCB0ai0tKSB7XG4gICAgICAgICAgX2xvb3AyKGosIHRqKTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgX2xvb3AoaSwgYmMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VyaWVzKF9yZWYpIHtcbiAgICAgIHZhciByZWFsSW5kZXggPSBfcmVmLnJlYWxJbmRleCxcbiAgICAgICAgICBwYXRoRmlsbCA9IF9yZWYucGF0aEZpbGwsXG4gICAgICAgICAgbGluZUZpbGwgPSBfcmVmLmxpbmVGaWxsLFxuICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgaSA9IF9yZWYuaSxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYucGF0aEZyb20sXG4gICAgICAgICAgcGF0aFRvID0gX3JlZi5wYXRoVG8sXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcyxcbiAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgIHkgPSBfcmVmLnksXG4gICAgICAgICAgc2VyaWVzID0gX3JlZi5zZXJpZXMsXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBfcmVmLmVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgdmlzaWJsZVNlcmllcyA9IF9yZWYudmlzaWJsZVNlcmllcyxcbiAgICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuXG4gICAgICBpZiAoIWxpbmVGaWxsKSB7XG4gICAgICAgIC8qIGZpeCBhcGV4Y2hhcnRzIzM0MSAqL1xuICAgICAgICBsaW5lRmlsbCA9IHRoaXMuYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW2pdIDogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbcmVhbEluZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgcGF0aEZpbGwgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWxheSA9IGogLyB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZGVsYXkgKiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzKSAvIDIuNDtcbiAgICAgIHZhciByZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyh7XG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGosXG4gICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBzdHJva2U6IGxpbmVGaWxsLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IHcuY29uZmlnLnN0cm9rZS5saW5lQ2FwLFxuICAgICAgICBmaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgIGRhdGFDaGFuZ2VTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkLFxuICAgICAgICBjbGFzc05hbWU6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYXJlYVwiKSxcbiAgICAgICAgaWQ6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYXJlYVwiKVxuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIGZpbHRlcnMuc2V0U2VsZWN0aW9uRmlsdGVyKHJlbmRlcmVkUGF0aCwgcmVhbEluZGV4LCBqKTtcbiAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZFBhdGgpO1xuICAgICAgdmFyIGRhdGFMYWJlbHMgPSB0aGlzLmNhbGN1bGF0ZURhdGFMYWJlbHNQb3Moe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBpOiBpLFxuICAgICAgICBqOiBqLFxuICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICB2aXNpYmxlU2VyaWVzOiB2aXNpYmxlU2VyaWVzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGRhdGFMYWJlbHMgIT09IG51bGwpIHtcbiAgICAgICAgZWxEYXRhTGFiZWxzV3JhcC5hZGQoZGF0YUxhYmVscyk7XG4gICAgICB9XG5cbiAgICAgIGVsU2VyaWVzLmFkZChlbERhdGFMYWJlbHNXcmFwKTtcbiAgICAgIHJldHVybiBlbFNlcmllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VmFyaWFibGVzKHNlcmllcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgICB0aGlzLnRvdGFsSXRlbXMgPSAwO1xuICAgICAgdGhpcy5zZXJpZXNMZW4gPSAwO1xuICAgICAgdGhpcy52aXNpYmxlSSA9IC0xO1xuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSAxOyAvLyBudW1iZXIgb2YgdmlzaWJsZSBiYXJzIGFmdGVyIHVzZXIgem9vbWVkIGluL291dFxuXG4gICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NsXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXJpZXNMZW4gPSB0aGlzLnNlcmllc0xlbiArIDE7XG4gICAgICAgICAgdGhpcy50b3RhbEl0ZW1zICs9IHNlcmllc1tzbF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBsZWFzdCB4IGRpZmYgaWYgbnVtZXJpYyB4IGF4aXMgaXMgcHJlc2VudFxuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYLmZvckVhY2goZnVuY3Rpb24gKHNYLCBpKSB7XG4gICAgICAgICAgICBzWC5mb3JFYWNoKGZ1bmN0aW9uIChzLCBqKSB7XG4gICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB4RGlmZiA9IHMgLSB3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqIC0gMV07XG4gICAgICAgICAgICAgICAgX3RoaXMyLm1pblhEaWZmID0gTWF0aC5taW4oeERpZmYsIF90aGlzMi5taW5YRGlmZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBnZXQgbWF4IHZpc2libGUgaXRlbXNcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyaWVzW3NsXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA+IHcuZ2xvYmFscy5taW5YICYmIHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA8IHcuZ2xvYmFscy5tYXhYKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VyaWVzTGVuID09PSAwKSB7XG4gICAgICAgIC8vIEEgc21hbGwgYWRqdXN0bWVudCB3aGVuIGNvbWJvIGNoYXJ0cyBhcmUgdXNlZFxuICAgICAgICB0aGlzLnNlcmllc0xlbiA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFBvc2l0aW9ucygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHgsIHksIHlEaXZpc2lvbiwgeERpdmlzaW9uLCBiYXJIZWlnaHQsIGJhcldpZHRoLCB6ZXJvSCwgemVyb1c7XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBoZWlnaHQgZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdGhpcy50b3RhbEl0ZW1zO1xuICAgICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFySGVpZ2h0ID0gYmFySGVpZ2h0ICogcGFyc2VJbnQodGhpcy5iYXJPcHRpb25zLmJhckhlaWdodCkgLyAxMDA7XG4gICAgICAgIHplcm9XID0gdGhpcy5iYXNlTGluZUludmVydGVkWSArIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICogMiA6IDApO1xuICAgICAgICB5ID0gKHlEaXZpc2lvbiAtIGJhckhlaWdodCAqIHRoaXMuc2VyaWVzTGVuKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aWR0aCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgeERpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRoaXMudmlzaWJsZUl0ZW1zO1xuICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuICogcGFyc2VJbnQodGhpcy5iYXJPcHRpb25zLmNvbHVtbldpZHRoKSAvIDEwMDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAvLyBtYXggYmFyd2lkdGggc2hvdWxkIGJlIGVxdWFsIHRvIG1pblhEaWZmIHRvIGF2b2lkIG92ZXJsYXBcbiAgICAgICAgICBpZiAodGhpcy5taW5YRGlmZiA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgLy8gcG9zc2libHkgYSBzaW5nbGUgZGF0YVBvaW50IChmaXhlcyByZWFjdC1hcGV4Y2hhcnRzL2lzc3VlIzM0KVxuICAgICAgICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbGVuID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbiA8IDMpIHtcbiAgICAgICAgICAgICAgbGVuID0gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5taW5YRGlmZiA9ICh3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5taW5YKSAvIGxlbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4RGl2aXNpb24gPSB0aGlzLm1pblhEaWZmIC8gdGhpcy54UmF0aW87XG4gICAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb24gLyB0aGlzLnNlcmllc0xlbiAqIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB6ZXJvSCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdGhpcy5iYXNlTGluZVlbdGhpcy55YXhpc0luZGV4XSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCA6IDApICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gKiAyIDogMCk7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArICh4RGl2aXNpb24gLSBiYXJXaWR0aCAqIHRoaXMuc2VyaWVzTGVuKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICB6ZXJvVzogemVyb1dcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFyUGF0aHMoX3JlZjIpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBfcmVmMi5iYXJIZWlnaHQsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmMi5wYXRoRnJvbSxcbiAgICAgICAgICB6ZXJvVyA9IF9yZWYyLnplcm9XLFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYyLnlEaXZpc2lvbixcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYyLmVsU2VyaWVzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciBiYyA9IGluZGV4ZXMuYmM7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB5ID0gKHcuZ2xvYmFscy5zZXJpZXNYW2ldW2pdIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy5pbnZlcnRlZFhSYXRpbyAtIGJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhcllQb3NpdGlvbiA9IHkgKyBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJO1xuICAgICAgcGF0aFRvID0gZ3JhcGhpY3MubW92ZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gZ3JhcGhpY3MubW92ZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF0aEZyb20gPSB0aGlzLmdldFBhdGhGcm9tKHJlYWxJbmRleCwgaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJpZXNbaV1bal0gPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2VyaWVzW2ldW2pdID09PSBudWxsKSB7XG4gICAgICAgIHggPSB6ZXJvVztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB6ZXJvVyArIHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbyAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gOiAwKSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IHBhdGhUbyArIGdyYXBoaWNzLmxpbmUoeCwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUoeCwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKHplcm9XLCBiYXJZUG9zaXRpb24pICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB5ID0geSArIHlEaXZpc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGggPiAwICYmIGkgPT09IDApIHtcbiAgICAgICAgaWYgKGJjID49IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBiYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmNvbG9yID0gdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzW2JjXTtcbiAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCgwLCBiYXJZUG9zaXRpb24gLSBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCBiYXJIZWlnaHQgKiB0aGlzLnNlcmllc0xlbiwgMCwgYmNvbG9yLCB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29sdW1uUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NvbHVtblBhdGhzKF9yZWYzKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IF9yZWYzLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnksXG4gICAgICAgICAgeERpdmlzaW9uID0gX3JlZjMueERpdmlzaW9uLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYzLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYzLnBhdGhGcm9tLFxuICAgICAgICAgIGJhcldpZHRoID0gX3JlZjMuYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0ggPSBfcmVmMy56ZXJvSCxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZjMuZWxTZXJpZXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeSA9IHplcm9IO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHplcm9IIC0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgIH1cblxuICAgICAgcGF0aFRvID0gcGF0aFRvICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCB5KSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHplcm9IKTtcbiAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCB6ZXJvSCkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGgsIHplcm9IKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoYmFyWFBvc2l0aW9uIC0gYmFyV2lkdGggKiB0aGlzLnZpc2libGVJLCAwLCBiYXJXaWR0aCAqIHRoaXMuc2VyaWVzTGVuLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCwgYmNvbG9yLCB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogZ2V0UGF0aEZyb20gaXMgYSBjb21tb24gZnVuY3Rpb24gZm9yIGJhcnMvY29sdW1ucyB3aGljaCBpcyB1c2VkIHRvIGdldCBwcmV2aW91cyBwYXRocyB3aGVuIGRhdGEgY2hhbmdlcy5cbiAgICAgKiBAbWVtYmVyb2YgQmFyXG4gICAgICogQHBhcmFtIHtpbnR9IHJlYWxJbmRleCAtIGN1cnJlbnQgaXRlcmF0aW5nIGlcbiAgICAgKiBAcGFyYW0ge2ludH0gaiAtIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllcydzIGogaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhdGhGcm9tIGlzIHRoZSBzdHJpbmcgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCBpbiBhbmltYXRpb25zXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwYXRoRnJvbTtcblxuICAgICAgZm9yICh2YXIgcHAgPSAwOyBwcCA8IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aDsgcHArKykge1xuICAgICAgICB2YXIgZ3BwID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdO1xuXG4gICAgICAgIGlmIChncHAucGF0aHMubGVuZ3RoID4gMCAmJiBwYXJzZUludChncHAucmVhbEluZGV4KSA9PT0gcGFyc2VJbnQocmVhbEluZGV4KSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF0aEZyb20gPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbal0uZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhGcm9tO1xuICAgIH1cbiAgICAvKiogY2FsY3VsYXRlQmFyRGF0YUxhYmVscyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGZvciB0aGUgZGF0YS1sYWJlbHNcbiAgICAgKiBJdCBhbHNvIHNldHMgdGhlIGVsZW1lbnQncyBkYXRhIGF0dHIgZm9yIGJhcnMgYW5kIGNhbGxzIGRyYXdDYWxjdWxhdGVkQmFyRGF0YUxhYmVscygpXG4gICAgICogQG1lbWJlcm9mIEJhclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB7YmFyUHJvcHN9IG1vc3Qgb2YgdGhlIGJhciBwcm9wZXJ0aWVzIHVzZWQgdGhyb3VnaG91dCB0aGUgYmFyXG4gICAgICogZHJhd2luZyBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge29iamVjdH0gZGF0YUxhYmVscyBub2RlLWVsZW1lbnQgd2hpY2ggeW91IGNhbiBhcHBlbmQgbGF0ZXJcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVEYXRhTGFiZWxzUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFMYWJlbHNQb3MoX3JlZjQpIHtcbiAgICAgIHZhciB4ID0gX3JlZjQueCxcbiAgICAgICAgICB5ID0gX3JlZjQueSxcbiAgICAgICAgICBpID0gX3JlZjQuaSxcbiAgICAgICAgICBqID0gX3JlZjQuaixcbiAgICAgICAgICByZWFsSW5kZXggPSBfcmVmNC5yZWFsSW5kZXgsXG4gICAgICAgICAgc2VyaWVzID0gX3JlZjQuc2VyaWVzLFxuICAgICAgICAgIGJhckhlaWdodCA9IF9yZWY0LmJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWY0LmJhcldpZHRoLFxuICAgICAgICAgIHZpc2libGVTZXJpZXMgPSBfcmVmNC52aXNpYmxlU2VyaWVzLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aCA9IF9yZWY0LnJlbmRlcmVkUGF0aDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkodGhpcy5zdHJva2VXaWR0aCkgPyB0aGlzLnN0cm9rZVdpZHRoW3JlYWxJbmRleF0gOiB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGJjeCA9IHggKyBwYXJzZUZsb2F0KGJhcldpZHRoICogdmlzaWJsZVNlcmllcyk7XG4gICAgICB2YXIgYmN5ID0geSArIHBhcnNlRmxvYXQoYmFySGVpZ2h0ICogdmlzaWJsZVNlcmllcyk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBiY3ggPSB4ICsgcGFyc2VGbG9hdChiYXJXaWR0aCAqICh2aXNpYmxlU2VyaWVzICsgMSkpIC0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIGJjeSA9IHkgKyBwYXJzZUZsb2F0KGJhckhlaWdodCAqICh2aXNpYmxlU2VyaWVzICsgMSkpIC0gc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhTGFiZWxzID0gbnVsbDtcbiAgICAgIHZhciBkYXRhTGFiZWxzWCA9IHg7XG4gICAgICB2YXIgZGF0YUxhYmVsc1kgPSB5O1xuICAgICAgdmFyIGRhdGFMYWJlbHNQb3MgPSB7fTtcbiAgICAgIHZhciBkYXRhTGFiZWxzQ29uZmlnID0gdy5jb25maWcuZGF0YUxhYmVscztcbiAgICAgIHZhciBiYXJEYXRhTGFiZWxzQ29uZmlnID0gdGhpcy5iYXJPcHRpb25zLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgb2ZmWCA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZO1xuICAgICAgdmFyIHRleHRSZWN0cyA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICB0ZXh0UmVjdHMgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMody5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF0ody5nbG9iYWxzLm1heFkpLCBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICBkYXRhTGFiZWxzUG9zID0gdGhpcy5jYWxjdWxhdGVCYXJzRGF0YUxhYmVsc1Bvc2l0aW9uKHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICAgIGJjeTogYmN5LFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICBkYXRhTGFiZWxzWDogZGF0YUxhYmVsc1gsXG4gICAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZLFxuICAgICAgICAgIGJhckRhdGFMYWJlbHNDb25maWc6IGJhckRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgb2ZmWDogb2ZmWCxcbiAgICAgICAgICBvZmZZOiBvZmZZXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUxhYmVsc1BvcyA9IHRoaXMuY2FsY3VsYXRlQ29sdW1uc0RhdGFMYWJlbHNQb3NpdGlvbih7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICByZW5kZXJlZFBhdGg6IHJlbmRlcmVkUGF0aCxcbiAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICBiY3g6IGJjeCxcbiAgICAgICAgICBiY3k6IGJjeSxcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgdGV4dFJlY3RzOiB0ZXh0UmVjdHMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGRhdGFMYWJlbHNZOiBkYXRhTGFiZWxzWSxcbiAgICAgICAgICBiYXJEYXRhTGFiZWxzQ29uZmlnOiBiYXJEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIG9mZlg6IG9mZlgsXG4gICAgICAgICAgb2ZmWTogb2ZmWVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZWRQYXRoLmF0dHIoe1xuICAgICAgICBjeTogZGF0YUxhYmVsc1Bvcy5iY3ksXG4gICAgICAgIGN4OiBkYXRhTGFiZWxzUG9zLmJjeCxcbiAgICAgICAgajogaixcbiAgICAgICAgdmFsOiBzZXJpZXNbaV1bal0sXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGhcbiAgICAgIH0pO1xuICAgICAgZGF0YUxhYmVscyA9IHRoaXMuZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKHtcbiAgICAgICAgeDogZGF0YUxhYmVsc1Bvcy5kYXRhTGFiZWxzWCxcbiAgICAgICAgeTogZGF0YUxhYmVsc1Bvcy5kYXRhTGFiZWxzWSxcbiAgICAgICAgdmFsOiBzZXJpZXNbaV1bal0sXG4gICAgICAgIGk6IHJlYWxJbmRleCxcbiAgICAgICAgajogaixcbiAgICAgICAgZGF0YUxhYmVsc0NvbmZpZzogZGF0YUxhYmVsc0NvbmZpZ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YUxhYmVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlQ29sdW1uc0RhdGFMYWJlbHNQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb2x1bW5zRGF0YUxhYmVsc1Bvc2l0aW9uKG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGkgPSBvcHRzLmksXG4gICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICByZWFsSW5kZXggPSBvcHRzLnJlYWxJbmRleCxcbiAgICAgICAgICB5ID0gb3B0cy55LFxuICAgICAgICAgIGJjeCA9IG9wdHMuYmN4LFxuICAgICAgICAgIGJhcldpZHRoID0gb3B0cy5iYXJXaWR0aCxcbiAgICAgICAgICB0ZXh0UmVjdHMgPSBvcHRzLnRleHRSZWN0cyxcbiAgICAgICAgICBkYXRhTGFiZWxzWSA9IG9wdHMuZGF0YUxhYmVsc1ksXG4gICAgICAgICAgYmFyRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyRGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICBvZmZZID0gb3B0cy5vZmZZO1xuICAgICAgdmFyIGRhdGFMYWJlbHNYO1xuICAgICAgdmFyIGJhckhlaWdodCA9IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgIHZhciBkYXRhUG9pbnRzRGl2aWRlZFdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgYmN4ID0gYmN4IC0gc3Ryb2tlV2lkdGggLyAyO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSBiY3ggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSBiY3ggLSBkYXRhUG9pbnRzRGl2aWRlZFdpZHRoICsgYmFyV2lkdGggLyAyICsgb2ZmWDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbElzTmVnYXRpdmUgPSB0aGlzLnNlcmllc1tpXVtqXSA8PSAwO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICB5ID0geSAtIGJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChiYXJEYXRhTGFiZWxzQ29uZmlnLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiArIG9mZlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiAtIG9mZlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5ICsgYmFySGVpZ2h0ICsgdGV4dFJlY3RzLmhlaWdodCArIHN0cm9rZVdpZHRoICsgb2ZmWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5ICsgYmFySGVpZ2h0IC0gdGV4dFJlY3RzLmhlaWdodCAvIDIgKyBzdHJva2VXaWR0aCAtIG9mZlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5IC0gdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBvZmZZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IHkgKyB0ZXh0UmVjdHMuaGVpZ2h0ICsgb2ZmWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmN4OiBiY3gsXG4gICAgICAgIGJjeTogeSxcbiAgICAgICAgZGF0YUxhYmVsc1g6IGRhdGFMYWJlbHNYLFxuICAgICAgICBkYXRhTGFiZWxzWTogZGF0YUxhYmVsc1lcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUJhcnNEYXRhTGFiZWxzUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQmFyc0RhdGFMYWJlbHNQb3NpdGlvbihvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgIGkgPSBvcHRzLmksXG4gICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICBiY3kgPSBvcHRzLmJjeSxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBvcHRzLmJhckhlaWdodCxcbiAgICAgICAgICB0ZXh0UmVjdHMgPSBvcHRzLnRleHRSZWN0cyxcbiAgICAgICAgICBkYXRhTGFiZWxzWCA9IG9wdHMuZGF0YUxhYmVsc1gsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGJhckRhdGFMYWJlbHNDb25maWcgPSBvcHRzLmJhckRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICBvZmZZID0gb3B0cy5vZmZZO1xuICAgICAgdmFyIGRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgIHZhciBkYXRhTGFiZWxzWSA9IGJjeSAtIGRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmFySGVpZ2h0IC8gMiArIHRleHRSZWN0cy5oZWlnaHQgLyAyICsgb2ZmWSAtIDM7XG4gICAgICB2YXIgYmFyV2lkdGggPSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICB2YXIgdmFsSXNOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzW2ldW2pdIDw9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIHggPSB4ICsgYmFyV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYmFyRGF0YUxhYmVsc0NvbmZpZy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgLSBvZmZYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGggLSBNYXRoLnJvdW5kKHRleHRSZWN0cy53aWR0aCAvIDIpIC0gb2ZmWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSB4IC0gYmFyV2lkdGggKyBzdHJva2VXaWR0aCArIE1hdGgucm91bmQodGV4dFJlY3RzLndpZHRoIC8gMikgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSAtIG9mZlg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoIC0gTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSArIG9mZlg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzWCA8IDApIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSB0ZXh0UmVjdHMud2lkdGggKyBzdHJva2VXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YUxhYmVsc1ggKyB0ZXh0UmVjdHMud2lkdGggLyAyID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICBkYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYIC0gdGV4dFJlY3RzLndpZHRoIC0gc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJjeDogeCxcbiAgICAgICAgYmN5OiBiY3ksXG4gICAgICAgIGRhdGFMYWJlbHNYOiBkYXRhTGFiZWxzWCxcbiAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q2FsY3VsYXRlZERhdGFMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKF9yZWY1KSB7XG4gICAgICB2YXIgeCA9IF9yZWY1LngsXG4gICAgICAgICAgeSA9IF9yZWY1LnksXG4gICAgICAgICAgdmFsID0gX3JlZjUudmFsLFxuICAgICAgICAgIGkgPSBfcmVmNS5pLFxuICAgICAgICAgIGogPSBfcmVmNS5qLFxuICAgICAgICAgIGRhdGFMYWJlbHNDb25maWcgPSBfcmVmNS5kYXRhTGFiZWxzQ29uZmlnO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZGF0YUxhYmVsc0NvbmZpZy5mb3JtYXR0ZXI7XG4gICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IG51bGw7XG4gICAgICB2YXIgaXNTZXJpZXNOb3RDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID4gLTE7XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLmVuYWJsZWQgJiYgIWlzU2VyaWVzTm90Q29sbGFwc2VkKSB7XG4gICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dCA9IGZvcm1hdHRlcih2YWwsIHtcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHBhcmVudDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGFsd2F5c0RyYXdEYXRhTGFiZWw6IHRydWUsXG4gICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsRGF0YUxhYmVsc1dyYXA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEJhclN0YWNrZWQgQ2xhc3MgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgYm90aCBTdGFja2VkIENvbHVtbnMgYW5kIEJhcnMuXG4gKlxuICogQG1vZHVsZSBCYXJTdGFja2VkXG4gKiBUaGUgd2hvbGUgY2FsY3VsYXRpb24gZm9yIHN0YWNrZWQgYmFyL2NvbHVtbiBpcyBkaWZmZXJlbnQgZnJvbSBub3JtYWwgYmFyL2NvbHVtbixcbiAqIGhlbmNlIGl0IG1ha2VzIHNlbnNlIHRvIGRlcml2ZSBhIG5ldyBjbGFzcyBmb3IgaXQgZXh0ZW5kaW5nIG1vc3Qgb2YgdGhlIHByb3BzIG9mIFBhcmVudCBCYXJcbiAqKi9cblxudmFyIEJhclN0YWNrZWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXIpIHtcbiAgX2luaGVyaXRzKEJhclN0YWNrZWQsIF9CYXIpO1xuXG4gIGZ1bmN0aW9uIEJhclN0YWNrZWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhclN0YWNrZWQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihCYXJTdGFja2VkKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXJTdGFja2VkLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuYmFyID0gbmV3IEJhcih0aGlzLmN0eCwgdGhpcy54eVJhdGlvcyk7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCwgdyk7XG4gICAgICB0aGlzLnNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tUeXBlID09PSAnMTAwJScpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSB3Lmdsb2JhbHMuc2VyaWVzUGVyY2VudC5zbGljZSgpO1xuICAgICAgICBzZXJpZXMgPSB0aGlzLnNlcmllcztcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEl0ZW1zID0gMDtcbiAgICAgIHRoaXMucHJldlkgPSBbXTsgLy8geSBwb3NpdGlvbiBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZYID0gW107IC8vIHggcG9zaXRpb24gb24gY2hhcnRcblxuICAgICAgdGhpcy5wcmV2WUYgPSBbXTsgLy8geSBwb3NpdGlvbiBpbmNsdWRpbmcgc2hhcGVzIG9uIGNoYXJ0XG5cbiAgICAgIHRoaXMucHJldlhGID0gW107IC8vIHggcG9zaXRpb24gaW5jbHVkaW5nIHNoYXBlcyBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZZVmFsID0gW107IC8vIHkgdmFsdWVzIChzZXJpZXNbaV1bal0pIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy5wcmV2WFZhbCA9IFtdOyAvLyB4IHZhbHVlcyAoc2VyaWVzW2ldW2pdKSBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmogPSBbXTsgLy8geGogaW5kaWNhdGVzIHggcG9zaXRpb24gb24gZ3JhcGggaW4gYmFyc1xuXG4gICAgICB0aGlzLnhBcnJqRiA9IFtdOyAvLyB4akYgaW5kaWNhdGVzIGJhcidzIHggcG9zaXRpb24gKyBlbmRpbmdzaGFwZSdzIHBvc2l0aW9ucyBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmpWYWwgPSBbXTsgLy8geCB2YWwgbWVhbnMgdGhlIGFjdHVhbCBzZXJpZXMncyB5IHZhbHVlcyBpbiBob3Jpem9udGFsL2JhcnNcblxuICAgICAgdGhpcy55QXJyaiA9IFtdOyAvLyB5aiBpbmRpY2F0ZXMgeSBwb3NpdGlvbiBvbiBncmFwaCBpbiBjb2x1bW5zXG5cbiAgICAgIHRoaXMueUFycmpGID0gW107IC8vIHlqRiBpbmRpY2F0ZXMgYmFyJ3MgeSBwb3NpdGlvbiArIGVuZGluZ3NoYXBlJ3MgcG9zaXRpb25zIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy55QXJyalZhbCA9IFtdOyAvLyB5IHZhbCBtZWFucyB0aGUgYWN0dWFsIHNlcmllcydzIHkgdmFsdWVzIGluIGNvbHVtbnNcblxuICAgICAgZm9yICh2YXIgc2wgPSAwOyBzbCA8IHNlcmllcy5sZW5ndGg7IHNsKyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzbF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudG90YWxJdGVtcyArPSBzZXJpZXNbc2xdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpLCBiYykge1xuICAgICAgICB2YXIgcGF0aFRvID0gdm9pZCAwLFxuICAgICAgICAgICAgcGF0aEZyb20gPSB2b2lkIDA7XG4gICAgICAgIHZhciB4RGl2aXNpb24gPSB2b2lkIDA7IC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG5cbiAgICAgICAgdmFyIHlEaXZpc2lvbiA9IHZvaWQgMDsgLy8geURpdmlzaW9uIGlzIHRoZSBHUklESEVJR0hUIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGJhcnMpXG5cbiAgICAgICAgdmFyIHplcm9IID0gdm9pZCAwOyAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcblxuICAgICAgICB2YXIgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgIHZhciB4QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciB5QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7XG5cbiAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgX3RoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZDsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICB2YXIgZWxTZXJpZXMgPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSkpLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pOyAvLyBlbGRhdGFsYWJlbHNcblxuXG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoID0gMDtcblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IF90aGlzLmluaXRpYWxQb3NpdGlvbnMoeCwgeSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHplcm9ILCB6ZXJvVyk7XG5cbiAgICAgICAgeSA9IGluaXRQb3NpdGlvbnMueTtcbiAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgIHlEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueURpdmlzaW9uO1xuICAgICAgICB6ZXJvVyA9IGluaXRQb3NpdGlvbnMuemVyb1c7XG4gICAgICAgIHggPSBpbml0UG9zaXRpb25zLng7XG4gICAgICAgIGJhcldpZHRoID0gaW5pdFBvc2l0aW9ucy5iYXJXaWR0aDtcbiAgICAgICAgeERpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy54RGl2aXNpb247XG4gICAgICAgIHplcm9IID0gaW5pdFBvc2l0aW9ucy56ZXJvSDtcbiAgICAgICAgX3RoaXMueUFycmogPSBbXTtcbiAgICAgICAgX3RoaXMueUFycmpGID0gW107XG4gICAgICAgIF90aGlzLnlBcnJqVmFsID0gW107XG4gICAgICAgIF90aGlzLnhBcnJqID0gW107XG4gICAgICAgIF90aGlzLnhBcnJqRiA9IFtdO1xuICAgICAgICBfdGhpcy54QXJyalZhbCA9IFtdOyAvLyBpZiAoIXRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyB0aGlzLnhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMilcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaikge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzTnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheShfdGhpcy5zdHJva2VXaWR0aCkgPyBfdGhpcy5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogX3RoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhzID0gbnVsbDtcblxuICAgICAgICAgIGlmIChfdGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd0JhclBhdGhzKHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgemVyb1c6IHplcm9XLFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aHMgPSBfdGhpcy5kcmF3Q29sdW1uUGF0aHMoe1xuICAgICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGJjOiBiY1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICB6ZXJvSDogemVyb0gsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoVG8gPSBwYXRocy5wYXRoVG87XG4gICAgICAgICAgcGF0aEZyb20gPSBwYXRocy5wYXRoRnJvbTtcbiAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICB4ID0gcGF0aHMueDtcbiAgICAgICAgICB4QXJyVmFsdWVzLnB1c2goeCk7XG4gICAgICAgICAgeUFyclZhbHVlcy5wdXNoKHkpO1xuICAgICAgICAgIHZhciBzZXJpZXNOdW1iZXIgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgPyBqIDogaTtcbiAgICAgICAgICB2YXIgZmlsbENvbG9yID0gbnVsbDtcblxuICAgICAgICAgIGlmIChfdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yUmFuZ2UgPSBfdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXM7XG4gICAgICAgICAgICBjb2xvclJhbmdlLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChzZXJpZXNbaV1bal0gPj0gcmFuZ2UuZnJvbSAmJiBzZXJpZXNbaV1bal0gPD0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gX3RoaXMuZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IF90aGlzLmJhck9wdGlvbnMuZGlzdHJpYnV0ZWQgPyBzZXJpZXNOdW1iZXIgOiByZWFsSW5kZXgsXG4gICAgICAgICAgICBjb2xvcjogZmlsbENvbG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlbFNlcmllcyA9IF90aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgICB2aXNpYmxlU2VyaWVzOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrKSB7XG4gICAgICAgICAgX2xvb3AyKGopO1xuICAgICAgICB9IC8vIHB1c2ggYWxsIHggdmFsIGFycmF5cyBpbnRvIG1haW4geEFyclxuXG5cbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbcmVhbEluZGV4XSA9IHhBcnJWYWx1ZXM7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyVmFsdWVzOyAvLyBwdXNoIGFsbCBjdXJyZW50IHkgdmFsdWVzIGFycmF5IHRvIG1haW4gUHJldlkgQXJyYXlcblxuICAgICAgICBfdGhpcy5wcmV2WS5wdXNoKF90aGlzLnlBcnJqKTtcblxuICAgICAgICBfdGhpcy5wcmV2WUYucHVzaChfdGhpcy55QXJyakYpO1xuXG4gICAgICAgIF90aGlzLnByZXZZVmFsLnB1c2goX3RoaXMueUFycmpWYWwpO1xuXG4gICAgICAgIF90aGlzLnByZXZYLnB1c2goX3RoaXMueEFycmopO1xuXG4gICAgICAgIF90aGlzLnByZXZYRi5wdXNoKF90aGlzLnhBcnJqRik7XG5cbiAgICAgICAgX3RoaXMucHJldlhWYWwucHVzaChfdGhpcy54QXJyalZhbCk7XG5cbiAgICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgYmMgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrLCBiYysrKSB7XG4gICAgICAgIF9sb29wKGksIGJjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsUG9zaXRpb25zKHgsIHksIHhEaXZpc2lvbiwgeURpdmlzaW9uLCB6ZXJvSCwgemVyb1cpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGJhckhlaWdodCwgYmFyV2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBoZWlnaHQgZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbjtcbiAgICAgICAgYmFySGVpZ2h0ID0gYmFySGVpZ2h0ICogcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmJhckhlaWdodCkgLyAxMDA7XG4gICAgICAgIHplcm9XID0gdGhpcy5iYXNlTGluZUludmVydGVkWSArIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICogMiA6IDApOyAvLyBpbml0aWFsIHkgcG9zaXRpb24gaXMgaGFsZiBvZiBiYXJIZWlnaHQgKiBoYWxmIG9mIG51bWJlciBvZiBCYXJzXG5cbiAgICAgICAgeSA9ICh5RGl2aXNpb24gLSBiYXJIZWlnaHQpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuICAgICAgICB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhcldpZHRoID0geERpdmlzaW9uO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIC8vIG1heCBiYXJ3aWR0aCBzaG91bGQgYmUgZXF1YWwgdG8gbWluWERpZmYgdG8gYXZvaWQgb3ZlcmxhcFxuICAgICAgICAgIHhEaXZpc2lvbiA9IHRoaXMubWluWERpZmYgLyB0aGlzLnhSYXRpbztcbiAgICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAqIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFyV2lkdGggPSBiYXJXaWR0aCAqIHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB6ZXJvSCA9IHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApOyAvLyBpbml0aWFsIHggcG9zaXRpb24gaXMgb25lIHRoaXJkIG9mIGJhcldpZHRoXG5cbiAgICAgICAgeCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHhEaXZpc2lvbiAtIGJhcldpZHRoKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICB6ZXJvVzogemVyb1dcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFyUGF0aHMoX3JlZikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZi5wYXRoRnJvbSxcbiAgICAgICAgICB6ZXJvVyA9IF9yZWYuemVyb1csXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYueURpdmlzaW9uLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGJhcllQb3NpdGlvbiA9IHk7XG4gICAgICB2YXIgYmFyWFBvc2l0aW9uO1xuICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciBiYyA9IGluZGV4ZXMuYmM7XG4gICAgICB2YXIgcHJldkJhclcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMucHJldlhGLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHByZXZCYXJXID0gcHJldkJhclcgKyB0aGlzLnByZXZYRltrXVtqXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHZhciBiWFAgPSB6ZXJvVztcblxuICAgICAgICBpZiAodGhpcy5wcmV2WFZhbFtpIC0gMV1bal0gPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdICsgcHJldkJhclcgLSAodGhpcy5pc1JldmVyc2VkID8gcHJldkJhclcgOiAwKSAqIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZYVmFsW2kgLSAxXVtqXSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnByZXZYW2kgLSAxXVtqXSAtIHByZXZCYXJXICsgKHRoaXMuaXNSZXZlcnNlZCA/IHByZXZCYXJXIDogMCkgKiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJhclhQb3NpdGlvbiA9IGJYUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WCB2YWx1ZXNcbiAgICAgICAgYmFyWFBvc2l0aW9uID0gemVyb1c7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gYmFyWFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGJhclhQb3NpdGlvbiArIHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbyAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gOiAwKSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueEFycmoucHVzaCh4KTtcbiAgICAgIHRoaXMueEFycmpGLnB1c2goTWF0aC5hYnMoYmFyWFBvc2l0aW9uIC0geCkpO1xuICAgICAgdGhpcy54QXJyalZhbC5wdXNoKHRoaXMuc2VyaWVzW2ldW2pdKTtcbiAgICAgIHBhdGhUbyA9IHRoaXMuZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHRoaXMuZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhGcm9tID0gdGhpcy5iYXIuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IHBhdGhUbyArIHRoaXMuZ3JhcGhpY3MubGluZSh4LCBiYXJZUG9zaXRpb24pICsgdGhpcy5ncmFwaGljcy5saW5lKHgsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHBhdGhGcm9tICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCBiYXJZUG9zaXRpb24sIHcuZ2xvYmFscy5ncmlkV2lkdGgsIGJhckhlaWdodCwgMCwgYmNvbG9yLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHkgPSB5ICsgeURpdmlzaW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NvbHVtblBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb2x1bW5QYXRocyhfcmVmMikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmMi5pbmRleGVzLFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYyLnhEaXZpc2lvbixcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmMi5wYXRoRnJvbSxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWYyLmJhcldpZHRoLFxuICAgICAgICAgIHplcm9IID0gX3JlZjIuemVyb0gsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYyLmVsU2VyaWVzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHZhciBzZXJpZXNWYWwgPSB3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXTtcbiAgICAgICAgaWYgKCFzZXJpZXNWYWwpIHNlcmllc1ZhbCA9IDA7XG4gICAgICAgIHggPSAoc2VyaWVzVmFsIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy54UmF0aW8gLSBiYXJXaWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXJYUG9zaXRpb24gPSB4O1xuICAgICAgdmFyIGJhcllQb3NpdGlvbjtcbiAgICAgIHZhciBwcmV2QmFySCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5wcmV2WUYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcHJldkJhckggPSBwcmV2QmFySCArIHRoaXMucHJldllGW2tdW2pdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDAgJiYgIXcuZ2xvYmFscy5pc1hOdW1lcmljIHx8IGkgPiAwICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuZ2xvYmFscy5zZXJpZXNYW2kgLSAxXVtqXSA9PT0gdy5nbG9iYWxzLnNlcmllc1hbaV1bal0pIHtcbiAgICAgICAgdmFyIGJZUDtcbiAgICAgICAgdmFyIHByZXZZVmFsdWUgPSB0aGlzLnByZXZZW2kgLSAxXVtqXTtcblxuICAgICAgICBpZiAodGhpcy5wcmV2WVZhbFtpIC0gMV1bal0gPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWUgLSBwcmV2QmFySCArICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFySCA6IDApICogMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYllQID0gcHJldllWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWUgKyBwcmV2QmFySCAtICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFySCA6IDApICogMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBiYXJZUG9zaXRpb24gPSBiWVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzLCBhbHNvIGlmIHRoZSBwcmV2IGluZGV4J3Mgc2VyaWVzIFggZG9lc24ndCBtYXRjaGVzIHRoZSBjdXJyZW50IGluZGV4J3Mgc2VyaWVzIFgsIHRoZW4gc3RhcnQgZnJvbSB6ZXJvXG4gICAgICAgIGJhcllQb3NpdGlvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gemVyb0g7XG4gICAgICB9XG5cbiAgICAgIHkgPSBiYXJZUG9zaXRpb24gLSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgdGhpcy55QXJyai5wdXNoKHkpO1xuICAgICAgdGhpcy55QXJyakYucHVzaChNYXRoLmFicyhiYXJZUG9zaXRpb24gLSB5KSk7XG4gICAgICB0aGlzLnlBcnJqVmFsLnB1c2godGhpcy5zZXJpZXNbaV1bal0pO1xuICAgICAgcGF0aFRvID0gdGhpcy5ncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gdGhpcy5ncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF0aEZyb20gPSB0aGlzLmJhci5nZXRQYXRoRnJvbShyZWFsSW5kZXgsIGosIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcGF0aFRvID0gcGF0aFRvICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeSkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgeSkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHBhdGhGcm9tICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCBiYXJZUG9zaXRpb24pICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGgsIGJhcllQb3NpdGlvbikgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdChiYXJYUG9zaXRpb24sIDAsIGJhcldpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCwgYmNvbG9yLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogdy5nbG9iYWxzLmlzWE51bWVyaWMgPyB4IC0geERpdmlzaW9uIDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFyU3RhY2tlZDtcbn0oQmFyKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIENhbmRsZVN0aWNrIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGJvdGggU3RhY2tlZCBDb2x1bW5zIGFuZCBCYXJzLlxuICpcbiAqIEBtb2R1bGUgQ2FuZGxlU3RpY2tcbiAqIFRoZSB3aG9sZSBjYWxjdWxhdGlvbiBmb3Igc3RhY2tlZCBiYXIvY29sdW1uIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBiYXIvY29sdW1uLFxuICogaGVuY2UgaXQgbWFrZXMgc2Vuc2UgdG8gZGVyaXZlIGEgbmV3IGNsYXNzIGZvciBpdCBleHRlbmRpbmcgbW9zdCBvZiB0aGUgcHJvcHMgb2YgUGFyZW50IEJhclxuICoqL1xuXG52YXIgQ2FuZGxlU3RpY2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXIpIHtcbiAgX2luaGVyaXRzKENhbmRsZVN0aWNrLCBfQmFyKTtcblxuICBmdW5jdGlvbiBDYW5kbGVTdGljaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FuZGxlU3RpY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDYW5kbGVTdGljaykuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FuZGxlU3RpY2ssIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY2FuZGxlc3RpY2tPcHRpb25zID0gdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5jYW5kbGVzdGljaztcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgIHRoaXMuc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgc2VyaWVzID0gdGhpcy5zZXJpZXM7XG4gICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTtcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgfSk7XG4gICAgICByZXQuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGJjID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKywgYmMrKykge1xuICAgICAgICB2YXIgcGF0aFRvID0gdm9pZCAwLFxuICAgICAgICAgICAgcGF0aEZyb20gPSB2b2lkIDA7XG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgIC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG4gICAgICAgIHplcm9IID0gdm9pZCAwOyAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcblxuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tyZWFsSW5kZXhdKSksXG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiByZWFsSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlSSA9IHRoaXMudmlzaWJsZUkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IHRoaXMuaW5pdGlhbFBvc2l0aW9ucygpO1xuICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IO1xuICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHRqID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrLCB0ai0tKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2VyaWVzW2ldW2pdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlzTnVsbFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBBcnJheS5pc0FycmF5KHRoaXMuc3Ryb2tlV2lkdGgpID8gdGhpcy5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5kcmF3Q2FuZGxlU3RpY2tQYXRocyh7XG4gICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHhEaXZpc2lvbjogeERpdmlzaW9uLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICB6ZXJvSDogemVyb0gsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoVG8gPSBwYXRocy5wYXRoVG87XG4gICAgICAgICAgcGF0aEZyb20gPSBwYXRocy5wYXRoRnJvbTtcbiAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICB4ID0gcGF0aHMueDtcbiAgICAgICAgICBjb2xvciA9IHBhdGhzLmNvbG9yOyAvLyBwdXNoIGN1cnJlbnQgWFxuXG4gICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBsaW5lRmlsbCA9IHRoaXMuY2FuZGxlc3RpY2tPcHRpb25zLndpY2sudXNlRmlsbENvbG9yID8gY29sb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZWxTZXJpZXMgPSB0aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGxpbmVGaWxsOiBsaW5lRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdmlzaWJsZVNlcmllczogdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdjYW5kbGVzdGljaydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NhbmRsZVN0aWNrUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbmRsZVN0aWNrUGF0aHMoX3JlZikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYueERpdmlzaW9uLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZi5wYXRoRnJvbSxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWYuYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0ggPSBfcmVmLnplcm9ILFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICB2YXIgaXNQb3NpdGl2ZSA9IHRydWU7XG4gICAgICB2YXIgY29sb3JQb3MgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5jYW5kbGVzdGljay5jb2xvcnMudXB3YXJkO1xuICAgICAgdmFyIGNvbG9yTmVnID0gdy5jb25maWcucGxvdE9wdGlvbnMuY2FuZGxlc3RpY2suY29sb3JzLmRvd253YXJkO1xuICAgICAgdmFyIHlSYXRpbyA9IHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF07XG4gICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICB2YXIgb2hsYyA9IHRoaXMuZ2V0T0hMQ1ZhbHVlKHJlYWxJbmRleCwgaik7XG4gICAgICB2YXIgbDEgPSB6ZXJvSDtcbiAgICAgIHZhciBsMiA9IHplcm9IO1xuXG4gICAgICBpZiAob2hsYy5vID4gb2hsYy5jKSB7XG4gICAgICAgIGlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHkxID0gTWF0aC5taW4ob2hsYy5vLCBvaGxjLmMpO1xuICAgICAgdmFyIHkyID0gTWF0aC5tYXgob2hsYy5vLCBvaGxjLmMpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFyWFBvc2l0aW9uID0geCArIGJhcldpZHRoICogdGhpcy52aXNpYmxlSTtcbiAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG4gICAgICBwYXRoRnJvbSA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhGcm9tID0gdGhpcy5nZXRQYXRoRnJvbShyZWFsSW5kZXgsIGosIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICB5MSA9IHplcm9IO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB6ZXJvSCAtIHkxIC8geVJhdGlvO1xuICAgICAgICB5MiA9IHplcm9IIC0geTIgLyB5UmF0aW87XG4gICAgICAgIGwxID0gemVyb0ggLSBvaGxjLmggLyB5UmF0aW87XG4gICAgICAgIGwyID0gemVyb0ggLSBvaGxjLmwgLyB5UmF0aW87XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIGwxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIGwyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkyIC0gc3Ryb2tlV2lkdGggLyAyKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB4ID0geCArIHhEaXZpc2lvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeTIsXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICBjb2xvcjogaXNQb3NpdGl2ZSA/IGNvbG9yUG9zIDogY29sb3JOZWdcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9ITENWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPSExDVmFsdWUoaSwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlT1tpXVtqXSxcbiAgICAgICAgaDogdy5nbG9iYWxzLnNlcmllc0NhbmRsZUhbaV1bal0sXG4gICAgICAgIGw6IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVMW2ldW2pdLFxuICAgICAgICBjOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlQ1tpXVtqXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FuZGxlU3RpY2s7XG59KEJhcik7XG5cbnZhciBDcm9zc2hhaXJzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3Jvc3NoYWlycyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvc3NoYWlycyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDcm9zc2hhaXJzLCBbe1xuICAgIGtleTogXCJkcmF3WENyb3NzaGFpcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hDcm9zc2hhaXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY3Jvc3NoYWlyR3JhZGllbnQgPSB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLmZpbGwuZ3JhZGllbnQ7XG4gICAgICB2YXIgY3Jvc3NoYWlyU2hhZG93ID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5kcm9wU2hhZG93O1xuICAgICAgdmFyIGZpbGxUeXBlID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5maWxsLnR5cGU7XG4gICAgICB2YXIgZ3JhZGllbnRGcm9tID0gY3Jvc3NoYWlyR3JhZGllbnQuY29sb3JGcm9tO1xuICAgICAgdmFyIGdyYWRpZW50VG8gPSBjcm9zc2hhaXJHcmFkaWVudC5jb2xvclRvO1xuICAgICAgdmFyIG9wYWNpdHlGcm9tID0gY3Jvc3NoYWlyR3JhZGllbnQub3BhY2l0eUZyb207XG4gICAgICB2YXIgb3BhY2l0eVRvID0gY3Jvc3NoYWlyR3JhZGllbnQub3BhY2l0eVRvO1xuICAgICAgdmFyIHN0b3BzID0gY3Jvc3NoYWlyR3JhZGllbnQuc3RvcHM7XG4gICAgICB2YXIgc2hhZG93ID0gJ25vbmUnO1xuICAgICAgdmFyIGRyb3BTaGFkb3cgPSBjcm9zc2hhaXJTaGFkb3cuZW5hYmxlZDtcbiAgICAgIHZhciBzaGFkb3dMZWZ0ID0gY3Jvc3NoYWlyU2hhZG93LmxlZnQ7XG4gICAgICB2YXIgc2hhZG93VG9wID0gY3Jvc3NoYWlyU2hhZG93LnRvcDtcbiAgICAgIHZhciBzaGFkb3dCbHVyID0gY3Jvc3NoYWlyU2hhZG93LmJsdXI7XG4gICAgICB2YXIgc2hhZG93Q29sb3IgPSBjcm9zc2hhaXJTaGFkb3cuY29sb3I7XG4gICAgICB2YXIgc2hhZG93T3BhY2l0eSA9IGNyb3NzaGFpclNoYWRvdy5vcGFjaXR5O1xuICAgICAgdmFyIHhjcm9zc2hhaXJzRmlsbCA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZmlsbC5jb2xvcjtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuc2hvdykge1xuICAgICAgICBpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlyc0ZpbGwgPSBncmFwaGljcy5kcmF3R3JhZGllbnQoJ3ZlcnRpY2FsJywgZ3JhZGllbnRGcm9tLCBncmFkaWVudFRvLCBvcGFjaXR5RnJvbSwgb3BhY2l0eVRvLCBudWxsLCBzdG9wcywgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeGNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3UmVjdCgpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAxKSB7XG4gICAgICAgICAgLy8gdG8gcHJldmVudCBkcmF3aW5nIDIgbGluZXMsIGNvbnZlcnQgcmVjdCB0byBsaW5lXG4gICAgICAgICAgeGNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3TGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGNyb3NzaGFpcnMuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhjcm9zc2hhaXJzJyxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgeTI6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBVdGlscy5pc051bWJlcih3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoKSA/IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggOiAwLFxuICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsXG4gICAgICAgICAgZmlsbDogeGNyb3NzaGFpcnNGaWxsLFxuICAgICAgICAgIGZpbHRlcjogc2hhZG93LFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLm9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnN0cm9rZS5kYXNoQXJyYXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyb3BTaGFkb3cpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlycyA9IGZpbHRlcnMuZHJvcFNoYWRvdyh4Y3Jvc3NoYWlycywge1xuICAgICAgICAgICAgbGVmdDogc2hhZG93TGVmdCxcbiAgICAgICAgICAgIHRvcDogc2hhZG93VG9wLFxuICAgICAgICAgICAgYmx1cjogc2hhZG93Qmx1cixcbiAgICAgICAgICAgIGNvbG9yOiBzaGFkb3dDb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IHNoYWRvd09wYWNpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHhjcm9zc2hhaXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZQ3Jvc3NoYWlycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBjcm9zc2hhaXIgPSB3LmNvbmZpZy55YXhpc1swXS5jcm9zc2hhaXJzO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5zaG93KSB7XG4gICAgICAgIHZhciB5Y3Jvc3NoYWlycyA9IGdyYXBoaWNzLmRyYXdMaW5lKDAsIDAsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIDAsIGNyb3NzaGFpci5zdHJva2UuY29sb3IsIGNyb3NzaGFpci5zdHJva2UuZGFzaEFycmF5LCBjcm9zc2hhaXIuc3Ryb2tlLndpZHRoKTtcbiAgICAgICAgeWNyb3NzaGFpcnMuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXljcm9zc2hhaXJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoeWNyb3NzaGFpcnMpO1xuICAgICAgfSAvLyBkcmF3IGFuIGludmlzaWJsZSBjcm9zc2hhaXIgdG8gaGVscCBpbiBwb3NpdGlvbmluZyB0aGUgeWF4aXMgdG9vbHRpcFxuXG5cbiAgICAgIHZhciB5Y3Jvc3NoYWlyc0hpZGRlbiA9IGdyYXBoaWNzLmRyYXdMaW5lKDAsIDAsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIDAsIGNyb3NzaGFpci5zdHJva2UuY29sb3IsIDAsIDApO1xuICAgICAgeWNyb3NzaGFpcnNIaWRkZW4uYXR0cih7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4nXG4gICAgICB9KTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHljcm9zc2hhaXJzSGlkZGVuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvc3NoYWlycztcbn0oKTtcblxuLyoqXG4gKiBEYXRlVGltZSBDbGFzcyB0byBtYW5pcHVsYXRlIGRhdGV0aW1lIHZhbHVlcy5cbiAqXG4gKiBAbW9kdWxlIERhdGVUaW1lXG4gKiovXG5cbnZhciBEYXRlVGltZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGltZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm1vbnRoczMxID0gWzEsIDMsIDUsIDcsIDgsIDEwLCAxMl07XG4gICAgdGhpcy5tb250aHMzMCA9IFsyLCA0LCA2LCA5LCAxMV07XG4gICAgdGhpcy5kYXlzQ250T2ZZZWFyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRlVGltZSwgW3tcbiAgICBrZXk6IFwiaXNWYWxpZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZSkge1xuICAgICAgcmV0dXJuICFpc05hTih0aGlzLnBhcnNlRGF0ZShkYXRlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVUQ1RpbWVTdGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVVENUaW1lU3RhbXAoZGF0ZVN0cikge1xuICAgICAgaWYgKCFEYXRlLnBhcnNlKGRhdGVTdHIpKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoZGF0ZVN0cikudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMjUpKS5nZXRUaW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cikge1xuICAgICAgdmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cik7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENUaW1lU3RhbXAoZGF0ZVN0cik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSBEYXRlLnBhcnNlKGRhdGVTdHIucmVwbGFjZSgvLS9nLCAnLycpLnJlcGxhY2UoL1thLXpdKy9naSwgJyAnKSk7XG4gICAgICBvdXRwdXQgPSB0aGlzLmdldFVUQ1RpbWVTdGFtcChvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTI1MjE2Ny82NDk1MDQzXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmVhdEFzVXRjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyZWF0QXNVdGMoZGF0ZVN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgcmVzdWx0LnNldE1pbnV0ZXMocmVzdWx0LmdldE1pbnV0ZXMoKSAtIHJlc3VsdC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NjM4MDE4L2N1cnJlbnQtdGltZS1mb3JtYXR0aW5nLXdpdGgtamF2YXNjcmlwdCNhbnN3ZXItMTQ2MzgxOTFcblxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgIHZhciB1dGMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgY29udmVydFRvVVRDID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgdmFyIGxvY2FsZSA9IHRoaXMudy5nbG9iYWxzLmxvY2FsZTtcbiAgICAgIHZhciBNTU1NID0gWydcXHgwMCddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG9jYWxlLm1vbnRocykpO1xuICAgICAgdmFyIE1NTSA9IFsnXFx4MDEnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydE1vbnRocykpO1xuICAgICAgdmFyIGRkZGQgPSBbJ1xceDAyJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NhbGUuZGF5cykpO1xuICAgICAgdmFyIGRkZCA9IFsnXFx4MDMnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydERheXMpKTtcblxuICAgICAgZnVuY3Rpb24gaWkoaSwgbGVuKSB7XG4gICAgICAgIHZhciBzID0gaSArICcnO1xuICAgICAgICBsZW4gPSBsZW4gfHwgMjtcblxuICAgICAgICB3aGlsZSAocy5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICBzID0gJzAnICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udmVydFRvVVRDKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLnRyZWF0QXNVdGMoZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ID0gdXRjID8gZGF0ZS5nZXRVVENGdWxsWWVhcigpIDogZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXl5eSsvZywgJyQxJyArIHkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXkvZywgJyQxJyArIHkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMikpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peS9nLCAnJDEnICsgeSk7XG4gICAgICB2YXIgTSA9ICh1dGMgPyBkYXRlLmdldFVUQ01vbnRoKCkgOiBkYXRlLmdldE1vbnRoKCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTU0rL2csICckMScgKyBNTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTS9nLCAnJDEnICsgTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NL2csICckMScgKyBpaShNKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlNL2csICckMScgKyBNKTtcbiAgICAgIHZhciBkID0gdXRjID8gZGF0ZS5nZXRVVENEYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZGQrL2csICckMScgKyBkZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZC9nLCAnJDEnICsgZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkL2csICckMScgKyBpaShkKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlkL2csICckMScgKyBkKTtcbiAgICAgIHZhciBIID0gdXRjID8gZGF0ZS5nZXRVVENIb3VycygpIDogZGF0ZS5nZXRIb3VycygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pSEgrL2csICckMScgKyBpaShIKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlIL2csICckMScgKyBIKTtcbiAgICAgIHZhciBoID0gSCA+IDEyID8gSCAtIDEyIDogSCA9PT0gMCA/IDEyIDogSDtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWhoKy9nLCAnJDEnICsgaWkoaCkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0paC9nLCAnJDEnICsgaCk7XG4gICAgICB2YXIgbSA9IHV0YyA/IGRhdGUuZ2V0VVRDTWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSltbSsvZywgJyQxJyArIGlpKG0pKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKW0vZywgJyQxJyArIG0pO1xuICAgICAgdmFyIHMgPSB1dGMgPyBkYXRlLmdldFVUQ1NlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pc3MrL2csICckMScgKyBpaShzKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlzL2csICckMScgKyBzKTtcbiAgICAgIHZhciBmID0gdXRjID8gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmZmYrL2csICckMScgKyBpaShmLCAzKSk7XG4gICAgICBmID0gTWF0aC5yb3VuZChmIC8gMTApO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZmYvZywgJyQxJyArIGlpKGYpKTtcbiAgICAgIGYgPSBNYXRoLnJvdW5kKGYgLyAxMCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmL2csICckMScgKyBmKTtcbiAgICAgIHZhciBUID0gSCA8IDEyID8gJ0FNJyA6ICdQTSc7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlUVCsvZywgJyQxJyArIFQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pVC9nLCAnJDEnICsgVC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHQgPSBULnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSl0dCsvZywgJyQxJyArIHQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pdC9nLCAnJDEnICsgdC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHR6ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBLID0gdXRjIHx8ICF0eiA/ICdaJyA6IHR6ID4gMCA/ICcrJyA6ICctJztcblxuICAgICAgaWYgKCF1dGMpIHtcbiAgICAgICAgdHogPSBNYXRoLmFicyh0eik7XG4gICAgICAgIHZhciB0ekhycyA9IE1hdGguZmxvb3IodHogLyA2MCk7XG4gICAgICAgIHZhciB0ek1pbiA9IHR6ICUgNjA7XG4gICAgICAgIEsgKz0gaWkodHpIcnMpICsgJzonICsgaWkodHpNaW4pO1xuICAgICAgfVxuXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlLL2csICckMScgKyBLKTtcbiAgICAgIHZhciBkYXkgPSAodXRjID8gZGF0ZS5nZXRVVENEYXkoKSA6IGRhdGUuZ2V0RGF5KCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkZFswXSwgJ2cnKSwgZGRkZFtkYXldKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkWzBdLCAnZycpLCBkZGRbZGF5XSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKE1NTU1bMF0sICdnJyksIE1NTU1bTV0pO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobmV3IFJlZ0V4cChNTU1bMF0sICdnJyksIE1NTVtNXSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKTtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGltZVVuaXRzZnJvbVRpbWVzdGFtcChtaW5YLCBtYXhYKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pblggPSB3LmNvbmZpZy54YXhpcy5taW47XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXhYID0gdy5jb25maWcueGF4aXMubWF4O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWWVhciA9IG5ldyBEYXRlKG1pblgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWF4WWVhciA9IG5ldyBEYXRlKG1heFgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWluTW9udGggPSBuZXcgRGF0ZShtaW5YKS5nZXRNb250aCgpO1xuICAgICAgdmFyIG1heE1vbnRoID0gbmV3IERhdGUobWF4WCkuZ2V0TW9udGgoKTtcbiAgICAgIHZhciBtaW5EYXRlID0gbmV3IERhdGUobWluWCkuZ2V0RGF0ZSgpO1xuICAgICAgdmFyIG1heERhdGUgPSBuZXcgRGF0ZShtYXhYKS5nZXREYXRlKCk7XG4gICAgICB2YXIgbWluSG91ciA9IG5ldyBEYXRlKG1pblgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWF4SG91ciA9IG5ldyBEYXRlKG1heFgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWluTWludXRlID0gbmV3IERhdGUobWluWCkuZ2V0TWludXRlcygpO1xuICAgICAgdmFyIG1heE1pbnV0ZSA9IG5ldyBEYXRlKG1heFgpLmdldE1pbnV0ZXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbk1pbnV0ZTogbWluTWludXRlLFxuICAgICAgICBtYXhNaW51dGU6IG1heE1pbnV0ZSxcbiAgICAgICAgbWluSG91cjogbWluSG91cixcbiAgICAgICAgbWF4SG91cjogbWF4SG91cixcbiAgICAgICAgbWluRGF0ZTogbWluRGF0ZSxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZSxcbiAgICAgICAgbWluTW9udGg6IG1pbk1vbnRoLFxuICAgICAgICBtYXhNb250aDogbWF4TW9udGgsXG4gICAgICAgIG1pblllYXI6IG1pblllYXIsXG4gICAgICAgIG1heFllYXI6IG1heFllYXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxjYXRlTGFzdERheXNPZk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGNhdGVMYXN0RGF5c09mTW9udGgobW9udGgsIHllYXIsIHN1YnRyYWN0KSB7XG4gICAgICB2YXIgZGF5cyA9IHRoaXMuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKTsgLy8gd2hhdGV2ZXIgZGF5cyB3ZSBnZXQsIHN1YnRyYWN0IHRoZSBudW1iZXIgb2YgZGF5cyBhc2tlZFxuXG4gICAgICByZXR1cm4gZGF5cyAtIHN1YnRyYWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURheXNPZlllYXIoeWVhcikge1xuICAgICAgdmFyIGRheXMgPSAzNjU7XG5cbiAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgZGF5cyA9IDM2NjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZVJlbWFpbmluZ0RheXNPZlllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcih5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgdmFyIGRheU9mWWVhciA9IHRoaXMuZGF5c0NudE9mWWVhclttb250aF0gKyBkYXRlO1xuICAgICAgaWYgKG1vbnRoID4gMSAmJiB0aGlzLmlzTGVhcFllYXIoKSkgZGF5T2ZZZWFyKys7XG4gICAgICByZXR1cm4gZGF5T2ZZZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZNb250aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKSB7XG4gICAgICB2YXIgZGF5cyA9IDMwO1xuICAgICAgbW9udGggPSBVdGlscy5tb250aE1vZChtb250aCk7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHRoaXMubW9udGhzMzAuaW5kZXhPZihtb250aCkgPiAtMTpcbiAgICAgICAgICBpZiAobW9udGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5tb250aHMzMS5pbmRleE9mKG1vbnRoKSA+IC0xOlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGVUaW1lO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgSGVhdE1hcCBDbGFzcy5cbiAqIEBtb2R1bGUgSGVhdE1hcFxuICoqL1xuXG52YXIgSGVhdE1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhlYXRNYXAoY3R4LCB4eVJhdGlvcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWF0TWFwKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueFJhdGlvID0geHlSYXRpb3MueFJhdGlvO1xuICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbjtcbiAgICB0aGlzLnJlY3RSYWRpdXMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAucmFkaXVzO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB0aGlzLncuY29uZmlnLnN0cm9rZS53aWR0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIZWF0TWFwLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmV0ID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtaGVhdG1hcCdcbiAgICAgIH0pO1xuICAgICAgcmV0LmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7IC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuXG4gICAgICB2YXIgeERpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgdmFyIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICB2YXIgeTEgPSAwO1xuICAgICAgdmFyIHJldiA9IGZhbHNlO1xuICAgICAgdmFyIGhlYXRTZXJpZXMgPSBzZXJpZXMuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgIHJldiA9IHRydWU7XG4gICAgICAgIGhlYXRTZXJpZXMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gcmV2ID8gMCA6IGhlYXRTZXJpZXMubGVuZ3RoIC0gMTsgcmV2ID8gaSA8IGhlYXRTZXJpZXMubGVuZ3RoIDogaSA+PSAwOyByZXYgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtaGVhdG1hcC1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaV0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFNlcmllcywgc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWF0U2VyaWVzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGNvbG9yU2hhZGVQZXJjZW50ID0gMTtcbiAgICAgICAgICB2YXIgaGVhdENvbG9yUHJvcHMgPSB0aGlzLmRldGVybWluZUhlYXRDb2xvcihpLCBqKTtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaGFzTmVncykge1xuICAgICAgICAgICAgdmFyIHNoYWRlSW50ZW5zaXR5ID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5zaGFkZUludGVuc2l0eTtcblxuICAgICAgICAgICAgaWYgKGhlYXRDb2xvclByb3BzLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gMSAtICgxICsgaGVhdENvbG9yUHJvcHMucGVyY2VudCAvIDEwMCkgKiBzaGFkZUludGVuc2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gKDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSAqIHNoYWRlSW50ZW5zaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9IDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb2xvciA9IGhlYXRDb2xvclByb3BzLmNvbG9yO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuZW5hYmxlU2hhZGVzKSB7XG4gICAgICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMoKTtcbiAgICAgICAgICAgIGNvbG9yID0gVXRpbHMuaGV4VG9SZ2JhKHV0aWxzLnNoYWRlQ29sb3IoY29sb3JTaGFkZVBlcmNlbnQsIGhlYXRDb2xvclByb3BzLmNvbG9yKSwgdy5jb25maWcuZmlsbC5vcGFjaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yZWN0UmFkaXVzO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgcmFkaXVzKTtcbiAgICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgICAgY3g6IHgxLFxuICAgICAgICAgICAgY3k6IHkxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaGVhdG1hcC1yZWN0Jyk7XG4gICAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB2YWw6IGhlYXRTZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbMF0sXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWN0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgcmVjdCkpO1xuICAgICAgICAgIHJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCByZWN0KSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGdyYXBoaWNzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCByZWN0KSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgICAgIGlmICghdy5nbG9iYWxzLnJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgc3BlZWQgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVIZWF0TWFwKHJlY3QsIHgxLCB5MSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHNwZWVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgX3NwZWVkID0gMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0uZW5hYmxlZCAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgICBfc3BlZWQgPSB0aGlzLmR5bmFtaWNBbmltLnNwZWVkO1xuICAgICAgICAgICAgICB2YXIgY29sb3JGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0uY29sb3I7XG4gICAgICAgICAgICAgIGlmICghY29sb3JGcm9tKSBjb2xvckZyb20gPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUhlYXRDb2xvcihyZWN0LCBVdGlscy5pc0NvbG9ySGV4KGNvbG9yRnJvbSkgPyBjb2xvckZyb20gOiBVdGlscy5yZ2IyaGV4KGNvbG9yRnJvbSksIFV0aWxzLmlzQ29sb3JIZXgoY29sb3IpID8gY29sb3IgOiBVdGlscy5yZ2IyaGV4KGNvbG9yKSwgX3NwZWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuY2FsY3VsYXRlSGVhdG1hcERhdGFMYWJlbHMoe1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiB5MSxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgc2VyaWVzOiBoZWF0U2VyaWVzLFxuICAgICAgICAgICAgcmVjdEhlaWdodDogeURpdmlzaW9uLFxuICAgICAgICAgICAgcmVjdFdpZHRoOiB4RGl2aXNpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkYXRhTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbFNlcmllcy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSB4MSArIHhEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHkxID0geTEgKyB5RGl2aXNpb247XG4gICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgfSAvLyBhZGp1c3QgeWF4aXMgbGFiZWxzIGZvciBoZWF0bWFwXG5cblxuICAgICAgdmFyIHlBeGlzU2NhbGUgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgIHlBeGlzU2NhbGUudW5zaGlmdCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5QXhpc1NjYWxlLnB1c2goJycpO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQgPSB5QXhpc1NjYWxlO1xuICAgICAgdmFyIGRpdmlzb3IgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm9mZnNldFkgPSAtKGRpdmlzb3IgLyAyKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUhlYXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVIZWF0Q29sb3IoaSwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtqXTtcbiAgICAgIHZhciBoZWF0bWFwID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcDtcbiAgICAgIHZhciBzZXJpZXNOdW1iZXIgPSBoZWF0bWFwLmNvbG9yU2NhbGUuaW52ZXJzZSA/IGogOiBpO1xuICAgICAgdmFyIGNvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tzZXJpZXNOdW1iZXJdO1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh3Lmdsb2JhbHMuc2VyaWVzW2ldKSk7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHcuZ2xvYmFscy5zZXJpZXNbaV0pKTtcblxuICAgICAgaWYgKCFoZWF0bWFwLmRpc3RyaWJ1dGVkKSB7XG4gICAgICAgIG1pbiA9IHcuZ2xvYmFscy5taW5ZO1xuICAgICAgICBtYXggPSB3Lmdsb2JhbHMubWF4WTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoZWF0bWFwLmNvbG9yU2NhbGUubWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtaW4gPSBoZWF0bWFwLmNvbG9yU2NhbGUubWluIDwgdy5nbG9iYWxzLm1pblkgPyBoZWF0bWFwLmNvbG9yU2NhbGUubWluIDogdy5nbG9iYWxzLm1pblk7XG4gICAgICAgIG1heCA9IGhlYXRtYXAuY29sb3JTY2FsZS5tYXggPiB3Lmdsb2JhbHMubWF4WSA/IGhlYXRtYXAuY29sb3JTY2FsZS5tYXggOiB3Lmdsb2JhbHMubWF4WTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsID0gTWF0aC5hYnMobWF4KSArIE1hdGguYWJzKG1pbik7XG4gICAgICB2YXIgcGVyY2VudCA9IDEwMCAqIHZhbCAvICh0b3RhbCA9PT0gMCA/IHRvdGFsIC0gMC4wMDAwMDEgOiB0b3RhbCk7XG5cbiAgICAgIGlmIChoZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNvbG9yUmFuZ2UgPSBoZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzO1xuICAgICAgICBjb2xvclJhbmdlLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHZhbCA+PSByYW5nZS5mcm9tICYmIHZhbCA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgY29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgIG1pbiA9IHJhbmdlLmZyb207XG4gICAgICAgICAgICBtYXggPSByYW5nZS50bztcbiAgICAgICAgICAgIHRvdGFsID0gTWF0aC5hYnMobWF4KSArIE1hdGguYWJzKG1pbik7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTAwICogdmFsIC8gdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBwZXJjZW50OiBwZXJjZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVIZWF0bWFwRGF0YUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVIZWF0bWFwRGF0YUxhYmVscyhfcmVmKSB7XG4gICAgICB2YXIgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgaiA9IF9yZWYuaixcbiAgICAgICAgICBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICByZWN0SGVpZ2h0ID0gX3JlZi5yZWN0SGVpZ2h0LFxuICAgICAgICAgIHJlY3RXaWR0aCA9IF9yZWYucmVjdFdpZHRoO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIGxldCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eClcblxuICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBkYXRhTGFiZWxzID0gbmV3IERhdGFMYWJlbHModGhpcy5jdHgpO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcuZm9ybWF0dGVyO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9mZlggPSBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgIHZhciBvZmZZID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZO1xuICAgICAgICB2YXIgZGF0YUxhYmVsc1ggPSB4ICsgcmVjdFdpZHRoIC8gMiArIG9mZlg7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzWSA9IHkgKyByZWN0SGVpZ2h0IC8gMiArIHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpIC8gMyArIG9mZlk7XG4gICAgICAgIHZhciB0ZXh0ID0gZm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV1bal0sIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgeDogZGF0YUxhYmVsc1gsXG4gICAgICAgICAgeTogZGF0YUxhYmVsc1ksXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgcGFyZW50OiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IGRhdGFMYWJlbHNDb25maWdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlSGVhdE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlSGVhdE1hcChlbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3BlZWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgYW5pbWF0aW9ucy5hbmltYXRlUmVjdChlbCwge1xuICAgICAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9LCBzcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVIZWF0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRDb2xvcihlbCwgY29sb3JGcm9tLCBjb2xvclRvLCBzcGVlZCkge1xuICAgICAgZWwuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yRnJvbVxuICAgICAgfSkuYW5pbWF0ZShzcGVlZCkuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yVG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWF0TWFwO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgUGllIENsYXNzIGZvciBkcmF3aW5nIFBpZSAvIERvbnV0IENoYXJ0cy5cbiAqIEBtb2R1bGUgUGllXG4gKiovXG5cbnZhciBQaWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWUoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmNoYXJ0VHlwZSA9IHRoaXMudy5jb25maWcuY2hhcnQudHlwZTtcbiAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMuaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDtcbiAgICB0aGlzLmFuaW1CZWdpbkFyciA9IFswXTtcbiAgICB0aGlzLmFuaW1EdXIgPSAwO1xuICAgIHRoaXMuZG9udXREYXRhTGFiZWxzID0gdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQubGFiZWxzO1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMubGluZUNvbG9yQXJyID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgIT09IHVuZGVmaW5lZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIDogdy5nbG9iYWxzLmNvbG9ycztcbiAgICB0aGlzLmRlZmF1bHRTaXplID0gdy5nbG9iYWxzLnN2Z0hlaWdodCA8IHcuZ2xvYmFscy5zdmdXaWR0aCA/IHcuZ2xvYmFscy5zdmdIZWlnaHQgLSAzNSA6IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgdGhpcy5jZW50ZXJZID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDI7XG4gICAgdGhpcy5jZW50ZXJYID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgdGhpcy5mdWxsQW5nbGUgPSAzNjA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmRvbnV0U2l6ZSA9IDA7XG4gICAgdGhpcy5zbGljZUxhYmVscyA9IFtdO1xuICAgIHRoaXMucHJldlNlY3RvckFuZ2xlQXJyID0gW107IC8vIGZvciBkeW5hbWljIGFuaW1hdGlvbnNcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaWUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1waWUnXG4gICAgICB9KTtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VyaWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIENBTENVTEFURSBUSEUgVE9UQUxcbiAgICAgICAgdG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHNlcmllc1trXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWN0b3JBbmdsZUFyciA9IFtdOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCgpOyAvLyBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm8gZXJyb3IgaWYgdGhlcmUgaXMgbm8gZGF0YVxuXG4gICAgICBpZiAodG90YWwgPT09IDApIHtcbiAgICAgICAgdG90YWwgPSAwLjAwMDAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIEFOR0xFU1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmZ1bGxBbmdsZSAqIFV0aWxzLm5lZ1RvWmVybyhzZXJpZXNbaV0pIC8gdG90YWw7XG4gICAgICAgIHNlY3RvckFuZ2xlQXJyLnB1c2goYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBwcmV2VG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIFBSRVYgVE9UQUxcbiAgICAgICAgICBwcmV2VG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW19rXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNBbmdsZTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgLy8gQ0FMQ1VMQVRFIFRIRSBQUkVWSU9VUyBBTkdMRVNcbiAgICAgICAgICBwcmV2aW91c0FuZ2xlID0gdGhpcy5mdWxsQW5nbGUgKiBVdGlscy5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbX2ldKSAvIHByZXZUb3RhbDtcbiAgICAgICAgICB0aGlzLnByZXZTZWN0b3JBbmdsZUFyci5wdXNoKHByZXZpb3VzQW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyLjA1IC0gdy5jb25maWcuc3Ryb2tlLndpZHRoIC0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb251dFNpemUgPSB0aGlzLnNpemUgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuc2l6ZSkgLyAxMDA7XG4gICAgICB2YXIgc2NhbGVTaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucGllLmN1c3RvbVNjYWxlO1xuICAgICAgdmFyIGhhbGZXID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IGhhbGZXIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIgKiBzY2FsZVNpemU7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IGhhbGZIIC0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyICogc2NhbGVTaXplO1xuXG4gICAgICBpZiAodGhpcy5kb251dERhdGFMYWJlbHMuc2hvdykge1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMucmVuZGVySW5uZXJEYXRhTGFiZWxzKHRoaXMuZG9udXREYXRhTGFiZWxzLCB7XG4gICAgICAgICAgaG9sbG93U2l6ZTogdGhpcy5kb251dFNpemUsXG4gICAgICAgICAgY2VudGVyWDogdGhpcy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmRvbnV0RGF0YUxhYmVscy5zaG93LFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXG4gICAgICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0LmFkZChkYXRhTGFiZWxzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW5uZXIgY2lyY2xlIGFuZCBhZGQgc29tZSB0ZXh0IHRvIGl0XG4gICAgICAgIHZhciBjaXJjbGUgPSBncmFwaGljcy5kcmF3Q2lyY2xlKHRoaXMuZG9udXRTaXplKTtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgIGN4OiB0aGlzLmNlbnRlclgsXG4gICAgICAgICAgY3k6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuYmFja2dyb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGNpcmNsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbEcgPSBzZWxmLmRyYXdBcmNzKHNlY3RvckFuZ2xlQXJyLCBzZXJpZXMpOyAvLyBhZGQgc2xpY2UgZGF0YUxhYmVscyBhdCB0aGUgZW5kXG5cbiAgICAgIHRoaXMuc2xpY2VMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICBlbEcuYWRkKHMpO1xuICAgICAgfSk7XG4gICAgICBlbFNlcmllcy5hdHRyKHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSAtIDUsIFwiKSBzY2FsZShcIikuY29uY2F0KHNjYWxlU2l6ZSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKHtcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVYJzogdHJhbnNsYXRlWCxcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVZJzogdHJhbnNsYXRlWSAtIDI1XG4gICAgICB9KTtcbiAgICAgIGVsU2VyaWVzLmFkZChlbEcpO1xuICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gY29yZSBmdW5jdGlvbiBmb3IgZHJhd2luZyBwaWUgYXJjc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0FyY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Moc2VjdG9yQW5nbGVBcnIsIHNlcmllcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gMDtcbiAgICAgIHZhciBwcmV2U3RhcnRBbmdsZSA9IDA7XG4gICAgICB2YXIgZW5kQW5nbGUgPSAwO1xuICAgICAgdmFyIHByZXZFbmRBbmdsZSA9IDA7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gdy5jb25maWcuc3Ryb2tlLnNob3cgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGggOiAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3RvckFuZ2xlQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGlmKHNlY3RvckFuZ2xlQXJyW2ldPjApIHtcbiAgICAgICAgdmFyIGVsUGllQXJjID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcGllLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpLFxuICAgICAgICAgIGlkOiAnYXBleGNoYXJ0cy1zZXJpZXMtJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGQoZWxQaWVBcmMpO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIHByZXZTdGFydEFuZ2xlID0gcHJldkVuZEFuZ2xlO1xuICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgcHJldkVuZEFuZ2xlID0gcHJldlN0YXJ0QW5nbGUgKyB0aGlzLnByZXZTZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgdmFyIGFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgICAgIH0pOyAvLyBhZGRpdGlvbmFseSwgcGFzcyBzaXplIGZvciBncmFkaWVudCBkcmF3aW5nIGluIHRoZSBmaWxsUGF0aCBmdW5jdGlvblxuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRDaGFuZ2VkUGF0aChwcmV2U3RhcnRBbmdsZSwgcHJldkVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVsUGF0aCA9IGdyYXBoaWNzLmRyYXdQYXRoKHtcbiAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5saW5lQ29sb3JBcnIgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMubGluZUNvbG9yQXJyW2ldIDogdGhpcy5saW5lQ29sb3JBcnIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IHcuY29uZmlnLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICBjbGFzc2VzOiAnYXBleGNoYXJ0cy1waWUtYXJlYSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICBpZDogJ2FwZXhjaGFydHMtcGllLXNsaWNlLScgKyBpLFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIGo6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIHNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZExpc3RlbmVycyhlbFBhdGgsIHRoaXMuZG9udXREYXRhTGFiZWxzKTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAnZGF0YTphbmdsZSc6IGFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0YXJ0QW5nbGUnOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0cm9rZVdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAnZGF0YTp2YWx1ZSc6IHNlcmllc1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IFV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4odGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMuc2l6ZSAvIDEuMjUgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICBsYWJlbFBvc2l0aW9uID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgKHRoaXMuc2l6ZSArIHRoaXMuZG9udXRTaXplKSAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxQaWVBcmMuYWRkKGVsUGF0aCk7IC8vIEFuaW1hdGlvbiBjb2RlIHN0YXJ0c1xuXG4gICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyB0aGlzLmZ1bGxBbmdsZSAqIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgdGhpcy5hbmltRHVyID0gZHVyICsgdGhpcy5hbmltRHVyO1xuICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0gJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldlN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldkVuZEFuZ2xlOiBwcmV2RW5kQW5nbGUsXG4gICAgICAgICAgICBhbmltYXRlU3RhcnRpbmdQb3M6IHRydWUsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgYW5pbUJlZ2luQXJyOiB0aGlzLmFuaW1CZWdpbkFycixcbiAgICAgICAgICAgIGR1cjogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHRvdGFsSXRlbXM6IHNlY3RvckFuZ2xlQXJyLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgICAgZHVyOiBkdXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhbmltYXRpb24gY29kZSBlbmRzXG5cblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLmV4cGFuZE9uQ2xpY2spIHtcbiAgICAgICAgICBlbFBhdGguY2xpY2sodGhpcy5waWVDbGlja2VkLmJpbmQodGhpcywgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciB4UG9zID0gbGFiZWxQb3NpdGlvbi54O1xuICAgICAgICAgIHZhciB5UG9zID0gbGFiZWxQb3NpdGlvbi55O1xuICAgICAgICAgIHZhciB0ZXh0ID0gMTAwICogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKyAnJSc7XG5cbiAgICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1BlcmNlbnRbaV1bMF0sIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9yZUNvbG9yID0gdy5nbG9iYWxzLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzW2ldO1xuICAgICAgICAgICAgdmFyIGVsUGllTGFiZWwgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICAgIHg6IHhQb3MsXG4gICAgICAgICAgICAgIHk6IHlQb3MsXG4gICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgICB2YXIgdGV4dFNoYWRvdyA9IHcuY29uZmlnLmRhdGFMYWJlbHMuZHJvcFNoYWRvdztcblxuICAgICAgICAgICAgICB2YXIgX2ZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgICAgX2ZpbHRlcnMuZHJvcFNoYWRvdyhlbFBpZUxhYmVsLCB0ZXh0U2hhZG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxQaWVMYWJlbC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtcGllLWxhYmVsJyk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGUgJiYgdy5nbG9iYWxzLnJlc2l6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVsUGllTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXBpZS1sYWJlbC1kZWxheScpO1xuICAgICAgICAgICAgICBlbFBpZUxhYmVsLm5vZGUuc3R5bGUuYW5pbWF0aW9uRGVsYXkgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkIC8gOTQwICsgJ3MnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNsaWNlTGFiZWxzLnB1c2goZWxQaWVMYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhlbFBhdGgsIGRhdGFMYWJlbHMpIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7IC8vIGFwcGVuZCBmaWx0ZXJzIG9uIG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmVcblxuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5wcmludERhdGFMYWJlbHNJbm5lci5iaW5kKHRoaXMsIGVsUGF0aC5ub2RlLCBkYXRhTGFiZWxzKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCBlbFBhdGgpKTtcbiAgICAgIGVsUGF0aC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnJldmVydERhdGFMYWJlbHNJbm5lci5iaW5kKHRoaXMsIGVsUGF0aC5ub2RlLCBkYXRhTGFiZWxzKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnByaW50RGF0YUxhYmVsc0lubmVyLmJpbmQodGhpcywgZWxQYXRoLm5vZGUsIGRhdGFMYWJlbHMpKTtcbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIG90aGVyIGNpcmNsZSBjaGFydHMgdG9vXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVBhdGhzKGVsLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgYW5nbGUgPSBvcHRzLmVuZEFuZ2xlIC0gb3B0cy5zdGFydEFuZ2xlO1xuICAgICAgdmFyIHByZXZBbmdsZSA9IGFuZ2xlO1xuICAgICAgdmFyIGZyb21TdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuICAgICAgdmFyIHRvU3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcblxuICAgICAgaWYgKG9wdHMucHJldlN0YXJ0QW5nbGUgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnByZXZFbmRBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyb21TdGFydEFuZ2xlID0gb3B0cy5wcmV2RW5kQW5nbGU7XG4gICAgICAgIHByZXZBbmdsZSA9IG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuaSA9PT0gdy5jb25maWcuc2VyaWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gc29tZSBhZGp1c3RtZW50cyBmb3IgdGhlIGxhc3Qgb3ZlcmxhcHBpbmcgcGF0aHNcbiAgICAgICAgaWYgKGFuZ2xlICsgdG9TdGFydEFuZ2xlID4gdGhpcy5mdWxsQW5nbGUpIHtcbiAgICAgICAgICBvcHRzLmVuZEFuZ2xlID0gb3B0cy5lbmRBbmdsZSAtIChhbmdsZSArIHRvU3RhcnRBbmdsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUgPCB0aGlzLmZ1bGxBbmdsZSkge1xuICAgICAgICAgIG9wdHMuZW5kQW5nbGUgPSBvcHRzLmVuZEFuZ2xlICsgKHRoaXMuZnVsbEFuZ2xlIC0gKGFuZ2xlICsgdG9TdGFydEFuZ2xlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID09PSB0aGlzLmZ1bGxBbmdsZSkgYW5nbGUgPSB0aGlzLmZ1bGxBbmdsZSAtIDAuMDE7XG4gICAgICBtZS5hbmltYXRlQXJjKGVsLCBmcm9tU3RhcnRBbmdsZSwgdG9TdGFydEFuZ2xlLCBhbmdsZSwgcHJldkFuZ2xlLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUFyY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQXJjKGVsLCBmcm9tU3RhcnRBbmdsZSwgdG9TdGFydEFuZ2xlLCBhbmdsZSwgcHJldkFuZ2xlLCBvcHRzKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2l6ZSA9IG1lLnNpemU7XG5cbiAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICBzaXplID0gb3B0cy5zaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGlzTmFOKGZyb21TdGFydEFuZ2xlKSB8fCBpc05hTihwcmV2QW5nbGUpKSB7XG4gICAgICAgIGZyb21TdGFydEFuZ2xlID0gdG9TdGFydEFuZ2xlO1xuICAgICAgICBwcmV2QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgb3B0cy5kdXIgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VyckFuZ2xlID0gYW5nbGU7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHRvU3RhcnRBbmdsZTtcbiAgICAgIHZhciBmcm9tQW5nbGUgPSBmcm9tU3RhcnRBbmdsZSAtIHRvU3RhcnRBbmdsZTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCAmJiBvcHRzLnNob3VsZFNldFByZXZQYXRocykge1xuICAgICAgICAvLyB0byBhdm9pZCBmbGlja2VyaW5nLCBzZXQgcHJldiBwYXRoIGZpcnN0IGFuZCB0aGVuIHdlIHdpbGwgYW5pbWF0ZSBmcm9tIHRoZXJlXG4gICAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgICBtZTogbWUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBhbmdsZTogcHJldkFuZ2xlLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIGQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmR1ciAhPT0gMCkge1xuICAgICAgICBlbC5hbmltYXRlKG9wdHMuZHVyLCB3Lmdsb2JhbHMuZWFzaW5nLCBvcHRzLmFuaW1CZWdpbkFycltvcHRzLmldKS5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSgzMDApLmF0dHIoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdy5jb25maWcuc3Ryb2tlLndpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICB9KS5kdXJpbmcoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIGN1cnJBbmdsZSA9IGZyb21BbmdsZSArIChhbmdsZSAtIGZyb21BbmdsZSkgKiBwb3M7XG5cbiAgICAgICAgICBpZiAob3B0cy5hbmltYXRlU3RhcnRpbmdQb3MpIHtcbiAgICAgICAgICAgIGN1cnJBbmdsZSA9IHByZXZBbmdsZSArIChhbmdsZSAtIHByZXZBbmdsZSkgKiBwb3M7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZnJvbVN0YXJ0QW5nbGUgLSBwcmV2QW5nbGUgKyAodG9TdGFydEFuZ2xlIC0gKGZyb21TdGFydEFuZ2xlIC0gcHJldkFuZ2xlKSkgKiBwb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGFuZ2xlOiBjdXJyQW5nbGUsXG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWwubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGF0aE9yaWcnLCBwYXRoKTtcbiAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgIGQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gbWUuZ2V0UGllUGF0aCh7XG4gICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFvcHRzLmlzVHJhY2spIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGF0aE9yaWcnLCBwYXRoKTtcbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgZDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGllQ2xpY2tlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWVDbGlja2VkKGkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBwYXRoO1xuICAgICAgdmFyIHNpemUgPSBtZS5zaXplICsgMztcbiAgICAgIHZhciBlbFBhdGggPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdCgnI2FwZXhjaGFydHMtcGllLXNsaWNlLScgKyBpKS5tZW1iZXJzWzBdO1xuICAgICAgdmFyIHBhdGhGcm9tID0gZWxQYXRoLmF0dHIoJ2QnKTtcblxuICAgICAgaWYgKGVsUGF0aC5hdHRyKCdkYXRhOnBpZUNsaWNrZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICAnZGF0YTpwaWVDbGlja2VkJzogJ2ZhbHNlJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9yaWdQYXRoID0gZWxQYXRoLmF0dHIoJ2RhdGE6cGF0aE9yaWcnKTtcbiAgICAgICAgZWxQYXRoLmF0dHIoe1xuICAgICAgICAgIGQ6IG9yaWdQYXRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNldCBhbGwgZWxlbXNcbiAgICAgICAgdmFyIGFsbEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXBpZS1hcmVhJyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYWxsRWxzLCBmdW5jdGlvbiAocGllU2xpY2UpIHtcbiAgICAgICAgICBwaWVTbGljZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGllQ2xpY2tlZCcsICdmYWxzZScpO1xuICAgICAgICAgIHZhciBvcmlnUGF0aCA9IHBpZVNsaWNlLmdldEF0dHJpYnV0ZSgnZGF0YTpwYXRoT3JpZycpO1xuICAgICAgICAgIHBpZVNsaWNlLnNldEF0dHJpYnV0ZSgnZCcsIG9yaWdQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUGF0aC5hdHRyKCdkYXRhOnBpZUNsaWNrZWQnLCAndHJ1ZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHBhcnNlSW50KGVsUGF0aC5hdHRyKCdkYXRhOnN0YXJ0QW5nbGUnKSk7XG4gICAgICB2YXIgYW5nbGUgPSBwYXJzZUludChlbFBhdGguYXR0cignZGF0YTphbmdsZScpKTtcbiAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgbWU6IG1lLFxuICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICAgIH0pO1xuICAgICAgaWYgKGFuZ2xlID09PSAzNjApIHJldHVybjtcbiAgICAgIGVsUGF0aC5wbG90KHBhdGgpLmFuaW1hdGUoMSkucGxvdChwYXRoRnJvbSkuYW5pbWF0ZSgxMDApLnBsb3QocGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYW5nZWRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZWRQYXRoKHByZXZTdGFydEFuZ2xlLCBwcmV2RW5kQW5nbGUpIHtcbiAgICAgIHZhciBwYXRoID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLmR5bmFtaWNBbmltICYmIHRoaXMudy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLmdldFBpZVBhdGgoe1xuICAgICAgICAgIG1lOiB0aGlzLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgIGFuZ2xlOiBwcmV2RW5kQW5nbGUgLSBwcmV2U3RhcnRBbmdsZSxcbiAgICAgICAgICBzaXplOiB0aGlzLnNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaWVQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpZVBhdGgoX3JlZikge1xuICAgICAgdmFyIG1lID0gX3JlZi5tZSxcbiAgICAgICAgICBzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgICAgICBzaXplID0gX3JlZi5zaXplO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIHZhciBzdGFydERlZyA9IHN0YXJ0QW5nbGU7XG4gICAgICB2YXIgc3RhcnRSYWRpYW5zID0gTWF0aC5QSSAqIChzdGFydERlZyAtIDkwKSAvIDE4MDtcbiAgICAgIHZhciBlbmREZWcgPSBhbmdsZSArIHN0YXJ0QW5nbGU7XG4gICAgICBpZiAoTWF0aC5jZWlsKGVuZERlZykgPj0gMzYwKSBlbmREZWcgPSAzNTkuOTk7XG4gICAgICB2YXIgZW5kUmFkaWFucyA9IE1hdGguUEkgKiAoZW5kRGVnIC0gOTApIC8gMTgwO1xuICAgICAgdmFyIHgxID0gbWUuY2VudGVyWCArIHNpemUgKiBNYXRoLmNvcyhzdGFydFJhZGlhbnMpO1xuICAgICAgdmFyIHkxID0gbWUuY2VudGVyWSArIHNpemUgKiBNYXRoLnNpbihzdGFydFJhZGlhbnMpO1xuICAgICAgdmFyIHgyID0gbWUuY2VudGVyWCArIHNpemUgKiBNYXRoLmNvcyhlbmRSYWRpYW5zKTtcbiAgICAgIHZhciB5MiA9IG1lLmNlbnRlclkgKyBzaXplICogTWF0aC5zaW4oZW5kUmFkaWFucyk7XG4gICAgICB2YXIgc3RhcnRJbm5lciA9IFV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4obWUuY2VudGVyWCwgbWUuY2VudGVyWSwgbWUuZG9udXRTaXplLCBlbmREZWcpO1xuICAgICAgdmFyIGVuZElubmVyID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbihtZS5jZW50ZXJYLCBtZS5jZW50ZXJZLCBtZS5kb251dFNpemUsIHN0YXJ0RGVnKTtcbiAgICAgIHZhciBsYXJnZUFyYyA9IGFuZ2xlID4gMTgwID8gMSA6IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgIHBhdGggPSBbJ00nLCB4MSwgeTEsICdBJywgc2l6ZSwgc2l6ZSwgMCwgbGFyZ2VBcmMsIDEsIHgyLCB5MiwgJ0wnLCBzdGFydElubmVyLngsIHN0YXJ0SW5uZXIueSwgJ0EnLCBtZS5kb251dFNpemUsIG1lLmRvbnV0U2l6ZSwgMCwgbGFyZ2VBcmMsIDAsIGVuZElubmVyLngsIGVuZElubmVyLnksICdMJywgeDEsIHkxLCAneiddLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScpIHtcbiAgICAgICAgcGF0aCA9IFsnTScsIHgxLCB5MSwgJ0EnLCBzaXplLCBzaXplLCAwLCBsYXJnZUFyYywgMSwgeDIsIHkyLCAnTCcsIG1lLmNlbnRlclgsIG1lLmNlbnRlclksICdMJywgeDEsIHkxXS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gWydNJywgeDEsIHkxLCAnQScsIHNpemUsIHNpemUsIDAsIGxhcmdlQXJjLCAxLCB4MiwgeTJdLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlcklubmVyRGF0YUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbm5lckRhdGFMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgb3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzLWdyb3VwJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQob3B0cy50cmFuc2xhdGVYID8gb3B0cy50cmFuc2xhdGVYIDogMCwgXCIsIFwiKS5jb25jYXQob3B0cy50cmFuc2xhdGVZID8gb3B0cy50cmFuc2xhdGVZIDogMCwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBzaG93VG90YWwgPSBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLnNob3c7XG4gICAgICBnLm5vZGUuc3R5bGUub3BhY2l0eSA9IG9wdHMub3BhY2l0eTtcbiAgICAgIHZhciB4ID0gb3B0cy5jZW50ZXJYO1xuICAgICAgdmFyIHkgPSBvcHRzLmNlbnRlclk7XG4gICAgICB2YXIgbGFiZWxDb2xvciwgdmFsdWVDb2xvcjtcblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcubmFtZS5jb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxDb2xvciA9IGRhdGFMYWJlbHNDb25maWcubmFtZS5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcudmFsdWUuY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZUNvbG9yID0gdy5jb25maWcuY2hhcnQuZm9yZUNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVDb2xvciA9IGRhdGFMYWJlbHNDb25maWcudmFsdWUuY29sb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9ybWF0dGVyO1xuICAgICAgdmFyIHZhbCA9ICcnO1xuICAgICAgdmFyIG5hbWUgPSAnJztcblxuICAgICAgaWYgKHNob3dUb3RhbCkge1xuICAgICAgICBsYWJlbENvbG9yID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5jb2xvcjtcbiAgICAgICAgbmFtZSA9IGRhdGFMYWJlbHNDb25maWcudG90YWwubGFiZWw7XG4gICAgICAgIHZhbCA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyKHcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1swXSwgdyk7XG4gICAgICAgICAgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLnNob3cpIHtcbiAgICAgICAgdmFyIGVsTGFiZWwgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5ICsgcGFyc2VJbnQoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLm9mZnNldFkpLFxuICAgICAgICAgIHRleHQ6IG5hbWUsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgZm9yZUNvbG9yOiBsYWJlbENvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmZvbnRGYW1pbHlcbiAgICAgICAgfSk7XG4gICAgICAgIGVsTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCcpO1xuICAgICAgICBnLmFkZChlbExhYmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFMYWJlbHNDb25maWcudmFsdWUuc2hvdykge1xuICAgICAgICB2YXIgdmFsT2Zmc2V0ID0gZGF0YUxhYmVsc0NvbmZpZy5uYW1lLnNob3cgPyBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLm9mZnNldFkpICsgMTYgOiBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLm9mZnNldFk7XG4gICAgICAgIHZhciBlbFZhbHVlID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSArIHZhbE9mZnNldCxcbiAgICAgICAgICB0ZXh0OiB2YWwsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgZm9yZUNvbG9yOiB2YWx1ZUNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLnZhbHVlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9udEZhbWlseVxuICAgICAgICB9KTtcbiAgICAgICAgZWxWYWx1ZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlJyk7XG4gICAgICAgIGcuYWRkKGVsVmFsdWUpO1xuICAgICAgfSAvLyBmb3IgYSBtdWx0aS1zZXJpZXMgY2lyY2xlIGNoYXJ0LCB3ZSBuZWVkIHRvIHNob3cgdG90YWwgdmFsdWUgaW5zdGVhZCBvZiBmaXJzdCBzZXJpZXMgbGFiZWxzXG5cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSB2YWx1ZSBvZiB0aGF0IHNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCAtIE9wdGlvbmFsIGVsIChpbmRpY2F0ZXMgd2hpY2ggc2VyaWVzIHdhcyBob3ZlcmVkL2NsaWNrZWQpLiBJZiB0aGlzIHBhcmFtIGlzIG5vdCBwcmVzZW50LCBtZWFucyB3ZSBuZWVkIHRvIHNob3cgdG90YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50SW5uZXJMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRJbm5lckxhYmVscyhsYWJlbHNDb25maWcsIG5hbWUsIHZhbCwgZWwpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxhYmVsQ29sb3I7XG5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICBpZiAobGFiZWxzQ29uZmlnLm5hbWUuY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhYmVsQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW3BhcnNlSW50KGVsLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gbGFiZWxzQ29uZmlnLm5hbWUuY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEgJiYgbGFiZWxzQ29uZmlnLnRvdGFsLnNob3cpIHtcbiAgICAgICAgICBsYWJlbENvbG9yID0gbGFiZWxzQ29uZmlnLnRvdGFsLmNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVsLWxhYmVsJyk7XG4gICAgICB2YXIgZWxWYWx1ZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWRhdGFsYWJlbC12YWx1ZScpO1xuICAgICAgdmFyIGxiRm9ybWF0dGVyID0gbGFiZWxzQ29uZmlnLnZhbHVlLmZvcm1hdHRlcjtcbiAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgdyk7IC8vIHdlIG5lZWQgdG8gc2hvdyBUb3RhbCBWYWwgLSBzbyBnZXQgdGhlIGZvcm1hdHRlciBvZiBpdFxuXG4gICAgICBpZiAoIWVsICYmIHR5cGVvZiBsYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IGxhYmVsc0NvbmZpZy50b3RhbC5mb3JtYXR0ZXIodyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbExhYmVsICE9PSBudWxsKSB7XG4gICAgICAgIGVsTGFiZWwudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlbFZhbHVlLnRleHRDb250ZW50ID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMYWJlbCAhPT0gbnVsbCkge1xuICAgICAgICBlbExhYmVsLnN0eWxlLmZpbGwgPSBsYWJlbENvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmludERhdGFMYWJlbHNJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludERhdGFMYWJlbHNJbm5lcihlbCwgZGF0YUxhYmVsc0NvbmZpZykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhOnZhbHVlJyk7XG4gICAgICB2YXIgbmFtZSA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lc1twYXJzZUludChlbC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMV07XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5wcmludElubmVyTGFiZWxzKGRhdGFMYWJlbHNDb25maWcsIG5hbWUsIHZhbCwgZWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YUxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVscy1ncm91cCcpO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0dyb3VwICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGFMYWJlbHNHcm91cC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0RGF0YUxhYmVsc0lubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydERhdGFMYWJlbHNJbm5lcihlbCwgZGF0YUxhYmVsc0NvbmZpZykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZGF0YUxhYmVsc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVscy1ncm91cCcpO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5zaG93ICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICAgIHBpZS5wcmludElubmVyTGFiZWxzKGRhdGFMYWJlbHNDb25maWcsIGRhdGFMYWJlbHNDb25maWcudG90YWwubGFiZWwsIGRhdGFMYWJlbHNDb25maWcudG90YWwuZm9ybWF0dGVyKHcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbMF07XG5cbiAgICAgICAgICAgIHZhciBfZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiI2FwZXhjaGFydHMtcGllLXNsaWNlLVwiLmNvbmNhdChpbmRleCkpO1xuXG4gICAgICAgICAgICB0aGlzLnByaW50RGF0YUxhYmVsc0lubmVyKF9lbCwgZGF0YUxhYmVsc0NvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNHcm91cC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cy5sZW5ndGggPT09IDAgfHwgZGF0YUxhYmVsc0dyb3VwICE9PSBudWxsICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGRhdGFMYWJlbHNHcm91cC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaWU7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSYWRhciBDbGFzcyBmb3IgU3BpZGVyL1JhZGFyIENoYXJ0cy5cbiAqIEBtb2R1bGUgUmFkYXJcbiAqKi9cblxudmFyIFJhZGFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmFkYXIoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuY2hhcnRUeXBlID0gdGhpcy53LmNvbmZpZy5jaGFydC50eXBlO1xuICAgIHRoaXMuaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICB0aGlzLmR5bmFtaWNBbmltID0gdGhpcy5pbml0aWFsQW5pbSAmJiB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkO1xuICAgIHRoaXMuYW5pbUR1ciA9IDA7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgdGhpcy5saW5lQ29sb3JBcnIgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyAhPT0gdW5kZWZpbmVkID8gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgOiB3Lmdsb2JhbHMuY29sb3JzO1xuICAgIHRoaXMuZGVmYXVsdFNpemUgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IDwgdy5nbG9iYWxzLnN2Z1dpZHRoID8gdy5nbG9iYWxzLnN2Z0hlaWdodCAtIDM1IDogdy5nbG9iYWxzLmdyaWRXaWR0aDtcbiAgICB0aGlzLm1heFZhbHVlID0gdGhpcy53Lmdsb2JhbHMubWF4WTtcbiAgICB0aGlzLnBvbHlnb25zID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkYXIucG9seWdvbnM7XG4gICAgdGhpcy5tYXhMYWJlbFdpZHRoID0gMjA7XG4gICAgdmFyIGxvbmdlc3RMYWJlbCA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9KVswXTtcbiAgICB2YXIgbGFiZWxXaWR0aCA9IHRoaXMuZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGxvbmdlc3RMYWJlbCwgdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSk7XG4gICAgdGhpcy5zaXplID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDIuMSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1ciAtIGxhYmVsV2lkdGgud2lkdGggLyAxLjc1O1xuXG4gICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGFyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkYXIuc2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnQgPSBbXTtcbiAgICB0aGlzLmRhdGFSYWRpdXMgPSBbXTtcbiAgICB0aGlzLmFuZ2xlQXJyID0gW107XG4gICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFkYXIsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgYWxsU2VyaWVzID0gW107XG4gICAgICB0aGlzLmRhdGFQb2ludHNMZW4gPSBzZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDtcbiAgICAgIHRoaXMuZGlzQW5nbGUgPSBNYXRoLlBJICogMiAvIHRoaXMuZGF0YVBvaW50c0xlbjtcbiAgICAgIHZhciBoYWxmVyA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgdmFyIGhhbGZIID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyO1xuICAgICAgdmFyIHRyYW5zbGF0ZVggPSBoYWxmVztcbiAgICAgIHZhciB0cmFuc2xhdGVZID0gaGFsZkg7XG4gICAgICB2YXIgcmV0ID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMnLFxuICAgICAgICAnZGF0YTppbm5lclRyYW5zbGF0ZVgnOiB0cmFuc2xhdGVYLFxuICAgICAgICAnZGF0YTppbm5lclRyYW5zbGF0ZVknOiB0cmFuc2xhdGVZIC0gMjUsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZVggfHwgMCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSB8fCAwLCBcIilcIilcbiAgICAgIH0pO1xuICAgICAgdmFyIGRhdGFQb2ludHNQb3MgPSBbXTtcbiAgICAgIHZhciBlbFBvaW50c01haW4gPSBudWxsO1xuICAgICAgdGhpcy55YXhpc0xhYmVscyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMnXG4gICAgICB9KTtcbiAgICAgIHNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG4gICAgICAgIHZhciBlbFNlcmllcyA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKCkuYXR0cih7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaV0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuZGF0YVJhZGl1c09mUGVyY2VudFtpXSA9IFtdO1xuICAgICAgICBfdGhpcy5kYXRhUmFkaXVzW2ldID0gW107XG4gICAgICAgIF90aGlzLmFuZ2xlQXJyW2ldID0gW107XG4gICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoZHYsIGopIHtcbiAgICAgICAgICBfdGhpcy5kYXRhUmFkaXVzT2ZQZXJjZW50W2ldW2pdID0gZHYgLyBfdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgICBfdGhpcy5kYXRhUmFkaXVzW2ldW2pdID0gX3RoaXMuZGF0YVJhZGl1c09mUGVyY2VudFtpXVtqXSAqIF90aGlzLnNpemU7XG4gICAgICAgICAgX3RoaXMuYW5nbGVBcnJbaV1bal0gPSBqICogX3RoaXMuZGlzQW5nbGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhUG9pbnRzUG9zID0gX3RoaXMuZ2V0RGF0YVBvaW50c1BvcyhfdGhpcy5kYXRhUmFkaXVzW2ldLCBfdGhpcy5hbmdsZUFycltpXSk7XG5cbiAgICAgICAgdmFyIHBhdGhzID0gX3RoaXMuY3JlYXRlUGF0aHMoZGF0YVBvaW50c1Bvcywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9KTsgLy8gcG9pbnRzXG5cblxuICAgICAgICBlbFBvaW50c01haW4gPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzLXdyYXAgaGlkZGVuJ1xuICAgICAgICB9KTtcbiAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICBlbDogZWxQb2ludHNNYWluLm5vZGUsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHJlYWxJbmRleDogaSxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogaSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFwZXhjaGFydHMtcmFkYXJcIixcbiAgICAgICAgICBpZDogXCJhcGV4Y2hhcnRzLXJhZGFyXCIsXG4gICAgICAgICAgc2hvdWxkQ2xpcFRvR3JpZDogZmFsc2UsXG4gICAgICAgICAgYmluZEV2ZW50c09uUGF0aHM6IGZhbHNlLFxuICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbaV0sXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcDogdy5jb25maWcuc3Ryb2tlLmxpbmVDYXBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhdGhGcm9tID0gbnVsbDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhdGhGcm9tID0gX3RoaXMuZ2V0UGF0aEZyb20oaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxpbmVQYXRoc1RvLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHJlbmRlcmVkTGluZVBhdGggPSBfdGhpcy5ncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tID09PSBudWxsID8gcGF0aHMubGluZVBhdGhzRnJvbVtwXSA6IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5saW5lUGF0aHNUb1twXSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS53aWR0aCkgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGhbaV0gOiB3LmNvbmZpZy5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRMaW5lUGF0aCk7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IGlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciByZW5kZXJlZEFyZWFQYXRoID0gX3RoaXMuZ3JhcGhpY3MucmVuZGVyUGF0aHMoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMsIHtcbiAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSA9PT0gbnVsbCA/IHBhdGhzLmFyZWFQYXRoc0Zyb21bcF0gOiBwYXRoRnJvbSxcbiAgICAgICAgICAgIHBhdGhUbzogcGF0aHMuYXJlYVBhdGhzVG9bcF0sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgIGZpbGw6IHBhdGhGaWxsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyhfdGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG4gICAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3cocmVuZGVyZWRBcmVhUGF0aCwgX29iamVjdFNwcmVhZCh7fSwgc2hhZG93LCB7XG4gICAgICAgICAgICAgIG5vVXNlclNwYWNlT25Vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRBcmVhUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNqLCBqKSB7XG4gICAgICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2VycyhfdGhpcy5jdHgpO1xuICAgICAgICAgIHZhciBvcHRzID0gbWFya2Vycy5nZXRNYXJrZXJDb25maWcoJ2FwZXhjaGFydHMtbWFya2VyJywgaSk7XG5cbiAgICAgICAgICB2YXIgcG9pbnQgPSBfdGhpcy5ncmFwaGljcy5kcmF3TWFya2VyKGRhdGFQb2ludHNQb3Nbal0ueCwgZGF0YVBvaW50c1Bvc1tqXS55LCBvcHRzKTtcblxuICAgICAgICAgIHBvaW50LmF0dHIoJ3JlbCcsIGopO1xuICAgICAgICAgIHBvaW50LmF0dHIoJ2onLCBqKTtcbiAgICAgICAgICBwb2ludC5hdHRyKCdpbmRleCcsIGkpO1xuICAgICAgICAgIHBvaW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJywgb3B0cy5wU2l6ZSk7XG5cbiAgICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCkge1xuICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChwb2ludCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICAgIGVsU2VyaWVzLmFkZChlbFBvaW50c01haW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2VyaWVzLnB1c2goZWxTZXJpZXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRyYXdQb2x5Z29ucyh7XG4gICAgICAgIHBhcmVudDogcmV0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuZHJhd0xhYmVscygpO1xuICAgICAgICByZXQuYWRkKGRhdGFMYWJlbHMpO1xuICAgICAgfVxuXG4gICAgICByZXQuYWRkKHRoaXMueWF4aXNMYWJlbHMpO1xuICAgICAgYWxsU2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVsUykge1xuICAgICAgICByZXQuYWRkKGVsUyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQb2x5Z29uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9seWdvbnMob3B0cykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgdmFyIHlheGlzVGV4dHMgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgdmFyIGxheWVycyA9IHlheGlzVGV4dHMubGVuZ3RoO1xuICAgICAgdmFyIHJhZGl1c1NpemVzID0gW107XG4gICAgICB2YXIgbGF5ZXJEaXMgPSB0aGlzLnNpemUgLyAobGF5ZXJzIC0gMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzOyBpKyspIHtcbiAgICAgICAgcmFkaXVzU2l6ZXNbaV0gPSBsYXllckRpcyAqIGk7XG4gICAgICB9XG5cbiAgICAgIHJhZGl1c1NpemVzLnJldmVyc2UoKTtcbiAgICAgIHZhciBwb2x5Z29uU3RyaW5ncyA9IFtdO1xuICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICByYWRpdXNTaXplcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpdXNTaXplLCByKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gX3RoaXMyLmdldFBvbHlnb25Qb3MocmFkaXVzU2l6ZSk7XG5cbiAgICAgICAgdmFyIHN0cmluZyA9ICcnO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBfdGhpczIuZ3JhcGhpY3MuZHJhd0xpbmUocC54LCBwLnksIDAsIDAsIEFycmF5LmlzQXJyYXkoX3RoaXMyLnBvbHlnb25zLmNvbm5lY3RvckNvbG9ycykgPyBfdGhpczIucG9seWdvbnMuY29ubmVjdG9yQ29sb3JzW2ldIDogX3RoaXMyLnBvbHlnb25zLmNvbm5lY3RvckNvbG9ycyk7XG5cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIF90aGlzMi55YXhpc0xhYmVsc1RleHRzUG9zLnB1c2goe1xuICAgICAgICAgICAgICB4OiBwLngsXG4gICAgICAgICAgICAgIHk6IHAueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyaW5nICs9IHAueCArICcsJyArIHAueSArICcgJztcbiAgICAgICAgfSk7XG4gICAgICAgIHBvbHlnb25TdHJpbmdzLnB1c2goc3RyaW5nKTtcbiAgICAgIH0pO1xuICAgICAgcG9seWdvblN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3JzID0gX3RoaXMyLnBvbHlnb25zLnN0cm9rZUNvbG9ycztcblxuICAgICAgICB2YXIgcG9seWdvbiA9IF90aGlzMi5ncmFwaGljcy5kcmF3UG9seWdvbihwLCBBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9ycykgPyBzdHJva2VDb2xvcnNbaV0gOiBzdHJva2VDb2xvcnMsIHcuZ2xvYmFscy5yYWRhclBvbHlnb25zLmZpbGwuY29sb3JzW2ldKTtcblxuICAgICAgICBwYXJlbnQuYWRkKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHBhcmVudC5hZGQobCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnNob3cpIHtcbiAgICAgICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICB2YXIgeVRleHQgPSBfdGhpczIuZHJhd1lBeGlzVGV4dChwLngsIHAueSwgaSwgeWF4aXNUZXh0c1tpXSk7XG5cbiAgICAgICAgICBfdGhpczIueWF4aXNMYWJlbHMuYWRkKHlUZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZQXhpc1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lBeGlzVGV4dCh4LCB5LCBpLCB0ZXh0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB5YXhpc0NvbmZpZyA9IHcuY29uZmlnLnlheGlzWzBdO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgdmFyIHlheGlzTGFiZWwgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogeCArIHlheGlzQ29uZmlnLmxhYmVscy5vZmZzZXRYLFxuICAgICAgICB5OiB5ICsgeWF4aXNDb25maWcubGFiZWxzLm9mZnNldFksXG4gICAgICAgIHRleHQ6IGZvcm1hdHRlcih0ZXh0LCBpKSxcbiAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgIGZvbnRTaXplOiB5YXhpc0NvbmZpZy5sYWJlbHMuc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5jb2xvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4geWF4aXNMYWJlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxpbWl0ID0gMTA7XG4gICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2x5Z29uUG9zID0gdGhpcy5nZXRQb2x5Z29uUG9zKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgY3VyclBvc1ggPSAwO1xuICAgICAgdmFyIGN1cnJQb3NZID0gMDtcbiAgICAgIHcuZ2xvYmFscy5sYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGkpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcuZm9ybWF0dGVyO1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKF90aGlzMy5jdHgpO1xuXG4gICAgICAgIGlmIChwb2x5Z29uUG9zW2ldKSB7XG4gICAgICAgICAgY3VyclBvc1ggPSBwb2x5Z29uUG9zW2ldLng7XG4gICAgICAgICAgY3VyclBvc1kgPSBwb2x5Z29uUG9zW2ldLnk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMocG9seWdvblBvc1tpXS54KSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25Qb3NbaV0ueCA+IDApIHtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICAgIGN1cnJQb3NYICs9IDEwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2x5Z29uUG9zW2ldLnggPCAwKSB7XG4gICAgICAgICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgICAgICAgICAgY3VyclBvc1ggLT0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMocG9seWdvblBvc1tpXS55KSA+PSBfdGhpczMuc2l6ZSAtIGxpbWl0KSB7XG4gICAgICAgICAgICBpZiAocG9seWdvblBvc1tpXS55IDwgMCkge1xuICAgICAgICAgICAgICBjdXJyUG9zWSAtPSAxMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9seWdvblBvc1tpXS55ID4gMCkge1xuICAgICAgICAgICAgICBjdXJyUG9zWSArPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IGZvcm1hdHRlcihsYWJlbCwge1xuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IC0xLFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YUxhYmVscy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgeDogY3VyclBvc1gsXG4gICAgICAgICAgICB5OiBjdXJyUG9zWSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGksXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGF0aHMocG9zLCBvcmlnaW4pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgbGluZVBhdGhzVG8gPSBbXTtcbiAgICAgIHZhciBsaW5lUGF0aHNGcm9tID0gW107XG4gICAgICB2YXIgYXJlYVBhdGhzVG8gPSBbXTtcbiAgICAgIHZhciBhcmVhUGF0aHNGcm9tID0gW107XG5cbiAgICAgIGlmIChwb3MubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVQYXRoc0Zyb20gPSBbdGhpcy5ncmFwaGljcy5tb3ZlKG9yaWdpbi54LCBvcmlnaW4ueSldO1xuICAgICAgICBhcmVhUGF0aHNGcm9tID0gW3RoaXMuZ3JhcGhpY3MubW92ZShvcmlnaW4ueCwgb3JpZ2luLnkpXTtcbiAgICAgICAgdmFyIGxpbmVQYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUocG9zWzBdLngsIHBvc1swXS55KTtcbiAgICAgICAgdmFyIGFyZWFQYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUocG9zWzBdLngsIHBvc1swXS55KTtcbiAgICAgICAgcG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICBsaW5lUGF0aFRvICs9IF90aGlzNC5ncmFwaGljcy5saW5lKHAueCwgcC55KTtcbiAgICAgICAgICBhcmVhUGF0aFRvICs9IF90aGlzNC5ncmFwaGljcy5saW5lKHAueCwgcC55KTtcblxuICAgICAgICAgIGlmIChpID09PSBwb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGluZVBhdGhUbyArPSAnWic7XG4gICAgICAgICAgICBhcmVhUGF0aFRvICs9ICdaJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lUGF0aHNUby5wdXNoKGxpbmVQYXRoVG8pO1xuICAgICAgICBhcmVhUGF0aHNUby5wdXNoKGFyZWFQYXRoVG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lUGF0aHNGcm9tOiBsaW5lUGF0aHNGcm9tLFxuICAgICAgICBsaW5lUGF0aHNUbzogbGluZVBhdGhzVG8sXG4gICAgICAgIGFyZWFQYXRoc0Zyb206IGFyZWFQYXRoc0Zyb20sXG4gICAgICAgIGFyZWFQYXRoc1RvOiBhcmVhUGF0aHNUb1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZyb20ocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwYXRoRnJvbSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICBpZiAoZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoRnJvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVBvaW50c1Bvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhUG9pbnRzUG9zKGRhdGFSYWRpdXNBcnIsIGFuZ2xlQXJyKSB7XG4gICAgICB2YXIgZGF0YVBvaW50c0xlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5kYXRhUG9pbnRzTGVuO1xuICAgICAgZGF0YVJhZGl1c0FyciA9IGRhdGFSYWRpdXNBcnIgfHwgW107XG4gICAgICBhbmdsZUFyciA9IGFuZ2xlQXJyIHx8IFtdO1xuICAgICAgdmFyIGRhdGFQb2ludHNQb3NBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFQb2ludHNMZW47IGorKykge1xuICAgICAgICB2YXIgY3VyUG9pbnRQb3MgPSB7fTtcbiAgICAgICAgY3VyUG9pbnRQb3MueCA9IGRhdGFSYWRpdXNBcnJbal0gKiBNYXRoLnNpbihhbmdsZUFycltqXSk7XG4gICAgICAgIGN1clBvaW50UG9zLnkgPSAtZGF0YVJhZGl1c0FycltqXSAqIE1hdGguY29zKGFuZ2xlQXJyW2pdKTtcbiAgICAgICAgZGF0YVBvaW50c1Bvc0FycmF5LnB1c2goY3VyUG9pbnRQb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVBvaW50c1Bvc0FycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2x5Z29uUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvbHlnb25Qb3Moc2l6ZSkge1xuICAgICAgdmFyIGRvdHNBcnJheSA9IFtdO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgLyB0aGlzLmRhdGFQb2ludHNMZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzTGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1clBvcyA9IHt9O1xuICAgICAgICBjdXJQb3MueCA9IHNpemUgKiBNYXRoLnNpbihpICogYW5nbGUpO1xuICAgICAgICBjdXJQb3MueSA9IC1zaXplICogTWF0aC5jb3MoaSAqIGFuZ2xlKTtcbiAgICAgICAgZG90c0FycmF5LnB1c2goY3VyUG9zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvdHNBcnJheTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkYXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSYWRpYWwgQ2xhc3MgZm9yIGRyYXdpbmcgQ2lyY2xlIC8gU2VtaSBDaXJjbGUgQ2hhcnRzLlxuICogQG1vZHVsZSBSYWRpYWxcbiAqKi9cblxudmFyIFJhZGlhbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BpZSkge1xuICBfaW5oZXJpdHMoUmFkaWFsLCBfUGllKTtcblxuICBmdW5jdGlvbiBSYWRpYWwoY3R4KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlhbCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSYWRpYWwpLmNhbGwodGhpcywgY3R4KSk7XG4gICAgX3RoaXMuY3R4ID0gY3R4O1xuICAgIF90aGlzLncgPSBjdHgudztcbiAgICBfdGhpcy5hbmltQmVnaW5BcnIgPSBbMF07XG4gICAgX3RoaXMuYW5pbUR1ciA9IDA7XG4gICAgdmFyIHcgPSBfdGhpcy53O1xuICAgIF90aGlzLnN0YXJ0QW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuc3RhcnRBbmdsZTtcbiAgICBfdGhpcy5lbmRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5lbmRBbmdsZTtcbiAgICBfdGhpcy50cmFja1N0YXJ0QW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc3RhcnRBbmdsZTtcbiAgICBfdGhpcy50cmFja0VuZEFuZ2xlID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLmVuZEFuZ2xlO1xuICAgIF90aGlzLnJhZGlhbERhdGFMYWJlbHMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuZGF0YUxhYmVscztcbiAgICBpZiAoIV90aGlzLnRyYWNrU3RhcnRBbmdsZSkgX3RoaXMudHJhY2tTdGFydEFuZ2xlID0gX3RoaXMuc3RhcnRBbmdsZTtcbiAgICBpZiAoIV90aGlzLnRyYWNrRW5kQW5nbGUpIF90aGlzLnRyYWNrRW5kQW5nbGUgPSBfdGhpcy5lbmRBbmdsZTtcbiAgICBpZiAoX3RoaXMuZW5kQW5nbGUgPT09IDM2MCkgX3RoaXMuZW5kQW5nbGUgPSAzNTkuOTk7XG4gICAgX3RoaXMuZnVsbEFuZ2xlID0gMzYwIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmVuZEFuZ2xlIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnN0YXJ0QW5nbGU7XG4gICAgX3RoaXMubWFyZ2luID0gcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLm1hcmdpbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJhZGlhbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhcidcbiAgICAgIH0pO1xuICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBjZW50ZXJZID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDI7XG4gICAgICB2YXIgY2VudGVyWCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLmRlZmF1bHRTaXplIC8gMi4wNSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1cjtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2l6ZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JBcnIgPSB3Lmdsb2JhbHMuZmlsbC5jb2xvcnM7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc2hvdykge1xuICAgICAgICB2YXIgZWxUcmFja3MgPSB0aGlzLmRyYXdUcmFja3Moe1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgY2VudGVyWDogY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICAgIGNvbG9yQXJyOiBjb2xvckFycixcbiAgICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGVsVHJhY2tzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsRyA9IHRoaXMuZHJhd0FyY3Moe1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjZW50ZXJYOiBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICBjb2xvckFycjogY29sb3JBcnIsXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KTtcbiAgICAgIGVsU2VyaWVzLmFkZChlbEcuZyk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgIGVsRy5nLmFkZChlbEcuZWxIb2xsb3cpO1xuXG4gICAgICAgIGlmIChlbEcuZGF0YUxhYmVscykge1xuICAgICAgICAgIGVsRy5nLmFkZChlbEcuZGF0YUxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VHJhY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUcmFja3Mob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgob3B0cyk7XG4gICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsUmFkaWFsQmFyVHJhY2sgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci10cmFjayBhcGV4Y2hhcnRzLXRyYWNrJ1xuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGQoZWxSYWRpYWxCYXJUcmFjayk7XG4gICAgICAgIGVsUmFkaWFsQmFyVHJhY2suYXR0cih7XG4gICAgICAgICAgaWQ6ICdhcGV4Y2hhcnRzLXRyYWNrLScgKyBpLFxuICAgICAgICAgIHJlbDogaSArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC0gdGhpcy5tYXJnaW47XG4gICAgICAgIHZhciB0cmFja0NvbmZpZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjaztcbiAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgc2VyaWVzTnVtYmVyOiAwLFxuICAgICAgICAgIHNpemU6IG9wdHMuc2l6ZSxcbiAgICAgICAgICBmaWxsQ29sb3JzOiBBcnJheS5pc0FycmF5KHRyYWNrQ29uZmlnLmJhY2tncm91bmQpID8gdHJhY2tDb25maWcuYmFja2dyb3VuZFtpXSA6IHRyYWNrQ29uZmlnLmJhY2tncm91bmQsXG4gICAgICAgICAgc29saWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy50cmFja1N0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IHRoaXMudHJhY2tFbmRBbmdsZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlKSArIE1hdGguYWJzKHN0YXJ0QW5nbGUpID49IDM2MCkgZW5kQW5nbGUgPSAzNjAgLSBNYXRoLmFicyh0aGlzLnN0YXJ0QW5nbGUpIC0gMC4xO1xuICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHN0cm9rZTogcGF0aEZpbGwsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoICogcGFyc2VJbnQodHJhY2tDb25maWcuc3Ryb2tlV2lkdGgpIC8gMTAwLFxuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0cmFja0NvbmZpZy5vcGFjaXR5LFxuICAgICAgICAgIGNsYXNzZXM6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1hcmVhJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHJhY2tDb25maWcuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHNoYWRvdyA9IHRyYWNrQ29uZmlnLmRyb3BTaGFkb3c7XG4gICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsUGF0aCwgc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsUmFkaWFsQmFyVHJhY2suYWRkKGVsUGF0aCk7XG4gICAgICAgIGVsUGF0aC5hdHRyKCdpZCcsICdhcGV4Y2hhcnRzLXJhZGlhbGJhclRyYWNrLScgKyBpKTtcbiAgICAgICAgdmFyIHBpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuICAgICAgICBwaWUuYW5pbWF0ZVBhdGhzKGVsUGF0aCwge1xuICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBvcHRzLmNlbnRlclksXG4gICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgdG90YWxJdGVtczogMixcbiAgICAgICAgICBhbmltQmVnaW5BcnI6IDAsXG4gICAgICAgICAgZHVyOiAwLFxuICAgICAgICAgIGlzVHJhY2s6IHRydWUsXG4gICAgICAgICAgZWFzaW5nOiB3Lmdsb2JhbHMuZWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0FyY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Mob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIHNpemUsIGRvbnV0U2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgY29sb3JBcnIsIGxpbmVDb2xvckFyciwgc2VjdG9yQW5nbGVBcnIsIHNlcmllc1xuXG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgob3B0cyk7XG4gICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICB2YXIgaG9sbG93RmlsbElEID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5iYWNrZ3JvdW5kO1xuICAgICAgdmFyIGhvbGxvd1NpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAqIG9wdHMuc2VyaWVzLmxlbmd0aCAtIHRoaXMubWFyZ2luICogb3B0cy5zZXJpZXMubGVuZ3RoIC0gc3Ryb2tlV2lkdGggKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc3Ryb2tlV2lkdGgpIC8gMTAwIC8gMjtcbiAgICAgIHZhciBob2xsb3dSYWRpdXMgPSBob2xsb3dTaXplIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5tYXJnaW47XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG9sbG93RmlsbElEID0gdGhpcy5kcmF3SG9sbG93SW1hZ2Uob3B0cywgZywgaG9sbG93U2l6ZSwgaG9sbG93RmlsbElEKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsSG9sbG93ID0gdGhpcy5kcmF3SG9sbG93KHtcbiAgICAgICAgc2l6ZTogaG9sbG93UmFkaXVzLFxuICAgICAgICBjZW50ZXJYOiBvcHRzLmNlbnRlclgsXG4gICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgZmlsbDogaG9sbG93RmlsbElEXG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmRyb3BTaGFkb3c7XG4gICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbEhvbGxvdywgc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3duID0gMTtcblxuICAgICAgaWYgKCF0aGlzLnJhZGlhbERhdGFMYWJlbHMudG90YWwuc2hvdyAmJiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2hvd24gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnJhZGlhbERhdGFMYWJlbHMuc2hvdykge1xuICAgICAgICBkYXRhTGFiZWxzID0gcGllLnJlbmRlcklubmVyRGF0YUxhYmVscyh0aGlzLnJhZGlhbERhdGFMYWJlbHMsIHtcbiAgICAgICAgICBob2xsb3dTaXplOiBob2xsb3dTaXplLFxuICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBvcHRzLmNlbnRlclksXG4gICAgICAgICAgb3BhY2l0eTogc2hvd25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgZy5hZGQoZWxIb2xsb3cpO1xuXG4gICAgICAgIGlmIChkYXRhTGFiZWxzKSB7XG4gICAgICAgICAgZy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldmVyc2VMb29wID0gZmFsc2U7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaW52ZXJzZU9yZGVyKSB7XG4gICAgICAgIHJldmVyc2VMb29wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHJldmVyc2VMb29wID8gb3B0cy5zZXJpZXMubGVuZ3RoIC0gMSA6IDA7IHJldmVyc2VMb29wID8gaSA+PSAwIDogaSA8IG9wdHMuc2VyaWVzLmxlbmd0aDsgcmV2ZXJzZUxvb3AgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgdmFyIGVsUmFkaWFsQmFyQXJjID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcmFkaWFsLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpXG4gICAgICAgIH0pO1xuICAgICAgICBnLmFkZChlbFJhZGlhbEJhckFyYyk7XG4gICAgICAgIGVsUmFkaWFsQmFyQXJjLmF0dHIoe1xuICAgICAgICAgIGlkOiAnYXBleGNoYXJ0cy1zZXJpZXMtJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxSYWRpYWxCYXJBcmMsIGkpO1xuICAgICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAtIHRoaXMubWFyZ2luO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHByZXZTdGFydEFuZ2xlID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG90YWxBbmdsZSA9IE1hdGguYWJzKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5lbmRBbmdsZSAtIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zdGFydEFuZ2xlKTsgLy8gaWYgZGF0YSBleGNlZWRzIDEwMCwgbWFrZSBpdCAxMDBcblxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gVXRpbHMubmVnVG9aZXJvKG9wdHMuc2VyaWVzW2ldID4gMTAwID8gMTAwIDogb3B0cy5zZXJpZXNbaV0pIC8gMTAwO1xuICAgICAgICB2YXIgZW5kQW5nbGUgPSBNYXRoLnJvdW5kKHRvdGFsQW5nbGUgKiBkYXRhVmFsdWUpICsgdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcHJldkVuZEFuZ2xlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICBwcmV2U3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgICBwcmV2RW5kQW5nbGUgPSBNYXRoLnJvdW5kKHRvdGFsQW5nbGUgKiBVdGlscy5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0pIC8gMTAwKSArIHByZXZTdGFydEFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJGdWxsQW5nbGUgPSBNYXRoLmFicyhlbmRBbmdsZSkgKyBNYXRoLmFicyhzdGFydEFuZ2xlKTtcblxuICAgICAgICBpZiAoY3VyckZ1bGxBbmdsZSA+PSAzNjApIHtcbiAgICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlIC0gMC4wMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2RnVsbEFuZ2xlID0gTWF0aC5hYnMocHJldkVuZEFuZ2xlKSArIE1hdGguYWJzKHByZXZTdGFydEFuZ2xlKTtcblxuICAgICAgICBpZiAocHJldkZ1bGxBbmdsZSA+PSAzNjApIHtcbiAgICAgICAgICBwcmV2RW5kQW5nbGUgPSBwcmV2RW5kQW5nbGUgLSAwLjAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgZGFzaEFycmF5ID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5KSA/IHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXlbaV0gOiB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5O1xuICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHN0cm9rZTogcGF0aEZpbGwsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogdy5jb25maWcuZmlsbC5vcGFjaXR5LFxuICAgICAgICAgIGNsYXNzZXM6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1hcmVhJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXk6IGRhc2hBcnJheVxuICAgICAgICB9KTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAnZGF0YTphbmdsZSc6IGFuZ2xlLFxuICAgICAgICAgICdkYXRhOnZhbHVlJzogb3B0cy5zZXJpZXNbaV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBfc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWxQYXRoLCBfc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXJzKGVsUGF0aCwgdGhpcy5yYWRpYWxEYXRhTGFiZWxzKTtcblxuICAgICAgICB2YXIgX3BpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuXG4gICAgICAgIGVsUmFkaWFsQmFyQXJjLmFkZChlbFBhdGgpO1xuICAgICAgICBlbFBhdGguYXR0cih7XG4gICAgICAgICAgaWQ6ICdhcGV4Y2hhcnRzLXJhZGlhbEFyYy0nICsgaSxcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICBqOiBpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZHVyID0gMDtcblxuICAgICAgICBpZiAoX3BpZS5pbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIGR1ciA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gMzYwICogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZDtcbiAgICAgICAgICB0aGlzLmFuaW1EdXIgPSBkdXIgLyAob3B0cy5zZXJpZXMubGVuZ3RoICogMS4yKSArIHRoaXMuYW5pbUR1cjtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKHRoaXMuYW5pbUR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQ7XG4gICAgICAgICAgdGhpcy5hbmltRHVyID0gZHVyIC8gKG9wdHMuc2VyaWVzLmxlbmd0aCAqIDEuMikgKyB0aGlzLmFuaW1EdXI7XG4gICAgICAgICAgdGhpcy5hbmltQmVnaW5BcnIucHVzaCh0aGlzLmFuaW1EdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BpZS5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBwcmV2RW5kQW5nbGU6IHByZXZFbmRBbmdsZSxcbiAgICAgICAgICBwcmV2U3RhcnRBbmdsZTogcHJldlN0YXJ0QW5nbGUsXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgdG90YWxJdGVtczogMixcbiAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgIGR1cjogZHVyLFxuICAgICAgICAgIHNob3VsZFNldFByZXZQYXRoczogdHJ1ZSxcbiAgICAgICAgICBlYXNpbmc6IHcuZ2xvYmFscy5lYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGc6IGcsXG4gICAgICAgIGVsSG9sbG93OiBlbEhvbGxvdyxcbiAgICAgICAgZGF0YUxhYmVsczogZGF0YUxhYmVsc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0hvbGxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SG9sbG93KG9wdHMpIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShvcHRzLnNpemUgKiAyKTtcbiAgICAgIGNpcmNsZS5hdHRyKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1ob2xsb3cnLFxuICAgICAgICBjeDogb3B0cy5jZW50ZXJYLFxuICAgICAgICBjeTogb3B0cy5jZW50ZXJZLFxuICAgICAgICByOiBvcHRzLnNpemUsXG4gICAgICAgIGZpbGw6IG9wdHMuZmlsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3SG9sbG93SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0hvbGxvd0ltYWdlKG9wdHMsIGcsIGhvbGxvd1NpemUsIGhvbGxvd0ZpbGxJRCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciByYW5kSUQgPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCk7XG4gICAgICB2YXIgaG9sbG93RmlsbEltZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2U7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlQ2xpcHBlZCkge1xuICAgICAgICBmaWxsLmNsaXBwZWRJbWdBcmVhKHtcbiAgICAgICAgICB3aWR0aDogaG9sbG93U2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGhvbGxvd1NpemUsXG4gICAgICAgICAgaW1hZ2U6IGhvbGxvd0ZpbGxJbWcsXG4gICAgICAgICAgcGF0dGVybklEOiBcInBhdHRlcm5cIi5jb25jYXQody5nbG9iYWxzLmN1aWQpLmNvbmNhdChyYW5kSUQpXG4gICAgICAgIH0pO1xuICAgICAgICBob2xsb3dGaWxsSUQgPSBcInVybCgjcGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KHJhbmRJRCwgXCIpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltZ1dpZHRoID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZVdpZHRoO1xuICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZUhlaWdodDtcblxuICAgICAgICBpZiAoaW1nV2lkdGggPT09IHVuZGVmaW5lZCAmJiBpbWdIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IHcuZ2xvYmFscy5kb20uUGFwZXIuaW1hZ2UoaG9sbG93RmlsbEltZykubG9hZGVkKGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZShvcHRzLmNlbnRlclggLSBsb2FkZXIud2lkdGggLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFgsIG9wdHMuY2VudGVyWSAtIGxvYWRlci5oZWlnaHQgLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcuYWRkKGltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2ltYWdlID0gdy5nbG9iYWxzLmRvbS5QYXBlci5pbWFnZShob2xsb3dGaWxsSW1nKS5sb2FkZWQoZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKG9wdHMuY2VudGVyWCAtIGltZ1dpZHRoIC8gMiArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2VPZmZzZXRYLCBvcHRzLmNlbnRlclkgLSBpbWdIZWlnaHQgLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFkpO1xuICAgICAgICAgICAgdGhpcy5zaXplKGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZy5hZGQoX2ltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG9sbG93RmlsbElEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHJva2VXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJva2VXaWR0aChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHJldHVybiBvcHRzLnNpemUgKiAoMTAwIC0gcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5zaXplKSkgLyAxMDAgLyAob3B0cy5zZXJpZXMubGVuZ3RoICsgMSkgLSB0aGlzLm1hcmdpbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaWFsO1xufShQaWUpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgTGluZSBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBMaW5lIC8gQXJlYSBDaGFydHMuXG4gKiBUaGlzIGNsYXNzIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdmFsdWVzIGZvciBCdWJibGUvU2NhdHRlciBjaGFydHMsIHNvIG5lZWQgdG8gcmVuYW1lIGl0IHRvIEF4aXMgQ2hhcnRzIHRvIGF2b2lkIGNvbmZ1c2lvbnNcbiAqIEBtb2R1bGUgTGluZVxuICoqL1xuXG52YXIgTGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmUoY3R4LCB4eVJhdGlvcywgaXNQb2ludHNDaGFydCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICB0aGlzLnBvaW50c0NoYXJ0ID0gISh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnICYmIHRoaXMudy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3NjYXR0ZXInKSB8fCBpc1BvaW50c0NoYXJ0O1xuICAgIHRoaXMuc2NhdHRlciA9IG5ldyBTY2F0dGVyKHRoaXMuY3R4KTtcbiAgICB0aGlzLm5vTmVnYXRpdmVzID0gdGhpcy53Lmdsb2JhbHMubWluWCA9PT0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLnlheGlzSW5kZXggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMsIHB0eXBlLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgdHlwZSA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHB0eXBlIDogdy5jb25maWcuY2hhcnQudHlwZTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgIHNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHZhciB5UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnlSYXRpbztcbiAgICAgIHlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHlSYXRpbyk7XG4gICAgICB2YXIgelJhdGlvID0gdGhpcy54eVJhdGlvcy56UmF0aW87XG4gICAgICB2YXIgeFJhdGlvID0gdGhpcy54eVJhdGlvcy54UmF0aW87XG4gICAgICB2YXIgYmFzZUxpbmVZID0gdGhpcy54eVJhdGlvcy5iYXNlTGluZVk7IC8vIHB1c2ggYWxsIHNlcmllcyBpbiBhbiBhcnJheSwgc28gd2UgY2FuIGRyYXcgaW4gcmV2ZXJzZSBvcmRlciAoZm9yIHN0YWNrZWQgY2hhcnRzKVxuXG4gICAgICB2YXIgYWxsU2VyaWVzID0gW107XG4gICAgICB2YXIgcHJldlNlcmllc1kgPSBbXTtcbiAgICAgIHZhciBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2lkdGggZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHZhciB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7XG5cbiAgICAgICAgaWYgKHlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy55YXhpc0luZGV4ID0gcmVhbEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1JldmVyc2VkID0gdy5jb25maWcueWF4aXNbdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdLnJldmVyc2VkO1xuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcbiAgICAgICAgLy8gemVyb1kgaXMgdGhlIDAgdmFsdWUgaW4geSBzZXJpZXMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gbmVnYXRpdmUgY2hhcnRzXG5cbiAgICAgICAgdmFyIHplcm9ZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSBiYXNlTGluZVlbdGhpcy55YXhpc0luZGV4XSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCA6IDApICsgKHRoaXMuaXNSZXZlcnNlZCA/IGJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApO1xuICAgICAgICB2YXIgYXJlYUJvdHRvbVkgPSB6ZXJvWTtcblxuICAgICAgICBpZiAoemVyb1kgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgIGFyZWFCb3R0b21ZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0geERpdmlzaW9uIC8gMjtcbiAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIGNhdGVnb3J5QXhpc0NvcnJlY3Rpb247XG4gICAgICAgIHZhciB5ID0gMTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4ID0gKHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1bMF0gLSB3Lmdsb2JhbHMubWluWCkgLyB4UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB4QXJyai5wdXNoKHgpO1xuICAgICAgICB2YXIgbGluZVBhdGggPSB2b2lkIDAsXG4gICAgICAgICAgICBhcmVhUGF0aCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tQXJlYSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxpbmVQYXRocyA9IFtdO1xuICAgICAgICB2YXIgYXJlYVBhdGhzID0gW107IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pKVxuICAgICAgICB9KTsgLy8gcG9pbnRzXG5cbiAgICAgICAgdmFyIGVsUG9pbnRzTWFpbiA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCdcbiAgICAgICAgfSk7IC8vIGVsZGF0YWxhYmVsc1xuXG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7XG4gICAgICAgIHZhciBsb25nZXN0U2VyaWVzID0gc2VyaWVzW2ldLmxlbmd0aCA9PT0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGVsU2VyaWVzLmF0dHIoe1xuICAgICAgICAgICdkYXRhOmxvbmdlc3RTZXJpZXMnOiBsb25nZXN0U2VyaWVzLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZFBhdGhGcm9tID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBYID0geDtcbiAgICAgICAgdmFyIHBZID0gdm9pZCAwO1xuICAgICAgICB2YXIgcHJldlggPSBwWDtcbiAgICAgICAgdmFyIHByZXZZID0gemVyb1k7IC8vIHcuZ2xvYmFscy5zdmdIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpbmVZUG9zaXRpb24gPSAwOyAvLyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuXG4gICAgICAgIHZhciBmaXJzdFByZXZZID0gdGhpcy5kZXRlcm1pbmVGaXJzdFByZXZZKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgIHlSYXRpbzogeVJhdGlvW3RoaXMueWF4aXNJbmRleF0sXG4gICAgICAgICAgemVyb1k6IHplcm9ZLFxuICAgICAgICAgIHByZXZZOiBwcmV2WSxcbiAgICAgICAgICBwcmV2U2VyaWVzWTogcHJldlNlcmllc1ksXG4gICAgICAgICAgbGluZVlQb3NpdGlvbjogbGluZVlQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlkgPSBmaXJzdFByZXZZLnByZXZZO1xuICAgICAgICB5QXJyai5wdXNoKHByZXZZKTtcbiAgICAgICAgcFkgPSBwcmV2WTtcblxuICAgICAgICBpZiAoc2VyaWVzW2ldWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgdmFsdWUgaXRzZWxmIGlzIG51bGwsIHdlIG5lZWQgdG8gbW92ZSB0aGUgcG9pbnRlciB0byBhIGxvY2F0aW9uIHdoZXJlIGEgbnVsbCB2YWx1ZSBpcyBub3QgZm91bmRcbiAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNlcmllc1tpXS5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgaWYgKHNlcmllc1tpXVtzXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2WCA9IHhEaXZpc2lvbiAqIHM7XG4gICAgICAgICAgICAgIHByZXZZID0gemVyb1kgLSBzZXJpZXNbaV1bc10gLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBwcmV2WSk7XG4gICAgICAgICAgICAgIGFyZWFQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgYXJlYUJvdHRvbVkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBwcmV2WSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5saW5lKHByZXZYLCBwcmV2WSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoRnJvbUxpbmUgPSBncmFwaGljcy5tb3ZlKC0xLCB6ZXJvWSkgKyBncmFwaGljcy5saW5lKC0xLCB6ZXJvWSk7XG4gICAgICAgIHBhdGhGcm9tQXJlYSA9IGdyYXBoaWNzLm1vdmUoLTEsIHplcm9ZKSArIGdyYXBoaWNzLmxpbmUoLTEsIHplcm9ZKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwYXRoRnJvbSA9IHRoaXMuY2hlY2tQcmV2aW91c1BhdGhzKHtcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZTogcGF0aEZyb21MaW5lLFxuICAgICAgICAgICAgcGF0aEZyb21BcmVhOiBwYXRoRnJvbUFyZWEsXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHBhdGhGcm9tLnBhdGhGcm9tTGluZTtcbiAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBwYXRoRnJvbS5wYXRoRnJvbUFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IHcuZ2xvYmFscy5kYXRhUG9pbnRzID4gMSA/IHcuZ2xvYmFscy5kYXRhUG9pbnRzIC0gMSA6IHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICB2YXIgc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2ogKyAxXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2ogKyAxXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLyogZml4ICMzNzQgKi9cbiAgICAgICAgICAgICAgc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2l0ZXJhdGlvbnMgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCA9IChzWCAtIHcuZ2xvYmFscy5taW5YKSAvIHhSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1pblkgPSBVdGlscy5pc051bWJlcih3Lmdsb2JhbHMubWluWUFycltyZWFsSW5kZXhdKSA/IHcuZ2xvYmFscy5taW5ZQXJyW3JlYWxJbmRleF0gOiB3Lmdsb2JhbHMubWluWTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPCB3LmNvbmZpZy5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gcHJldlNlcmllc1lbaSAtIDFdW2ogKyAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WSB2YWx1ZXNcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHplcm9ZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc1tpXVtqICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqICsgMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgeSA9IGxpbmVZUG9zaXRpb24gLSBtaW5ZIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gbWluWSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeSA9IGxpbmVZUG9zaXRpb24gLSBzZXJpZXNbaV1baiArIDFdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gc2VyaWVzW2ldW2ogKyAxXSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc1tpXVtqICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqICsgMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgeSA9IHplcm9ZIC0gbWluWSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IG1pblkgLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHkgPSB6ZXJvWSAtIHNlcmllc1tpXVtqICsgMV0gLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSArICh0aGlzLmlzUmV2ZXJzZWQgPyBzZXJpZXNbaV1baiArIDFdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gOiAwKSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBwdXNoIGN1cnJlbnQgWFxuXG5cbiAgICAgICAgICB4QXJyai5wdXNoKHgpOyAvLyBwdXNoIGN1cnJlbnQgWSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBuZXh0IHNlcmllcydzIGJvdHRvbSBwb3NpdGlvblxuXG4gICAgICAgICAgeUFycmoucHVzaCh5KTtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBhdGhzID0gdGhpcy5jcmVhdGVQYXRocyh7XG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgIHBYOiBwWCxcbiAgICAgICAgICAgIHBZOiBwWSxcbiAgICAgICAgICAgIGFyZWFCb3R0b21ZOiBhcmVhQm90dG9tWSxcbiAgICAgICAgICAgIGxpbmVQYXRoOiBsaW5lUGF0aCxcbiAgICAgICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aCxcbiAgICAgICAgICAgIGxpbmVQYXRoczogbGluZVBhdGhzLFxuICAgICAgICAgICAgYXJlYVBhdGhzOiBhcmVhUGF0aHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcmVhUGF0aHMgPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGhzO1xuICAgICAgICAgIGxpbmVQYXRocyA9IGNhbGN1bGF0ZWRQYXRocy5saW5lUGF0aHM7XG4gICAgICAgICAgcFggPSBjYWxjdWxhdGVkUGF0aHMucFg7XG4gICAgICAgICAgcFkgPSBjYWxjdWxhdGVkUGF0aHMucFk7XG4gICAgICAgICAgYXJlYVBhdGggPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGg7XG4gICAgICAgICAgbGluZVBhdGggPSBjYWxjdWxhdGVkUGF0aHMubGluZVBhdGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRQYXRoRnJvbSkge1xuICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gcGF0aEZyb21MaW5lICsgZ3JhcGhpY3MubGluZSh4LCB6ZXJvWSk7XG4gICAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBwYXRoRnJvbUFyZWEgKyBncmFwaGljcy5saW5lKHgsIHplcm9ZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRzUG9zID0gdGhpcy5jYWxjdWxhdGVQb2ludHMoe1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uOiBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uLFxuICAgICAgICAgICAgeFJhdGlvOiB4UmF0aW9cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YVBvaW50cyA+IDEpIHtcbiAgICAgICAgICAgICAgZWxQb2ludHNNYWluLm5vZGUuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBtYXJrZXJzLnBsb3RDaGFydE1hcmtlcnMocG9pbnRzUG9zLCByZWFsSW5kZXgsIGogKyAxKTtcblxuICAgICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbFBvaW50c01haW4uYWRkKGVsUG9pbnRzV3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNjYXR0ZXIgLyBidWJibGUgY2hhcnQgcG9pbnRzIGNyZWF0aW9uXG4gICAgICAgICAgICB0aGlzLnNjYXR0ZXIuZHJhdyhlbFNlcmllcywgaiwge1xuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgcG9pbnRzUG9zOiBwb2ludHNQb3MsXG4gICAgICAgICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICAgICAgICBlbFBhcmVudDogZWxQb2ludHNNYWluXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcbiAgICAgICAgICB2YXIgZHJhd25MYWJlbHMgPSBkYXRhTGFiZWxzLmRyYXdEYXRhTGFiZWwocG9pbnRzUG9zLCByZWFsSW5kZXgsIGogKyAxKTtcblxuICAgICAgICAgIGlmIChkcmF3bkxhYmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxEYXRhTGFiZWxzV3JhcC5hZGQoZHJhd25MYWJlbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwdXNoIGFsbCBjdXJyZW50IHkgdmFsdWVzIGFycmF5IHRvIG1haW4gUHJldlkgQXJyYXlcblxuXG4gICAgICAgIHByZXZTZXJpZXNZLnB1c2goeUFycmopOyAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tyZWFsSW5kZXhdID0geEFycmo7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyajsgLy8gdGhlc2UgZWxlbWVudHMgd2lsbCBiZSBzaG93biBhZnRlciBhcmVhIHBhdGggYW5pbWF0aW9uIGNvbXBsZXRlc1xuXG4gICAgICAgIGlmICghdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbDogZWxQb2ludHNNYWluLm5vZGUsXG4gICAgICAgICAgICBpbmRleDogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogaSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUpLFxuICAgICAgICAgIGlkOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnN0cm9rZS5zaG93ICYmICF0aGlzLnBvaW50c0NoYXJ0KSB7XG4gICAgICAgICAgdmFyIGxpbmVGaWxsID0gbnVsbDtcblxuICAgICAgICAgIGlmICh0eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIC8vIGZpbGxhYmxlIGxpbmVzIG9ubHkgZm9yIGxpbmVDaGFydFxuICAgICAgICAgICAgbGluZUZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lRmlsbCA9IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW3JlYWxJbmRleF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBsaW5lUGF0aHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21MaW5lLFxuICAgICAgICAgICAgICBwYXRoVG86IGxpbmVQYXRoc1twXSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5lRmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSA/IHcuY29uZmlnLnN0cm9rZS53aWR0aFtyZWFsSW5kZXhdIDogdy5jb25maWcuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiB3LmNvbmZpZy5zdHJva2UubGluZUNhcCxcbiAgICAgICAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gd2UgaGF2ZSBkcmF3biB0aGUgbGluZXMsIG5vdyBpZiBpdCBpcyBhcmVhIGNoYXJ0LCB3ZSBuZWVkIHRvIGZpbGwgcGF0aHNcblxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICAgIHNlcmllc051bWJlcjogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfcCA9IDA7IF9wIDwgYXJlYVBhdGhzLmxlbmd0aDsgX3ArKykge1xuICAgICAgICAgICAgdmFyIF9yZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb21BcmVhLFxuICAgICAgICAgICAgICBwYXRoVG86IGFyZWFQYXRoc1tfcF0sXG4gICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogbnVsbCxcbiAgICAgICAgICAgICAgZmlsbDogcGF0aEZpbGxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZWxTZXJpZXMuYWRkKF9yZW5kZXJlZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsU2VyaWVzLmFkZChlbFBvaW50c01haW4pO1xuICAgICAgICBlbFNlcmllcy5hZGQoZWxEYXRhTGFiZWxzV3JhcCk7XG4gICAgICAgIGFsbFNlcmllcy5wdXNoKGVsU2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3MgPSBhbGxTZXJpZXMubGVuZ3RoOyBfcyA+IDA7IF9zLS0pIHtcbiAgICAgICAgcmV0LmFkZChhbGxTZXJpZXNbX3MgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhdGhzKF9yZWYpIHtcbiAgICAgIHZhciBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHBYID0gX3JlZi5wWCxcbiAgICAgICAgICBwWSA9IF9yZWYucFksXG4gICAgICAgICAgeERpdmlzaW9uID0gX3JlZi54RGl2aXNpb24sXG4gICAgICAgICAgYXJlYUJvdHRvbVkgPSBfcmVmLmFyZWFCb3R0b21ZLFxuICAgICAgICAgIGxpbmVQYXRoID0gX3JlZi5saW5lUGF0aCxcbiAgICAgICAgICBhcmVhUGF0aCA9IF9yZWYuYXJlYVBhdGgsXG4gICAgICAgICAgbGluZVBhdGhzID0gX3JlZi5saW5lUGF0aHMsXG4gICAgICAgICAgYXJlYVBhdGhzID0gX3JlZi5hcmVhUGF0aHM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY3VydmUgPSBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS5jdXJ2ZSkgPyB3LmNvbmZpZy5zdHJva2UuY3VydmVbaV0gOiB3LmNvbmZpZy5zdHJva2UuY3VydmU7IC8vIGxvZ2ljIG9mIHNtb290aCBjdXJ2ZSBkZXJpdmVkIGZyb20gY2hhcnRpc3RcbiAgICAgIC8vIENSRURJVFM6IGh0dHBzOi8vZ2lvbmt1bnouZ2l0aHViLmlvL2NoYXJ0aXN0LWpzL1xuXG4gICAgICBpZiAoY3VydmUgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSAoeCAtIHBYKSAqIDAuMzU7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5oYXNOdWxsVmFsdWVzKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tpXVtqXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNlcmllc1tpXVtqICsgMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHBYLCBwWSkgKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHggKyAxLCB5KTtcbiAgICAgICAgICAgICAgYXJlYVBhdGggPSBncmFwaGljcy5tb3ZlKHBYICsgMSwgcFkpICsgZ3JhcGhpY3MuY3VydmUocFggKyBsZW5ndGgsIHBZLCB4IC0gbGVuZ3RoLCB5LCB4ICsgMSwgeSkgKyBncmFwaGljcy5saW5lKHgsIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLmxpbmUocFgsIGFyZWFCb3R0b21ZKSArICd6JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwWCwgcFkpO1xuICAgICAgICAgICAgICBhcmVhUGF0aCA9IGdyYXBoaWNzLm1vdmUocFgsIHBZKSArICd6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lUGF0aHMucHVzaChsaW5lUGF0aCk7XG4gICAgICAgICAgYXJlYVBhdGhzLnB1c2goYXJlYVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVQYXRoID0gbGluZVBhdGggKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHgsIHkpO1xuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5jdXJ2ZShwWCArIGxlbmd0aCwgcFksIHggLSBsZW5ndGgsIHksIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcFggPSB4O1xuICAgICAgICBwWSA9IHk7XG5cbiAgICAgICAgaWYgKGogPT09IHNlcmllc1tpXS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgLy8gbGFzdCBsb29wLCBjbG9zZSBwYXRoXG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmN1cnZlKHBYLCBwWSwgeCwgeSwgeCwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZSh4LCB5KSArICd6JztcblxuICAgICAgICAgIGlmICghdy5nbG9iYWxzLmhhc051bGxWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxpbmVQYXRocy5wdXNoKGxpbmVQYXRoKTtcbiAgICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZXJpZXNbaV1baiArIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLm1vdmUoeCwgeSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmxpbmUoeCAtIHhEaXZpc2lvbiwgYXJlYUJvdHRvbVkpICsgZ3JhcGhpY3MubW92ZSh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubW92ZSh4LCB5KTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubW92ZSh4LCBhcmVhQm90dG9tWSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VydmUgPT09ICdzdGVwbGluZScpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubGluZSh4LCBudWxsLCAnSCcpICsgZ3JhcGhpY3MubGluZShudWxsLCB5LCAnVicpO1xuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHgsIG51bGwsICdIJykgKyBncmFwaGljcy5saW5lKG51bGwsIHksICdWJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5KTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZSh4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqID09PSBzZXJpZXNbaV0ubGVuZ3RoIC0gMikge1xuICAgICAgICAgIC8vIGxhc3QgbG9vcCwgY2xvc2UgcGF0aFxuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHgsIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLm1vdmUoeCwgeSkgKyAneic7XG4gICAgICAgICAgbGluZVBhdGhzLnB1c2gobGluZVBhdGgpO1xuICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lUGF0aHM6IGxpbmVQYXRocyxcbiAgICAgICAgYXJlYVBhdGhzOiBhcmVhUGF0aHMsXG4gICAgICAgIHBYOiBwWCxcbiAgICAgICAgcFk6IHBZLFxuICAgICAgICBsaW5lUGF0aDogbGluZVBhdGgsXG4gICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50cyhfcmVmMikge1xuICAgICAgdmFyIHNlcmllcyA9IF9yZWYyLnNlcmllcyxcbiAgICAgICAgICByZWFsSW5kZXggPSBfcmVmMi5yZWFsSW5kZXgsXG4gICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnksXG4gICAgICAgICAgaSA9IF9yZWYyLmksXG4gICAgICAgICAgaiA9IF9yZWYyLmosXG4gICAgICAgICAgcHJldlkgPSBfcmVmMi5wcmV2WSxcbiAgICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0gX3JlZjIuY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbixcbiAgICAgICAgICB4UmF0aW8gPSBfcmVmMi54UmF0aW87XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwdFggPSBbXTtcbiAgICAgIHZhciBwdFkgPSBbXTtcblxuICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgdmFyIHhQVDFzdCA9IGNhdGVnb3J5QXhpc0NvcnJlY3Rpb24gKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFg7IC8vIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZSBzZXJpZXNcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIGl0J3Mgbm90IGEgdGltZSBzZXJpZXMsIGJlY2F1c2UgYSB0aW1lIHNlcmllcyBtYXlcbiAgICAgICAgLy8gc3RhcnQgZnJvbSB0aGUgbWlkZGxlIG9mIHRoZSB4IGF4aXNcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4UFQxc3QgPSAody5nbG9iYWxzLnNlcmllc1hbcmVhbEluZGV4XVswXSAtIHcuZ2xvYmFscy5taW5YKSAvIHhSYXRpbyArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgfSAvLyBwdXNoIDIgcG9pbnRzIGZvciB0aGUgZmlyc3QgZGF0YSB2YWx1ZXNcblxuXG4gICAgICAgIHB0WC5wdXNoKHhQVDFzdCk7XG4gICAgICAgIHB0WS5wdXNoKFV0aWxzLmlzTnVtYmVyKHNlcmllc1tpXVswXSkgPyBwcmV2WSArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WSA6IG51bGwpO1xuICAgICAgICBwdFgucHVzaCh4ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYKTtcbiAgICAgICAgcHRZLnB1c2goVXRpbHMuaXNOdW1iZXIoc2VyaWVzW2ldW2ogKyAxXSkgPyB5ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRZIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdFgucHVzaCh4ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYKTtcbiAgICAgICAgcHRZLnB1c2goVXRpbHMuaXNOdW1iZXIoc2VyaWVzW2ldW2ogKyAxXSkgPyB5ICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRZIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludHNQb3MgPSB7XG4gICAgICAgIHg6IHB0WCxcbiAgICAgICAgeTogcHRZXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBvaW50c1BvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tQcmV2aW91c1BhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUHJldmlvdXNQYXRocyhfcmVmMykge1xuICAgICAgdmFyIHBhdGhGcm9tTGluZSA9IF9yZWYzLnBhdGhGcm9tTGluZSxcbiAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBfcmVmMy5wYXRoRnJvbUFyZWEsXG4gICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjMucmVhbEluZGV4O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICBpZiAoKGdwcC50eXBlID09PSAnbGluZScgfHwgZ3BwLnR5cGUgPT09ICdhcmVhJykgJiYgZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCkpIHtcbiAgICAgICAgICBpZiAoZ3BwLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRQYXRoRnJvbSA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChncHAudHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFBhdGhGcm9tID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgICBwYXRoRnJvbUxpbmUgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMF0uZDtcbiAgICAgICAgICAgICAgcGF0aEZyb21BcmVhID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzFdLmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXRoRnJvbUFyZWEgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMF0uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aEZyb21MaW5lOiBwYXRoRnJvbUxpbmUsXG4gICAgICAgIHBhdGhGcm9tQXJlYTogcGF0aEZyb21BcmVhXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVGaXJzdFByZXZZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUZpcnN0UHJldlkoX3JlZjQpIHtcbiAgICAgIHZhciBpID0gX3JlZjQuaSxcbiAgICAgICAgICBzZXJpZXMgPSBfcmVmNC5zZXJpZXMsXG4gICAgICAgICAgeVJhdGlvID0gX3JlZjQueVJhdGlvLFxuICAgICAgICAgIHplcm9ZID0gX3JlZjQuemVyb1ksXG4gICAgICAgICAgcHJldlkgPSBfcmVmNC5wcmV2WSxcbiAgICAgICAgICBwcmV2U2VyaWVzWSA9IF9yZWY0LnByZXZTZXJpZXNZLFxuICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBfcmVmNC5saW5lWVBvc2l0aW9uO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW2ldWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gMXN0IHkgdmFsdWUgb2YgcHJldmlvdXMgc2VyaWVzXG4gICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gcHJldlNlcmllc1lbaSAtIDFdWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzXG4gICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gemVyb1k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlkgPSBsaW5lWVBvc2l0aW9uIC0gc2VyaWVzW2ldWzBdIC8geVJhdGlvICsgKHRoaXMuaXNSZXZlcnNlZCA/IHNlcmllc1tpXVswXSAvIHlSYXRpbyA6IDApICogMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2WSA9IHplcm9ZIC0gc2VyaWVzW2ldWzBdIC8geVJhdGlvICsgKHRoaXMuaXNSZXZlcnNlZCA/IHNlcmllc1tpXVswXSAvIHlSYXRpbyA6IDApICogMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBjdXJyZW50IHNlcmllcyBpcyBudWxsXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkICYmIGkgPiAwICYmIHR5cGVvZiBzZXJpZXNbaV1bMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIHVuZGVmaW5lZCB2YWx1ZSAodW5kZWZpbmVkIHZhbHVlIHdpbGwgb2NjdXIgd2hlbiB3ZSBjbGVhciB0aGUgc2VyaWVzIHdoaWxlIHVzZXIgY2xpY2tzIG9uIGxlZ2VuZCB0byBoaWRlIHNlcmllc2VzKVxuICAgICAgICAgIGZvciAodmFyIHMgPSBpIC0gMTsgcyA+PSAwOyBzLS0pIHtcbiAgICAgICAgICAgIC8vIGZvciBsb29wIHRvIGdldCB0byAxc3QgcHJldmlvdXMgdmFsdWUgdW50aWwgd2UgZ2V0IGl0XG4gICAgICAgICAgICBpZiAoc2VyaWVzW3NdWzBdICE9PSBudWxsICYmIHR5cGVvZiBzZXJpZXNbc11bMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBwcmV2U2VyaWVzWVtzXVswXTtcbiAgICAgICAgICAgICAgcHJldlkgPSBsaW5lWVBvc2l0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJldlk6IHByZXZZLFxuICAgICAgICBsaW5lWVBvc2l0aW9uOiBsaW5lWVBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWUF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWS1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWUF4aXNcbiAqKi9cblxudmFyIFlBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWUF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueGF4aXNGb250U2l6ZSA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgIHRoaXMuYXhpc0ZvbnRGYW1pbHkgPSB0aGlzLncuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250RmFtaWx5O1xuICAgIHRoaXMuaXNCYXJIb3Jpem9udGFsID0gISEodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKTtcbiAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmNvbG9ycztcbiAgICB0aGlzLnhBeGlzb2ZmWCA9IDA7XG5cbiAgICBpZiAodGhpcy53LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMueEF4aXNvZmZYID0gdGhpcy53Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWUF4aXMsIFt7XG4gICAga2V5OiBcImRyYXdZYXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXMocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeWF4aXNGb250U2l6ZSA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgICAgdmFyIHlheGlzRm9udEZhbWlseSA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICB2YXIgZWxZYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzJyxcbiAgICAgICAgcmVsOiByZWFsSW5kZXgsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdICsgJywgMCknXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnNob3cpIHtcbiAgICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbFlheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nJ1xuICAgICAgfSk7XG4gICAgICBlbFlheGlzLmFkZChlbFlheGlzVGV4dHMpO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdLnJlc3VsdC5sZW5ndGggLSAxOyAvLyBsYWJlbHNEaXZpZGVyIGlzIHNpbXBseSBzdmcgaGVpZ2h0L251bWJlciBvZiB0aWNrc1xuXG4gICAgICB2YXIgbGFiZWxzRGl2aWRlciA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdGlja0Ftb3VudCArIDAuMTsgLy8gaW5pdGlhbCBsYWJlbCBwb3NpdGlvbiA9IDA7XG5cbiAgICAgIHZhciBsID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVk7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tyZWFsSW5kZXhdO1xuICAgICAgdmFyIGxhYmVscyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0LnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIGxhYmVscy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5zaG93KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aWNrQW1vdW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciB2YWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIodmFsLCBpKTtcbiAgICAgICAgICB2YXIgeFBhZCA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5vcHBvc2l0ZSAmJiB3LmNvbmZpZy55YXhpcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHhQYWQgPSB4UGFkICogLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeFBhZCxcbiAgICAgICAgICAgIHk6IGwgKyB0aWNrQW1vdW50IC8gMTAgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5vZmZzZXRZICsgMSxcbiAgICAgICAgICAgIHRleHQ6IHZhbCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgPyAnc3RhcnQnIDogJ2VuZCcsXG4gICAgICAgICAgICBmb250U2l6ZTogeWF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHlheGlzRm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuc3R5bGUuY29sb3IsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxZYXhpc1RleHRzLmFkZChsYWJlbCk7XG4gICAgICAgICAgdmFyIGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIobGFiZWwubm9kZSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBsYWJlbC5ub2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoXCIuY29uY2F0KHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdChsYWJlbFJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQobGFiZWxSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVsWWF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeCA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsWUF4aXNUaXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUtdGV4dCAnICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIF94ID0gMzEgKyBheGlzQm9yZGVyLm9mZnNldFg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICBfeCA9IC0zMSAtIGF4aXNCb3JkZXIub2Zmc2V0WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKF94LCB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIGF4aXNCb3JkZXIub2Zmc2V0WSAtIDIsIF94LCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIHcuZ2xvYmFscy50cmFuc2xhdGVZICsgYXhpc0JvcmRlci5vZmZzZXRZICsgMiwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWWF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1RpY2tzKF94LCB0aWNrQW1vdW50LCBheGlzQm9yZGVyLCB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNUaWNrcywgcmVhbEluZGV4LCBsYWJlbHNEaXZpZGVyLCBlbFlheGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgfSAvLyBUaGlzIGFjdHVhbGx5IGJlY29tZXMgaG9yaXpvbmFsIGF4aXMgKGZvciBiYXIgY2hhcnRzKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lheGlzSW52ZXJzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzSW52ZXJzZWQocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzIGFwZXhjaGFydHMteWF4aXMtaW52ZXJzZWQnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGVsWGF4aXMuYWRkKGVsWGF4aXNUZXh0cyk7XG4gICAgICB2YXIgdGlja0Ftb3VudCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0Lmxlbmd0aCAtIDE7IC8vIGxhYmVsc0RpdmlkZXIgaXMgc2ltcGx5IHN2ZyB3aWR0aC9udW1iZXIgb2YgdGlja3NcblxuICAgICAgdmFyIGxhYmVsc0RpdmlkZXIgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGlja0Ftb3VudCArIDAuMTsgLy8gaW5pdGlhbCBsYWJlbCBwb3NpdGlvbjtcblxuICAgICAgdmFyIGwgPSBsYWJlbHNEaXZpZGVyICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFg7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyO1xuICAgICAgdmFyIGxhYmVscyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0LnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIGxhYmVscy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGlja0Ftb3VudDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgdmFsID0gbGFiZWxzW2ldO1xuICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgaSk7XG4gICAgICAgICAgdmFyIGVsVGljayA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCAtIChsIC0gbGFiZWxzRGl2aWRlciArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYKSxcbiAgICAgICAgICAgIHk6IHRoaXMueEF4aXNvZmZYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFkgKyAzMCxcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkodGhpcy54YXhpc0ZvcmVDb2xvcnMpID8gdGhpcy54YXhpc0ZvcmVDb2xvcnNbcmVhbEluZGV4XSA6IHRoaXMueGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMueGF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMueGF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWxhYmVsICcgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFhheGlzVGV4dHMuYWRkKGVsVGljayk7XG4gICAgICAgICAgZWxUaWNrLnRzcGFuKHZhbCk7XG4gICAgICAgICAgdmFyIGVsVG9vbHRpcFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3RpdGxlJyk7XG4gICAgICAgICAgZWxUb29sdGlwVGl0bGUudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbFlheGlzVGl0bGUgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlIGFwZXhjaGFydHMteWF4aXMtdGl0bGUtaW52ZXJzZWQnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxZQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMixcbiAgICAgICAgICB5OiB0aGlzLnhBeGlzb2ZmWCArIHBhcnNlSW50KHRoaXMueGF4aXNGb250U2l6ZSkgKyBwYXJzZUludCh3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSkgKyAyMCxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZS10ZXh0ICcgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIGVsVmVydGljYWxMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyBheGlzQm9yZGVyLm9mZnNldFgsIDEgKyBheGlzQm9yZGVyLm9mZnNldFksIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgYXhpc0JvcmRlci5vZmZzZXRYLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGF4aXNCb3JkZXIub2Zmc2V0WSwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWGF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWGF4aXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBeGlzVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0F4aXNUaWNrcyh4LCB0aWNrQW1vdW50LCBheGlzQm9yZGVyLCBheGlzVGlja3MsIHJlYWxJbmRleCwgbGFiZWxzRGl2aWRlciwgZWxZYXhpcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpOyAvLyBpbml0aWFsIGxhYmVsIHBvc2l0aW9uID0gMDtcblxuICAgICAgdmFyIHQgPSB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcblxuICAgICAgaWYgKGF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLm9wcG9zaXRlID09PSB0cnVlKSB4ID0geCArIGF4aXNUaWNrcy53aWR0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gdGlja0Ftb3VudDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgdFkgPSB0ICsgdGlja0Ftb3VudCAvIDEwICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMub2Zmc2V0WSAtIDE7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRZID0gbGFiZWxzRGl2aWRlciAqIGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVsVGljayA9IGdyYXBoaWNzLmRyYXdMaW5lKHggKyBheGlzQm9yZGVyLm9mZnNldFggLSBheGlzVGlja3Mud2lkdGggKyBheGlzVGlja3Mub2Zmc2V0WCwgdFkgKyBheGlzVGlja3Mub2Zmc2V0WSwgeCArIGF4aXNCb3JkZXIub2Zmc2V0WCArIGF4aXNUaWNrcy5vZmZzZXRYLCB0WSArIGF4aXNUaWNrcy5vZmZzZXRZLCBheGlzQm9yZGVyLmNvbG9yKTtcbiAgICAgICAgICBlbFlheGlzLmFkZChlbFRpY2spO1xuICAgICAgICAgIHQgPSB0ICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5QXhpc1RpdGxlUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHlBeGlzVGl0bGVSb3RhdGUocmVhbEluZGV4LCB5QXhpc09wcG9zaXRlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeUF4aXNMYWJlbHNDb29yZCA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciB5QXhpc1RpdGxlQ29vcmQgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgZWxZQXhpc0xhYmVsc1dyYXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiIC5hcGV4Y2hhcnRzLXlheGlzW3JlbD0nXCIuY29uY2F0KHJlYWxJbmRleCwgXCInXSAuYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nXCIpKTtcblxuICAgICAgaWYgKGVsWUF4aXNMYWJlbHNXcmFwICE9PSBudWxsKSB7XG4gICAgICAgIHlBeGlzTGFiZWxzQ29vcmQgPSBlbFlBeGlzTGFiZWxzV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHlBeGlzVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQocmVhbEluZGV4LCBcIiddIC5hcGV4Y2hhcnRzLXlheGlzLXRpdGxlIHRleHRcIikpO1xuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB5QXhpc1RpdGxlQ29vcmQgPSB5QXhpc1RpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMueFBhZGRpbmdGb3JZQXhpc1RpdGxlKHJlYWxJbmRleCwgeUF4aXNMYWJlbHNDb29yZCwgeUF4aXNUaXRsZUNvb3JkLCB5QXhpc09wcG9zaXRlKTtcbiAgICAgICAgeUF4aXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ3gnLCB4LnhQb3MgLSAoeUF4aXNPcHBvc2l0ZSA/IDEwIDogMCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGl0bGVSb3RhdGluZ0NlbnRlciA9IGdyYXBoaWNzLnJvdGF0ZUFyb3VuZENlbnRlcih5QXhpc1RpdGxlKTtcblxuICAgICAgICBpZiAoIXlBeGlzT3Bwb3NpdGUpIHtcbiAgICAgICAgICB5QXhpc1RpdGxlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoLVwiLmNvbmNhdCh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdCh0aXRsZVJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlBeGlzVGl0bGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5yb3RhdGUsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KHRpdGxlUm90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4UGFkZGluZ0ZvcllBeGlzVGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geFBhZGRpbmdGb3JZQXhpc1RpdGxlKHJlYWxJbmRleCwgeUF4aXNMYWJlbHNDb29yZCwgeUF4aXNUaXRsZUNvb3JkLCB5QXhpc09wcG9zaXRlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBvcHBvc2l0ZUF4aXNDb3VudCA9IDA7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgcGFkZCA9IDEwO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ID09PSB1bmRlZmluZWQgfHwgcmVhbEluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHhQb3M6IHgsXG4gICAgICAgICAgcGFkZDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNPcHBvc2l0ZSkge1xuICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUub2Zmc2V0WCArIHlBeGlzVGl0bGVDb29yZC53aWR0aCAvIDIgKyBwYWRkIC8gMjtcbiAgICAgICAgb3Bwb3NpdGVBeGlzQ291bnQgKz0gMTtcblxuICAgICAgICBpZiAob3Bwb3NpdGVBeGlzQ291bnQgPT09IDApIHtcbiAgICAgICAgICB4ID0geCAtIHBhZGQgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCAqIC0xICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYICsgcGFkZCAvIDIgKyB5QXhpc1RpdGxlQ29vcmQud2lkdGggLyAyO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIHBhZGQgPSAyNTtcbiAgICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCAqIC0xIC0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYIC0gcGFkZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4UG9zOiB4LFxuICAgICAgICBwYWRkOiBwYWRkXG4gICAgICB9O1xuICAgIH0gLy8gc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgeS1heGlzIGJ5IGNvdW50aW5nIHRoZSBsYWJlbHMgd2lkdGgsIHRpdGxlIHdpZHRoIGFuZCBhbnkgb2Zmc2V0XG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRZQXhpc1hQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZQXhpc1hQb3NpdGlvbih5YXhpc0xhYmVsQ29vcmRzLCB5VGl0bGVDb29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhMZWZ0ID0gMDtcbiAgICAgIHZhciB4UmlnaHQgPSAwO1xuICAgICAgdmFyIGxlZnRPZmZzZXRYID0gMjE7XG4gICAgICB2YXIgcmlnaHRPZmZzZXRYID0gMTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZVlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICB2YXIgc2hvdWxkTm90RHJhd0F4aXMgPSB3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID4gLTEgfHwgIXlheGUuc2hvdyB8fCB5YXhlLmZsb2F0aW5nIHx8IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoID09PSAwO1xuICAgICAgICB2YXIgYXhpc1dpZHRoID0geWF4aXNMYWJlbENvb3Jkc1tpbmRleF0ud2lkdGggKyB5VGl0bGVDb29yZHNbaW5kZXhdLndpZHRoO1xuXG4gICAgICAgIGlmICgheWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgIHhMZWZ0ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVggLSBsZWZ0T2Zmc2V0WDtcblxuICAgICAgICAgIGlmICghc2hvdWxkTm90RHJhd0F4aXMpIHtcbiAgICAgICAgICAgIGxlZnRPZmZzZXRYID0gbGVmdE9mZnNldFggKyBheGlzV2lkdGggKyAyMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW2luZGV4XSA9IHhMZWZ0ICsgeWF4ZS5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4UmlnaHQgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVggLSAxO1xuICAgICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gPSB4UmlnaHQgLSB5YXhlLmxhYmVscy5vZmZzZXRYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4UmlnaHQgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVggKyByaWdodE9mZnNldFg7XG5cbiAgICAgICAgICAgIGlmICghc2hvdWxkTm90RHJhd0F4aXMpIHtcbiAgICAgICAgICAgICAgcmlnaHRPZmZzZXRYID0gcmlnaHRPZmZzZXRYICsgYXhpc1dpZHRoICsgMjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbaW5kZXhdID0geFJpZ2h0IC0geWF4ZS5sYWJlbHMub2Zmc2V0WCArIDIwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBeGlzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRm9ybWF0dGVyIENsYXNzIGZvciBzZXR0aW5nIHZhbHVlIGZvcm1hdHRlcnMgZm9yIGF4ZXMgYXMgd2VsbCBhcyB0b29sdGlwcy5cbiAqXG4gKiBAbW9kdWxlIEZvcm1hdHRlcnNcbiAqKi9cblxudmFyIEZvcm1hdHRlcnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXR0ZXJzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtYXR0ZXJzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMudG9vbHRpcEtleUZvcm1hdCA9ICdkZCBNTU0nO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm1hdHRlcnMsIFt7XG4gICAga2V5OiBcInhMYWJlbEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4TGFiZWxGb3JtYXQoZm4sIHZhbCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgIC8vIGlmIHVzZXIgaGFzIG5vdCBzcGVjaWZpZWQgYSBjdXN0b20gZm9ybWF0dGVyLCB1c2UgdGhlIGRlZmF1bHQgdG9vbHRpcC54LmZvcm1hdFxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC54LmZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhdGV0aW1lT2JqID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVPYmouZm9ybWF0RGF0ZShuZXcgRGF0ZSh2YWwpLCB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4odmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGFiZWxGb3JtYXR0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExhYmVsRm9ybWF0dGVycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy50dFpGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICB3Lmdsb2JhbHMubGVnZW5kRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcueGF4aXMudG9vbHRpcC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlciA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZm9ybWF0dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy50b29sdGlwLnkpKSB7XG4gICAgICAgIHcuZ2xvYmFscy50dFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLnkuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMudHRWYWwgPSB3LmNvbmZpZy50b29sdGlwLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuei5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMudHRaRm9ybWF0dGVyID0gdy5jb25maWcudG9vbHRpcC56LmZvcm1hdHRlcjtcbiAgICAgIH0gLy8gbGVnZW5kIGZvcm1hdHRlciAtIGlmIHVzZXIgd2FudHMgdG8gYXBwZW5kIGFueSBnbG9iYWwgdmFsdWVzIG9mIHNlcmllcyB0byBsZWdlbmQgdGV4dFxuXG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmxlZ2VuZEZvcm1hdHRlciA9IHcuY29uZmlnLmxlZ2VuZC5mb3JtYXR0ZXI7XG4gICAgICB9IC8vIGZvcm1hdHRlciBmdW5jdGlvbiB3aWxsIGFsd2F5cyBvdmVyd3JpdGUgZm9ybWF0IHByb3BlcnR5XG5cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgeGF4aXMgbWF5IGhhdmUgc21hbGxlciByYW5nZSwgc28gZGVmYXVsdGluZyB0byAxIGRlY2ltYWxcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnbnVtZXJpYycgJiYgdy5nbG9iYWxzLmRhdGFQb2ludHMgPCA1MCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSAvLyBmb3JtYXR0ZXIgZnVuY3Rpb24gd2lsbCBhbHdheXMgb3ZlcndyaXRlIGZvcm1hdCBwcm9wZXJ0eVxuXG5cbiAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGkpIHtcbiAgICAgICAgaWYgKHlheGUubGFiZWxzLmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaV0gPSB5YXhlLmxhYmVscy5mb3JtYXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLnlWYWx1ZURlY2ltYWwgIT09IDAgfHwgdy5nbG9iYWxzLm1heFkgLSB3Lmdsb2JhbHMubWluWSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoeWF4ZS5kZWNpbWFsc0luRmxvYXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHcuZ2xvYmFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhdG1hcExhYmVsRm9ybWF0dGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWF0bWFwTGFiZWxGb3JtYXR0ZXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ucmVzdWx0ID0gdy5nbG9iYWxzLnNlcmllc05hbWVzLnNsaWNlKCk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgICB2YXIgbG9uZ2VzdCA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1heCA9IGxvbmdlc3Q7XG4gICAgICAgIHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gPSBsb25nZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtYXR0ZXJzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWEF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWC1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWEF4aXNcbiAqKi9cblxudmFyIFhBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMueGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7XG5cbiAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vICB0aW1lbGluZSBsYWJlbHMgYXJlIHRoZXJlXG4gICAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3bkxhYmVscyA9IFtdO1xuXG4gICAgaWYgKHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgdGhpcy5vZmZZID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmZZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyAxO1xuICAgIH1cblxuICAgIHRoaXMub2ZmWSA9IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WTtcbiAgICB0aGlzLnhheGlzRm9udFNpemUgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemU7XG4gICAgdGhpcy54YXhpc0ZvbnRGYW1pbHkgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udEZhbWlseTtcbiAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgdGhpcy54YXhpc0JvcmRlcldpZHRoID0gdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci53aWR0aDtcblxuICAgIGlmICh0aGlzLnhheGlzQm9yZGVyV2lkdGguaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgIHRoaXMueGF4aXNCb3JkZXJXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKiBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpIC8gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnhheGlzQm9yZGVyV2lkdGggPSBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMueGF4aXNCb3JkZXJIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmhlaWdodDsgLy8gRm9yIGJhcnMsIHdlIHdpbGwgb25seSBjb25zaWRlciBzaW5nbGUgeSB4YWlzLFxuICAgIC8vIGFzIHdlIGFyZSBub3QgcHJvdmlkaW5nIG11bHRpcGxlIHlheGlzIGZvciBiYXIgY2hhcnRzXG5cbiAgICB0aGlzLnlheGlzID0gdy5jb25maWcueWF4aXNbMF07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWEF4aXMsIFt7XG4gICAga2V5OiBcImRyYXdYYXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGVsWGF4aXMuYWRkKGVsWGF4aXNUZXh0cyk7XG4gICAgICB2YXIgY29sV2lkdGg7IC8vIGluaXRpYWwgeCBQb3NpdGlvbiAoa2VlcCBhZGRpbmcgY29sdW1uIHdpZHRoIGluIHRoZSBsb29wKVxuXG4gICAgICB2YXIgeFBvcyA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFiZWxzLnB1c2godGhpcy54YXhpc0xhYmVsc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBjb2xXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAobGFiZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICB4UG9zID0geFBvcyArIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgeFBvcyA9IHhQb3MgKyBjb2xXaWR0aCArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcjtcbiAgICAgIHZhciBjdXN0b21Gb3JtYXR0ZXIgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgdmFyIGxhYmVsc0xlbiA9IGxhYmVscy5sZW5ndGg7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDw9IGxhYmVsc0xlbiAtIDE7IF9pKyspIHtcbiAgICAgICAgICB2YXIgcmF3TGFiZWwgPSB0eXBlb2YgbGFiZWxzW19pXSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGxhYmVsc1tfaV07XG4gICAgICAgICAgdmFyIGxhYmVsID0gdm9pZCAwO1xuICAgICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgIGxhYmVsID0geEZvcm1hdC54TGFiZWxGb3JtYXQoeGxiRm9ybWF0dGVyLCByYXdMYWJlbCk7XG5cbiAgICAgICAgICBpZiAoY3VzdG9tRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhYmVsID0gY3VzdG9tRm9ybWF0dGVyKHJhd0xhYmVsLCB0aGlzLnhheGlzTGFiZWxzW19pXSwgX2kpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4ID0geFBvcyAtIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB4ID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzW19pXS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxhYmVsID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzW19pXS52YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScgJiYgY3VzdG9tRm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGFiZWwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignTmFOJykgPT09IDAgfHwgbGFiZWwgPT09ICd1bmRlZmluZWQnIHx8IGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaW52YWxpZCcpID09PSAwIHx8IGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaW5maW5pdHknKSA+PSAwIHx8IHRoaXMuZHJhd25MYWJlbHMuaW5kZXhPZihsYWJlbCkgPj0gMCAmJiAhdy5jb25maWcueGF4aXMubGFiZWxzLnNob3dEdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICBsYWJlbCA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZHJhd25MYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgdmFyIG9mZnNldFlDb3JyZWN0aW9uID0gMjg7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMpIHtcbiAgICAgICAgICAgIG9mZnNldFlDb3JyZWN0aW9uID0gMjI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVsVGljayA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB0aGlzLm9mZlkgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WSArIG9mZnNldFlDb3JyZWN0aW9uLFxuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLnhheGlzRm9udFNpemUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLnhheGlzRm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogQXJyYXkuaXNBcnJheSh0aGlzLnhheGlzRm9yZUNvbG9ycykgPyB0aGlzLnhheGlzRm9yZUNvbG9yc1tfaV0gOiB0aGlzLnhheGlzRm9yZUNvbG9ycyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy1sYWJlbCAnICsgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxYYXhpc1RleHRzLmFkZChlbFRpY2spO1xuICAgICAgICAgIGdyYXBoaWNzLmFkZFRzcGFuKGVsVGljaywgbGFiZWwsIHRoaXMueGF4aXNGb250RmFtaWx5KTtcbiAgICAgICAgICB2YXIgZWxUb29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAndGl0bGUnKTtcbiAgICAgICAgICBlbFRvb2x0aXBUaXRsZS50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICAgIGVsVGljay5ub2RlLmFwcGVuZENoaWxkKGVsVG9vbHRpcFRpdGxlKTtcbiAgICAgICAgICB4UG9zID0geFBvcyArIGNvbFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVsWGF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteGF4aXMtdGl0bGUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxYQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLnRpdGxlLm9mZnNldFgsXG4gICAgICAgICAgeTogdGhpcy5vZmZZIC0gcGFyc2VJbnQodGhpcy54YXhpc0ZvbnRTaXplKSArIHcuZ2xvYmFscy54QXhpc0xhYmVsc0hlaWdodCArIHcuY29uZmlnLnhheGlzLnRpdGxlLm9mZnNldFksXG4gICAgICAgICAgdGV4dDogdy5jb25maWcueGF4aXMudGl0bGUudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb250U2l6ZTogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3I6IHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZS10ZXh0ICcgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxYYXhpc1RpdGxlLmFkZChlbFhBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxYYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIuc2hvdykge1xuICAgICAgICB2YXIgbGluZUNvcnJlY3Rpb24gPSAwO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIGxpbmVDb3JyZWN0aW9uID0gbGluZUNvcnJlY3Rpb24gLSAxNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEhvcnpMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyBsaW5lQ29ycmVjdGlvbiArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WCwgdGhpcy5vZmZZLCB0aGlzLnhheGlzQm9yZGVyV2lkdGgsIHRoaXMub2ZmWSwgdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci5jb2xvciwgMCwgdGhpcy54YXhpc0JvcmRlckhlaWdodCk7XG4gICAgICAgIGVsWGF4aXMuYWRkKGVsSG9yekxpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxYYXhpcztcbiAgICB9IC8vIHRoaXMgYWN0dWFsbHkgYmVjb21lcyB0aGUgdmVydGljYWwgYXhpcyAoZm9yIGJhciBjaGFydHMpXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3WGF4aXNJbnZlcnNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXNJbnZlcnNlZChyZWFsSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB0cmFuc2xhdGVZQXhpc1ggPSB3LmNvbmZpZy55YXhpc1swXS5vcHBvc2l0ZSA/IHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbcmVhbEluZGV4XSA6IDA7XG4gICAgICB2YXIgZWxZYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzIGFwZXhjaGFydHMteGF4aXMtaW52ZXJzZWQnLFxuICAgICAgICByZWw6IHJlYWxJbmRleFxuICAgICAgfSk7XG4gICAgICB2YXIgZWxZYXhpc1RleHRzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGV4dHMtZyBhcGV4Y2hhcnRzLXhheGlzLWludmVyc2VkLXRleHRzLWcnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVlBeGlzWCArICcsIDApJ1xuICAgICAgfSk7XG4gICAgICBlbFlheGlzLmFkZChlbFlheGlzVGV4dHMpO1xuICAgICAgdmFyIGNvbEhlaWdodDsgLy8gaW5pdGlhbCB4IFBvc2l0aW9uIChrZWVwIGFkZGluZyBjb2x1bW4gd2lkdGggaW4gdGhlIGxvb3ApXG5cbiAgICAgIHZhciB5UG9zO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFiZWxzLnB1c2godGhpcy54YXhpc0xhYmVsc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gbGFiZWxzLmxlbmd0aDtcbiAgICAgIHlQb3MgPSAtKGNvbEhlaWdodCAvIDIuMik7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1swXTtcbiAgICAgIHZhciB5bGFiZWxzID0gdy5jb25maWcueWF4aXNbMF0ubGFiZWxzO1xuXG4gICAgICBpZiAoeWxhYmVscy5zaG93KSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8PSBsYWJlbHMubGVuZ3RoIC0gMTsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSB0eXBlb2YgbGFiZWxzW19pMl0gPT09ICd1bmRlZmluZWQnID8gJycgOiBsYWJlbHNbX2kyXTtcbiAgICAgICAgICBsYWJlbCA9IGxiRm9ybWF0dGVyKGxhYmVsKTtcbiAgICAgICAgICB2YXIgZWxMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHlsYWJlbHMub2Zmc2V0WCAtIDE1LFxuICAgICAgICAgICAgeTogeVBvcyArIGNvbEhlaWdodCArIHlsYWJlbHMub2Zmc2V0WSxcbiAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogdGhpcy55YXhpcy5vcHBvc2l0ZSA/ICdzdGFydCcgOiAnZW5kJyxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogeWxhYmVscy5zdHlsZS5jb2xvciA/IHlsYWJlbHMuc3R5bGUuY29sb3IgOiB5bGFiZWxzLnN0eWxlLmNvbG9yc1tfaTJdLFxuICAgICAgICAgICAgZm9udFNpemU6IHlsYWJlbHMuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB5bGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHlsYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICB9KTsgLy8gbGV0IGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoZWxMYWJlbC5ub2RlKVxuICAgICAgICAgIC8vIGlmICh5bGFiZWxzLnJvdGF0ZSAhPT0gMCkge1xuICAgICAgICAgIC8vICAgZWxMYWJlbC5ub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAvLyAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgLy8gICAgIGByb3RhdGUoJHt5bGFiZWxzLnJvdGF0ZX0gJHtsYWJlbFJvdGF0aW5nQ2VudGVyLnh9ICR7bGFiZWxSb3RhdGluZ0NlbnRlci55fSlgXG4gICAgICAgICAgLy8gICApXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgZWxZYXhpc1RleHRzLmFkZChlbExhYmVsKTtcbiAgICAgICAgICB5UG9zID0geVBvcyArIGNvbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbMF0udGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbFhheGlzVGl0bGUgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLXRpdGxlIGFwZXhjaGFydHMteGF4aXMtdGl0bGUtaW52ZXJzZWQnLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWUF4aXNYICsgJywgMCknXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxYQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gMixcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueWF4aXNbMF0udGl0bGUuc3R5bGUuY29sb3IsXG4gICAgICAgICAgZm9udFNpemU6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBlbFhheGlzVGl0bGUuYWRkKGVsWEF4aXNUaXRsZVRleHQpO1xuICAgICAgICBlbFlheGlzLmFkZChlbFhheGlzVGl0bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuYXhpc0JvcmRlci5zaG93KSB7XG4gICAgICAgIHZhciBlbEhvcnpMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLm9mZnNldFgsIHRoaXMub2ZmWSwgdGhpcy54YXhpc0JvcmRlcldpZHRoLCB0aGlzLm9mZlksIHRoaXMueWF4aXMuYXhpc0JvcmRlci5jb2xvciwgMCwgdGhpcy54YXhpc0JvcmRlckhlaWdodCk7XG4gICAgICAgIGVsWWF4aXMuYWRkKGVsSG9yekxpbmUpOyAvLyBsZXQgeCA9IHcuZ2xvYmFscy55QXhpc1dpZHRoc1swXSAvIDJcbiAgICAgICAgLy8gaWYgKHcuY29uZmlnLnlheGlzWzBdLm9wcG9zaXRlKSB7XG4gICAgICAgIC8vICAgeCA9IC13Lmdsb2JhbHMueUF4aXNXaWR0aHNbMF0gLyAyXG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgeWF4aXMgPSBuZXcgWUF4aXModGhpcy5jdHgpO1xuICAgICAgICB5YXhpcy5kcmF3QXhpc1RpY2tzKDAsIGxhYmVscy5sZW5ndGgsIHcuY29uZmlnLnlheGlzWzBdLmF4aXNCb3JkZXIsIHcuY29uZmlnLnlheGlzWzBdLmF4aXNUaWNrcywgMCwgY29sSGVpZ2h0LCBlbFlheGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdYYXhpc1RpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc1RpY2tzKHgxLCBhcHBlbmRUb0VsZW1lbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHgyID0geDE7XG4gICAgICBpZiAoeDEgPCAwIHx8IHgxID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkgcmV0dXJuO1xuICAgICAgdmFyIHkxID0gdGhpcy5vZmZZICsgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLm9mZnNldFk7XG4gICAgICB2YXIgeTIgPSB5MSArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5oZWlnaHQ7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5heGlzVGlja3Muc2hvdykge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHgxICsgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLm9mZnNldFgsIHkxICsgdy5jb25maWcueGF4aXMub2Zmc2V0WSwgeDIgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Mub2Zmc2V0WCwgeTIgKyB3LmNvbmZpZy54YXhpcy5vZmZzZXRZLCB3LmNvbmZpZy54YXhpcy5heGlzVGlja3MuY29sb3IpOyAvLyB3ZSBhcmUgbm90IHJldHVybmluZyBhbnl0aGluZywgYnV0IGFwcGVuZGluZyBkaXJlY3RseSB0byB0aGUgZWxlbWVudCBwYXNlZCBpbiBwYXJhbVxuXG4gICAgICAgIGFwcGVuZFRvRWxlbWVudC5hZGQobGluZSk7XG4gICAgICAgIGxpbmUubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXhheGlzLXRpY2snKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WEF4aXNUaWNrc1Bvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYQXhpc1RpY2tzUG9zaXRpb25zKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeEF4aXNUaWNrc1Bvc2l0aW9ucyA9IFtdO1xuICAgICAgdmFyIHhDb3VudCA9IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoO1xuICAgICAgdmFyIHgxID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgeDEgPSB0aGlzLnhheGlzTGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgIHhBeGlzVGlja3NQb3NpdGlvbnMucHVzaCh4MSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cyA9IHhDb3VudDtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0czsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgeDFDb3VudCA9IHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdiYXInKSB7XG4gICAgICAgICAgICB4MUNvdW50IC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSB4MSArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyB4MUNvdW50O1xuICAgICAgICAgIHhBeGlzVGlja3NQb3NpdGlvbnMucHVzaCh4MSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHhBeGlzVGlja3NQb3NpdGlvbnM7XG4gICAgfSAvLyB0byByb3RhdGUgeC1heGlzIGxhYmVscyBvciB0byBwdXQgLi4uIGZvciBsb25nZXIgdGV4dCBpbiB4YXhpc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwieEF4aXNMYWJlbENvcnJlY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHhBeGlzTGFiZWxDb3JyZWN0aW9ucygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB4QXhpcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXhheGlzLXRleHRzLWcnKTtcbiAgICAgIHZhciB4QXhpc1RleHRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZyB0ZXh0Jyk7XG4gICAgICB2YXIgeUF4aXNUZXh0c0ludmVyc2VkID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteWF4aXMtaW52ZXJzZWQgdGV4dCcpO1xuICAgICAgdmFyIHhBeGlzVGV4dHNJbnZlcnNlZCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXhheGlzLWludmVyc2VkLXRleHRzLWcgdGV4dCcpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgfHwgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZUFsd2F5cykge1xuICAgICAgICBmb3IgKHZhciB4YXQgPSAwOyB4YXQgPCB4QXhpc1RleHRzLmxlbmd0aDsgeGF0KyspIHtcbiAgICAgICAgICB2YXIgdGV4dFJvdGF0aW5nQ2VudGVyID0gZ3JhcGhpY3Mucm90YXRlQXJvdW5kQ2VudGVyKHhBeGlzVGV4dHNbeGF0XSk7XG4gICAgICAgICAgdGV4dFJvdGF0aW5nQ2VudGVyLnkgPSB0ZXh0Um90YXRpbmdDZW50ZXIueSAtIDE7IC8vICsgdGlja1dpZHRoLzQ7XG5cbiAgICAgICAgICB0ZXh0Um90YXRpbmdDZW50ZXIueCA9IHRleHRSb3RhdGluZ0NlbnRlci54ICsgMTtcbiAgICAgICAgICB4QXhpc1RleHRzW3hhdF0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdCh0ZXh0Um90YXRpbmdDZW50ZXIueCwgXCIgXCIpLmNvbmNhdCh0ZXh0Um90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgICB4QXhpc1RleHRzW3hhdF0uc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsIFwiZW5kXCIpO1xuICAgICAgICAgIHZhciBvZmZzZXRIZWlnaHQgPSAxMDtcbiAgICAgICAgICB4QXhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwidHJhbnNsYXRlKDAsIFwiLmNvbmNhdCgtb2Zmc2V0SGVpZ2h0LCBcIilcIikpO1xuICAgICAgICAgIHZhciB0U3BhbiA9IHhBeGlzVGV4dHNbeGF0XS5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy50cmltKSB7XG4gICAgICAgICAgICBncmFwaGljcy5wbGFjZVRleHRXaXRoRWxsaXBzaXModFNwYW5bMF0sIHRTcGFuWzBdLnRleHRDb250ZW50LCB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWF4SGVpZ2h0IC0gNDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF94YXQgPSAwOyBfeGF0IDwgeEF4aXNUZXh0cy5sZW5ndGg7IF94YXQrKykge1xuICAgICAgICAgIHZhciBfdFNwYW4gPSB4QXhpc1RleHRzW194YXRdLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnRyaW0gJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2JhcicgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGdyYXBoaWNzLnBsYWNlVGV4dFdpdGhFbGxpcHNpcyhfdFNwYW5bMF0sIF90U3BhblswXS50ZXh0Q29udGVudCwgd2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gdHJ1bmNhdGUgcm90YXRlZCB5IGF4aXMgaW4gYmFyIGNoYXJ0ICh4IGF4aXMpXG4gICAgICAgIHZhciBmaXJzdExhYmVsUG9zWCA9IHlBeGlzVGV4dHNJbnZlcnNlZFt5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoIC0gMV0uZ2V0QkJveCgpO1xuICAgICAgICB2YXIgbGFzdExhYmVsUG9zWCA9IHlBeGlzVGV4dHNJbnZlcnNlZFswXS5nZXRCQm94KCk7XG5cbiAgICAgICAgaWYgKGZpcnN0TGFiZWxQb3NYLnggPCAtMjApIHtcbiAgICAgICAgICB5QXhpc1RleHRzSW52ZXJzZWRbeUF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeUF4aXNUZXh0c0ludmVyc2VkW3lBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdExhYmVsUG9zWC54ICsgbGFzdExhYmVsUG9zWC53aWR0aCA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgICB5QXhpc1RleHRzSW52ZXJzZWRbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh5QXhpc1RleHRzSW52ZXJzZWRbMF0pO1xuICAgICAgICB9IC8vIHRydW5jYXRlIHJvdGF0ZWQgeCBheGlzIGluIGJhciBjaGFydCAoeSBheGlzKVxuXG5cbiAgICAgICAgZm9yICh2YXIgX3hhdDIgPSAwOyBfeGF0MiA8IHhBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGg7IF94YXQyKyspIHtcbiAgICAgICAgICBncmFwaGljcy5wbGFjZVRleHRXaXRoRWxsaXBzaXMoeEF4aXNUZXh0c0ludmVyc2VkW194YXQyXSwgeEF4aXNUZXh0c0ludmVyc2VkW194YXQyXS50ZXh0Q29udGVudCwgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm1heFdpZHRoIC0gcGFyc2VJbnQody5jb25maWcueWF4aXNbMF0udGl0bGUuc3R5bGUuZm9udFNpemUpICogMiAtIDIwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVuZGVyWEF4aXNCYW5kcygpIHtcbiAgICAvLyAgIGxldCB3ID0gdGhpcy53O1xuICAgIC8vICAgbGV0IHBsb3RCYW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3JlY3QnKVxuICAgIC8vICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQocGxvdEJhbmQpXG4gICAgLy8gfVxuXG4gIH1dKTtcblxuICByZXR1cm4gWEF4aXM7XG59KCk7XG5cbnZhciBSYW5nZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhbmdlKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmlzQmFySG9yaXpvbnRhbCA9ICEhKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCk7XG4gIH0gLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMjY2NzkvY2hvb3NpbmctYW4tYXR0cmFjdGl2ZS1saW5lYXItc2NhbGUtZm9yLWEtZ3JhcGhzLXktYXhpc3NcbiAgLy8gVGhpcyByb3V0aW5lIGNyZWF0ZXMgdGhlIFkgYXhpcyB2YWx1ZXMgZm9yIGEgZ3JhcGguXG5cblxuICBfY3JlYXRlQ2xhc3MoUmFuZ2UsIFt7XG4gICAga2V5OiBcIm5pY2VTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuaWNlU2NhbGUoeU1pbiwgeU1heCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxMDtcblxuICAgICAgaWYgKHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUgJiYgeU1heCA9PT0gMCB8fCAhVXRpbHMuaXNOdW1iZXIoeU1pbikgJiYgIVV0aWxzLmlzTnVtYmVyKHlNYXgpIHx8IHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUgJiYgeU1heCA9PT0gLU51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgLy8gd2hlbiBhbGwgdmFsdWVzIGFyZSAwXG4gICAgICAgIHlNaW4gPSAwO1xuICAgICAgICB5TWF4ID0gdGlja3M7XG4gICAgICAgIHZhciBsaW5lYXJTY2FsZSA9IHRoaXMubGluZWFyU2NhbGUoeU1pbiwgeU1heCwgdGlja3MpO1xuICAgICAgICByZXR1cm4gbGluZWFyU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh5TWluID4geU1heCkge1xuICAgICAgICAvLyBpZiBzb21laG93IGR1ZSB0byBzb21lIHdyb25nIGNvbmZpZywgdXNlciBzZW50IG1heCBsZXNzIHRoYW4gbWluLFxuICAgICAgICAvLyBhZGp1c3QgdGhlIG1pbi9tYXggYWdhaW5cbiAgICAgICAgY29uc29sZS53YXJuKCd5YXhpcy5taW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB5YXhpcy5tYXgnKTtcbiAgICAgICAgeU1heCA9IHlNaW4gKyAwLjE7XG4gICAgICB9IGVsc2UgaWYgKHlNaW4gPT09IHlNYXgpIHtcbiAgICAgICAgLy8gSWYgeU1pbiBhbmQgeU1heCBhcmUgaWRlbnRpY2FsLCB0aGVuXG4gICAgICAgIC8vIGFkanVzdCB0aGUgeU1pbiBhbmQgeU1heCB2YWx1ZXMgdG8gYWN0dWFsbHlcbiAgICAgICAgLy8gbWFrZSBhIGdyYXBoLiBBbHNvIGF2b2lkcyBkaXZpc2lvbiBieSB6ZXJvIGVycm9ycy5cbiAgICAgICAgeU1pbiA9IHlNaW4gPT09IDAgPyAwIDogeU1pbiAtIDAuMTsgLy8gc29tZSBzbWFsbCB2YWx1ZVxuXG4gICAgICAgIHlNYXggPSB5TWF4ID09PSAwID8gMiA6IHlNYXggKyAwLjE7IC8vIHNvbWUgc21hbGwgdmFsdWVcbiAgICAgIH0gLy8gQ2FsY3VsYXRlIE1pbiBhbWQgTWF4IGdyYXBoaWNhbCBsYWJlbHMgYW5kIGdyYXBoXG4gICAgICAvLyBpbmNyZW1lbnRzLiAgVGhlIG51bWJlciBvZiB0aWNrcyBkZWZhdWx0cyB0b1xuICAgICAgLy8gMTAgd2hpY2ggaXMgdGhlIFNVR0dFU1RFRCB2YWx1ZS4gIEFueSB0aWNrIHZhbHVlXG4gICAgICAvLyBlbnRlcmVkIGlzIHVzZWQgYXMgYSBzdWdnZXN0ZWQgdmFsdWUgd2hpY2ggaXNcbiAgICAgIC8vIGFkanVzdGVkIHRvIGJlIGEgJ3ByZXR0eScgdmFsdWUuXG4gICAgICAvL1xuICAgICAgLy8gT3V0cHV0IHdpbGwgYmUgYW4gYXJyYXkgb2YgdGhlIFkgYXhpcyB2YWx1ZXMgdGhhdFxuICAgICAgLy8gZW5jb21wYXNzIHRoZSBZIHZhbHVlcy5cblxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107IC8vIERldGVybWluZSBSYW5nZVxuXG4gICAgICB2YXIgcmFuZ2UgPSB5TWF4IC0geU1pbjtcbiAgICAgIHZhciB0aWtzID0gdGlja3MgKyAxOyAvLyBBZGp1c3QgdGlja3MgaWYgbmVlZGVkXG5cbiAgICAgIGlmICh0aWtzIDwgMikge1xuICAgICAgICB0aWtzID0gMjtcbiAgICAgIH0gZWxzZSBpZiAodGlrcyA+IDIpIHtcbiAgICAgICAgdGlrcyAtPSAyO1xuICAgICAgfSAvLyBHZXQgcmF3IHN0ZXAgdmFsdWVcblxuXG4gICAgICB2YXIgdGVtcFN0ZXAgPSByYW5nZSAvIHRpa3M7IC8vIENhbGN1bGF0ZSBwcmV0dHkgc3RlcCB2YWx1ZVxuXG4gICAgICB2YXIgbWFnID0gTWF0aC5mbG9vcihVdGlscy5sb2cxMCh0ZW1wU3RlcCkpO1xuICAgICAgdmFyIG1hZ1BvdyA9IE1hdGgucG93KDEwLCBtYWcpO1xuICAgICAgdmFyIG1hZ01zZCA9IHBhcnNlSW50KHRlbXBTdGVwIC8gbWFnUG93KTtcbiAgICAgIHZhciBzdGVwU2l6ZSA9IG1hZ01zZCAqIG1hZ1BvdzsgLy8gYnVpbGQgWSBsYWJlbCBhcnJheS5cbiAgICAgIC8vIExvd2VyIGFuZCB1cHBlciBib3VuZHMgY2FsY3VsYXRpb25zXG5cbiAgICAgIHZhciBsYiA9IHN0ZXBTaXplICogTWF0aC5mbG9vcih5TWluIC8gc3RlcFNpemUpO1xuICAgICAgdmFyIHViID0gc3RlcFNpemUgKiBNYXRoLmNlaWwoeU1heCAvIHN0ZXBTaXplKTsgLy8gQnVpbGQgYXJyYXlcblxuICAgICAgdmFyIHZhbCA9IGxiO1xuXG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICB2YWwgKz0gc3RlcFNpemU7XG5cbiAgICAgICAgaWYgKHZhbCA+IHViKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogbmVlZCB0byByZW1vdmUgdGhpcyBjb25kaXRpb24gYmVsb3cgd2hpY2ggbWFrZXMgdGhpcyBmdW5jdGlvbiB0aWdodGx5IGNvdXBsZWQgd2l0aCB3LlxuXG5cbiAgICAgIGlmICh0aGlzLncuY29uZmlnLnlheGlzW2luZGV4XS5tYXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLncuY29uZmlnLnlheGlzW2luZGV4XS5taW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzLncuY29uZmlnLnlheGlzW2luZGV4XS5mb3JjZU5pY2VTY2FsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgIG5pY2VNaW46IHJlc3VsdFswXSxcbiAgICAgICAgICBuaWNlTWF4OiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHYgPSB5TWluO1xuICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgdmFyIHZhbHVlc0RpdmlkZXIgPSBNYXRoLmFicyh5TWF4IC0geU1pbikgLyB0aWNrcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aWNrcyAtIDE7IGkrKykge1xuICAgICAgICAgIHYgPSB2ICsgdmFsdWVzRGl2aWRlcjtcbiAgICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgbmljZU1pbjogcmVzdWx0WzBdLFxuICAgICAgICAgIG5pY2VNYXg6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGluZWFyU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZWFyU2NhbGUoeU1pbiwgeU1heCkge1xuICAgICAgdmFyIHRpY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDtcbiAgICAgIHZhciByYW5nZSA9IE1hdGguYWJzKHlNYXggLSB5TWluKTtcbiAgICAgIHZhciBzdGVwID0gcmFuZ2UgLyB0aWNrcztcblxuICAgICAgaWYgKHRpY2tzID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgIHRpY2tzID0gMTA7XG4gICAgICAgIHN0ZXAgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgdiA9IHlNaW47XG5cbiAgICAgIHdoaWxlICh0aWNrcyA+PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB2ID0gdiArIHN0ZXA7XG4gICAgICAgIHRpY2tzIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgIG5pY2VNYXg6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZ2FyaXRobWljU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nYXJpdGhtaWNTY2FsZShpbmRleCwgeU1pbiwgeU1heCwgdGlja3MpIHtcbiAgICAgIGlmICh5TWluIDwgMCB8fCB5TWluID09PSBOdW1iZXIuTUlOX1ZBTFVFKSB5TWluID0gMC4wMTtcbiAgICAgIHZhciBiYXNlID0gMTA7XG4gICAgICB2YXIgbWluID0gTWF0aC5sb2coeU1pbikgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICAgIHZhciBtYXggPSBNYXRoLmxvZyh5TWF4KSAvIE1hdGgubG9nKGJhc2UpO1xuICAgICAgdmFyIHJhbmdlID0gTWF0aC5hYnMoeU1heCAtIHlNaW4pO1xuICAgICAgdmFyIHN0ZXAgPSByYW5nZSAvIHRpY2tzO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHYgPSB5TWluO1xuXG4gICAgICB3aGlsZSAodGlja3MgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgdiA9IHYgKyBzdGVwO1xuICAgICAgICB0aWNrcyAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9ncyA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKG5pY2VOdW1iZXIsIGkpIHtcbiAgICAgICAgaWYgKG5pY2VOdW1iZXIgPD0gMCkge1xuICAgICAgICAgIG5pY2VOdW1iZXIgPSAwLjAxO1xuICAgICAgICB9IC8vIGNhbGN1bGF0ZSBhZGp1c3RtZW50IGZhY3RvclxuXG5cbiAgICAgICAgdmFyIHNjYWxlID0gKG1heCAtIG1pbikgLyAoeU1heCAtIHlNaW4pO1xuICAgICAgICB2YXIgbG9nVmFsID0gTWF0aC5wb3coYmFzZSwgbWluICsgc2NhbGUgKiAobmljZU51bWJlciAtIG1pbikpO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChsb2dWYWwgLyBVdGlscy5yb3VuZFRvQmFzZShsb2dWYWwsIGJhc2UpKSAqIFV0aWxzLnJvdW5kVG9CYXNlKGxvZ1ZhbCwgYmFzZSk7XG4gICAgICB9KTsgLy8gTWF0aC5mbG9vciBtYXkgaGF2ZSByb3VuZGVkIHRoZSB2YWx1ZSB0byAwLCByZXZlcnQgYmFjayB0byAxXG5cbiAgICAgIGlmIChsb2dzWzBdID09PSAwKSBsb2dzWzBdID0gMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogbG9ncyxcbiAgICAgICAgbmljZU1pbjogbG9nc1swXSxcbiAgICAgICAgbmljZU1heDogbG9nc1tsb2dzLmxlbmd0aCAtIDFdXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRZU2NhbGVGb3JJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZU2NhbGVGb3JJbmRleChpbmRleCwgbWluWSwgbWF4WSkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciB5ID0gdGhpcy5pc0Jhckhvcml6b250YWwgPyBjbmYueGF4aXMgOiBjbmYueWF4aXNbaW5kZXhdO1xuXG4gICAgICBpZiAodHlwZW9mIGdsLnlBeGlzU2NhbGVbaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoeS5sb2dhcml0aG1pYykge1xuICAgICAgICBnbC5hbGxTZXJpZXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLmxvZ2FyaXRobWljU2NhbGUoaW5kZXgsIG1pblksIG1heFksIHkudGlja0Ftb3VudCA/IHkudGlja0Ftb3VudCA6IE1hdGguZmxvb3IoTWF0aC5sb2cxMChtYXhZKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1heFkgPT09IC1OdW1iZXIuTUFYX1ZBTFVFIHx8ICFVdGlscy5pc051bWJlcihtYXhZKSkge1xuICAgICAgICAgIC8vIG5vIGRhdGEgaW4gdGhlIGNoYXJ0LiBFaXRoZXIgYWxsIHNlcmllcyBjb2xsYXBzZWQgb3IgdXNlciBwYXNzZWQgYSBibGFuayBhcnJheVxuICAgICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0gdGhpcy5saW5lYXJTY2FsZSgwLCA1LCA1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVyZSBpcyBzb21lIGRhdGEuIFR1cm4gb2ZmIHRoZSBhbGxTZXJpZXNDb2xsYXBzZWQgZmxhZ1xuICAgICAgICAgIGdsLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0gdGhpcy5uaWNlU2NhbGUobWluWSwgbWF4WSwgaW5kZXgsIHkudGlja0Ftb3VudCA/IHkudGlja0Ftb3VudCA6IDUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE11bHRpcGxlWVNjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNdWx0aXBsZVlTY2FsZXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIG1pbllBcnIgPSBnbC5taW5ZQXJyLmNvbmNhdChbXSk7XG4gICAgICB2YXIgbWF4WUFyciA9IGdsLm1heFlBcnIuY29uY2F0KFtdKTtcbiAgICAgIHZhciBzY2FsZXNJbmRpY2VzID0gW107IC8vIGhlcmUsIHdlIGxvb3AgdGhyb3VnaCB0aGUgeWF4aXMgYXJyYXkgYW5kIGZpbmQgdGhlIGl0ZW0gd2hpY2ggaGFzIFwic2VyaWVzTmFtZVwiIHByb3BlcnR5XG5cbiAgICAgIGNuZi55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGk7XG4gICAgICAgIGNuZi5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocywgc2kpIHtcbiAgICAgICAgICAvLyBpZiBzZXJpZXNOYW1lIG1hdGNoZXMgYW5kIHRoYXQgc2VyaWVzIGlzIG5vdCBjb2xsYXBzZWQsIHdlIHVzZSB0aGF0IHNjYWxlXG4gICAgICAgICAgaWYgKHMubmFtZSA9PT0geWF4ZS5zZXJpZXNOYW1lICYmIGdsLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihzaSkgPT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleCA9IHNpO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gc2kpIHtcbiAgICAgICAgICAgICAgc2NhbGVzSW5kaWNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogc2ksXG4gICAgICAgICAgICAgICAgc2ltaWxhckluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGFscmVhZHlFeGlzdHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY2FsZXNJbmRpY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBzaVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWluWSA9IG1pbllBcnJbaW5kZXhdO1xuICAgICAgICB2YXIgbWF4WSA9IG1heFlBcnJbaW5kZXhdO1xuXG4gICAgICAgIF90aGlzLnNldFlTY2FsZUZvckluZGV4KGksIG1pblksIG1heFkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNhbWVTY2FsZUluTXVsdGlwbGVBeGVzKG1pbllBcnIsIG1heFlBcnIsIHNjYWxlc0luZGljZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzYW1lU2NhbGVJbk11bHRpcGxlQXhlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1lU2NhbGVJbk11bHRpcGxlQXhlcyhtaW5ZQXJyLCBtYXhZQXJyLCBzY2FsZXNJbmRpY2VzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFsczsgLy8gd2UgZ290IHRoZSBzY2FsZXNJbmRpY2VzIGFycmF5IGluIHRoZSBhYm92ZSBjb2RlLCBidXQgd2UgbmVlZCB0byBmaWx0ZXIgb3V0IHRoZSBpdGVtcyB3aGljaCBkb2Vzbid0IGhhdmUgc2FtZSBzY2FsZXNcblxuICAgICAgdmFyIHNpbWlsYXJJbmRpY2VzID0gW107XG4gICAgICBzY2FsZXNJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIGlmIChzY2FsZS5hbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzaW1pbGFySW5kaWNlc1tzY2FsZS5pbmRleF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaW1pbGFySW5kaWNlc1tzY2FsZS5pbmRleF0gPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzaW1pbGFySW5kaWNlc1tzY2FsZS5pbmRleF0ucHVzaChzY2FsZS5pbmRleCk7XG4gICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdLnB1c2goc2NhbGUuc2ltaWxhckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYi5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzaW1pbGFySW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaSwgaSkge1xuICAgICAgICBzaW1pbGFySW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaiwgaikge1xuICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KHNpLCBzaikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzaW1pbGFySW5kaWNlc1tpXSA9IHNpbWlsYXJJbmRpY2VzW2ldLmNvbmNhdChzaW1pbGFySW5kaWNlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyB0aGVuLCB3ZSByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBzaW1pbGFyU2NhbGUgYXJyYXlcblxuICAgICAgdmFyIHVuaXF1ZVNpbWlsYXJJbmRpY2VzID0gc2ltaWxhckluZGljZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmZpbHRlcihmdW5jdGlvbiAoaSwgcG9zKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0uaW5kZXhPZihpKSA9PT0gcG9zO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBzb3J0IGZ1cnRoZXIgdG8gcmVtb3ZlIHdob2xlIGR1cGxpY2F0ZSBhcnJheXMgbGF0ZXJcblxuICAgICAgdmFyIHNvcnRlZEluZGljZXMgPSB1bmlxdWVTaW1pbGFySW5kaWNlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuc29ydCgpO1xuICAgICAgfSk7IC8vIHJlbW92ZSB1bmRlZmluZWQgaXRlbXNcblxuICAgICAgc2ltaWxhckluZGljZXMgPSBzaW1pbGFySW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuICEhcztcbiAgICAgIH0pO1xuICAgICAgdmFyIGluZGljZXMgPSBzb3J0ZWRJbmRpY2VzLnNsaWNlKCk7XG4gICAgICB2YXIgc3RyaW5nSW5kaWNlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpbmQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZCk7XG4gICAgICB9KTtcbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLmZpbHRlcihmdW5jdGlvbiAoaW5kLCBwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdJbmRpY2VzLmluZGV4T2YoSlNPTi5zdHJpbmdpZnkoaW5kKSkgPT09IHA7XG4gICAgICB9KTtcbiAgICAgIHZhciBzYW1lU2NhbGVNaW5ZQXJyID0gW107XG4gICAgICB2YXIgc2FtZVNjYWxlTWF4WUFyciA9IFtdO1xuICAgICAgbWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChtaW5ZVmFsdWUsIHlpKSB7XG4gICAgICAgIGluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NhbGUsIGkpIHtcbiAgICAgICAgICAvLyB3ZSBjb21wYXJlIG9ubHkgdGhlIHlJbmRleCB3aGljaCBleGlzdHMgaW4gdGhlIGluZGljZXMgYXJyYXlcbiAgICAgICAgICBpZiAoc2NhbGUuaW5kZXhPZih5aSkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzYW1lU2NhbGVNaW5ZQXJyW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBzYW1lU2NhbGVNaW5ZQXJyW2ldID0gW107XG4gICAgICAgICAgICAgIHNhbWVTY2FsZU1heFlBcnJbaV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2FtZVNjYWxlTWluWUFycltpXS5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiB5aSxcbiAgICAgICAgICAgICAgdmFsdWU6IG1pbllWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYW1lU2NhbGVNYXhZQXJyW2ldLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IHlpLFxuICAgICAgICAgICAgICB2YWx1ZTogbWF4WUFyclt5aV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzYW1lU2NhbGVNaW4gPSBBcnJheS5hcHBseShudWxsLCBBcnJheShpbmRpY2VzLmxlbmd0aCkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgdmFyIHNhbWVTY2FsZU1heCA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGluZGljZXMubGVuZ3RoKSkubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgc2FtZVNjYWxlTWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoc2MsIGopIHtcbiAgICAgICAgICBzYW1lU2NhbGVNaW5baV0gPSBNYXRoLm1pbihzYy52YWx1ZSwgc2FtZVNjYWxlTWluW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNhbWVTY2FsZU1heFlBcnIuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNjLCBqKSB7XG4gICAgICAgICAgc2FtZVNjYWxlTWF4W2ldID0gTWF0aC5tYXgoc2MudmFsdWUsIHNhbWVTY2FsZU1heFtpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBtaW5ZQXJyLmZvckVhY2goZnVuY3Rpb24gKG1pbiwgaSkge1xuICAgICAgICBzYW1lU2NhbGVNYXhZQXJyLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgdmFyIG1pblkgPSBzYW1lU2NhbGVNaW5bc2ldO1xuICAgICAgICAgIHZhciBtYXhZID0gc2FtZVNjYWxlTWF4W3NpXTtcbiAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKGluZCwgaykge1xuICAgICAgICAgICAgaWYgKHNba10ua2V5ID09PSBpKSB7XG4gICAgICAgICAgICAgIGlmIChjbmYueWF4aXNbaV0ubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNuZi55YXhpc1tpXS5taW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIG1pblkgPSBjbmYueWF4aXNbaV0ubWluKGdsLm1pblkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtaW5ZID0gY25mLnlheGlzW2ldLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY25mLnlheGlzW2ldLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbmYueWF4aXNbaV0ubWF4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBtYXhZID0gY25mLnlheGlzW2ldLm1heChnbC5tYXhZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF4WSA9IGNuZi55YXhpc1tpXS5tYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMyLnNldFlTY2FsZUZvckluZGV4KGksIG1pblksIG1heFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdXRvU2NhbGVZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9TY2FsZVkoY3R4LCBlKSB7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICBjdHggPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBjdHgudy5jb25maWcuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHNlcmllKSB7XG4gICAgICAgIHZhciBtaW4sIG1heDtcbiAgICAgICAgdmFyIGZpcnN0ID0gc2VyaWUuZGF0YS5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHhbMF0gPj0gZS54YXhpcy5taW47XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGZpcnN0WzFdO1xuICAgICAgICBtYXggPSBtaW4gPSBmaXJzdFZhbHVlO1xuICAgICAgICBzZXJpZS5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YVswXSA8PSBlLnhheGlzLm1heCAmJiBkYXRhWzBdID49IGUueGF4aXMubWluKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVsxXSA+IG1heCAmJiBkYXRhWzFdICE9PSBudWxsKSBtYXggPSBkYXRhWzFdO1xuICAgICAgICAgICAgaWYgKGRhdGFbMV0gPCBtaW4gJiYgZGF0YVsxXSAhPT0gbnVsbCkgbWluID0gZGF0YVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtaW4gKj0gMC45NTtcbiAgICAgICAgbWF4ICo9IDEuMDU7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2U7XG59KCk7XG5cbi8qKlxuICogUmFuZ2UgaXMgdXNlZCB0byBnZW5lcmF0ZXMgdmFsdWVzIGJldHdlZW4gbWluIGFuZCBtYXguXG4gKlxuICogQG1vZHVsZSBSYW5nZVxuICoqL1xuXG52YXIgUmFuZ2UkMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhbmdlJCQxKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZSQkMSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmlzQmFySG9yaXpvbnRhbCA9ICEhKHRoaXMudy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgUmFuZ2UoY3R4KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYW5nZSQkMSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXRZUmFuZ2UoKTtcbiAgICAgIHRoaXMuc2V0WFJhbmdlKCk7XG4gICAgICB0aGlzLnNldFpSYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaW5ZTWF4WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW5ZTWF4WShzdGFydGluZ0luZGV4KSB7XG4gICAgICB2YXIgbG93ZXN0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBoaWdoZXN0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gICAgICBpZiAobGVuID09PSBudWxsKSB7XG4gICAgICAgIGxlbiA9IHN0YXJ0aW5nSW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzID0gZ2wuc2VyaWVzO1xuICAgICAgdmFyIHNlcmllc01pbiA9IHNlcmllcztcbiAgICAgIHZhciBzZXJpZXNNYXggPSBzZXJpZXM7XG5cbiAgICAgIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgc2VyaWVzTWluID0gZ2wuc2VyaWVzQ2FuZGxlTDtcbiAgICAgICAgc2VyaWVzTWF4ID0gZ2wuc2VyaWVzQ2FuZGxlSDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0aW5nSW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBnbC5kYXRhUG9pbnRzID0gTWF0aC5tYXgoZ2wuZGF0YVBvaW50cywgc2VyaWVzW2ldLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbC5zZXJpZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoc2VyaWVzW2ldW2pdICE9PSBudWxsICYmIFV0aWxzLmlzTnVtYmVyKHNlcmllc1tpXVtqXSkpIHtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBzZXJpZXNNYXhbaV1bal0pO1xuICAgICAgICAgICAgbG93ZXN0WSA9IE1hdGgubWluKGxvd2VzdFksIHNlcmllc01pbltpXVtqXSk7XG4gICAgICAgICAgICBoaWdoZXN0WSA9IE1hdGgubWF4KGhpZ2hlc3RZLCBzZXJpZXNNaW5baV1bal0pO1xuXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNGbG9hdChzZXJpZXNbaV1bal0pKSB7XG4gICAgICAgICAgICAgIGdsLnlWYWx1ZURlY2ltYWwgPSBNYXRoLm1heChnbC55VmFsdWVEZWNpbWFsLCBzZXJpZXNbaV1bal0udG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW5ZID4gc2VyaWVzTWluW2ldW2pdICYmIHNlcmllc01pbltpXVtqXSA8IDApIHtcbiAgICAgICAgICAgICAgbWluWSA9IHNlcmllc01pbltpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuaGFzTnVsbFZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFk6IG1heFksXG4gICAgICAgIGxvd2VzdFk6IGxvd2VzdFksXG4gICAgICAgIGhpZ2hlc3RZOiBoaWdoZXN0WVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFlSYW5nZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICBnbC5tYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5taW5ZID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgIHZhciBsb3dlc3RZSW5BbGxTZXJpZXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IG1pblkgYW5kIG1heFkgZm9yIG11bHRpcGxlIHkgYXhpc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtaW5ZTWF4WUFyciA9IHRoaXMuZ2V0TWluWU1heFkoaSwgbG93ZXN0WUluQWxsU2VyaWVzLCBudWxsLCBpICsgMSk7XG4gICAgICAgICAgZ2wubWluWUFyci5wdXNoKG1pbllNYXhZQXJyLm1pblkpO1xuICAgICAgICAgIGdsLm1heFlBcnIucHVzaChtaW5ZTWF4WUFyci5tYXhZKTtcbiAgICAgICAgICBsb3dlc3RZSW5BbGxTZXJpZXMgPSBtaW5ZTWF4WUFyci5sb3dlc3RZO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFuZCB0aGVuLCBnZXQgdGhlIG1pblkgYW5kIG1heFkgZnJvbSBhbGwgc2VyaWVzXG5cblxuICAgICAgdmFyIG1pbllNYXhZID0gdGhpcy5nZXRNaW5ZTWF4WSgwLCBsb3dlc3RZSW5BbGxTZXJpZXMsIG51bGwsIGdsLnNlcmllcy5sZW5ndGgpO1xuICAgICAgZ2wubWluWSA9IG1pbllNYXhZLm1pblk7XG4gICAgICBnbC5tYXhZID0gbWluWU1heFkubWF4WTtcbiAgICAgIGxvd2VzdFlJbkFsbFNlcmllcyA9IG1pbllNYXhZLmxvd2VzdFk7XG5cbiAgICAgIGlmIChjbmYuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAvLyBmb3Igc3RhY2tlZCBjaGFydHMsIHdlIGNhbGN1bGF0ZSBlYWNoIHNlcmllcydzIHBhcmFsbGVsIHZhbHVlcy4gaS5lLCBzZXJpZXNbMF1bal0gKyBzZXJpZXNbMV1bal0gLi4uLiBbc2VyaWVzW2kubGVuZ3RoXVtqXV0gYW5kIGdldCB0aGUgbWF4IG91dCBvZiBpdFxuICAgICAgICB2YXIgc3RhY2tlZFBvc3MgPSBbXTtcbiAgICAgICAgdmFyIHN0YWNrZWROZWdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbC5zZXJpZXNbZ2wubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcG9zcyA9IDA7XG4gICAgICAgICAgdmFyIG5lZ3MgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGdsLnNlcmllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmIChnbC5zZXJpZXNbX2ldW2pdICE9PSBudWxsICYmIFV0aWxzLmlzTnVtYmVyKGdsLnNlcmllc1tfaV1bal0pKSB7XG4gICAgICAgICAgICAgIGlmIChnbC5zZXJpZXNbX2ldW2pdID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIDAuMDAwMSBmaXhlcyAjMTg1IHdoZW4gdmFsdWVzIGFyZSB2ZXJ5IHNtYWxsXG4gICAgICAgICAgICAgICAgcG9zcyA9IHBvc3MgKyBwYXJzZUZsb2F0KGdsLnNlcmllc1tfaV1bal0pICsgMC4wMDAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZ3MgPSBuZWdzICsgcGFyc2VGbG9hdChnbC5zZXJpZXNbX2ldW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX2kgPT09IGdsLnNlcmllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIC8vIHB1c2ggYWxsIHRoZSB0b3RhbHMgdG8gdGhlIGFycmF5IGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICAgIHN0YWNrZWRQb3NzLnB1c2gocG9zcyk7XG4gICAgICAgICAgICAgIHN0YWNrZWROZWdzLnB1c2gobmVncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGdldCB0aGUgbWF4L21pbiBvdXQgb2YgdGhlIGFkZGVkIHBhcmFsbGVsIHZhbHVlc1xuXG5cbiAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBzdGFja2VkUG9zcy5sZW5ndGg7IHorKykge1xuICAgICAgICAgIGdsLm1heFkgPSBNYXRoLm1heChnbC5tYXhZLCBzdGFja2VkUG9zc1t6XSk7XG4gICAgICAgICAgZ2wubWluWSA9IE1hdGgubWluKGdsLm1pblksIHN0YWNrZWROZWdzW3pdKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiB0aGUgbnVtYmVycyBhcmUgdG9vIGJpZywgcmVkdWNlIHRoZSByYW5nZVxuICAgICAgLy8gZm9yIGVnLCBpZiBudW1iZXIgaXMgYmV0d2VlbiAxMDAwMDAtMTEwMDAwLCBwdXR0aW5nIDAgYXMgdGhlIGxvd2VzdCB2YWx1ZSBpcyBub3Qgc28gZ29vZCBpZGVhLiBTbyBjaGFuZ2UgdGhlIGdsLm1pblkgZm9yIGxpbmUvYXJlYS9jYW5kbGVzdGlja3NcblxuXG4gICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdsaW5lJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ2FyZWEnIHx8IGNuZi5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgIGlmIChnbC5taW5ZID09PSBOdW1iZXIuTUlOX1ZBTFVFICYmIGxvd2VzdFlJbkFsbFNlcmllcyAhPT0gLU51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IGdsLm1heFkgLSBsb3dlc3RZSW5BbGxTZXJpZXM7XG5cbiAgICAgICAgICBpZiAobG93ZXN0WUluQWxsU2VyaWVzID49IDAgJiYgbG93ZXN0WUluQWxsU2VyaWVzIDw9IDEwKSB7XG4gICAgICAgICAgICAvLyBpZiBtaW5ZIGlzIGFscmVhZHkgMC9sb3cgdmFsdWUsIHdlIGRvbid0IHdhbnQgdG8gZ28gbmVnYXRpdmVzIGhlcmUgLSBzbyB0aGlzIGNoZWNrIGlzIGVzc2VudGlhbC5cbiAgICAgICAgICAgIGRpZmYgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLm1pblkgPSBsb3dlc3RZSW5BbGxTZXJpZXMgLSBkaWZmICogNSAvIDEwMDtcbiAgICAgICAgICBnbC5tYXhZID0gZ2wubWF4WSArIGRpZmYgKiA1IC8gMTAwICsgMC4wNTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAvLyBvdmVycmlkZSBhbGwgbWluL21heCB2YWx1ZXMgYnkgdXNlciBkZWZpbmVkIHZhbHVlcyAoeSBheGlzKVxuICAgICAgICBpZiAoeWF4ZS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgeWF4ZS5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBnbC5tYXhZQXJyW2luZGV4XSA9IHlheGUubWF4O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHlheGUubWF4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBnbC5tYXhZQXJyW2luZGV4XSA9IHlheGUubWF4KGdsLm1heFkpO1xuICAgICAgICAgIH0gLy8gZ2wubWF4WSBpcyBmb3Igc2luZ2xlIHktYXhpcyBjaGFydCwgaXQgd2lsbCBiZSBpZ25vcmVkIGluIG11bHRpLXlheGlzXG5cblxuICAgICAgICAgIGdsLm1heFkgPSBnbC5tYXhZQXJyW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5YXhlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5YXhlLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGdsLm1pbllBcnJbaW5kZXhdID0geWF4ZS5taW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeWF4ZS5taW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGdsLm1pbllBcnJbaW5kZXhdID0geWF4ZS5taW4oZ2wubWluWSk7XG4gICAgICAgICAgfSAvLyBnbC5taW5ZIGlzIGZvciBzaW5nbGUgeS1heGlzIGNoYXJ0LCBpdCB3aWxsIGJlIGlnbm9yZWQgaW4gbXVsdGkteWF4aXNcblxuXG4gICAgICAgICAgZ2wubWluWSA9IGdsLm1pbllBcnJbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gZm9yIGhvcml6b250YWwgYmFyIGNoYXJ0cywgd2UgbmVlZCB0byBjaGVjayB4YXhpcyBtaW4vbWF4IGFzIHVzZXIgbWF5IGhhdmUgc3BlY2lmaWVkIHRoZXJlXG5cbiAgICAgIGlmICh0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoY25mLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjbmYueGF4aXMubWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGdsLm1pblkgPSBjbmYueGF4aXMubWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1heCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBnbC5tYXhZID0gY25mLnhheGlzLm1heDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgbXVsdGkgeS1heGlzIHdlIG5lZWQgZGlmZmVyZW50IHNjYWxlcyBmb3IgZWFjaFxuXG5cbiAgICAgIGlmIChnbC5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgdGhpcy5zY2FsZXMuc2V0TXVsdGlwbGVZU2NhbGVzKCk7XG4gICAgICAgIGdsLm1pblkgPSBsb3dlc3RZSW5BbGxTZXJpZXM7XG4gICAgICAgIGdsLnlBeGlzU2NhbGUuZm9yRWFjaChmdW5jdGlvbiAoc2NhbGUsIGkpIHtcbiAgICAgICAgICBnbC5taW5ZQXJyW2ldID0gc2NhbGUubmljZU1pbjtcbiAgICAgICAgICBnbC5tYXhZQXJyW2ldID0gc2NhbGUubmljZU1heDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjYWxlcy5zZXRZU2NhbGVGb3JJbmRleCgwLCBnbC5taW5ZLCBnbC5tYXhZKTtcbiAgICAgICAgZ2wubWluWSA9IGdsLnlBeGlzU2NhbGVbMF0ubmljZU1pbjtcbiAgICAgICAgZ2wubWF4WSA9IGdsLnlBeGlzU2NhbGVbMF0ubmljZU1heDtcbiAgICAgICAgZ2wubWluWUFyclswXSA9IGdsLnlBeGlzU2NhbGVbMF0ubmljZU1pbjtcbiAgICAgICAgZ2wubWF4WUFyclswXSA9IGdsLnlBeGlzU2NhbGVbMF0ubmljZU1heDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFhSYW5nZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgaXNYTnVtZXJpYyA9IGNuZi54YXhpcy50eXBlID09PSAnbnVtZXJpYycgfHwgY25mLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScgfHwgY25mLnhheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgIWdsLm5vTGFiZWxzUHJvdmlkZWQ7IC8vIG1pblggbWF4WCBzdGFydHMgaGVyZVxuXG4gICAgICBpZiAoZ2wuaXNYTnVtZXJpYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChnbC5sYWJlbHNbaV0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wubGFiZWxzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChnbC5sYWJlbHNbaV1bal0gIT09IG51bGwgJiYgVXRpbHMuaXNOdW1iZXIoZ2wubGFiZWxzW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgIGdsLm1heFggPSBNYXRoLm1heChnbC5tYXhYLCBnbC5sYWJlbHNbaV1bal0pO1xuICAgICAgICAgICAgICAgIGdsLmluaXRpYWxtYXhYID0gTWF0aC5tYXgoZ2wubWF4WCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5taW5YID0gTWF0aC5taW4oZ2wubWluWCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5pbml0aWFsbWluWCA9IE1hdGgubWluKGdsLm1pblgsIGdsLmxhYmVsc1tpXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdsLm5vTGFiZWxzUHJvdmlkZWQpIHtcbiAgICAgICAgaWYgKGNuZi54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGdsLm1heFggPSBnbC5sYWJlbHNbZ2wubGFiZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGdsLmluaXRpYWxtYXhYID0gZ2wubGFiZWxzW2dsLmxhYmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBnbC5taW5YID0gMTtcbiAgICAgICAgICBnbC5pbml0aWFsbWluWCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG51bWVyaWMgeGF4aXMsIHdlIG5lZWQgdG8gYWRqdXN0IHNvbWUgcGFkZGluZyBsZWZ0IGFuZCByaWdodCBmb3IgYmFyIGNoYXJ0c1xuXG5cbiAgICAgIGlmIChnbC5jb21ib0NoYXJ0c0hhc0JhcnMgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNuZi54YXhpcy50eXBlICE9PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgIGlmIChjbmYueGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIHZhciBtaW5YID0gZ2wubWluWCAtIGdsLnN2Z1dpZHRoIC8gZ2wuZGF0YVBvaW50cyAqIChNYXRoLmFicyhnbC5tYXhYIC0gZ2wubWluWCkgLyBnbC5zdmdXaWR0aCkgLyAyO1xuICAgICAgICAgIGdsLm1pblggPSBtaW5YO1xuICAgICAgICAgIGdsLmluaXRpYWxtaW5YID0gbWluWDtcbiAgICAgICAgICB2YXIgbWF4WCA9IGdsLm1heFggKyBnbC5zdmdXaWR0aCAvIGdsLmRhdGFQb2ludHMgKiAoTWF0aC5hYnMoZ2wubWF4WCAtIGdsLm1pblgpIC8gZ2wuc3ZnV2lkdGgpIC8gMjtcbiAgICAgICAgICBnbC5tYXhYID0gbWF4WDtcbiAgICAgICAgICBnbC5pbml0aWFsbWF4WCA9IG1heFg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdsLmlzWE51bWVyaWMgfHwgZ2wubm9MYWJlbHNQcm92aWRlZCkge1xuICAgICAgICB2YXIgdGlja3M7XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy50aWNrQW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aWNrcyA9IE1hdGgucm91bmQoZ2wuc3ZnV2lkdGggLyAxNTApOyAvLyBubyBsYWJlbHMgcHJvdmlkZWQgYW5kIHRvdGFsIG51bWJlciBvZiBkYXRhUG9pbnRzIGlzIGxlc3MgdGhhbiAyMFxuXG4gICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnbnVtZXJpYycgJiYgZ2wuZGF0YVBvaW50cyA8IDIwKSB7XG4gICAgICAgICAgICB0aWNrcyA9IGdsLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICAgIH0gLy8gdGhpcyBjaGVjayBpcyBmb3Igd2hlbiB0aWNrcyBleGNlZWRzIHRvdGFsIGRhdGFwb2ludHMgYW5kIHRoYXQgd291bGQgcmVzdWx0IGluIGR1cGxpY2F0ZSBsYWJlbHNcblxuXG4gICAgICAgICAgaWYgKHRpY2tzID4gZ2wuZGF0YVBvaW50cyAmJiBnbC5kYXRhUG9pbnRzICE9PSAwKSB7XG4gICAgICAgICAgICB0aWNrcyA9IGdsLmRhdGFQb2ludHMgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbmYueGF4aXMudGlja0Ftb3VudCA9PT0gJ2RhdGFQb2ludHMnKSB7XG4gICAgICAgICAgdGlja3MgPSBnbC5zZXJpZXNbZ2wubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrcyA9IGNuZi54YXhpcy50aWNrQW1vdW50O1xuICAgICAgICB9IC8vIG92ZXJyaWRlIGFsbCBtaW4vbWF4IHZhbHVlcyBieSB1c2VyIGRlZmluZWQgdmFsdWVzICh4IGF4aXMpXG5cblxuICAgICAgICBpZiAoY25mLnhheGlzLm1heCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjbmYueGF4aXMubWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGdsLm1heFggPSBjbmYueGF4aXMubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBnbC5taW5YID0gY25mLnhheGlzLm1pbjtcbiAgICAgICAgfSAvLyBpZiByYW5nZSBpcyBwcm92aWRlZCwgYWRqdXN0IHRoZSBuZXcgbWluWFxuXG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ2wubWluWCA9IGdsLm1heFggLSBjbmYueGF4aXMucmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2wubWluWCAhPT0gTnVtYmVyLk1BWF9WQUxVRSAmJiBnbC5tYXhYICE9PSAtTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLnNjYWxlcy5saW5lYXJTY2FsZShnbC5taW5YLCBnbC5tYXhYLCB0aWNrcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wueEF4aXNTY2FsZSA9IHRoaXMuc2NhbGVzLmxpbmVhclNjYWxlKDEsIHRpY2tzLCB0aWNrcyk7XG5cbiAgICAgICAgICBpZiAoZ2wubm9MYWJlbHNQcm92aWRlZCAmJiBnbC5sYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2wueEF4aXNTY2FsZSA9IHRoaXMuc2NhbGVzLmxpbmVhclNjYWxlKDEsIGdsLmxhYmVscy5sZW5ndGgsIHRpY2tzIC0gMSk7XG4gICAgICAgICAgICBnbC5zZXJpZXNYID0gZ2wubGFiZWxzLnNsaWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHdlIHdpbGwgc3RpbGwgc3RvcmUgdGhlc2UgbGFiZWxzIGFzIHRoZSBjb3VudCBmb3IgdGhpcyB3aWxsIGJlIGRpZmZlcmVudCAodG8gZHJhdyBncmlkIGFuZCBsYWJlbHMgcGxhY2VtZW50KVxuXG5cbiAgICAgICAgaWYgKGlzWE51bWVyaWMpIHtcbiAgICAgICAgICBnbC5sYWJlbHMgPSBnbC54QXhpc1NjYWxlLnJlc3VsdC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnbC5taW5YID09PSBnbC5tYXhYKSB7XG4gICAgICAgIC8vIHNpbmdsZSBkYXRhUG9pbnRcbiAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgdmFyIG5ld01pblggPSBuZXcgRGF0ZShnbC5taW5YKTtcbiAgICAgICAgICBuZXdNaW5YLnNldERhdGUobmV3TWluWC5nZXREYXRlKCkgLSAyKTtcbiAgICAgICAgICBnbC5taW5YID0gbmV3IERhdGUobmV3TWluWCkuZ2V0VGltZSgpO1xuICAgICAgICAgIHZhciBuZXdNYXhYID0gbmV3IERhdGUoZ2wubWF4WCk7XG4gICAgICAgICAgbmV3TWF4WC5zZXREYXRlKG5ld01heFguZ2V0RGF0ZSgpICsgMik7XG4gICAgICAgICAgZ2wubWF4WCA9IG5ldyBEYXRlKG5ld01heFgpLmdldFRpbWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnIHx8IGNuZi54YXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmICFnbC5ub0xhYmVsc1Byb3ZpZGVkKSB7XG4gICAgICAgICAgZ2wubWluWCA9IGdsLm1pblggLSAyO1xuICAgICAgICAgIGdsLm1heFggPSBnbC5tYXhYICsgMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRaUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WlJhbmdlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7IC8vIG1pblosIG1heFogc3RhcnRzIGhlcmVcblxuICAgICAgaWYgKGdsLmlzRGF0YVhZWikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZ2wuc2VyaWVzWltpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzWltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzWltpXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihnbC5zZXJpZXNaW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgIGdsLm1heFogPSBNYXRoLm1heChnbC5tYXhaLCBnbC5zZXJpZXNaW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5taW5aID0gTWF0aC5taW4oZ2wubWluWiwgZ2wuc2VyaWVzWltpXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2UkJDE7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBTZXJpZXMgQ2xhc3MgZm9yIGludGVyYXRpb24gd2l0aCB0aGUgU2VyaWVzIG9mIHRoZSBjaGFydC5cbiAqXG4gKiBAbW9kdWxlIFNlcmllc1xuICoqL1xuXG52YXIgU2VyaWVzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VyaWVzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJpZXMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VyaWVzLCBbe1xuICAgIGtleTogXCJnZXRBbGxTZXJpZXNFbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsU2VyaWVzRWxzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VyaWVzQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc0J5TmFtZShzZXJpZXNOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzLlwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcoc2VyaWVzTmFtZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29sbGFwc2VkQ2xhc3NUb1Nlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCBpbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGZvciAodmFyIGNzID0gMDsgY3MgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgY3MrKykge1xuICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc1tjc10uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgZWxTZXJpZXMubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVTZXJpZXNPbkhvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNlcmllc09uSG92ZXIoZSwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWxsU2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1wiKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgdmFyIHNlcmllc0NudCA9IHBhcnNlSW50KHRhcmdldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxO1xuICAgICAgICB2YXIgc2VyaWVzRWwgPSBudWxsO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0NudCwgXCInXVwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nXCIuY29uY2F0KHNlcmllc0NudCArIDEsIFwiJ10gcGF0aFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBzZSA9IDA7IHNlIDwgYWxsU2VyaWVzRWxzLmxlbmd0aDsgc2UrKykge1xuICAgICAgICAgIGFsbFNlcmllc0Vsc1tzZV0uY2xhc3NMaXN0LmFkZCgnbGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcmllc0VsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgc2VyaWVzRWwucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VyaWVzRWwuY2xhc3NMaXN0LnJlbW92ZSgnbGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICBmb3IgKHZhciBfc2UgPSAwOyBfc2UgPCBhbGxTZXJpZXNFbHMubGVuZ3RoOyBfc2UrKykge1xuICAgICAgICAgIGFsbFNlcmllc0Vsc1tfc2VdLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWdobGlnaHRSYW5nZUluU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZ2hsaWdodFJhbmdlSW5TZXJpZXMoZSwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWxsSGVhdE1hcEVsZW1lbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtaGVhdG1hcC1yZWN0Jyk7XG5cbiAgICAgIHZhciBhbGxBY3RpdmUgPSBmdW5jdGlvbiBhbGxBY3RpdmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGFsbEluYWN0aXZlID0gZnVuY3Rpb24gYWxsSW5hY3RpdmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5hZGQoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHNlbGVjdGVkQWN0aXZlID0gZnVuY3Rpb24gc2VsZWN0ZWRBY3RpdmUocmFuZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxIZWF0TWFwRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQoYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgndmFsJykpO1xuXG4gICAgICAgICAgaWYgKHZhbCA+PSByYW5nZS5mcm9tICYmIHZhbCA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgYWxsSGVhdE1hcEVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgYWxsQWN0aXZlKCk7XG4gICAgICAgIGFsbEluYWN0aXZlKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXNbc2VyaWVzQ250XTtcbiAgICAgICAgc2VsZWN0ZWRBY3RpdmUocmFuZ2UpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgYWxsQWN0aXZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZVNlcmllc0luZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZVNlcmllc0luZGV4KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGFjdGl2ZSBzZXJpZXMgZmxhZyBpcyByZXF1aXJlZCB0byBrbm93IGlmIHVzZXIgaGFzIG5vdCBkZWFjdGl2YXRlZCB2aWEgbGVnZW5kIGNsaWNrXG4gICAgICAgIHZhciBmaXJzdEFjdGl2ZVNlcmllc0luZGV4ID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoc2VyaWVzLmxlbmd0aCA+IDAgJiYgdy5jb25maWcuc2VyaWVzW2luZGV4XS50eXBlICE9PSAnYmFyJyAmJiB3LmNvbmZpZy5zZXJpZXNbaW5kZXhdLnR5cGUgIT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgZmlyc3RBY3RpdmVTZXJpZXNJbmRleC5sZW5ndGg7IGErKykge1xuICAgICAgICAgIGlmIChmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3RpdmVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBhY3RpdmUgc2VyaWVzIGZsYWcgaXMgcmVxdWlyZWQgdG8ga25vdyBpZiB1c2VyIGhhcyBub3QgZGVhY3RpdmF0ZWQgdmlhIGxlZ2VuZCBjbGlja1xuICAgICAgICB2YXIgZmlyc3RBY3RpdmVTZXJpZXNJbmRleCA9IHcuY29uZmlnLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoc2VyaWVzLmRhdGEgJiYgc2VyaWVzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXgubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBpZiAoZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByZXZpb3VzUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldmlvdXNQYXRocygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gcHVzaFBhdGhzKHNlcmllc0VscywgaSwgdHlwZSkge1xuICAgICAgICB2YXIgcGF0aHMgPSBzZXJpZXNFbHNbaV0uY2hpbGROb2RlcztcbiAgICAgICAgdmFyIGRBcnIgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBwYXRoczogW10sXG4gICAgICAgICAgcmVhbEluZGV4OiBzZXJpZXNFbHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChwYXRoc1tqXS5oYXNBdHRyaWJ1dGUoJ3BhdGhUbycpKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHBhdGhzW2pdLmdldEF0dHJpYnV0ZSgncGF0aFRvJyk7XG4gICAgICAgICAgICBkQXJyLnBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICBkOiBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKGRBcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtbGluZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChsaW5lUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBwID0gbGluZVBhdGhzLmxlbmd0aCAtIDE7IHAgPj0gMDsgcC0tKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGxpbmVQYXRocywgcCwgJ2xpbmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYXJlYXBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChhcmVhcGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJlYXBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGFyZWFwYXRocywgaSwgJ2FyZWEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmFyUGF0aHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoYmFyUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcCA9IDA7IF9wIDwgYmFyUGF0aHMubGVuZ3RoOyBfcCsrKSB7XG4gICAgICAgICAgcHVzaFBhdGhzKGJhclBhdGhzLCBfcCwgJ2JhcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW5kbGVzdGlja1BhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoY2FuZGxlc3RpY2tQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIF9wMiA9IDA7IF9wMiA8IGNhbmRsZXN0aWNrUGF0aHMubGVuZ3RoOyBfcDIrKykge1xuICAgICAgICAgIHB1c2hQYXRocyhjYW5kbGVzdGlja1BhdGhzLCBfcDIsICdjYW5kbGVzdGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByYWRhclBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtcmFkYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAocmFkYXJQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIF9wMyA9IDA7IF9wMyA8IHJhZGFyUGF0aHMubGVuZ3RoOyBfcDMrKykge1xuICAgICAgICAgIHB1c2hQYXRocyhyYWRhclBhdGhzLCBfcDMsICdyYWRhcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVwYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJ1YmJsZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChidWJibGVwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgYnViYmxlcGF0aHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLWJ1YmJsZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHMsIFwiJ10gY2lyY2xlXCIpKTtcbiAgICAgICAgICB2YXIgZEFyciA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlcmllc0Vscy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRBcnIucHVzaCh7XG4gICAgICAgICAgICAgIHg6IHNlcmllc0Vsc1tfaV0uZ2V0QXR0cmlidXRlKCdjeCcpLFxuICAgICAgICAgICAgICB5OiBzZXJpZXNFbHNbX2ldLmdldEF0dHJpYnV0ZSgnY3knKSxcbiAgICAgICAgICAgICAgcjogc2VyaWVzRWxzW19pXS5nZXRBdHRyaWJ1dGUoJ3InKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMucHVzaChkQXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc2NhdHRlcnBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2NhdHRlci1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChzY2F0dGVycGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcyA9IDA7IF9zIDwgc2NhdHRlcnBhdGhzLmxlbmd0aDsgX3MrKykge1xuICAgICAgICAgIHZhciBfc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNjYXR0ZXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChfcywgXCInXSBjaXJjbGVcIikpO1xuXG4gICAgICAgICAgdmFyIF9kQXJyID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfc2VyaWVzRWxzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIF9kQXJyLnB1c2goe1xuICAgICAgICAgICAgICB4OiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdjeCcpLFxuICAgICAgICAgICAgICB5OiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdjeScpLFxuICAgICAgICAgICAgICByOiBfc2VyaWVzRWxzW19pMl0uZ2V0QXR0cmlidXRlKCdyJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLnB1c2goX2RBcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWF0bWFwQ29sb3JzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtaGVhdG1hcCAuYXBleGNoYXJ0cy1zZXJpZXMnKTtcblxuICAgICAgaWYgKGhlYXRtYXBDb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGhlYXRtYXBDb2xvcnMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgX3Nlcmllc0VsczIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtaGVhdG1hcCAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoaCwgXCInXSByZWN0XCIpKTtcblxuICAgICAgICAgIHZhciBfZEFycjIgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9zZXJpZXNFbHMyLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIF9kQXJyMi5wdXNoKHtcbiAgICAgICAgICAgICAgY29sb3I6IF9zZXJpZXNFbHMyW19pM10uZ2V0QXR0cmlidXRlKCdjb2xvcicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKF9kQXJyMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAvLyBmb3Igbm9uLWF4aXMgY2hhcnRzIChpLmUuLCBjaXJjdWxhciBjaGFydHMsIHBhdGhGcm9tIGlzIG5vdCB1c2FibGUuIFdlIG5lZWQgd2hvbGUgc2VyaWVzKVxuICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocyA9IHcuZ2xvYmFscy5zZXJpZXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU5vRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVOb0RhdGEoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgbm9EYXRhT3B0cyA9IHcuY29uZmlnLm5vRGF0YTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhtZS5jdHgpO1xuICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC8gMjtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICB3Lmdsb2JhbHMubm9EYXRhID0gdHJ1ZTtcbiAgICAgIHcuZ2xvYmFscy5hbmltYXRpb25FbmRlZCA9IHRydWU7XG5cbiAgICAgIGlmIChub0RhdGFPcHRzLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeCA9IDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSBpZiAobm9EYXRhT3B0cy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC0gMTA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vRGF0YU9wdHMudmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeSA9IDUwO1xuICAgICAgfSBlbHNlIGlmIChub0RhdGFPcHRzLnZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gNTA7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgbm9EYXRhT3B0cy5vZmZzZXRYO1xuICAgICAgeSA9IHkgKyBwYXJzZUludChub0RhdGFPcHRzLnN0eWxlLmZvbnRTaXplKSArIDI7XG5cbiAgICAgIGlmIChub0RhdGFPcHRzLnRleHQgIT09IHVuZGVmaW5lZCAmJiBub0RhdGFPcHRzLnRleHQgIT09ICcnKSB7XG4gICAgICAgIHZhciB0aXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IG5vRGF0YU9wdHMudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgIGZvbnRTaXplOiBub0RhdGFPcHRzLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IG5vRGF0YU9wdHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBmb3JlQ29sb3I6IG5vRGF0YU9wdHMuc3R5bGUuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdGV4dC1ub2RhdGEnXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZVRleHQubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FwZXhjaGFydHMtdGl0bGUtdGV4dCcpO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLlBhcGVyLmFkZCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgIH0gLy8gV2hlbiB1c2VyIGNsaWNrcyBvbiBsZWdlbmRzLCB0aGUgY29sbGFwc2VkIHNlcmllcyBpcyBmaWxsZWQgd2l0aCBbMCwwLDAsLi4uLDBdXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gYWx0ZXIgdGhlIHNlcmllcycgbGVuZ3RoIGFzIGl0IGlzIHVzZWQgYXQgbWFueSBwbGFjZXNcblxuICB9LCB7XG4gICAga2V5OiBcInNldE51bGxTZXJpZXNUb1plcm9WYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TnVsbFNlcmllc1RvWmVyb1ZhbHVlcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NsXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHNlcmllc1tzbF0ucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQWxsU2VyaWVzRXF1YWxYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0FsbFNlcmllc0VxdWFsWCgpIHtcbiAgICAgIHZhciBlcXVhbExlbiA9IHRydWU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJlZFNlclggPSB0aGlzLmZpbHRlcmVkU2VyaWVzWCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcmVkU2VyWC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGZpbHRlcmVkU2VyWFtpXVswXSAhPT0gZmlsdGVyZWRTZXJYW2kgKyAxXVswXSkge1xuICAgICAgICAgIGVxdWFsTGVuID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0hhc0VxdWFsWCA9IGVxdWFsTGVuO1xuICAgICAgcmV0dXJuIGVxdWFsTGVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWx0ZXJlZFNlcmllc1hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyZWRTZXJpZXNYKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVyZWRTZXJpZXNYID0gdy5nbG9iYWxzLnNlcmllc1gubWFwKGZ1bmN0aW9uIChzZXIsIGluZGV4KSB7XG4gICAgICAgIGlmIChzZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBzZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZFNlcmllc1g7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlcmllcztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIERpbWVuc2lvbnMgQ2xhc3MgZm9yIGNhbGN1bGF0aW5nIHJlY3RzIG9mIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBkcmF3biBhbmQgd2lsbCBiZSBkcmF3bi5cbiAqXG4gKiBAbW9kdWxlIERpbWVuc2lvbnNcbiAqKi9cblxudmFyIERpbWVuc2lvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaW1lbnNpb25zKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaW1lbnNpb25zKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMubGdSZWN0ID0ge307XG4gICAgdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICB0aGlzLmlzU3BhcmtsaW5lID0gdGhpcy53LmNvbmZpZy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZDtcbiAgICB0aGlzLnhQYWRSaWdodCA9IDA7XG4gICAgdGhpcy54UGFkTGVmdCA9IDA7XG4gICAgdGhpcy5pc0Jhckhvcml6b250YWwgPSAhISh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpO1xuICB9XG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gdyAtIGNoYXJ0IGNvbnRleHRcbiAgICoqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERpbWVuc2lvbnMsIFt7XG4gICAga2V5OiBcInBsb3RDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdENvb3JkcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGxnUmVjdCA9IHRoaXMuZ2V0TGVnZW5kc1JlY3QoKTtcblxuICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgLy8gZm9yIGxpbmUgLyBhcmVhIC8gc2NhdHRlciAvIGNvbHVtblxuICAgICAgICB0aGlzLnNldEdyaWRDb29yZHNGb3JBeGlzQ2hhcnRzKGxnUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgcGllIC8gZG9udXRzIC8gY2lyY2xlXG4gICAgICAgIHRoaXMuc2V0R3JpZENvb3Jkc0Zvck5vbkF4aXNDaGFydHMobGdSZWN0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50aXRsZVN1YnRpdGxlT2Zmc2V0KCk7IC8vIGFmdGVyIGNhbGN1bGF0aW5nIGV2ZXJ5dGhpbmcsIGFwcGx5IHBhZGRpbmcgc2V0IGJ5IHVzZXJcblxuICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRIZWlnaHQgLSB3LmNvbmZpZy5ncmlkLnBhZGRpbmcudG9wIC0gdy5jb25maWcuZ3JpZC5wYWRkaW5nLmJvdHRvbTtcbiAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLmdyaWRXaWR0aCAtIHcuY29uZmlnLmdyaWQucGFkZGluZy5sZWZ0IC0gdy5jb25maWcuZ3JpZC5wYWRkaW5nLnJpZ2h0IC0gdGhpcy54UGFkUmlnaHQgLSB0aGlzLnhQYWRMZWZ0O1xuICAgICAgZ2wudHJhbnNsYXRlWCA9IGdsLnRyYW5zbGF0ZVggKyB3LmNvbmZpZy5ncmlkLnBhZGRpbmcubGVmdCArIHRoaXMueFBhZExlZnQ7XG4gICAgICBnbC50cmFuc2xhdGVZID0gZ2wudHJhbnNsYXRlWSArIHcuY29uZmlnLmdyaWQucGFkZGluZy50b3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmRpdGlvbmFsQ2hlY2tzRm9yQXhpc0Nvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25kaXRpb25hbENoZWNrc0ZvckF4aXNDb29yZHMoeGF4aXNMYWJlbENvb3JkcywgeHRpdGxlQ29vcmRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSAoeGF4aXNMYWJlbENvb3Jkcy5oZWlnaHQgKyB4dGl0bGVDb29yZHMuaGVpZ2h0KSAqIHcuZ2xvYmFscy5MSU5FX0hFSUdIVF9SQVRJTyArIDE1O1xuICAgICAgdGhpcy54QXhpc1dpZHRoID0geGF4aXNMYWJlbENvb3Jkcy53aWR0aDtcblxuICAgICAgaWYgKHRoaXMueEF4aXNIZWlnaHQgLSB4dGl0bGVDb29yZHMuaGVpZ2h0ID4gdy5jb25maWcueGF4aXMubGFiZWxzLm1heEhlaWdodCkge1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gdy5jb25maWcueGF4aXMubGFiZWxzLm1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5taW5IZWlnaHQgJiYgdGhpcy54QXhpc0hlaWdodCA8IHcuY29uZmlnLnhheGlzLmxhYmVscy5taW5IZWlnaHQpIHtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5taW5IZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5mbG9hdGluZykge1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB0aGlzLmdldFRvdGFsWUF4aXNXaWR0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gdy5nbG9iYWxzLnlMYWJlbHNDb29yZHNbMF0ud2lkdGggKyB3Lmdsb2JhbHMueVRpdGxlQ29vcmRzWzBdLndpZHRoICsgMTU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICBpZiAodGhpcy55QXhpc1dpZHRoIDwgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm1pbldpZHRoKSB7XG4gICAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm1pbldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueUF4aXNXaWR0aCA+IHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5tYXhXaWR0aCkge1xuICAgICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5tYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmlkQ29vcmRzRm9yQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmlkQ29vcmRzRm9yQXhpc0NoYXJ0cyhsZ1JlY3QpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIHlheGlzTGFiZWxDb29yZHMgPSB0aGlzLmdldHlBeGlzTGFiZWxzQ29vcmRzKCk7XG4gICAgICB2YXIgeGF4aXNMYWJlbENvb3JkcyA9IHRoaXMuZ2V0eEF4aXNMYWJlbHNDb29yZHMoKTtcbiAgICAgIHZhciB5VGl0bGVDb29yZHMgPSB0aGlzLmdldHlBeGlzVGl0bGVDb29yZHMoKTtcbiAgICAgIHZhciB4dGl0bGVDb29yZHMgPSB0aGlzLmdldHhBeGlzVGl0bGVDb29yZHMoKTtcbiAgICAgIHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzID0gW107XG4gICAgICB3Lmdsb2JhbHMueVRpdGxlQ29vcmRzID0gW107XG4gICAgICB3LmNvbmZpZy55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYWJlbHMgYW5kIHRpdGxlcyBjb29yZHMgaW4gZ2xvYmFsIHZhcnNcbiAgICAgICAgdy5nbG9iYWxzLnlMYWJlbHNDb29yZHMucHVzaCh7XG4gICAgICAgICAgd2lkdGg6IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICB3aWR0aDogeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aCxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxDaGVja3NGb3JBeGlzQ29vcmRzKHhheGlzTGFiZWxDb29yZHMsIHh0aXRsZUNvb3Jkcyk7XG4gICAgICBnbC50cmFuc2xhdGVYQXhpc1kgPSB3Lmdsb2JhbHMucm90YXRlWExhYmVscyA/IHRoaXMueEF4aXNIZWlnaHQgLyA4IDogLTQ7XG4gICAgICBnbC50cmFuc2xhdGVYQXhpc1ggPSB3Lmdsb2JhbHMucm90YXRlWExhYmVscyAmJiB3Lmdsb2JhbHMuaXNYTnVtZXJpYyAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlIDw9IC00NSA/IC10aGlzLnhBeGlzV2lkdGggLyA0IDogMDtcblxuICAgICAgaWYgKHRoaXMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgIGdsLnJvdGF0ZVhMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgZ2wudHJhbnNsYXRlWEF4aXNZID0gLTEgKiAocGFyc2VJbnQody5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDEuNSk7XG4gICAgICB9XG5cbiAgICAgIGdsLnRyYW5zbGF0ZVhBeGlzWSA9IGdsLnRyYW5zbGF0ZVhBeGlzWSArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRZO1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNYID0gZ2wudHJhbnNsYXRlWEF4aXNYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFg7XG4gICAgICB2YXIgeUF4aXNXaWR0aCA9IHRoaXMueUF4aXNXaWR0aDtcbiAgICAgIHZhciB4QXhpc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICBnbC54QXhpc0xhYmVsc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICBnbC54QXhpc0hlaWdodCA9IHRoaXMueEF4aXNIZWlnaHQ7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IDEwO1xuXG4gICAgICBpZiAoIXcuY29uZmlnLmdyaWQuc2hvdyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkYXInKSB7XG4gICAgICAgIHlBeGlzV2lkdGggPSAwO1xuICAgICAgICB4QXhpc0hlaWdodCA9IDM1O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1NwYXJrbGluZSkge1xuICAgICAgICBsZ1JlY3QgPSB7XG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgeUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZGl0aW9uYWxQYWRkaW5nWExhYmVscyh4YXhpc0xhYmVsQ29vcmRzKTtcblxuICAgICAgc3dpdGNoICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0geUF4aXNXaWR0aDtcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gbGdSZWN0LmhlaWdodCAtIHhBeGlzSGVpZ2h0IC0gKCF0aGlzLmlzU3BhcmtsaW5lID8gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyAxMCA6IDE1IDogMCk7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IGxnUmVjdC5oZWlnaHQgKyB0cmFuc2xhdGVZO1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBsZ1JlY3QuaGVpZ2h0IC0geEF4aXNIZWlnaHQgLSAoIXRoaXMuaXNTcGFya2xpbmUgPyB3Lmdsb2JhbHMucm90YXRlWExhYmVscyA/IDEwIDogMTUgOiAwKTtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIHlBeGlzV2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZVk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IGxnUmVjdC53aWR0aCArIHlBeGlzV2lkdGg7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIHhBeGlzSGVpZ2h0IC0gMTI7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSBsZ1JlY3Qud2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0geUF4aXNXaWR0aDtcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0geEF4aXNIZWlnaHQgLSAxMjtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIGxnUmVjdC53aWR0aCAtIHlBeGlzV2lkdGggLSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWdlbmQgcG9zaXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEdyaWRYUG9zRm9yRHVhbFlBeGlzKHlUaXRsZUNvb3JkcywgeWF4aXNMYWJlbENvb3Jkcyk7IC8vIGFmdGVyIGRyYXdpbmcgZXZlcnl0aGluZywgc2V0IHRoZSBZIGF4aXMgcG9zaXRpb25zXG5cbiAgICAgIHZhciBvYmp5QXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG4gICAgICBvYmp5QXhpcy5zZXRZQXhpc1hQb3NpdGlvbih5YXhpc0xhYmVsQ29vcmRzLCB5VGl0bGVDb29yZHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmlkQ29vcmRzRm9yTm9uQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmlkQ29vcmRzRm9yTm9uQXhpc0NoYXJ0cyhsZ1JlY3QpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIHhQYWQgPSAwO1xuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLnNob3cgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZykge1xuICAgICAgICB4UGFkID0gMjA7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZZID0gMTA7XG4gICAgICB2YXIgb2ZmWCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncGllJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgIG9mZlkgPSBvZmZZICsgdy5jb25maWcucGxvdE9wdGlvbnMucGllLm9mZnNldFk7XG4gICAgICAgIG9mZlggPSBvZmZYICsgdy5jb25maWcucGxvdE9wdGlvbnMucGllLm9mZnNldFg7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgIG9mZlkgPSBvZmZZICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLm9mZnNldFk7XG4gICAgICAgIG9mZlggPSBvZmZYICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLm9mZnNldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5jb25maWcubGVnZW5kLnNob3cpIHtcbiAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIDM1O1xuICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5ncmlkSGVpZ2h0O1xuICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWSAtIDEwO1xuICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIChnbC5zdmdXaWR0aCAtIGdsLmdyaWRXaWR0aCkgLyAyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAody5jb25maWcubGVnZW5kLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIGxnUmVjdC5oZWlnaHQgLSAzNTtcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5ncmlkSGVpZ2h0O1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSBvZmZZIC0gMjA7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAoZ2wuc3ZnV2lkdGggLSBnbC5ncmlkV2lkdGgpIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBsZ1JlY3QuaGVpZ2h0IC0gMzU7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gbGdSZWN0LmhlaWdodCArIG9mZlk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAoZ2wuc3ZnV2lkdGggLSBnbC5ncmlkV2lkdGgpIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIGxnUmVjdC53aWR0aCAtIHhQYWQ7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRXaWR0aDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIGxnUmVjdC53aWR0aCArIHhQYWQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoIC0gbGdSZWN0LndpZHRoIC0geFBhZCAtIDU7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRXaWR0aDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0gb2ZmWCArIDEwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWdlbmQgcG9zaXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmlkWFBvc0ZvckR1YWxZQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmlkWFBvc0ZvckR1YWxZQXhpcyh5VGl0bGVDb29yZHMsIHlheGlzTGFiZWxDb29yZHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAody5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEgJiYgIXcuY29uZmlnLnlheGlzW2luZGV4XS5mbG9hdGluZyAmJiB3LmNvbmZpZy55YXhpc1tpbmRleF0uc2hvdykge1xuICAgICAgICAgIGlmICh5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWCA9IHcuZ2xvYmFscy50cmFuc2xhdGVYIC0gKHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoICsgeVRpdGxlQ29vcmRzW2luZGV4XS53aWR0aCkgLSBwYXJzZUludCh3LmNvbmZpZy55YXhpc1tpbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDEuMiAtIDEyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBTb21ldGltZXMsIHRoZSBsYXN0IGxhYmVscyBnZXRzIGNyb3BwZWQgaW4gY2F0ZWdvcnkvbnVtZXJpYyB4YXhpcy5cbiAgICAvLyBIZW5jZSwgd2UgYWRkIHNvbWUgYWRkaXRpb25hbCBwYWRkaW5nIGJhc2VkIG9uIHRoZSBsYWJlbCBsZW5ndGggdG8gYXZvaWQgdGhlIGxhc3QgbGFiZWwgYmVpbmcgY3JvcHBlZC5cbiAgICAvLyBOT1RFOiBkYXRldGltZSB4LWF4aXMgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IHdpdGggdGhpcyBhcyB3ZSBkb24ndCBrbm93IHRoZSBsYWJlbCBsZW5ndGggdGhlcmUgZHVlIHRvIG1hbnkgY29uc3RyYWludHMuXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRpdGlvbmFsUGFkZGluZ1hMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkaXRpb25hbFBhZGRpbmdYTGFiZWxzKHhheGlzTGFiZWxDb29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiB0aGlzLmlzQmFySG9yaXpvbnRhbCB8fCB3LmNvbmZpZy54YXhpcy50eXBlID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgdmFyIHJpZ2h0UGFkID0gZnVuY3Rpb24gcmlnaHRQYWQobGFiZWxzKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQucGFkZGluZy5yaWdodCA8IGxhYmVscy53aWR0aCkge1xuICAgICAgICAgICAgX3RoaXMueFBhZFJpZ2h0ID0gbGFiZWxzLndpZHRoIC8gMiArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsZWZ0UGFkID0gZnVuY3Rpb24gbGVmdFBhZChsYWJlbHMpIHtcbiAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wYWRkaW5nLmxlZnQgPCBsYWJlbHMud2lkdGgpIHtcbiAgICAgICAgICAgIF90aGlzLnhQYWRMZWZ0ID0gbGFiZWxzLndpZHRoIC8gMiArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsaW5lQXJlYSA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdsaW5lJyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYXJlYSc7XG4gICAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGkpIHtcbiAgICAgICAgICB2YXIgc2hvdWxkUGFkID0gIXlheGUuc2hvdyB8fCB5YXhlLmZsb2F0aW5nIHx8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xIHx8IGxpbmVBcmVhIHx8IHlheGUub3Bwb3NpdGUgJiYgX3RoaXMuaXNCYXJIb3Jpem9udGFsO1xuXG4gICAgICAgICAgaWYgKHNob3VsZFBhZCkge1xuICAgICAgICAgICAgaWYgKGxpbmVBcmVhICYmIHcuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSAhPT0gLTEgfHwgX3RoaXMuaXNCYXJIb3Jpem9udGFsICYmIHlheGUub3Bwb3NpdGUpIHtcbiAgICAgICAgICAgICAgbGVmdFBhZCh4YXhpc0xhYmVsQ29vcmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0Jhckhvcml6b250YWwgJiYgeWF4ZS5vcHBvc2l0ZSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpICE9PSAtMSB8fCBsaW5lQXJlYSAmJiAhdy5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAgICAgICByaWdodFBhZCh4YXhpc0xhYmVsQ29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aXRsZVN1YnRpdGxlT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpdGxlU3VidGl0bGVPZmZzZXQoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciBncmlkU2hyaW5rT2Zmc2V0ID0gdGhpcy5pc1NwYXJrbGluZSA/IDAgOiAxMDtcblxuICAgICAgaWYgKHcuY29uZmlnLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHcuY29uZmlnLnRpdGxlLm1hcmdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gdGhpcy5pc1NwYXJrbGluZSA/IDAgOiA1O1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcuc3VidGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gdy5jb25maWcuc3VidGl0bGUubWFyZ2luO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZFNocmlua09mZnNldCArPSB0aGlzLmlzU3BhcmtsaW5lID8gMCA6IDU7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuc2hvdyAmJiB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdib3R0b20nICYmICF3LmNvbmZpZy5sZWdlbmQuZmxvYXRpbmcgJiYgdy5jb25maWcuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZ3JpZFNocmlua09mZnNldCArPSAxMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlQ29vcmRzID0gdGhpcy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCd0aXRsZScpO1xuICAgICAgdmFyIHN1YnRpdGxlQ29vcmRzID0gdGhpcy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpO1xuICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLmdyaWRIZWlnaHQgLSB0aXRsZUNvb3Jkcy5oZWlnaHQgLSBzdWJ0aXRsZUNvb3Jkcy5oZWlnaHQgLSBncmlkU2hyaW5rT2Zmc2V0O1xuICAgICAgZ2wudHJhbnNsYXRlWSA9IGdsLnRyYW5zbGF0ZVkgKyB0aXRsZUNvb3Jkcy5oZWlnaHQgKyBzdWJ0aXRsZUNvb3Jkcy5oZWlnaHQgKyBncmlkU2hyaW5rT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbFlBeGlzV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG90YWxZQXhpc1dpZHRoKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeUF4aXNXaWR0aCA9IDA7XG4gICAgICB2YXIgcGFkZGluZyA9IDEwO1xuXG4gICAgICB2YXIgaXNIaWRkZW5ZQXhpcyA9IGZ1bmN0aW9uIGlzSGlkZGVuWUF4aXMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPiAtMTtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzLm1hcChmdW5jdGlvbiAoeUxhYmVsQ29vcmQsIGluZGV4KSB7XG4gICAgICAgIHZhciBmbG9hdGluZyA9IHcuY29uZmlnLnlheGlzW2luZGV4XS5mbG9hdGluZztcblxuICAgICAgICBpZiAoeUxhYmVsQ29vcmQud2lkdGggPiAwICYmICFmbG9hdGluZykge1xuICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoICsgeUxhYmVsQ29vcmQud2lkdGggKyBwYWRkaW5nO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuWUF4aXMoaW5kZXgpKSB7XG4gICAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCAtIHlMYWJlbENvb3JkLndpZHRoIC0gcGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggKyAoZmxvYXRpbmcgfHwgIXcuY29uZmlnLnlheGlzW2luZGV4XS5zaG93ID8gMCA6IDUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHcuZ2xvYmFscy55VGl0bGVDb29yZHMubWFwKGZ1bmN0aW9uICh5VGl0bGVDb29yZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGZsb2F0aW5nID0gdy5jb25maWcueWF4aXNbaW5kZXhdLmZsb2F0aW5nO1xuICAgICAgICBwYWRkaW5nID0gcGFyc2VJbnQody5jb25maWcueWF4aXNbaW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRTaXplKTtcblxuICAgICAgICBpZiAoeVRpdGxlQ29vcmQud2lkdGggPiAwICYmICFmbG9hdGluZykge1xuICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoICsgeVRpdGxlQ29vcmQud2lkdGggKyBwYWRkaW5nO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuWUF4aXMoaW5kZXgpKSB7XG4gICAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCAtIHlUaXRsZUNvb3JkLndpZHRoIC0gcGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggKyAoZmxvYXRpbmcgfHwgIXcuY29uZmlnLnlheGlzW2luZGV4XS5zaG93ID8gMCA6IDUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB5QXhpc1dpZHRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXR4QXhpc1RpbWVTY2FsZUxhYmVsc0Nvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc1RpbWVTY2FsZUxhYmVsc0Nvb3JkcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJlY3Q7XG4gICAgICB2YXIgdGltZXNjYWxlTGFiZWxzID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLnNsaWNlKCk7XG4gICAgICB2YXIgbGFiZWxzID0gdGltZXNjYWxlTGFiZWxzLm1hcChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsLnZhbHVlO1xuICAgICAgfSk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgdmFyIHZhbCA9IGxhYmVscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLy8gaWYgdW5kZWZpbmVkLCBtYXliZSB1c2VyIGRpZG4ndCBwYXNzIHRoZSBkYXRldGltZSh4KSB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBoYXZlIHBvc3NpYmx5IHN1cHBsaWVkIGludmFsaWQgRGF0ZSBmb3JtYXQuIFBsZWFzZSBzdXBwbHkgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUnKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICByZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbCwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgIHZhciB0b3RhbFdpZHRoUm90YXRlZCA9IHJlY3Qud2lkdGggKiAxLjA1ICogbGFiZWxzLmxlbmd0aDtcblxuICAgICAgaWYgKHRvdGFsV2lkdGhSb3RhdGVkID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgIHcuZ2xvYmFscy5vdmVybGFwcGluZ1hMYWJlbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFggQXhpcyBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eEF4aXNMYWJlbHNDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eEF4aXNMYWJlbHNDb29yZHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4YXhpc0xhYmVscyA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKTtcbiAgICAgIHZhciByZWN0O1xuXG4gICAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0eEF4aXNUaW1lU2NhbGVMYWJlbHNDb29yZHMoKTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogY29vcmRzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY29vcmRzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxnV2lkdGhGb3JTaWRlTGVnZW5kcyA9IHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnICYmIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nID8gdGhpcy5sZ1JlY3Qud2lkdGggOiAwOyAvLyAgZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyIHRvIGl0XG5cbiAgICAgICAgdmFyIHZhbCA9IHhheGlzTGFiZWxzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgIH0sIDApOyAvLyB0aGUgbGFiZWxzIGdldHMgY2hhbmdlZCBmb3IgYmFyIGNoYXJ0c1xuXG4gICAgICAgIGlmICh0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIHZhbCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLnJlc3VsdC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcjtcbiAgICAgICAgdmFyIHhGb3JtYXQgPSBuZXcgRm9ybWF0dGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHZhbCA9IHhGb3JtYXQueExhYmVsRm9ybWF0KHhsYkZvcm1hdHRlciwgdmFsKTtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHhMYWJlbHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIHdpZHRoOiB4TGFiZWxyZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogeExhYmVscmVjdC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVjdC53aWR0aCAqIHhheGlzTGFiZWxzLmxlbmd0aCA+IHcuZ2xvYmFscy5zdmdXaWR0aCAtIGxnV2lkdGhGb3JTaWRlTGVnZW5kcyAtIHRoaXMueUF4aXNXaWR0aCAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPSB0cnVlO1xuICAgICAgICAgICAgeExhYmVscmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZSwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHksIFwicm90YXRlKFwiLmNvbmNhdCh3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlLCBcIiAwIDApXCIpLCBmYWxzZSk7XG4gICAgICAgICAgICByZWN0LmhlaWdodCA9IHhMYWJlbHJlY3QuaGVpZ2h0IC8gMS42NjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXcuY29uZmlnLnhheGlzLmxhYmVscy5zaG93KSB7XG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgWSBBeGlzIERpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge3t3aWR0aCwgaGVpZ2h0fX1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXR5QXhpc0xhYmVsc0Nvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR5QXhpc0xhYmVsc0Nvb3JkcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIHZhciBsYWJlbFBhZCA9IDEwO1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAoeWF4ZS5zaG93ICYmIHlheGUubGFiZWxzLnNob3cgJiYgdy5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLnJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpbmRleF07IC8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIC0xIGlzIHRoZSBpbmRleCBvZiB0aWNrIHdoaWNoIHVzZXIgY2FuIHVzZSBpbiB0aGUgZm9ybWF0dGVyXG5cbiAgICAgICAgICB2YXIgdmFsID0gbGJGb3JtYXR0ZXIody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXgsIC0xKTsgLy8gaWYgdXNlciBoYXMgc3BlY2lmaWVkIGEgY3VzdG9tIGZvcm1hdHRlciwgYW5kIHRoZSByZXN1bHQgaXMgbnVsbCBvciBlbXB0eSwgd2UgbmVlZCB0byBkaXNjYXJkIHRoZSBmb3JtYXR0ZXIgYW5kIHRha2UgdGhlIHZhbHVlIGFzIGl0IGlzLlxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpczIuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBsYWJlbFBhZCA9IDA7XG4gICAgICAgICAgICB2YXIgYmFyWWF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgICAgICAgdmFsID0gYmFyWWF4aXNMYWJlbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhfdGhpczIuY3R4KTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHlheGUubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCArIGxhYmVsUGFkLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFggQXhpcyBUaXRsZSBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eEF4aXNUaXRsZUNvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR4QXhpc1RpdGxlQ29vcmRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMody5jb25maWcueGF4aXMudGl0bGUudGV4dCwgdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgWSBBeGlzIERpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge3t3aWR0aCwgaGVpZ2h0fX1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXR5QXhpc1RpdGxlQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldHlBeGlzVGl0bGVDb29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB3LmNvbmZpZy55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIGlmICh5YXhlLnNob3cgJiYgeWF4ZS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXMzLmN0eCk7XG4gICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMoeWF4ZS50aXRsZS50ZXh0LCB5YXhlLnRpdGxlLnN0eWxlLmZvbnRTaXplLCB5YXhlLnRpdGxlLnN0eWxlLmZvbnRGYW1pbHksICdyb3RhdGUoLTkwIDAgMCknLCBmYWxzZSk7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQ2hhcnQgVGl0bGUvU3VidGl0bGUgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlU3VidGl0bGVDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcyh0eXBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgIHZhciBmbG9hdGluZyA9IHR5cGUgPT09ICd0aXRsZScgPyB3LmNvbmZpZy50aXRsZS5mbG9hdGluZyA6IHcuY29uZmlnLnN1YnRpdGxlLmZsb2F0aW5nO1xuICAgICAgdmFyIGVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi10ZXh0XCIpKTtcblxuICAgICAgaWYgKGVsICE9PSBudWxsICYmICFmbG9hdGluZykge1xuICAgICAgICB2YXIgY29vcmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgd2lkdGggPSBjb29yZC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdy5nbG9iYWxzLmF4aXNDaGFydHMgPyBjb29yZC5oZWlnaHQgKyA1IDogY29vcmQuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZWdlbmRzUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWdlbmRzUmVjdCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsTGVnZW5kV3JhcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWxlZ2VuZCcpO1xuICAgICAgdmFyIGxnUmVjdCA9IE9iamVjdC5hc3NpZ24oe30sIFV0aWxzLmdldEJvdW5kaW5nQ2xpZW50UmVjdChlbExlZ2VuZFdyYXApKTtcblxuICAgICAgaWYgKGVsTGVnZW5kV3JhcCAhPT0gbnVsbCAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nICYmIHcuY29uZmlnLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgIHRoaXMubGdSZWN0ID0ge1xuICAgICAgICAgIHg6IGxnUmVjdC54LFxuICAgICAgICAgIHk6IGxnUmVjdC55LFxuICAgICAgICAgIGhlaWdodDogbGdSZWN0LmhlaWdodCxcbiAgICAgICAgICB3aWR0aDogbGdSZWN0LmhlaWdodCA9PT0gMCA/IDAgOiBsZ1JlY3Qud2lkdGhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGdSZWN0ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGdSZWN0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaW1lbnNpb25zO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVGltZVNjYWxlIENsYXNzIGZvciBnZW5lcmF0aW5nIHRpbWUgdGlja3MgZm9yIHgtYXhpcy5cbiAqXG4gKiBAbW9kdWxlIFRpbWVTY2FsZVxuICoqL1xuXG52YXIgVGltZVNjYWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVNjYWxlKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lU2NhbGUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy50aW1lU2NhbGVBcnJheSA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpbWVTY2FsZSwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRlVGltZVNjYWxlVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlVGltZVNjYWxlVGlja3MobWluWCwgbWF4WCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG51bGwgY2hlY2sgd2hlbiBubyBzZXJpZXMgdG8gc2hvd1xuXG4gICAgICBpZiAody5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICB3Lmdsb2JhbHMubGFiZWxzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy50aW1lbGluZUxhYmVscyA9IFtdO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF5c0RpZmYgPSAobWF4WCAtIG1pblgpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVJbnRlcnZhbChkYXlzRGlmZik7XG4gICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21JbiA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLmRpc2FibGVab29tT3V0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChkYXlzRGlmZiA8IDAuMDA1KSB7XG4gICAgICAgIHcuZ2xvYmFscy5kaXNhYmxlWm9vbUluID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF5c0RpZmYgPiA1MDAwMCkge1xuICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZUludGVydmFscyA9IGR0LmdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXAobWluWCwgbWF4WCk7XG4gICAgICB2YXIgZGF5c1dpZHRoT25YQXhpcyA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyBkYXlzRGlmZjtcbiAgICAgIHZhciBob3Vyc1dpZHRoT25YQXhpcyA9IGRheXNXaWR0aE9uWEF4aXMgLyAyNDtcbiAgICAgIHZhciBtaW51dGVzV2lkdGhPblhBeGlzID0gaG91cnNXaWR0aE9uWEF4aXMgLyA2MDtcbiAgICAgIHZhciBudW1iZXJPZkhvdXJzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAqIDI0KTtcbiAgICAgIHZhciBudW1iZXJPZk1pbnV0ZXMgPSBNYXRoLmZsb29yKGRheXNEaWZmICogMjQgKiA2MCk7XG4gICAgICB2YXIgbnVtYmVyT2ZEYXlzID0gTWF0aC5mbG9vcihkYXlzRGlmZik7XG4gICAgICB2YXIgbnVtYmVyT2ZNb250aHMgPSBNYXRoLmZsb29yKGRheXNEaWZmIC8gMzApO1xuICAgICAgdmFyIG51bWJlck9mWWVhcnMgPSBNYXRoLmZsb29yKGRheXNEaWZmIC8gMzY1KTtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHtcbiAgICAgICAgbWluTWludXRlOiB0aW1lSW50ZXJ2YWxzLm1pbk1pbnV0ZSxcbiAgICAgICAgbWluSG91cjogdGltZUludGVydmFscy5taW5Ib3VyLFxuICAgICAgICBtaW5EYXRlOiB0aW1lSW50ZXJ2YWxzLm1pbkRhdGUsXG4gICAgICAgIG1pbk1vbnRoOiB0aW1lSW50ZXJ2YWxzLm1pbk1vbnRoLFxuICAgICAgICBtaW5ZZWFyOiB0aW1lSW50ZXJ2YWxzLm1pblllYXJcbiAgICAgIH07XG4gICAgICB2YXIgY3VycmVudE1pbnV0ZSA9IGZpcnN0VmFsLm1pbk1pbnV0ZTtcbiAgICAgIHZhciBjdXJyZW50SG91ciA9IGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICB2YXIgY3VycmVudE1vbnRoRGF0ZSA9IGZpcnN0VmFsLm1pbkRhdGU7XG4gICAgICB2YXIgY3VycmVudERhdGUgPSBmaXJzdFZhbC5taW5EYXRlO1xuICAgICAgdmFyIGN1cnJlbnRNb250aCA9IGZpcnN0VmFsLm1pbk1vbnRoO1xuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gZmlyc3RWYWwubWluWWVhcjtcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIGZpcnN0VmFsOiBmaXJzdFZhbCxcbiAgICAgICAgY3VycmVudE1pbnV0ZTogY3VycmVudE1pbnV0ZSxcbiAgICAgICAgY3VycmVudEhvdXI6IGN1cnJlbnRIb3VyLFxuICAgICAgICBjdXJyZW50TW9udGhEYXRlOiBjdXJyZW50TW9udGhEYXRlLFxuICAgICAgICBjdXJyZW50RGF0ZTogY3VycmVudERhdGUsXG4gICAgICAgIGN1cnJlbnRNb250aDogY3VycmVudE1vbnRoLFxuICAgICAgICBjdXJyZW50WWVhcjogY3VycmVudFllYXIsXG4gICAgICAgIGRheXNXaWR0aE9uWEF4aXM6IGRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgIGhvdXJzV2lkdGhPblhBeGlzOiBob3Vyc1dpZHRoT25YQXhpcyxcbiAgICAgICAgbWludXRlc1dpZHRoT25YQXhpczogbWludXRlc1dpZHRoT25YQXhpcyxcbiAgICAgICAgbnVtYmVyT2ZNaW51dGVzOiBudW1iZXJPZk1pbnV0ZXMsXG4gICAgICAgIG51bWJlck9mSG91cnM6IG51bWJlck9mSG91cnMsXG4gICAgICAgIG51bWJlck9mRGF5czogbnVtYmVyT2ZEYXlzLFxuICAgICAgICBudW1iZXJPZk1vbnRoczogbnVtYmVyT2ZNb250aHMsXG4gICAgICAgIG51bWJlck9mWWVhcnM6IG51bWJlck9mWWVhcnNcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAodGhpcy50aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVZZWFyU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICBjYXNlICdoYWxmX3llYXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVNb250aFNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW9udGhzX2RheXMnOlxuICAgICAgICBjYXNlICdtb250aHNfZm9ydG5pZ2h0JzpcbiAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgIGNhc2UgJ3dlZWtfZGF5cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZURheVNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVIb3VyU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlTWludXRlU2NhbGUocGFyYW1zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZmlyc3QsIHdlIHdpbGwgYWRqdXN0IHRoZSBtb250aCB2YWx1ZXMgaW5kZXhcbiAgICAgIC8vIGFzIGluIHRoZSB1cHBlciBmdW5jdGlvbiwgaXQgaXMgc3RhcnRpbmcgZnJvbSAwXG4gICAgICAvLyB3ZSB3aWxsIHN0YXJ0IHRoZW0gZnJvbSAxXG5cblxuICAgICAgdmFyIGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5ID0gdGhpcy50aW1lU2NhbGVBcnJheS5tYXAoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0UmV0dXJuID0ge1xuICAgICAgICAgIHBvc2l0aW9uOiB0cy5wb3NpdGlvbixcbiAgICAgICAgICB1bml0OiB0cy51bml0LFxuICAgICAgICAgIHllYXI6IHRzLnllYXIsXG4gICAgICAgICAgZGF5OiB0cy5kYXkgPyB0cy5kYXkgOiAxLFxuICAgICAgICAgIGhvdXI6IHRzLmhvdXIgPyB0cy5ob3VyIDogMCxcbiAgICAgICAgICBtb250aDogdHMubW9udGggKyAxXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJldHVybiwge1xuICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRzLnVuaXQgPT09ICdkYXknIHx8IHRzLnVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmV0dXJuLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHMudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cy51bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmV0dXJuLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHMudmFsdWUsXG4gICAgICAgICAgICBtaW51dGU6IHRzLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHM7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaWx0ZXJlZFRpbWVTY2FsZSA9IGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5LmZpbHRlcihmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgdmFyIG1vZHVsbyA9IDE7XG4gICAgICAgIHZhciB0aWNrcyA9IE1hdGguY2VpbCh3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTIwKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHMudmFsdWU7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpY2tBbW91bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpY2tzID0gdy5jb25maWcueGF4aXMudGlja0Ftb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGp1c3RlZE1vbnRoSW5UaW1lU2NhbGVBcnJheS5sZW5ndGggPiB0aWNrcykge1xuICAgICAgICAgIG1vZHVsbyA9IE1hdGguZmxvb3IoYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkubGVuZ3RoIC8gdGlja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZE5vdFNraXBVbml0ID0gZmFsc2U7IC8vIHRoZXJlIGlzIGEgYmlnIGNoYW5nZSBpbiB1bml0IGkuZSBkYXlzIHRvIG1vbnRoc1xuXG4gICAgICAgIHZhciBzaG91bGROb3RQcmludCA9IGZhbHNlOyAvLyBzaG91bGQgc2tpcCB0aGVzZSB2YWx1ZXNcblxuICAgICAgICBzd2l0Y2ggKF90aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgIGNhc2UgJ2hhbGZfeWVhcic6XG4gICAgICAgICAgICBtb2R1bG8gPSA3O1xuXG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgbW9kdWxvID0gMTtcblxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9udGhzX2ZvcnRuaWdodCc6XG4gICAgICAgICAgICBtb2R1bG8gPSAxNTtcblxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJyB8fCB0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9udGhzX2RheXMnOlxuICAgICAgICAgICAgbW9kdWxvID0gMTA7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAzMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnd2Vla19kYXlzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDg7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDE7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlICUgNSAhPT0gMCkge1xuICAgICAgICAgICAgICBzaG91bGROb3RQcmludCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ21pbnV0ZXMnIHx8IF90aGlzLnRpY2tJbnRlcnZhbCA9PT0gJ2hvdXJzJykge1xuICAgICAgICAgIGlmICghc2hvdWxkTm90UHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKHZhbHVlICUgbW9kdWxvID09PSAwIHx8IHNob3VsZE5vdFNraXBVbml0KSAmJiAhc2hvdWxkTm90UHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRUaW1lU2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0KGZpbHRlcmVkVGltZVNjYWxlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWZvcm1hdHRlZFRpbWVzY2FsZUFycmF5ID0gdGhpcy5mb3JtYXREYXRlcyhmaWx0ZXJlZFRpbWVTY2FsZSk7XG4gICAgICB2YXIgcmVtb3ZlZE92ZXJsYXBwaW5nVFMgPSB0aGlzLnJlbW92ZU92ZXJsYXBwaW5nVFMocmVmb3JtYXR0ZWRUaW1lc2NhbGVBcnJheSk7XG4gICAgICB3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMgPSByZW1vdmVkT3ZlcmxhcHBpbmdUUy5zbGljZSgpOyAvLyBhdCB0aGlzIHN0YWdlLCB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBjb29yZHMgb2YgdGhlIGdyaWQgYXMgdGltZWxpbmUgbGFiZWxzIG1heSBoYXZlIGFsdGVyZWQgdGhlIHhheGlzIGxhYmVscyBjb29yZHNcbiAgICAgIC8vIFRoZSByZWFzb24gd2UgY2FuJ3QgZG8gdGhpcyBwcmlvciB0byB0aGlzIHN0YWdlIGlzIGJlY2F1c2UgdGltZWxpbmUgbGFiZWxzIGRlcGVuZHMgb24gZ3JpZFdpZHRoLCBhbmQgYXMgdGhlIHRpY2tzIGFyZSBjYWxjdWxhdGVkIGJhc2VkIG9uIGF2YWlsYWJsZSBncmlkV2lkdGgsIHRoZXJlIGNhbiBiZSB1bmtub3duIG51bWJlciBvZiB0aWNrcyBnZW5lcmF0ZWQgZm9yIGRpZmZlcmVudCBtaW5YIGFuZCBtYXhYXG4gICAgICAvLyBEZXBlbmRlbmN5IG9uIERpbWVuc2lvbnMoKSwgbmVlZCB0byByZWZhY3RvciBjb3JyZWN0bHlcbiAgICAgIC8vIFRPRE8gLSBmaW5kIGFuIGFsdGVybmF0ZSB3YXkgdG8gYXZvaWQgY2FsbGluZyB0aGlzIEhlYXZ5IG1ldGhvZCB0d2ljZVxuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgIGRpbWVuc2lvbnMucGxvdENvb3JkcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVJbnRlcnZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVJbnRlcnZhbChkYXlzRGlmZikge1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAxODI1OlxuICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaXMgbW9yZSB0aGFuIDUgeWVhcnNcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICd5ZWFycyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDgwMCAmJiBkYXlzRGlmZiA8PSAxODI1OlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ2hhbGZfeWVhcic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDE4MCAmJiBkYXlzRGlmZiA8PSA4MDA6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnbW9udGhzJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRheXNEaWZmID4gOTAgJiYgZGF5c0RpZmYgPD0gMTgwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21vbnRoc19mb3J0bmlnaHQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiA2MCAmJiBkYXlzRGlmZiA8PSA5MDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtb250aHNfZGF5cyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDMwICYmIGRheXNEaWZmIDw9IDYwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ3dlZWtfZGF5cyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDIgJiYgZGF5c0RpZmYgPD0gMzA6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnZGF5cyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDAuMSAmJiBkYXlzRGlmZiA8PSAyOlxuICAgICAgICAgIC8vIGxlc3MgdGhhbiAgMiBkYXlzXG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnaG91cnMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPCAwLjE6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnbWludXRlcyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdkYXlzJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVZZWFyU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVZZWFyU2NhbGUocGFyYW1zKSB7XG4gICAgICB2YXIgZmlyc3RWYWwgPSBwYXJhbXMuZmlyc3RWYWwsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBkYXlzV2lkdGhPblhBeGlzID0gcGFyYW1zLmRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgbnVtYmVyT2ZZZWFycyA9IHBhcmFtcy5udW1iZXJPZlllYXJzO1xuICAgICAgdmFyIGZpcnN0VGlja1ZhbHVlID0gZmlyc3RWYWwubWluWWVhcjtcbiAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHVuaXQgPSAneWVhcic7XG5cbiAgICAgIGlmIChmaXJzdFZhbC5taW5EYXRlID4gMSAmJiBmaXJzdFZhbC5taW5Nb250aCA+IDApIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RheXMgPSBkdC5kZXRlcm1pbmVSZW1haW5pbmdEYXlzT2ZZZWFyKGZpcnN0VmFsLm1pblllYXIsIGZpcnN0VmFsLm1pbk1vbnRoLCBmaXJzdFZhbC5taW5EYXRlKTsgLy8gcmVtYWluaW5nRGF5c29mRmlyc3RNb250aCBpcyB1c2VkIHRvIHJlYWNodCB0aGUgMm5kIHRpY2sgcG9zaXRpb25cblxuICAgICAgICB2YXIgcmVtYWluaW5nRGF5c09mRmlyc3RZZWFyID0gZHQuZGV0ZXJtaW5lRGF5c09mWWVhcihmaXJzdFZhbC5taW5ZZWFyKSAtIHJlbWFpbmluZ0RheXMgKyAxOyAvLyBjYWxjdWxhdGUgdGhlIGZpcnN0IHRpY2sgcG9zaXRpb25cblxuICAgICAgICBmaXJzdFRpY2tQb3NpdGlvbiA9IHJlbWFpbmluZ0RheXNPZkZpcnN0WWVhciAqIGRheXNXaWR0aE9uWEF4aXM7XG4gICAgICAgIGZpcnN0VGlja1ZhbHVlID0gZmlyc3RWYWwubWluWWVhciArIDE7IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogZmlyc3RUaWNrVmFsdWUsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKGN1cnJlbnRNb250aCArIDEpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFZhbC5taW5EYXRlID09PSAxICYmIGZpcnN0VmFsLm1pbk1vbnRoID09PSAwKSB7XG4gICAgICAgIC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChjdXJyZW50TW9udGggKyAxKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHllYXIgPSBmaXJzdFRpY2tWYWx1ZTtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZZZWFyczsgaSsrKSB7XG4gICAgICAgIHllYXIrKztcbiAgICAgICAgcG9zID0gZHQuZGV0ZXJtaW5lRGF5c09mWWVhcih5ZWFyIC0gMSkgKiBkYXlzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IHllYXIsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIG1vbnRoOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZU1vbnRoU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVNb250aFNjYWxlKHBhcmFtcykge1xuICAgICAgdmFyIGZpcnN0VmFsID0gcGFyYW1zLmZpcnN0VmFsLFxuICAgICAgICAgIGN1cnJlbnRNb250aERhdGUgPSBwYXJhbXMuY3VycmVudE1vbnRoRGF0ZSxcbiAgICAgICAgICBjdXJyZW50TW9udGggPSBwYXJhbXMuY3VycmVudE1vbnRoLFxuICAgICAgICAgIGN1cnJlbnRZZWFyID0gcGFyYW1zLmN1cnJlbnRZZWFyLFxuICAgICAgICAgIGRheXNXaWR0aE9uWEF4aXMgPSBwYXJhbXMuZGF5c1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZk1vbnRocyA9IHBhcmFtcy5udW1iZXJPZk1vbnRocztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGN1cnJlbnRNb250aDtcbiAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHVuaXQgPSAnbW9udGgnO1xuICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG5cbiAgICAgIGlmIChmaXJzdFZhbC5taW5EYXRlID4gMSkge1xuICAgICAgICAvLyByZW1haW5pbmdEYXlzb2ZGaXJzdE1vbnRoIGlzIHVzZWQgdG8gcmVhY2h0IHRoZSAybmQgdGljayBwb3NpdGlvblxuICAgICAgICB2YXIgcmVtYWluaW5nRGF5c09mRmlyc3RNb250aCA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhjdXJyZW50TW9udGggKyAxLCBmaXJzdFZhbC5taW5ZZWFyKSAtIGN1cnJlbnRNb250aERhdGUgKyAxOyAvLyBjYWxjdWxhdGUgdGhlIGZpcnN0IHRpY2sgcG9zaXRpb25cblxuICAgICAgICBmaXJzdFRpY2tQb3NpdGlvbiA9IHJlbWFpbmluZ0RheXNPZkZpcnN0TW9udGggKiBkYXlzV2lkdGhPblhBeGlzO1xuICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IFV0aWxzLm1vbnRoTW9kKGN1cnJlbnRNb250aCArIDEpO1xuICAgICAgICB2YXIgeWVhciA9IGN1cnJlbnRZZWFyICsgeXJDb3VudGVyO1xuXG4gICAgICAgIHZhciBfbW9udGggPSBVdGlscy5tb250aE1vZChmaXJzdFRpY2tWYWx1ZSk7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RUaWNrVmFsdWU7IC8vIGl0J3MgSmFuLCBzbyB1cGRhdGUgdGhlIHllYXJcblxuICAgICAgICBpZiAoZmlyc3RUaWNrVmFsdWUgPT09IDApIHtcbiAgICAgICAgICB1bml0ID0gJ3llYXInO1xuICAgICAgICAgIHZhbHVlID0geWVhcjtcbiAgICAgICAgICBfbW9udGggPSAxO1xuICAgICAgICAgIHlyQ291bnRlciArPSAxO1xuICAgICAgICAgIHllYXIgPSB5ZWFyICsgeXJDb3VudGVyO1xuICAgICAgICB9IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cblxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIG1vbnRoOiBfbW9udGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogZmlyc3RUaWNrVmFsdWUsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QoY3VycmVudE1vbnRoKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vbnRoID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuICAgICAgdmFyIHBvcyA9IGZpcnN0VGlja1Bvc2l0aW9uOyAvLyBrZWVwIGRyYXdpbmcgcmVzdCBvZiB0aGUgdGlja3NcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAxOyBpIDwgbnVtYmVyT2ZNb250aHM7IGkrKywgaisrKSB7XG4gICAgICAgIG1vbnRoID0gVXRpbHMubW9udGhNb2QobW9udGgpO1xuXG4gICAgICAgIGlmIChtb250aCA9PT0gMCkge1xuICAgICAgICAgIHVuaXQgPSAneWVhcic7XG4gICAgICAgICAgeXJDb3VudGVyICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3llYXIgPSBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG5cbiAgICAgICAgcG9zID0gZHQuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCBfeWVhcikgKiBkYXlzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB2YXIgbW9udGhWYWwgPSBtb250aCA9PT0gMCA/IF95ZWFyIDogbW9udGg7XG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICB2YWx1ZTogbW9udGhWYWwsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiBfeWVhcixcbiAgICAgICAgICBtb250aDogbW9udGggPT09IDAgPyAxIDogbW9udGhcbiAgICAgICAgfSk7XG4gICAgICAgIG1vbnRoKys7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRGF5U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVEYXlTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50TW9udGggPSBwYXJhbXMuY3VycmVudE1vbnRoLFxuICAgICAgICAgIGN1cnJlbnRZZWFyID0gcGFyYW1zLmN1cnJlbnRZZWFyLFxuICAgICAgICAgIGhvdXJzV2lkdGhPblhBeGlzID0gcGFyYW1zLmhvdXJzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mRGF5cyA9IHBhcmFtcy5udW1iZXJPZkRheXM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHVuaXQgPSAnZGF5JztcbiAgICAgIHZhciByZW1haW5pbmdIb3VycyA9IDI0IC0gZmlyc3RWYWwubWluSG91cjtcbiAgICAgIHZhciB5ckNvdW50ZXIgPSAwOyAvLyBjYWxjdWxhdGUgdGhlIGZpcnN0IHRpY2sgcG9zaXRpb25cblxuICAgICAgdmFyIGZpcnN0VGlja1Bvc2l0aW9uID0gcmVtYWluaW5nSG91cnMgKiBob3Vyc1dpZHRoT25YQXhpcztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbkRhdGUgKyAxO1xuICAgICAgdmFyIHZhbCA9IGZpcnN0VGlja1ZhbHVlO1xuXG4gICAgICB2YXIgY2hhbmdlTW9udGggPSBmdW5jdGlvbiBjaGFuZ2VNb250aChkYXRlVmFsLCBtb250aCwgeWVhcikge1xuICAgICAgICB2YXIgbW9udGhkYXlzID0gZHQuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoICsgMSwgeWVhcik7XG5cbiAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgICBkYXRlID0gMTtcbiAgICAgICAgICB1bml0ID0gJ21vbnRoJztcbiAgICAgICAgICB2YWwgPSBtb250aDtcbiAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGF0ZSA9IGZpcnN0VGlja1ZhbHVlO1xuICAgICAgdmFyIG1vbnRoID0gY2hhbmdlTW9udGgoZGF0ZSwgY3VycmVudE1vbnRoLCBjdXJyZW50WWVhcik7IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cbiAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgeWVhcjogY3VycmVudFllYXIsXG4gICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChtb250aCksXG4gICAgICAgIGRheTogZGF0ZVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mRGF5czsgaSsrKSB7XG4gICAgICAgIGRhdGUgKz0gMTtcbiAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIG1vbnRoLCBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXIpO1xuICAgICAgICB2YXIgeWVhciA9IGN1cnJlbnRZZWFyICsgTWF0aC5mbG9vcihtb250aCAvIDEyKSArIHlyQ291bnRlcjtcbiAgICAgICAgcG9zID0gMjQgKiBob3Vyc1dpZHRoT25YQXhpcyArIHBvcztcblxuICAgICAgICB2YXIgX3ZhbCA9IGRhdGUgPT09IDEgPyBVdGlscy5tb250aE1vZChtb250aCkgOiBkYXRlO1xuXG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICB2YWx1ZTogX3ZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKSxcbiAgICAgICAgICBkYXk6IF92YWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlSG91clNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlSG91clNjYWxlKHBhcmFtcykge1xuICAgICAgdmFyIGZpcnN0VmFsID0gcGFyYW1zLmZpcnN0VmFsLFxuICAgICAgICAgIGN1cnJlbnREYXRlID0gcGFyYW1zLmN1cnJlbnREYXRlLFxuICAgICAgICAgIGN1cnJlbnRNb250aCA9IHBhcmFtcy5jdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXIgPSBwYXJhbXMuY3VycmVudFllYXIsXG4gICAgICAgICAgbWludXRlc1dpZHRoT25YQXhpcyA9IHBhcmFtcy5taW51dGVzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mSG91cnMgPSBwYXJhbXMubnVtYmVyT2ZIb3VycztcbiAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgeXJDb3VudGVyID0gMDtcbiAgICAgIHZhciB1bml0ID0gJ2hvdXInO1xuXG4gICAgICB2YXIgY2hhbmdlRGF0ZSA9IGZ1bmN0aW9uIGNoYW5nZURhdGUoZGF0ZVZhbCwgbW9udGgpIHtcbiAgICAgICAgdmFyIG1vbnRoZGF5cyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCArIDEsIGN1cnJlbnRZZWFyKTtcblxuICAgICAgICBpZiAoZGF0ZVZhbCA+IG1vbnRoZGF5cykge1xuICAgICAgICAgIGRhdGUgPSAxO1xuICAgICAgICAgIG1vbnRoID0gbW9udGggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgICAgZGF0ZTogZGF0ZVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIGNoYW5nZU1vbnRoID0gZnVuY3Rpb24gY2hhbmdlTW9udGgoZGF0ZVZhbCwgbW9udGgpIHtcbiAgICAgICAgdmFyIG1vbnRoZGF5cyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCArIDEsIGN1cnJlbnRZZWFyKTtcblxuICAgICAgICBpZiAoZGF0ZVZhbCA+IG1vbnRoZGF5cykge1xuICAgICAgICAgIG1vbnRoID0gbW9udGggKyAxO1xuICAgICAgICAgIHJldHVybiBtb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb250aDtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZW1haW5pbmdNaW5zID0gNjAgLSBmaXJzdFZhbC5taW5NaW51dGU7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdNaW5zICogbWludXRlc1dpZHRoT25YQXhpcztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbkhvdXIgKyAxO1xuICAgICAgdmFyIGhvdXIgPSBmaXJzdFRpY2tWYWx1ZSArIDE7XG5cbiAgICAgIGlmIChyZW1haW5pbmdNaW5zID09PSA2MCkge1xuICAgICAgICBmaXJzdFRpY2tQb3NpdGlvbiA9IDA7XG4gICAgICAgIGZpcnN0VGlja1ZhbHVlID0gZmlyc3RWYWwubWluSG91cjtcbiAgICAgICAgaG91ciA9IGZpcnN0VGlja1ZhbHVlICsgMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGUgPSBjdXJyZW50RGF0ZTtcbiAgICAgIHZhciBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIGN1cnJlbnRNb250aCk7IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cbiAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZIb3VyczsgaSsrKSB7XG4gICAgICAgIHVuaXQgPSAnaG91cic7XG5cbiAgICAgICAgaWYgKGhvdXIgPj0gMjQpIHtcbiAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICBkYXRlICs9IDE7XG4gICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgIHZhciBjaGVja05leHRNb250aCA9IGNoYW5nZURhdGUoZGF0ZSwgbW9udGgpO1xuICAgICAgICAgIG1vbnRoID0gY2hlY2tOZXh0TW9udGgubW9udGg7XG4gICAgICAgICAgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBtb250aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeWVhciA9IGN1cnJlbnRZZWFyICsgTWF0aC5mbG9vcihtb250aCAvIDEyKSArIHlyQ291bnRlcjtcbiAgICAgICAgcG9zID0gaG91ciA9PT0gMCAmJiBpID09PSAwID8gcmVtYWluaW5nTWlucyAqIG1pbnV0ZXNXaWR0aE9uWEF4aXMgOiA2MCAqIG1pbnV0ZXNXaWR0aE9uWEF4aXMgKyBwb3M7XG4gICAgICAgIHZhciB2YWwgPSBob3VyID09PSAwID8gZGF0ZSA6IGhvdXI7XG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgaG91cjogaG91cixcbiAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpXG4gICAgICAgIH0pO1xuICAgICAgICBob3VyKys7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlTWludXRlU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVNaW51dGVTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50TWludXRlID0gcGFyYW1zLmN1cnJlbnRNaW51dGUsXG4gICAgICAgICAgY3VycmVudEhvdXIgPSBwYXJhbXMuY3VycmVudEhvdXIsXG4gICAgICAgICAgY3VycmVudERhdGUgPSBwYXJhbXMuY3VycmVudERhdGUsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBtaW51dGVzV2lkdGhPblhBeGlzID0gcGFyYW1zLm1pbnV0ZXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgbnVtYmVyT2ZNaW51dGVzID0gcGFyYW1zLm51bWJlck9mTWludXRlcztcbiAgICAgIHZhciB5ckNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHVuaXQgPSAnbWludXRlJztcbiAgICAgIHZhciByZW1haW5pbmdNaW5zID0gY3VycmVudE1pbnV0ZSAtIGZpcnN0VmFsLm1pbk1pbnV0ZTtcbiAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IG1pbnV0ZXNXaWR0aE9uWEF4aXMgLSByZW1haW5pbmdNaW5zO1xuICAgICAgdmFyIGZpcnN0VGlja1ZhbHVlID0gZmlyc3RWYWwubWluTWludXRlICsgMTtcbiAgICAgIHZhciBtaW51dGUgPSBmaXJzdFRpY2tWYWx1ZSArIDE7XG4gICAgICB2YXIgZGF0ZSA9IGN1cnJlbnREYXRlO1xuICAgICAgdmFyIG1vbnRoID0gY3VycmVudE1vbnRoO1xuICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhcjtcbiAgICAgIHZhciBob3VyID0gY3VycmVudEhvdXI7IC8vIHB1c2ggdGhlIGZpcnN0IHRpY2sgaW4gdGhlIGFycmF5XG5cbiAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZNaW51dGVzOyBpKyspIHtcbiAgICAgICAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgICAgICAgIG1pbnV0ZSA9IDA7XG4gICAgICAgICAgaG91ciArPSAxO1xuXG4gICAgICAgICAgaWYgKGhvdXIgPT09IDI0KSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3llYXIyID0gY3VycmVudFllYXIgKyBNYXRoLmZsb29yKG1vbnRoIC8gMTIpICsgeXJDb3VudGVyO1xuXG4gICAgICAgIHBvcyA9IG1pbnV0ZXNXaWR0aE9uWEF4aXMgKyBwb3M7XG4gICAgICAgIHZhciB2YWwgPSBtaW51dGU7XG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgaG91cjogaG91cixcbiAgICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgICBkYXk6IGRhdGUsXG4gICAgICAgICAgeWVhcjogX3llYXIyLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChtb250aClcbiAgICAgICAgfSk7XG4gICAgICAgIG1pbnV0ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVSYXdEYXRlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhd0RhdGVTdHJpbmcodHMsIHZhbHVlKSB7XG4gICAgICB2YXIgcmF3ID0gdHMueWVhcjtcbiAgICAgIHJhdyArPSAnLScgKyAoJzAnICsgdHMubW9udGgudG9TdHJpbmcoKSkuc2xpY2UoLTIpOyAvLyB1bml0IGlzIGRheVxuXG4gICAgICBpZiAodHMudW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgcmF3ICs9IHRzLnVuaXQgPT09ICdkYXknID8gJy0nICsgKCcwJyArIHZhbHVlKS5zbGljZSgtMikgOiAnLTAxJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdyArPSAnLScgKyAoJzAnICsgKHRzLmRheSA/IHRzLmRheSA6ICcxJykpLnNsaWNlKC0yKTtcbiAgICAgIH0gLy8gdW5pdCBpcyBob3VyXG5cblxuICAgICAgaWYgKHRzLnVuaXQgPT09ICdob3VyJykge1xuICAgICAgICByYXcgKz0gdHMudW5pdCA9PT0gJ2hvdXInID8gJ1QnICsgKCcwJyArIHZhbHVlKS5zbGljZSgtMikgOiAnVDAwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdyArPSAnVCcgKyAoJzAnICsgKHRzLmhvdXIgPyB0cy5ob3VyIDogJzAnKSkuc2xpY2UoLTIpO1xuICAgICAgfSAvLyB1bml0IGlzIG1pbnV0ZVxuXG5cbiAgICAgIHJhdyArPSB0cy51bml0ID09PSAnbWludXRlJyA/ICc6JyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpICsgJzowMC4wMDBaJyA6ICc6MDA6MDAuMDAwWic7XG4gICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXREYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXREYXRlcyhmaWx0ZXJlZFRpbWVTY2FsZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkgPSBmaWx0ZXJlZFRpbWVTY2FsZS5tYXAoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZShfdGhpczIuY3R4KTtcblxuICAgICAgICB2YXIgcmF3ID0gX3RoaXMyLmNyZWF0ZVJhd0RhdGVTdHJpbmcodHMsIHZhbHVlKTsgLy8gcGFyc2UgdGhlIHdob2xlIElTTyBkYXRlc3RyaW5nXG5cblxuICAgICAgICB2YXIgZGF0ZVN0cmluZyA9IG5ldyBEYXRlKERhdGUucGFyc2UocmF3KSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBjdXN0b21Gb3JtYXQgPSAnZGQgTU1NJztcbiAgICAgICAgICB2YXIgZHRGb3JtYXR0ZXIgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZGF0ZXRpbWVGb3JtYXR0ZXI7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIueWVhcjtcbiAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21vbnRoJykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIubW9udGg7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdkYXknKSBjdXN0b21Gb3JtYXQgPSBkdEZvcm1hdHRlci5kYXk7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdob3VyJykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIuaG91cjtcbiAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21pbnV0ZScpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLm1pbnV0ZTtcbiAgICAgICAgICB2YWx1ZSA9IGR0LmZvcm1hdERhdGUoZGF0ZVN0cmluZywgY3VzdG9tRm9ybWF0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBkdC5mb3JtYXREYXRlKGRhdGVTdHJpbmcsIHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRlU3RyaW5nOiByYXcsXG4gICAgICAgICAgcG9zaXRpb246IHRzLnBvc2l0aW9uLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICB1bml0OiB0cy51bml0LFxuICAgICAgICAgIHllYXI6IHRzLnllYXIsXG4gICAgICAgICAgbW9udGg6IHRzLm1vbnRoXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWZvcm1hdHRlZFRpbWVzY2FsZUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVPdmVybGFwcGluZ1RTXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU92ZXJsYXBwaW5nVFMoYXJyKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBsYXN0RHJhd25JbmRleCA9IDA7XG4gICAgICB2YXIgZmlsdGVyZWRBcnJheSA9IGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+IDAgJiYgX3RoaXMzLncuY29uZmlnLnhheGlzLmxhYmVscy5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMpIHtcbiAgICAgICAgICB2YXIgcHJldkxhYmVsV2lkdGggPSBncmFwaGljcy5nZXRUZXh0UmVjdHMoYXJyW2xhc3REcmF3bkluZGV4XS52YWx1ZSkud2lkdGg7XG4gICAgICAgICAgdmFyIHByZXZQb3MgPSBhcnJbbGFzdERyYXduSW5kZXhdLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwb3MgPSBpdGVtLnBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKHBvcyA+IHByZXZQb3MgKyBwcmV2TGFiZWxXaWR0aCArIDEwKSB7XG4gICAgICAgICAgICBsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmaWx0ZXJlZEFycmF5ID0gZmlsdGVyZWRBcnJheS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYgIT09IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZEFycmF5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaW1lU2NhbGU7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDb3JlIENsYXNzIHJlc3BvbnNpYmxlIGZvciBtYWpvciBjYWxjdWxhdGlvbnMgYW5kIGNyZWF0aW5nIGVsZW1lbnRzLlxuICpcbiAqIEBtb2R1bGUgQ29yZVxuICoqL1xuXG52YXIgQ29yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvcmUoZWwsIGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3JlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgpO1xuICAgIHRoaXMudHdvRFNlcmllcyA9IFtdO1xuICAgIHRoaXMudGhyZWVEU2VyaWVzID0gW107XG4gICAgdGhpcy50d29EU2VyaWVzWCA9IFtdO1xuICB9IC8vIGdldCBkYXRhIGFuZCBzdG9yZSBpbnRvIGFwcHJvcHJpYXRlIHZhcnNcblxuXG4gIF9jcmVhdGVDbGFzcyhDb3JlLCBbe1xuICAgIGtleTogXCJzZXR1cEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRWxlbWVudHMoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnOyAvLyBjb25zdCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eClcblxuICAgICAgdmFyIGN0ID0gY25mLmNoYXJ0LnR5cGU7XG4gICAgICB2YXIgYXhpc0NoYXJ0c0FyclR5cGVzID0gWydsaW5lJywgJ2FyZWEnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3JhZGFyJywgJ3NjYXR0ZXInLCAnYnViYmxlJywgJ2hlYXRtYXAnXTtcbiAgICAgIHZhciB4eUNoYXJ0c0FyclR5cGVzID0gWydsaW5lJywgJ2FyZWEnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInLCAnYnViYmxlJ107XG4gICAgICBnbC5heGlzQ2hhcnRzID0gYXhpc0NoYXJ0c0FyclR5cGVzLmluZGV4T2YoY3QpID4gLTE7XG4gICAgICBnbC54eUNoYXJ0cyA9IHh5Q2hhcnRzQXJyVHlwZXMuaW5kZXhPZihjdCkgPiAtMTtcbiAgICAgIGdsLmNoYXJ0Q2xhc3MgPSAnLmFwZXhjaGFydHMnICsgZ2wuY3VpZDtcbiAgICAgIGdsLmRvbS5iYXNlRWwgPSB0aGlzLmVsO1xuICAgICAgZ2wuZG9tLmVsV3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZ2wuZG9tLmVsV3JhcCwge1xuICAgICAgICBpZDogZ2wuY2hhcnRDbGFzcy5zdWJzdHJpbmcoMSksXG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1jYW52YXMgJyArIGdsLmNoYXJ0Q2xhc3Muc3Vic3RyaW5nKDEpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsV3JhcCk7XG4gICAgICBnbC5kb20uUGFwZXIgPSBuZXcgd2luZG93LlNWRy5Eb2MoZ2wuZG9tLmVsV3JhcCk7XG4gICAgICBnbC5kb20uUGFwZXIuYXR0cih7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1zdmcnLFxuICAgICAgICAneG1sbnM6ZGF0YSc6ICdBcGV4Q2hhcnRzTlMnLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjbmYuY2hhcnQub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQoY25mLmNoYXJ0Lm9mZnNldFksIFwiKVwiKVxuICAgICAgfSk7XG4gICAgICBnbC5kb20uUGFwZXIubm9kZS5zdHlsZS5iYWNrZ3JvdW5kID0gY25mLmNoYXJ0LmJhY2tncm91bmQ7XG4gICAgICB0aGlzLnNldFNWR0RpbWVuc2lvbnMoKTtcbiAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbCA9IGdsLmRvbS5QYXBlci5ncm91cCgpLmF0dHIoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtaW5uZXIgYXBleGNoYXJ0cy1ncmFwaGljYWwnXG4gICAgICB9KTtcbiAgICAgIGdsLmRvbS5lbERlZnMgPSBnbC5kb20uUGFwZXIuZGVmcygpO1xuICAgICAgZ2wuZG9tLmVsTGVnZW5kV3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZ2wuZG9tLmVsTGVnZW5kV3JhcC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWxlZ2VuZCcpO1xuICAgICAgZ2wuZG9tLmVsV3JhcC5hcHBlbmRDaGlsZChnbC5kb20uZWxMZWdlbmRXcmFwKTsgLy8gZ2wuZG9tLlBhcGVyLmFkZChnbC5kb20uZWxMZWdlbmRXcmFwKVxuXG4gICAgICBnbC5kb20uUGFwZXIuYWRkKGdsLmRvbS5lbEdyYXBoaWNhbCk7XG4gICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGdsLmRvbS5lbERlZnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbG90Q2hhcnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3RDaGFydFR5cGUoc2VyLCB4eVJhdGlvcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICB2YXIgbGluZVNlcmllcyA9IHtcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgaTogW11cbiAgICAgIH07XG4gICAgICB2YXIgYXJlYVNlcmllcyA9IHtcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgaTogW11cbiAgICAgIH07XG4gICAgICB2YXIgc2NhdHRlclNlcmllcyA9IHtcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgaTogW11cbiAgICAgIH07XG4gICAgICB2YXIgY29sdW1uU2VyaWVzID0ge1xuICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICBpOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBjYW5kbGVzdGlja1NlcmllcyA9IHtcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgaTogW11cbiAgICAgIH07XG4gICAgICBnbC5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXJpZXMsIHN0KSB7XG4gICAgICAgIC8vIGlmIHVzZXIgaGFzIHNwZWNpZmllZCBhIHBhcnRpY3VsYXIgdHlwZSBmb3IgcGFydGljdWxhciBzZXJpZXNcbiAgICAgICAgaWYgKHR5cGVvZiBzZXJbc3RdLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2NvbHVtbicgfHwgc2VyW3N0XS50eXBlID09PSAnYmFyJykge1xuICAgICAgICAgICAgdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwgPSBmYWxzZTsgLy8gYmFyIG5vdCBzdXBwb3J0ZWQgaW4gbWl4ZWQgY2hhcnRzXG5cbiAgICAgICAgICAgIGNvbHVtblNlcmllcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgICAgICAgY29sdW1uU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdhcmVhJykge1xuICAgICAgICAgICAgYXJlYVNlcmllcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgICAgICAgYXJlYVNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIGxpbmVTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGxpbmVTZXJpZXMuaS5wdXNoKHN0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ3NjYXR0ZXInKSB7XG4gICAgICAgICAgICBzY2F0dGVyU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICAgICAgICBzY2F0dGVyU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdidWJibGUnKSA7IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZXIgaGFzIHNwZWNpZmllZCB0eXBlLCBidXQgaXQgaXMgbm90IHZhbGlkIChvdGhlciB0aGFuIGxpbmUvYXJlYS9jb2x1bW4pXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdSBoYXZlIHNwZWNpZmllZCBhbiB1bnJlY29nbml6ZWQgY2hhcnQgdHlwZS4gQXZhaWxhYmxlIHR5cGVzIGZvciB0aGlzIHByb3BlcnkgYXJlIGxpbmUvYXJlYS9jb2x1bW4vYmFyL3NjYXR0ZXIvYnViYmxlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuY29tYm9DaGFydHMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICBsaW5lU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgdmFyIGNhbmRsZXN0aWNrID0gbmV3IENhbmRsZVN0aWNrKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmFkaWFsQmFyID0gbmV3IFJhZGlhbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmFkYXIgPSBuZXcgUmFkYXIodGhpcy5jdHgpO1xuICAgICAgdmFyIGVsR3JhcGggPSBbXTtcblxuICAgICAgaWYgKGdsLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIGlmIChhcmVhU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWxHcmFwaC5wdXNoKGxpbmUuZHJhdyhhcmVhU2VyaWVzLnNlcmllcywgJ2FyZWEnLCBhcmVhU2VyaWVzLmkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW5TZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgICAgdmFyIGJhclN0YWNrZWQgPSBuZXcgQmFyU3RhY2tlZCh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgZWxHcmFwaC5wdXNoKGJhclN0YWNrZWQuZHJhdyhjb2x1bW5TZXJpZXMuc2VyaWVzLCBjb2x1bW5TZXJpZXMuaSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gbmV3IEJhcih0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgZWxHcmFwaC5wdXNoKGJhci5kcmF3KGNvbHVtblNlcmllcy5zZXJpZXMsIGNvbHVtblNlcmllcy5pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmVTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbEdyYXBoLnB1c2gobGluZS5kcmF3KGxpbmVTZXJpZXMuc2VyaWVzLCAnbGluZScsIGxpbmVTZXJpZXMuaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbmRsZXN0aWNrU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWxHcmFwaC5wdXNoKGNhbmRsZXN0aWNrLmRyYXcoY2FuZGxlc3RpY2tTZXJpZXMuc2VyaWVzLCBjYW5kbGVzdGlja1Nlcmllcy5pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhdHRlclNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBzY2F0dGVyTGluZSA9IG5ldyBMaW5lKHRoaXMuY3R4LCB4eVJhdGlvcywgdHJ1ZSk7XG4gICAgICAgICAgZWxHcmFwaC5wdXNoKHNjYXR0ZXJMaW5lLmRyYXcoc2NhdHRlclNlcmllcy5zZXJpZXMsICdzY2F0dGVyJywgc2NhdHRlclNlcmllcy5pKSk7XG4gICAgICAgIH0gLy8gVE9ETzogYWxsb3cgYnViYmxlIHNlcmllcyBpbiBhIGNvbWJvIGNoYXJ0XG4gICAgICAgIC8vIGlmIChidWJibGVTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gICBjb25zdCBidWJibGVMaW5lID0gbmV3IExpbmUodGhpcy5jdHgsIHh5UmF0aW9zLCB0cnVlKVxuICAgICAgICAvLyAgIGVsR3JhcGgucHVzaChcbiAgICAgICAgLy8gICAgIGJ1YmJsZUxpbmUuZHJhdyhidWJibGVTZXJpZXMuc2VyaWVzLCAnYnViYmxlJywgYnViYmxlU2VyaWVzLmkpXG4gICAgICAgIC8vICAgKVxuICAgICAgICAvLyB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoY25mLmNoYXJ0LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzLCAnbGluZScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhcmVhJzpcbiAgICAgICAgICAgIGVsR3JhcGggPSBsaW5lLmRyYXcoZ2wuc2VyaWVzLCAnYXJlYScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgICAgaWYgKGNuZi5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICAgIHZhciBfYmFyU3RhY2tlZCA9IG5ldyBCYXJTdGFja2VkKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG5cbiAgICAgICAgICAgICAgZWxHcmFwaCA9IF9iYXJTdGFja2VkLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfYmFyID0gbmV3IEJhcih0aGlzLmN0eCwgeHlSYXRpb3MpO1xuXG4gICAgICAgICAgICAgIGVsR3JhcGggPSBfYmFyLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjYW5kbGVzdGljayc6XG4gICAgICAgICAgICB2YXIgY2FuZGxlU3RpY2sgPSBuZXcgQ2FuZGxlU3RpY2sodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgIGVsR3JhcGggPSBjYW5kbGVTdGljay5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hlYXRtYXAnOlxuICAgICAgICAgICAgdmFyIGhlYXRtYXAgPSBuZXcgSGVhdE1hcCh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgICAgICAgZWxHcmFwaCA9IGhlYXRtYXAuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwaWUnOlxuICAgICAgICAgIGNhc2UgJ2RvbnV0JzpcbiAgICAgICAgICAgIGVsR3JhcGggPSBwaWUuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyYWRpYWxCYXInOlxuICAgICAgICAgICAgZWxHcmFwaCA9IHJhZGlhbEJhci5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3JhZGFyJzpcbiAgICAgICAgICAgIGVsR3JhcGggPSByYWRhci5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlbEdyYXBoID0gbGluZS5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsR3JhcGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNWR0RpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U1ZHRGltZW5zaW9ucygpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICBnbC5zdmdXaWR0aCA9IGNuZi5jaGFydC53aWR0aDtcbiAgICAgIGdsLnN2Z0hlaWdodCA9IGNuZi5jaGFydC5oZWlnaHQ7XG4gICAgICB2YXIgZWxEaW0gPSBVdGlscy5nZXREaW1lbnNpb25zKHRoaXMuZWwpO1xuICAgICAgdmFyIHdpZHRoVW5pdCA9IGNuZi5jaGFydC53aWR0aC50b1N0cmluZygpLnNwbGl0KC9bMC05XSsvZykucG9wKCk7XG5cbiAgICAgIGlmICh3aWR0aFVuaXQgPT09ICclJykge1xuICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoZWxEaW1bMF0pKSB7XG4gICAgICAgICAgaWYgKGVsRGltWzBdLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBlbERpbSA9IFV0aWxzLmdldERpbWVuc2lvbnModGhpcy5lbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnbC5zdmdXaWR0aCA9IGVsRGltWzBdICogcGFyc2VJbnQoY25mLmNoYXJ0LndpZHRoKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh3aWR0aFVuaXQgPT09ICdweCcgfHwgd2lkdGhVbml0ID09PSAnJykge1xuICAgICAgICBnbC5zdmdXaWR0aCA9IHBhcnNlSW50KGNuZi5jaGFydC53aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnbC5zdmdIZWlnaHQgIT09ICdhdXRvJyAmJiBnbC5zdmdIZWlnaHQgIT09ICcnKSB7XG4gICAgICAgIHZhciBoZWlnaHRVbml0ID0gY25mLmNoYXJ0LmhlaWdodC50b1N0cmluZygpLnNwbGl0KC9bMC05XSsvZykucG9wKCk7XG5cbiAgICAgICAgaWYgKGhlaWdodFVuaXQgPT09ICclJykge1xuICAgICAgICAgIHZhciBlbFBhcmVudERpbSA9IFV0aWxzLmdldERpbWVuc2lvbnModGhpcy5lbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBlbFBhcmVudERpbVsxXSAqIHBhcnNlSW50KGNuZi5jaGFydC5oZWlnaHQpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnN2Z0hlaWdodCA9IHBhcnNlSW50KGNuZi5jaGFydC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIGdsLnN2Z0hlaWdodCA9IGdsLnN2Z1dpZHRoIC8gMS42MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBnbC5zdmdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uUGFwZXIubm9kZSwge1xuICAgICAgICB3aWR0aDogZ2wuc3ZnV2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2wuc3ZnSGVpZ2h0XG4gICAgICB9KTsgLy8gZ2wuZG9tLlBhcGVyLm5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLm1pbldpZHRoID0gZ2wuc3ZnV2lkdGggKyBcInB4XCI7XG5cbiAgICAgIHZhciBvZmZzZXRZID0gY25mLmNoYXJ0LnNwYXJrbGluZS5lbmFibGVkID8gMCA6IGdsLmF4aXNDaGFydHMgPyAxNCA6IDU7XG4gICAgICBnbC5kb20uUGFwZXIubm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUubWluSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0ICsgb2Zmc2V0WSArICdweCc7XG4gICAgICBnbC5kb20uZWxXcmFwLnN0eWxlLndpZHRoID0gZ2wuc3ZnV2lkdGggKyAncHgnO1xuICAgICAgZ2wuZG9tLmVsV3JhcC5zdHlsZS5oZWlnaHQgPSBnbC5zdmdIZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdEdyYXBoUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnRHcmFwaFBvc2l0aW9uKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgdFkgPSBnbC50cmFuc2xhdGVZO1xuICAgICAgdmFyIHRYID0gZ2wudHJhbnNsYXRlWDtcbiAgICAgIHZhciBzY2FsaW5nQXR0cnMgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdFggKyAnLCAnICsgdFkgKyAnKSdcbiAgICAgIH07XG4gICAgICBHcmFwaGljcy5zZXRBdHRycyhnbC5kb20uZWxHcmFwaGljYWwubm9kZSwgc2NhbGluZ0F0dHJzKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiogQWxsIHRoZSBjYWxjdWxhdGlvbnMgZm9yIHNldHRpbmcgcmFuZ2UgaW4gY2hhcnRzIHdpbGwgYmUgZG9uZSBoZXJlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb3JlQ2FsY3VsYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcmVDYWxjdWxhdGlvbnMoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UkMSh0aGlzLmN0eCk7XG4gICAgICByYW5nZS5pbml0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0R2xvYmFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEdsb2JhbHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIGdsLnNlcmllcyA9IFtdO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlTyA9IFtdO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlSCA9IFtdO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlTCA9IFtdO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlQyA9IFtdO1xuICAgICAgZ2wuc2VyaWVzUGVyY2VudCA9IFtdO1xuICAgICAgZ2wuc2VyaWVzWCA9IFtdO1xuICAgICAgZ2wuc2VyaWVzWiA9IFtdO1xuICAgICAgZ2wuc2VyaWVzTmFtZXMgPSBbXTtcbiAgICAgIGdsLnNlcmllc1RvdGFscyA9IFtdO1xuICAgICAgZ2wuc3RhY2tlZFNlcmllc1RvdGFscyA9IFtdO1xuICAgICAgZ2wubGFiZWxzID0gW107XG4gICAgICBnbC50aW1lbGluZUxhYmVscyA9IFtdO1xuICAgICAgZ2wubm9MYWJlbHNQcm92aWRlZCA9IGZhbHNlO1xuICAgICAgZ2wudGltZXNjYWxlVGlja3MgPSBbXTtcbiAgICAgIGdsLnJlc2l6ZVRpbWVyID0gbnVsbDtcbiAgICAgIGdsLnNlbGVjdGlvblJlc2l6ZVRpbWVyID0gbnVsbDtcblxuICAgICAgZ2wuc2VyaWVzWHZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLncuY29uZmlnLnNlcmllcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgfSgpO1xuXG4gICAgICBnbC5zZXJpZXNZdmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9KCk7XG5cbiAgICAgIGdsLmRlbGF5ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgZ2wucG9pbnRzQXJyYXkgPSBbXTtcbiAgICAgIGdsLmRhdGFMYWJlbHNSZWN0cyA9IFtdO1xuICAgICAgZ2wuaXNYTnVtZXJpYyA9IGZhbHNlO1xuICAgICAgZ2wuaXNEYXRhWFlaID0gZmFsc2U7XG4gICAgICBnbC5tYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5taW5ZID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgIGdsLm1pbllBcnIgPSBbXTtcbiAgICAgIGdsLm1heFlBcnIgPSBbXTtcbiAgICAgIGdsLm1heFggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLm1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wuaW5pdGlhbG1heFggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLmluaXRpYWxtaW5YID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLm1heERhdGUgPSAwO1xuICAgICAgZ2wubWluRGF0ZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5taW5aID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLm1heFogPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLnlBeGlzU2NhbGUgPSBbXTtcbiAgICAgIGdsLnhBeGlzU2NhbGUgPSBudWxsO1xuICAgICAgZ2wueEF4aXNUaWNrc1Bvc2l0aW9ucyA9IFtdO1xuICAgICAgZ2wueUxhYmVsc0Nvb3JkcyA9IFtdO1xuICAgICAgZ2wueVRpdGxlQ29vcmRzID0gW107XG4gICAgICBnbC54UmFuZ2UgPSAwO1xuICAgICAgZ2wueVJhbmdlID0gW107XG4gICAgICBnbC56UmFuZ2UgPSAwO1xuICAgICAgZ2wuZGF0YVBvaW50cyA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTXVsdGlwbGVZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTXVsdGlwbGVZKCkge1xuICAgICAgLy8gdXNlciBoYXMgc3VwcGxpZWQgYW4gYXJyYXkgaW4geWF4aXMgcHJvcGVydHkuIFNvLCB0dXJuIG9uIG11bHRpcGxlWUF4aXMgZmxhZ1xuICAgICAgaWYgKHRoaXMudy5jb25maWcueWF4aXMuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIHRoaXMudy5jb25maWcueWF4aXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBmaXJzdCwgdHVybiBvZmYgc3RhY2tpbmcgaWYgbXVsdGlwbGUgeSBheGlzXG4gICAgICAgIHRoaXMudy5jb25maWcuY2hhcnQuc3RhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLncuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhjbHVkZUNvbGxhcHNlZFNlcmllc0luWUF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhjbHVkZUNvbGxhcHNlZFNlcmllc0luWUF4aXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5tYXAoZnVuY3Rpb24gKGNvbGxhcHNlZCwgaSkge1xuICAgICAgICBpZiAoX3RoaXMyLncuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGFwc2VkLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNdWx0aUZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc011bHRpRm9ybWF0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNGb3JtYXRYWSgpIHx8IHRoaXMuaXNGb3JtYXQyREFycmF5KCk7XG4gICAgfSAvLyBnaXZlbiBmb3JtYXQgaXMgW3t4LCB5fSwge3gsIHl9XVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGb3JtYXRYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zvcm1hdFhZKCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMudy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG4gICAgICB2YXIgc3IgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuYWN0aXZlU2VyaWVzSW5kZXggPSBzci5nZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleCgpO1xuXG4gICAgICBpZiAodHlwZW9mIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhICE9PSAndW5kZWZpbmVkJyAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YS5sZW5ndGggPiAwICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSBudWxsICYmIHR5cGVvZiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXS54ICE9PSAndW5kZWZpbmVkJyAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGdpdmVuIGZvcm1hdCBpcyBbW3gsIHldLCBbeCwgeV1dXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0Zvcm1hdDJEQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGb3JtYXQyREFycmF5KCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMudy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG4gICAgICB2YXIgc3IgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuYWN0aXZlU2VyaWVzSW5kZXggPSBzci5nZXRBY3RpdmVDb25maWdTZXJpZXNJbmRleCgpO1xuXG4gICAgICBpZiAodHlwZW9mIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhICE9PSAndW5kZWZpbmVkJyAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YS5sZW5ndGggPiAwICYmIHR5cGVvZiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09IG51bGwgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVGb3JtYXQyREFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUZvcm1hdDJEQXJyYXkoc2VyLCBpKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VyW2ldLmRhdGFbal1bMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyW2ldLmRhdGFbal1bMV0pICYmIHNlcltpXS5kYXRhW2pdWzFdLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal1bMV1bM10pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal1bMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAvLyBpZiB0aW1lc3RhbXBzIGFyZSBwcm92aWRlZCBhbmQgeGF4aXMgdHlwZSBpcyBkYXRldHRpbWUsXG4gICAgICAgICAgdmFyIHRzID0gbmV3IERhdGUoc2VyW2ldLmRhdGFbal1bMF0pO1xuICAgICAgICAgIHRzID0gbmV3IERhdGUodHMpLmdldFRpbWUoKTtcbiAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2godHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChzZXJbaV0uZGF0YVtqXVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgX2orKykge1xuICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW19qXVsyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLnRocmVlRFNlcmllcy5wdXNoKHNlcltpXS5kYXRhW19qXVsyXSk7XG4gICAgICAgICAgZ2wuaXNEYXRhWFlaID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVGb3JtYXRYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGb3JtYXRYWShzZXIsIGkpIHtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIGFjdGl2ZUkgPSBpO1xuXG4gICAgICBpZiAoZ2wuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID4gLTEpIHtcbiAgICAgICAgLy8gZml4ICMzNjhcbiAgICAgICAgYWN0aXZlSSA9IHRoaXMuYWN0aXZlU2VyaWVzSW5kZXg7XG4gICAgICB9IC8vIGdldCBzZXJpZXNcblxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VyW2ldLmRhdGFbal0ueSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJbaV0uZGF0YVtqXS55KSAmJiBzZXJbaV0uZGF0YVtqXS55Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal0ueVszXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXMucHVzaChVdGlscy5wYXJzZU51bWJlcihzZXJbaV0uZGF0YVtqXS55KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGdldCBzZXJpZXNYXG5cblxuICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgc2VyW2FjdGl2ZUldLmRhdGEubGVuZ3RoOyBfajIrKykge1xuICAgICAgICB2YXIgaXNYU3RyaW5nID0gdHlwZW9mIHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHZhciBpc1hEYXRlID0gISFkdC5pc1ZhbGlkRGF0ZShzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKGlzWFN0cmluZyB8fCBpc1hEYXRlKSB7XG4gICAgICAgICAgLy8gdXNlciBzdXBwbGllZCAnMDEvMDEvMjAxNycgb3IgYSBkYXRlIHN0cmluZyAoYSBKUyBkYXRlIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkKVxuICAgICAgICAgIGlmIChpc1hTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goZHQucGFyc2VEYXRlKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYSBjYXRlZ29yeSBhbmQgbm90IGEgbnVtZXJpYyB4IHZhbHVlXG4gICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goZHQucGFyc2VEYXRlKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueC50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2gocGFyc2VGbG9hdChzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYSBudW1lcmljIHZhbHVlIGluIHggcHJvcGVydHlcbiAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VyW2ldLmRhdGFbMF0gJiYgdHlwZW9mIHNlcltpXS5kYXRhWzBdLnogIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgc2VyW2ldLmRhdGEubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB0aGlzLnRocmVlRFNlcmllcy5wdXNoKHNlcltpXS5kYXRhW3RdLnopO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuaXNEYXRhWFlaID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2FuZGxlU3RpY2tEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNhbmRsZVN0aWNrRGF0YShzZXIsIGkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIG9obGMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgb2hsYyA9IHRoaXMuaGFuZGxlQ2FuZGxlU3RpY2tEYXRhRm9ybWF0KCdhcnJheScsIHNlciwgaSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGb3JtYXRYWSgpKSB7XG4gICAgICAgIG9obGMgPSB0aGlzLmhhbmRsZUNhbmRsZVN0aWNrRGF0YUZvcm1hdCgneHknLCBzZXIsIGkpO1xuICAgICAgfVxuXG4gICAgICBnbC5zZXJpZXNDYW5kbGVPLnB1c2gob2hsYy5vKTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUgucHVzaChvaGxjLmgpO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlTC5wdXNoKG9obGMubCk7XG4gICAgICBnbC5zZXJpZXNDYW5kbGVDLnB1c2gob2hsYy5jKTtcbiAgICAgIHJldHVybiBvaGxjO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDYW5kbGVTdGlja0RhdGFGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2FuZGxlU3RpY2tEYXRhRm9ybWF0KGZvcm1hdCwgc2VyLCBpKSB7XG4gICAgICB2YXIgc2VyTyA9IFtdO1xuICAgICAgdmFyIHNlckggPSBbXTtcbiAgICAgIHZhciBzZXJMID0gW107XG4gICAgICB2YXIgc2VyQyA9IFtdO1xuICAgICAgdmFyIGVyciA9ICdQbGVhc2UgcHJvdmlkZSBbT3BlbiwgSGlnaCwgTG93IGFuZCBDbG9zZV0gdmFsdWVzIGluIHZhbGlkIGZvcm1hdC4gUmVhZCBtb3JlIGh0dHBzOi8vYXBleGNoYXJ0cy5jb20vZG9jcy9zZXJpZXMvI2NhbmRsZXN0aWNrJztcblxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAoc2VyW2ldLmRhdGFbMF1bMV0ubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcltpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VyTy5wdXNoKHNlcltpXS5kYXRhW2pdWzFdWzBdKTtcbiAgICAgICAgICBzZXJILnB1c2goc2VyW2ldLmRhdGFbal1bMV1bMV0pO1xuICAgICAgICAgIHNlckwucHVzaChzZXJbaV0uZGF0YVtqXVsxXVsyXSk7XG4gICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW2pdWzFdWzNdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICd4eScpIHtcbiAgICAgICAgaWYgKHNlcltpXS5kYXRhWzBdLnkubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qMysrKSB7XG4gICAgICAgICAgc2VyTy5wdXNoKHNlcltpXS5kYXRhW19qM10ueVswXSk7XG4gICAgICAgICAgc2VySC5wdXNoKHNlcltpXS5kYXRhW19qM10ueVsxXSk7XG4gICAgICAgICAgc2VyTC5wdXNoKHNlcltpXS5kYXRhW19qM10ueVsyXSk7XG4gICAgICAgICAgc2VyQy5wdXNoKHNlcltpXS5kYXRhW19qM10ueVszXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbzogc2VyTyxcbiAgICAgICAgaDogc2VySCxcbiAgICAgICAgbDogc2VyTCxcbiAgICAgICAgYzogc2VyQ1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRhQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGFBeGlzQ2hhcnRzKHNlcikge1xuICAgICAgdmFyIGN0eCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5jdHg7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKGN0eCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudHdvRFNlcmllcyA9IFtdO1xuICAgICAgICB0aGlzLnR3b0RTZXJpZXNYID0gW107XG4gICAgICAgIHRoaXMudGhyZWVEU2VyaWVzID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXJbaV0uZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSXQgaXMgYSBwb3NzaWJpbGl0eSB0aGF0IHlvdSBtYXkgaGF2ZSBub3QgaW5jbHVkZWQgJ2RhdGEnIHByb3BlcnR5IGluIHNlcmllcy5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aUZvcm1hdCgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGb3JtYXQyREFycmF5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRm9ybWF0MkRBcnJheShzZXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0Zvcm1hdFhZKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRm9ybWF0WFkoc2VyLCBpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdjYW5kbGVzdGljaycgfHwgc2VyW2ldLnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FuZGxlU3RpY2tEYXRhKHNlciwgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuc2VyaWVzLnB1c2godGhpcy50d29EU2VyaWVzKTtcbiAgICAgICAgICBnbC5sYWJlbHMucHVzaCh0aGlzLnR3b0RTZXJpZXNYKTtcbiAgICAgICAgICBnbC5zZXJpZXNYLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5KSB7XG4gICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGRpZG4ndCBzdXBwbGllZCBbe3gseX1dIG9yIFtbeCx5XV0sIGJ1dCBzaW5nbGUgYXJyYXkgaW4gZGF0YS5cbiAgICAgICAgICAgIC8vIEFsc28gbGFiZWxzL2NhdGVnb3JpZXMgd2VyZSBzdXBwbGllZCBkaWZmZXJlbnRseVxuICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZGF0ZXMgPSBjbmYubGFiZWxzLmxlbmd0aCA+IDAgPyBjbmYubGFiZWxzLnNsaWNlKCkgOiBjbmYueGF4aXMuY2F0ZWdvcmllcy5zbGljZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZXNbal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRGF0ZSA9IGR0LmlzVmFsaWREYXRlKGRhdGVzW2pdKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChkdC5wYXJzZURhdGUoZGF0ZXNbal0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBwcm92aWRlZCBpbnZhbGlkIERhdGUgZm9ybWF0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgICAgICBnbC5pc1hOdW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB4ID0gY25mLmxhYmVscy5sZW5ndGggPiAwID8gY25mLmxhYmVscy5zbGljZSgpIDogY25mLnhheGlzLmNhdGVnb3JpZXMuc2xpY2UoKTtcblxuICAgICAgICAgICAgaWYgKHgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYID0geDtcbiAgICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLmxhYmVscy5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgIHZhciBzaW5nbGVBcnJheSA9IHNlcltpXS5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlTnVtYmVyKGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdsLnNlcmllcy5wdXNoKHNpbmdsZUFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnNlcmllc1oucHVzaCh0aGlzLnRocmVlRFNlcmllcyk7XG5cbiAgICAgICAgaWYgKHNlcltpXS5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKHNlcltpXS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5zZXJpZXNOYW1lcy5wdXNoKCdzZXJpZXMtJyArIHBhcnNlSW50KGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VEYXRhTm9uQXhpc0NoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGFOb25BeGlzQ2hhcnRzKHNlcikge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIGdsLnNlcmllcyA9IHNlci5zbGljZSgpO1xuICAgICAgZ2wuc2VyaWVzTmFtZXMgPSBjbmYubGFiZWxzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2wuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChnbC5zZXJpZXNOYW1lc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ2wuc2VyaWVzTmFtZXMucHVzaCgnc2VyaWVzLScgKyAoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFeHRlcm5hbExhYmVsc0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxMYWJlbHNEYXRhKHNlcikge1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFsczsgLy8gdXNlciBwcm92aWRlZCBsYWJlbHMgaW4gY2F0ZWdvcnkgYXhpc1xuXG4gICAgICBpZiAoY25mLnhheGlzLmNhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBnbC5sYWJlbHMgPSBjbmYueGF4aXMuY2F0ZWdvcmllcztcbiAgICAgIH0gZWxzZSBpZiAoY25mLmxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdsLmxhYmVscyA9IGNuZi5sYWJlbHMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mYWxsYmFja1RvQ2F0ZWdvcnkpIHtcbiAgICAgICAgZ2wubGFiZWxzID0gZ2wubGFiZWxzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlciBkaWRuJ3QgcHJvdmlkZWQgbGFiZWxzLCBmYWxsYmFjayB0byAxLTItMy00LTVcbiAgICAgICAgdmFyIGxhYmVsQXJyID0gW107XG5cbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllc1tnbC5tYXhWYWxzSW5BcnJheUluZGV4XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxBcnIucHVzaChpICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGdsLnNlcmllc1gucHVzaChsYWJlbEFycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgIH0gLy8gbm8gc2VyaWVzIHRvIHB1bGwgbGFiZWxzIGZyb20sIHB1dCBhIDAtMTAgc2VyaWVzXG5cblxuICAgICAgICBpZiAobGFiZWxBcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbGFiZWxBcnIgPSBbMCwgMTBdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc2VyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIGdsLnNlcmllc1gucHVzaChsYWJlbEFycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2wubGFiZWxzID0gbGFiZWxBcnI7XG4gICAgICAgIGdsLm5vTGFiZWxzUHJvdmlkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIGdsLmlzWE51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gU2VncmVnYXRlIHVzZXIgcHJvdmlkZWQgZGF0YSBpbnRvIGFwcHJvcHJpYXRlIHZhcnNcblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGEoc2VyKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHRoaXMuZXhjbHVkZUNvbGxhcHNlZFNlcmllc0luWUF4aXMoKTtcbiAgICAgIHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0R2xvYmFscygpO1xuICAgICAgdGhpcy5pc011bHRpcGxlWSgpO1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cykge1xuICAgICAgICB0aGlzLnBhcnNlRGF0YUF4aXNDaGFydHMoc2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VEYXRhTm9uQXhpc0NoYXJ0cyhzZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvcmVVdGlscy5nZXRMYXJnZXN0U2VyaWVzKCk7IC8vIHNldCBOdWxsIHZhbHVlcyB0byAwIGluIGFsbCBzZXJpZXMgd2hlbiB1c2VyIGhpZGVzL3Nob3dzIHNvbWUgc2VyaWVzXG5cbiAgICAgIGlmIChjbmYuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgY25mLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICBnbC5zZXJpZXMgPSBzZXJpZXMuc2V0TnVsbFNlcmllc1RvWmVyb1ZhbHVlcyhnbC5zZXJpZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvcmVVdGlscy5nZXRTZXJpZXNUb3RhbHMoKTtcblxuICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdGhpcy5jb3JlVXRpbHMuZ2V0U3RhY2tlZFNlcmllc1RvdGFscygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvcmVVdGlscy5nZXRQZXJjZW50U2VyaWVzKCk7IC8vIHVzZXIgZGlkbid0IHByb3ZpZGUgYSBbW3gseV0sW3gseV1dIHNlcmllcywgYnV0IGEgbmFtZWQgc2VyaWVzXG5cbiAgICAgIGlmICghZ2wuaXNYTnVtZXJpYyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnICYmIGNuZi5sYWJlbHMubGVuZ3RoID09PSAwICYmIGNuZi54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmhhbmRsZUV4dGVybmFsTGFiZWxzRGF0YShzZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4eVNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHh5U2V0dGluZ3MoKSB7XG4gICAgICB2YXIgeHlSYXRpb3MgPSBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgdmFyIGNyb3NzaGFpcnMgPSBuZXcgQ3Jvc3NoYWlycyh0aGlzLmN0eCk7XG4gICAgICAgICAgY3Jvc3NoYWlycy5kcmF3WENyb3NzaGFpcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5jcm9zc2hhaXJzLnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgICB2YXIgX2Nyb3NzaGFpcnMgPSBuZXcgQ3Jvc3NoYWlycyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICBfY3Jvc3NoYWlycy5kcmF3WUNyb3NzaGFpcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHh5UmF0aW9zID0gdGhpcy5jb3JlVXRpbHMuZ2V0Q2FsY3VsYXRlZFJhdGlvcygpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmIHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCAmJiBpc0Zpbml0ZSh3Lmdsb2JhbHMubWluWCkgJiYgaXNGaW5pdGUody5nbG9iYWxzLm1heFgpKSB7XG4gICAgICAgICAgdmFyIHRzID0gbmV3IFRpbWVTY2FsZSh0aGlzLmN0eCk7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlZFRpbWVTY2FsZSA9IHRzLmNhbGN1bGF0ZVRpbWVTY2FsZVRpY2tzKHcuZ2xvYmFscy5taW5YLCB3Lmdsb2JhbHMubWF4WCk7XG4gICAgICAgICAgdHMucmVjYWxjRGltZW5zaW9uc0Jhc2VkT25Gb3JtYXQoZm9ybWF0dGVkVGltZVNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geHlSYXRpb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBeGlzKHR5cGUsIHh5UmF0aW9zKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB5QXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzICYmIHR5cGUgIT09ICdyYWRhcicpIHtcbiAgICAgICAgdmFyIGVsWGF4aXMsIGVsWWF4aXM7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdiYXInICYmIGNuZi5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIGVsWWF4aXMgPSB5QXhpcy5kcmF3WWF4aXNJbnZlcnNlZCgwKTtcbiAgICAgICAgICBlbFhheGlzID0geEF4aXMuZHJhd1hheGlzSW52ZXJzZWQoMCk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbFhheGlzKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsWWF4aXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsWGF4aXMgPSB4QXhpcy5kcmF3WGF4aXMoKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsWGF4aXMpO1xuICAgICAgICAgIGNuZi55YXhpcy5tYXAoZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoZ2wuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICAgICAgICBlbFlheGlzID0geUF4aXMuZHJhd1lheGlzKGluZGV4KTtcbiAgICAgICAgICAgICAgZ2wuZG9tLlBhcGVyLmFkZChlbFlheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAoZ2wuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICAgIHlBeGlzLnlBeGlzVGl0bGVSb3RhdGUoaW5kZXgsIHlheGUub3Bwb3NpdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBCcnVzaEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBCcnVzaEhhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIG9ubHkgZm9yIGJydXNoIGNoYXJ0c1xuXG4gICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0LmJydXNoLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpZiB1c2VyIGhhcyBub3QgZGVmaW5lZCBhIGN1c3RvbSBmdW5jdGlvbiBmb3Igc2VsZWN0aW9uIC0gd2UgaGFuZGxlIHRoZSBicnVzaCBjaGFydFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlIGxlYXZlIGl0IHRvIHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgZnVuY3Rpb25hbGl0eSBmb3Igc2VsZWN0aW9uXG5cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0YXJnZXRzID0gdy5jb25maWcuY2hhcnQuYnJ1c2gudGFyZ2V0cyB8fCBbdy5jb25maWcuY2hhcnQuYnJ1c2gudGFyZ2V0XTsgLy8gcmV0cm8gY29tcGF0aWJpbGl0eSB3aXRoIHNpbmdsZSB0YXJnZXQgb3B0aW9uXG5cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0Q2hhcnQgPSBBcGV4Q2hhcnRzLmdldENoYXJ0QnlJRCh0YXJnZXQpO1xuICAgICAgICAgIHRhcmdldENoYXJ0LncuZ2xvYmFscy5icnVzaFNvdXJjZSA9IF90aGlzMy5jdHg7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlU291cmNlQ2hhcnQgPSBmdW5jdGlvbiB1cGRhdGVTb3VyY2VDaGFydCgpIHtcbiAgICAgICAgICAgIF90aGlzMy5jdHguX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0YXJnZXRDaGFydC53Lmdsb2JhbHMubWluWCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiB0YXJnZXRDaGFydC53Lmdsb2JhbHMubWF4WFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGRhdGVTb3VyY2VDaGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldENoYXJ0LncuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnNjcm9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB1cGRhdGVTb3VyY2VDaGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID0gZnVuY3Rpb24gKGNoYXJ0LCBlKSB7XG4gICAgICAgICAgICB2YXIgeWF4aXMgPSBVdGlscy5jbG9uZSh3LmNvbmZpZy55YXhpcyk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5icnVzaC5hdXRvU2NhbGVZYXhpcykge1xuICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBuZXcgUmFuZ2UodGFyZ2V0Q2hhcnQpO1xuICAgICAgICAgICAgICB5YXhpcyA9IHNjYWxlLmF1dG9TY2FsZVkodGFyZ2V0Q2hhcnQsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRDaGFydC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgbWluOiBlLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IGUueGF4aXMubWF4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvcmU7XG59KCk7XG5cbi8qKlxuICogQHRoaXMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIGZpbmFsbHlDb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gUHJvbWlzZSQxKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlJDEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlJDEuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgIGlmIChcbiAgICAgIG5ld1ZhbHVlICYmXG4gICAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlJDEpIHtcbiAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3Qoc2VsZiwgZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHNlbGYuX3N0YXRlID0gMjtcbiAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBpZiAoc2VsZi5fc3RhdGUgPT09IDIgJiYgc2VsZi5fZGVmZXJyZWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIFByb21pc2UkMS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZSQxLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gIH1cbiAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKFxuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChzZWxmLCBleCk7XG4gIH1cbn1cblxuUHJvbWlzZSQxLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlJDEucHJvdG90eXBlWydmaW5hbGx5J10gPSBmaW5hbGx5Q29uc3RydWN0b3I7XG5cblByb21pc2UkMS5hbGwgPSBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFhcnIgfHwgdHlwZW9mIGFyci5sZW5ndGggPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZSQxLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSQxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UkMS5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UkMS5yYWNlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZSQxLl9pbW1lZGlhdGVGbiA9XG4gICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSkgfHxcbiAgZnVuY3Rpb24oZm4pIHtcbiAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gIH07XG5cblByb21pc2UkMS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9XG59O1xuXG52YXIgRXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cG9ydHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cG9ydHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXhwb3J0cywgW3tcbiAgICBrZXk6IFwiZ2V0U3ZnU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN2Z1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uUGFwZXIuc3ZnKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBoaWRlIHNvbWUgZWxlbWVudHMgdG8gYXZvaWQgcHJpbnRpbmcgdGhlbSBvbiBleHBvcnRlZCBzdmdcblxuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGNyb3NzaGFpcnMnKTtcbiAgICAgIHZhciB5Y3Jvc3NoYWlycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXljcm9zc2hhaXJzJyk7XG5cbiAgICAgIGlmICh4Y3Jvc3NoYWlycykge1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3gnLCAtNTAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHljcm9zc2hhaXJzKSB7XG4gICAgICAgIHljcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneTEnLCAtMTAwKTtcbiAgICAgICAgeWNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd5MicsIC0xMDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdmdVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ZnVXJsKCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB2YXIgc3ZnRGF0YSA9IHRoaXMuZ2V0U3ZnU3RyaW5nKCk7XG4gICAgICB2YXIgc3ZnQmxvYiA9IG5ldyBCbG9iKFtzdmdEYXRhXSwge1xuICAgICAgICB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04J1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVVSSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhVVJJKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHcgPSBfdGhpcy53O1xuXG4gICAgICAgIF90aGlzLmNsZWFudXAoKTtcblxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHcuZ2xvYmFscy5zdmdXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHcuZ2xvYmFscy5zdmdIZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNCZyA9IHcuY29uZmlnLmNoYXJ0LmJhY2tncm91bmQgPT09ICd0cmFuc3BhcmVudCcgPyAnI2ZmZicgOiB3LmNvbmZpZy5jaGFydC5iYWNrZ3JvdW5kO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjYW52YXNCZztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHZhciBET01VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXG4gICAgICAgIHZhciBzdmdEYXRhID0gX3RoaXMuZ2V0U3ZnU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIHN2Z1VybCA9ICdkYXRhOmltYWdlL3N2Zyt4bWwsJyArIGVuY29kZVVSSUNvbXBvbmVudChzdmdEYXRhKTtcblxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICBET01VUkwucmV2b2tlT2JqZWN0VVJMKHN2Z1VybCk7XG4gICAgICAgICAgdmFyIGltZ1VSSSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgIHJlc29sdmUoaW1nVVJJKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpbWcuc3JjID0gc3ZnVXJsO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4cG9ydFRvU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFRvU1ZHKCkge1xuICAgICAgdGhpcy50cmlnZ2VyRG93bmxvYWQodGhpcy5zdmdVcmwoKSwgJy5zdmcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0VG9QbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0VG9QbmcoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5kYXRhVVJJKCkudGhlbihmdW5jdGlvbiAoaW1nVVJJKSB7XG4gICAgICAgIF90aGlzMi50cmlnZ2VyRG93bmxvYWQoaW1nVVJJLCAnLnBuZycpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyaWdnZXJEb3dubG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyRG93bmxvYWQoaHJlZiwgZXh0KSB7XG4gICAgICB2YXIgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSBocmVmO1xuICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gdGhpcy53Lmdsb2JhbHMuY2hhcnRJRCArIGV4dDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHBvcnRzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgR3JpZCBDbGFzcyBmb3IgZHJhd2luZyBDYXJ0ZXNpYW4gR3JpZC5cbiAqXG4gKiBAbW9kdWxlIEdyaWRcbiAqKi9cblxudmFyIEdyaWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcmlkKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltYXRpb25zKHRoaXMuY3R4KTtcbiAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpO1xuICAgIHRoaXMuYW5pbVggPSB3LmNvbmZpZy5ncmlkLnhheGlzLmxpbmVzLmFuaW1hdGUgJiYgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgIHRoaXMuYW5pbVkgPSB3LmNvbmZpZy5ncmlkLnlheGlzLmxpbmVzLmFuaW1hdGUgJiYgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuXG4gICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyAgdGltZWxpbmUgbGFiZWxzIGFyZSB0aGVyZVxuICAgICAgdGhpcy54YXhpc0xhYmVscyA9IHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5zbGljZSgpO1xuICAgIH1cbiAgfSAvLyAud2hlbiB1c2luZyBzcGFya2xpbmVzIG9yIHdoZW4gc2hvd2luZyBubyBncmlkLCB3ZSBuZWVkIHRvIGhhdmUgYSBncmlkIGFyZWEgd2hpY2ggaXMgcmV1c2VkIGF0IG1hbnkgcGxhY2VzIGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYXMgd2VsbFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEdyaWQsIFt7XG4gICAga2V5OiBcImRyYXdHcmlkQXJlYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JpZEFyZWEoKSB7XG4gICAgICB2YXIgZWxHcmlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuXG4gICAgICBpZiAoZWxHcmlkID09PSBudWxsKSB7XG4gICAgICAgIGVsR3JpZCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZ3JpZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsLCAxLCB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsICd0cmFuc3BhcmVudCcpO1xuICAgICAgdmFyIGVsSG9yekxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCwgdy5nbG9iYWxzLmdyaWRIZWlnaHQsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0LCAndHJhbnNwYXJlbnQnKTtcbiAgICAgIGVsR3JpZC5hZGQoZWxIb3J6TGluZSk7XG4gICAgICBlbEdyaWQuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgIHJldHVybiBlbEdyaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdHcmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgZWxncmlkID0gbnVsbDtcblxuICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQuc2hvdykge1xuICAgICAgICAgIC8vIGdyaWQgaXMgZHJhd24gYWZ0ZXIgeGF4aXMgYW5kIHlheGlzIGFyZSBkcmF3blxuICAgICAgICAgIGVsZ3JpZCA9IHRoaXMucmVuZGVyR3JpZCgpO1xuICAgICAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxncmlkLmVsKTtcbiAgICAgICAgICB0aGlzLmRyYXdHcmlkQXJlYShlbGdyaWQuZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGdyaWRBcmVhID0gdGhpcy5kcmF3R3JpZEFyZWEoKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsZ3JpZEFyZWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZ3JpZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHhBeGlzLnhBeGlzTGFiZWxDb3JyZWN0aW9ucyhlbGdyaWQueEF4aXNUaWNrV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIG1hc2sgd2lsbCBjbGlwIG9mZiBvdmVyZmxvd2luZyBncmFwaGljcyBmcm9tIHRoZSBkcmF3YWJsZSBhcmVhXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVHcmlkTWFza1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVHcmlkTWFzaygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBzdHJva2VTaXplID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gMCA6IHcuY29uZmlnLnN0cm9rZS53aWR0aDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSkge1xuICAgICAgICB2YXIgc3Ryb2tlTWF4U2l6ZSA9IDA7XG4gICAgICAgIHcuY29uZmlnLnN0cm9rZS53aWR0aC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgc3Ryb2tlTWF4U2l6ZSA9IE1hdGgubWF4KHN0cm9rZU1heFNpemUsIG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Ryb2tlU2l6ZSA9IHN0cm9rZU1heFNpemU7XG4gICAgICB9XG5cbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhnbC5TVkdOUywgJ2NsaXBQYXRoJyk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2suc2V0QXR0cmlidXRlKCdpZCcsIFwiZ3JpZFJlY3RNYXNrXCIuY29uY2F0KGdsLmN1aWQpKTtcbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyTWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhnbC5TVkdOUywgJ2NsaXBQYXRoJyk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hcmtlck1hc2suc2V0QXR0cmlidXRlKCdpZCcsIFwiZ3JpZFJlY3RNYXJrZXJNYXNrXCIuY29uY2F0KGdsLmN1aWQpKTtcbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoLXN0cm9rZVNpemUgLyAyLCAtc3Ryb2tlU2l6ZSAvIDIsIGdsLmdyaWRXaWR0aCArIHN0cm9rZVNpemUsIGdsLmdyaWRIZWlnaHQgKyBzdHJva2VTaXplLCAwLCAnI2ZmZicpO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcyk7XG4gICAgICBjb3JlVXRpbHMuZ2V0TGFyZ2VzdE1hcmtlclNpemUoKTtcbiAgICAgIHZhciBtYXJrZXJTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMubGFyZ2VzdFNpemUgKyB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemVPZmZzZXQgKyAxO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXIgPSBncmFwaGljcy5kcmF3UmVjdCgtbWFya2VyU2l6ZSwgLW1hcmtlclNpemUsIGdsLmdyaWRXaWR0aCArIG1hcmtlclNpemUgKiAyLCBnbC5ncmlkSGVpZ2h0ICsgbWFya2VyU2l6ZSAqIDIsIDAsICcjZmZmJyk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2suYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3Qubm9kZSk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hcmtlck1hc2suYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXIubm9kZSk7XG4gICAgICB2YXIgZGVmcyA9IGdsLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignZGVmcycpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChnbC5kb20uZWxHcmlkUmVjdE1hc2spO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChnbC5kb20uZWxHcmlkUmVjdE1hcmtlck1hc2spO1xuICAgIH0gLy8gYWN0dWFsIGdyaWQgcmVuZGVyaW5nXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJHcmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckdyaWQoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gdy5jb25maWcuZ3JpZC5zdHJva2VEYXNoQXJyYXk7XG4gICAgICB2YXIgZWxnID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZ3JpZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSA4O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMueUF4aXNTY2FsZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aWNrQW1vdW50ID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbaV0ucmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlja0Ftb3VudCA+IDIpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgeENvdW50O1xuICAgICAgdmFyIGludmVyc2VkR3JpZCA9ICEhKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInKTtcblxuICAgICAgaWYgKCFpbnZlcnNlZEdyaWQpIHtcbiAgICAgICAgeENvdW50ID0gdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7IC8vIGRyYXcgdmVydGljYWwgbGluZXNcblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93IHx8IHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgICAgdmFyIHgxID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG4gICAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgICB2YXIgeDI7XG4gICAgICAgICAgdmFyIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB4Q291bnQ7IF9pKyspIHtcbiAgICAgICAgICAgICAgeDEgPSB0aGlzLnhheGlzTGFiZWxzW19pXS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgeDIgPSB0aGlzLnhheGlzTGFiZWxzW19pXS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93ICYmIHgxID4gMCAmJiB4MSA8IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyLCB3LmNvbmZpZy5ncmlkLmJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuICAgICAgICAgICAgICAgIGxpbmUubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRsaW5lJyk7XG4gICAgICAgICAgICAgICAgZWxnLmFkZChsaW5lKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1YKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKGxpbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyOiAwXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHgyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgeEF4aXMgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuICAgICAgICAgICAgICB4QXhpcy5kcmF3WGF4aXNUaWNrcyh4MSwgZWxnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzID0geENvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0czsgX2kyKyspIHtcbiAgICAgICAgICAgICAgdmFyIHgxQ291bnQgPSB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cztcblxuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2JhcicpIHtcbiAgICAgICAgICAgICAgICB4MUNvdW50IC09IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHgxQ291bnQ7XG4gICAgICAgICAgICAgIHgyID0geDE7IC8vIHNraXAgdGhlIGxhc3QgbGluZVxuXG4gICAgICAgICAgICAgIGlmIChfaTIgPT09IHgxQ291bnQgLSAxKSBicmVhaztcblxuICAgICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9saW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUoeDEsIHkxLCB4MiwgeTIsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgICAgICBfbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZGxpbmUnKTtcblxuICAgICAgICAgICAgICAgIGVsZy5hZGQoX2xpbmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbVgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUxpbmUoX2xpbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyOiAwXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHgyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX3hBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcblxuICAgICAgICAgICAgICBfeEF4aXMuZHJhd1hheGlzVGlja3MoeDEsIGVsZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueWF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgIHZhciBfeCA9IDA7XG4gICAgICAgICAgdmFyIF95ID0gMDtcbiAgICAgICAgICB2YXIgX3kyID0gMDtcbiAgICAgICAgICB2YXIgX3gyID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHRpY2tBbW91bnQgKyAxOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIF9saW5lMiA9IGdyYXBoaWNzLmRyYXdMaW5lKF94LCBfeSwgX3gyLCBfeTIsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgIGVsZy5hZGQoX2xpbmUyKTtcblxuICAgICAgICAgICAgX2xpbmUyLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmltWSkge1xuICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKF9saW5lMiwge1xuICAgICAgICAgICAgICAgIHkxOiBfeSArIDIwLFxuICAgICAgICAgICAgICAgIHkyOiBfeTIgKyAyMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeTE6IF95LFxuICAgICAgICAgICAgICAgIHkyOiBfeTJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF95ID0gX3kgKyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgICAgICBfeTIgPSBfeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhDb3VudCA9IHRpY2tBbW91bnQ7IC8vIGRyYXcgdmVydGljYWwgbGluZXNcblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93IHx8IHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgICAgdmFyIF94MyA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgICAgIHZhciBfeTMgPSAwO1xuXG4gICAgICAgICAgdmFyIF94NDtcblxuICAgICAgICAgIHZhciBfeTQgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHhDb3VudCArIDE7IF9pNCsrKSB7XG4gICAgICAgICAgICBfeDMgPSBfeDMgKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50ICsgMC4zO1xuICAgICAgICAgICAgX3g0ID0gX3gzOyAvLyBza2lwIHRoZSBsYXN0IHZlcnRpY2FsIGxpbmVcblxuICAgICAgICAgICAgaWYgKF9pNCA9PT0geENvdW50IC0gMSkgYnJlYWs7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnhheGlzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICAgICAgdmFyIF9saW5lMyA9IGdyYXBoaWNzLmRyYXdMaW5lKF94MywgX3kzLCBfeDQsIF95NCwgdy5jb25maWcuZ3JpZC5ib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcblxuICAgICAgICAgICAgICBfbGluZTMubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRsaW5lJyk7XG5cbiAgICAgICAgICAgICAgZWxnLmFkZChfbGluZTMpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1YKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlTGluZShfbGluZTMsIHtcbiAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgeDI6IDBcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICB4MTogX3gzLFxuICAgICAgICAgICAgICAgICAgeDI6IF94NFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHNraXAgdGhlIGZpcnN0IHZlcnRpY2FsIGxpbmVcblxuXG4gICAgICAgICAgICB2YXIgX3hBeGlzMiA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgIF94QXhpczIuZHJhd1hheGlzVGlja3MoX3gzLCBlbGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBkcmF3IGhvcml6b250YWwgbGluZXNcblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnlheGlzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICB2YXIgX3g1ID0gMDtcbiAgICAgICAgICB2YXIgX3k1ID0gMDtcbiAgICAgICAgICB2YXIgX3k2ID0gMDtcbiAgICAgICAgICB2YXIgX3g2ID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHcuZ2xvYmFscy5kYXRhUG9pbnRzICsgMTsgX2k1KyspIHtcbiAgICAgICAgICAgIHZhciBfbGluZTQgPSBncmFwaGljcy5kcmF3TGluZShfeDUsIF95NSwgX3g2LCBfeTYsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgIGVsZy5hZGQoX2xpbmU0KTtcblxuICAgICAgICAgICAgX2xpbmU0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmltWSkge1xuICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKF9saW5lNCwge1xuICAgICAgICAgICAgICAgIHkxOiBfeTUgKyAyMCxcbiAgICAgICAgICAgICAgICB5MjogX3k2ICsgMjBcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHkxOiBfeTUsXG4gICAgICAgICAgICAgICAgeTI6IF95NlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3k1ID0gX3k1ICsgdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgICAgICAgIF95NiA9IF95NTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3R3JpZEJhbmRzKGVsZywgeENvdW50LCB0aWNrQW1vdW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsOiBlbGcsXG4gICAgICAgIHhBeGlzVGlja1dpZHRoOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3R3JpZEJhbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkQmFuZHMoZWxnLCB4Q291bnQsIHRpY2tBbW91bnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTsgLy8gcm93cyBiYWNrZ3JvdW5kIGJhbmRzXG5cbiAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgeDEgPSAwO1xuICAgICAgICB2YXIgeTEgPSAwO1xuICAgICAgICB2YXIgeTIgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgIHZhciB4MiA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMgPSAwOyBpIDwgdGlja0Ftb3VudDsgaSsrLCBjKyspIHtcbiAgICAgICAgICBpZiAoYyA+PSB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSB3LmNvbmZpZy5ncmlkLnJvdy5jb2xvcnNbY107XG4gICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCh4MSwgeTEsIHgyLCB5MiwgMCwgY29sb3IsIHcuY29uZmlnLmdyaWQucm93Lm9wYWNpdHkpO1xuICAgICAgICAgIGVsZy5hZGQocmVjdCk7XG4gICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZFJvdycpO1xuICAgICAgICAgIHkxID0geTEgKyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHRpY2tBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29sdW1ucyBiYWNrZ3JvdW5kIGJhbmRzXG5cblxuICAgICAgaWYgKHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfeDcgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcbiAgICAgICAgdmFyIF95NyA9IDA7XG5cbiAgICAgICAgdmFyIF94OCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudDtcblxuICAgICAgICB2YXIgX3k4ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX2MgPSAwOyBfaTYgPCB4Q291bnQ7IF9pNisrLCBfYysrKSB7XG4gICAgICAgICAgaWYgKF9jID49IHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIF9jID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2NvbG9yID0gdy5jb25maWcuZ3JpZC5jb2x1bW4uY29sb3JzW19jXTtcblxuICAgICAgICAgIHZhciBfcmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KF94NywgX3k3LCBfeDgsIF95OCwgMCwgX2NvbG9yLCB3LmNvbmZpZy5ncmlkLmNvbHVtbi5vcGFjaXR5KTtcblxuICAgICAgICAgIF9yZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkQ29sdW1uJyk7XG5cbiAgICAgICAgICBlbGcuYWRkKF9yZWN0KTtcbiAgICAgICAgICBfeDcgPSBfeDcgKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8geENvdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVMaW5lKGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBpbml0aWFsQW5pbSA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnM7XG5cbiAgICAgIGlmIChpbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgc3BlZWQgPSBpbml0aWFsQW5pbS5zcGVlZDtcbiAgICAgICAgdGhpcy5hbmltLmFuaW1hdGVMaW5lKGxpbmUsIGZyb20sIHRvLCBzcGVlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyaWQ7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBMZWdlbmQgQ2xhc3MgdG8gZHJhdyBsZWdlbmQuXG4gKlxuICogQG1vZHVsZSBMZWdlbmRcbiAqKi9cblxudmFyIExlZ2VuZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExlZ2VuZChjdHgsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVnZW5kKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMub25MZWdlbmRDbGljayA9IHRoaXMub25MZWdlbmRDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25MZWdlbmRIb3ZlcmVkID0gdGhpcy5vbkxlZ2VuZEhvdmVyZWQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZWdlbmQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIHNob3dMZWdlbmRBbHdheXMgPSBjbmYubGVnZW5kLnNob3dGb3JTaW5nbGVTZXJpZXMgJiYgZ2wuc2VyaWVzLmxlbmd0aCA9PT0gMSB8fCBnbC5zZXJpZXMubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKChzaG93TGVnZW5kQWx3YXlzIHx8ICFnbC5heGlzQ2hhcnRzKSAmJiBjbmYubGVnZW5kLnNob3cpIHtcbiAgICAgICAgd2hpbGUgKGdsLmRvbS5lbExlZ2VuZFdyYXAuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAucmVtb3ZlQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0xlZ2VuZHMoKTtcblxuICAgICAgICBpZiAoIVV0aWxzLmlzSUUxMSgpKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb0ZvcmVpZ25PYmplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydHMgZm9yZWlnbk9iamVjdCwgaGVuY2UgYXBwZW5kIGl0IHRvIDxoZWFkPlxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQodGhpcy5nZXRMZWdlbmRTdHlsZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZEFsaWduSG9yaXpvbnRhbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcgfHwgY25mLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRBbGlnblZlcnRpY2FsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVG9Gb3JlaWduT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRvRm9yZWlnbk9iamVjdCgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGVsRm9yZWlnbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhnbC5TVkdOUywgJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZ2wuc3ZnV2lkdGgpO1xuICAgICAgZWxGb3JlaWduLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgZ2wuc3ZnSGVpZ2h0KTtcbiAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyk7XG4gICAgICBlbEZvcmVpZ24uYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcCk7XG4gICAgICBlbEZvcmVpZ24uYXBwZW5kQ2hpbGQodGhpcy5nZXRMZWdlbmRTdHlsZXMoKSk7XG4gICAgICBnbC5kb20uUGFwZXIubm9kZS5pbnNlcnRCZWZvcmUoZWxGb3JlaWduLCBnbC5kb20uZWxHcmFwaGljYWwubm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMZWdlbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMZWdlbmRzKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHcuY29uZmlnLmxlZ2VuZC5mb250RmFtaWx5O1xuICAgICAgdmFyIGxlZ2VuZE5hbWVzID0gdy5nbG9iYWxzLnNlcmllc05hbWVzO1xuICAgICAgdmFyIGZpbGxjb2xvciA9IHcuZ2xvYmFscy5jb2xvcnMuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5jb2xvclNjYWxlLnJhbmdlcztcbiAgICAgICAgbGVnZW5kTmFtZXMgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChjb2xvclNjYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yU2NhbGUubmFtZSA/IGNvbG9yU2NhbGUubmFtZSA6IGNvbG9yU2NhbGUuZnJvbSArICcgLSAnICsgY29sb3JTY2FsZS50bztcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGxjb2xvciA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yLmNvbG9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZ2VuZEZvcm1hdHRlciA9IHcuZ2xvYmFscy5sZWdlbmRGb3JtYXR0ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxlZ2VuZE5hbWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IGxlZ2VuZEZvcm1hdHRlcihsZWdlbmROYW1lc1tpXSwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb2xsYXBzZWRTZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzW2NdLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgIGNvbGxhcHNlZFNlcmllcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXNbX2NdID09PSBpKSB7XG4gICAgICAgICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsTWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBlbE1hcmtlci5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKTtcbiAgICAgICAgdmFyIG1PZmZzZXRYID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMub2Zmc2V0WDtcbiAgICAgICAgdmFyIG1PZmZzZXRZID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMub2Zmc2V0WTtcbiAgICAgICAgdmFyIG1IZWlnaHQgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5oZWlnaHQ7XG4gICAgICAgIHZhciBtV2lkdGggPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy53aWR0aDtcbiAgICAgICAgdmFyIG1Cb3JkZXJXaWR0aCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLnN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgbUJvcmRlckNvbG9yID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuc3Ryb2tlQ29sb3I7XG4gICAgICAgIHZhciBtQm9yZGVyUmFkaXVzID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMucmFkaXVzO1xuICAgICAgICB2YXIgbVN0eWxlID0gZWxNYXJrZXIuc3R5bGU7XG4gICAgICAgIG1TdHlsZS5iYWNrZ3JvdW5kID0gZmlsbGNvbG9yW2ldO1xuICAgICAgICBtU3R5bGUuY29sb3IgPSBmaWxsY29sb3JbaV07XG4gICAgICAgIG1TdHlsZS5oZWlnaHQgPSBBcnJheS5pc0FycmF5KG1IZWlnaHQpID8gcGFyc2VGbG9hdChtSGVpZ2h0W2ldKSArICdweCcgOiBwYXJzZUZsb2F0KG1IZWlnaHQpICsgJ3B4JztcbiAgICAgICAgbVN0eWxlLndpZHRoID0gQXJyYXkuaXNBcnJheShtV2lkdGgpID8gcGFyc2VGbG9hdChtV2lkdGhbaV0pICsgJ3B4JyA6IHBhcnNlRmxvYXQobVdpZHRoKSArICdweCc7XG4gICAgICAgIG1TdHlsZS5sZWZ0ID0gQXJyYXkuaXNBcnJheShtT2Zmc2V0WCkgPyBtT2Zmc2V0WFtpXSA6IG1PZmZzZXRYO1xuICAgICAgICBtU3R5bGUudG9wID0gQXJyYXkuaXNBcnJheShtT2Zmc2V0WSkgPyBtT2Zmc2V0WVtpXSA6IG1PZmZzZXRZO1xuICAgICAgICBtU3R5bGUuYm9yZGVyV2lkdGggPSBBcnJheS5pc0FycmF5KG1Cb3JkZXJXaWR0aCkgPyBtQm9yZGVyV2lkdGhbaV0gOiBtQm9yZGVyV2lkdGg7XG4gICAgICAgIG1TdHlsZS5ib3JkZXJDb2xvciA9IEFycmF5LmlzQXJyYXkobUJvcmRlckNvbG9yKSA/IG1Cb3JkZXJDb2xvcltpXSA6IG1Cb3JkZXJDb2xvcjtcbiAgICAgICAgbVN0eWxlLmJvcmRlclJhZGl1cyA9IEFycmF5LmlzQXJyYXkobUJvcmRlclJhZGl1cykgPyBwYXJzZUZsb2F0KG1Cb3JkZXJSYWRpdXNbaV0pICsgJ3B4JyA6IHBhcnNlRmxvYXQobUJvcmRlclJhZGl1cykgKyAncHgnO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5jdXN0b21IVE1MKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCkpIHtcbiAgICAgICAgICAgIGVsTWFya2VyLmlubmVySFRNTCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUxbaV0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxNYXJrZXIuaW5uZXJIVE1MID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsTWFya2VyLCB7XG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpjb2xsYXBzZWQnOiBjb2xsYXBzZWRTZXJpZXMgfHwgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb2xsYXBzZWRTZXJpZXMgfHwgYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzKSB7XG4gICAgICAgICAgZWxNYXJrZXIuY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUtbGVnZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxMZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGVsTGVnZW5kVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZWxMZWdlbmRUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKTtcbiAgICAgICAgZWxMZWdlbmRUZXh0LmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIHZhciB0ZXh0Q29sb3IgPSB3LmNvbmZpZy5sZWdlbmQubGFiZWxzLnVzZVNlcmllc0NvbG9ycyA/IHcuZ2xvYmFscy5jb2xvcnNbaV0gOiB3LmNvbmZpZy5sZWdlbmQubGFiZWxzLmNvbG9ycztcblxuICAgICAgICBpZiAoIXRleHRDb2xvcikge1xuICAgICAgICAgIHRleHRDb2xvciA9IHcuY29uZmlnLmNoYXJ0LmZvcmVDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcbiAgICAgICAgZWxMZWdlbmRUZXh0LnN0eWxlLmZvbnRTaXplID0gcGFyc2VGbG9hdCh3LmNvbmZpZy5sZWdlbmQuZm9udFNpemUpICsgJ3B4JztcbiAgICAgICAgZWxMZWdlbmRUZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsTGVnZW5kVGV4dCwge1xuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxMZWdlbmQuYXBwZW5kQ2hpbGQoZWxNYXJrZXIpO1xuICAgICAgICBlbExlZ2VuZC5hcHBlbmRDaGlsZChlbExlZ2VuZFRleHQpO1xuICAgICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQuc2hvd0Zvclplcm9TZXJpZXMpIHtcbiAgICAgICAgICB2YXIgdG90YWwgPSBjb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxCeUluZGV4KGkpO1xuXG4gICAgICAgICAgaWYgKHRvdGFsID09PSAwICYmIGNvcmVVdGlscy5zZXJpZXNIYXZlU2FtZVZhbHVlcyhpKSAmJiAhY29yZVV0aWxzLmlzU2VyaWVzTnVsbChpKSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1oaWRkZW4temVyby1zZXJpZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuY29uZmlnLmxlZ2VuZC5zaG93Rm9yTnVsbFNlcmllcykge1xuICAgICAgICAgIGlmIChjb3JlVXRpbHMuaXNTZXJpZXNOdWxsKGkpICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPT09IC0xICYmIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGRlbi1udWxsLXNlcmllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmFwcGVuZENoaWxkKGVsTGVnZW5kKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCh3LmNvbmZpZy5sZWdlbmQuaG9yaXpvbnRhbEFsaWduKTsgLy8gdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCh3LmNvbmZpZy5sZWdlbmQudmVydGljYWxBbGlnbilcblxuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcC5jbGFzc0xpc3QuYWRkKCdwb3NpdGlvbi0nICsgdy5jb25maWcubGVnZW5kLnBvc2l0aW9uKTtcbiAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzJyk7XG4gICAgICAgIGVsTGVnZW5kLnN0eWxlLm1hcmdpbiA9IFwiXCIuY29uY2F0KHcuY29uZmlnLmxlZ2VuZC5pdGVtTWFyZ2luLmhvcml6b250YWwsIFwicHggXCIpLmNvbmNhdCh3LmNvbmZpZy5sZWdlbmQuaXRlbU1hcmdpbi52ZXJ0aWNhbCwgXCJweFwiKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuc3R5bGUud2lkdGggPSB3LmNvbmZpZy5sZWdlbmQud2lkdGggPyB3LmNvbmZpZy5sZWdlbmQud2lkdGggKyAncHgnIDogJyc7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCA9IHcuY29uZmlnLmxlZ2VuZC5oZWlnaHQgPyB3LmNvbmZpZy5sZWdlbmQuaGVpZ2h0ICsgJ3B4JyA6ICcnO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbExlZ2VuZCwge1xuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcykge1xuICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlLWxlZ2VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQub25JdGVtQ2xpY2sudG9nZ2xlRGF0YVNlcmllcykge1xuICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ25vLWNsaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG5vdyAtIGp1c3QgcHJldmVudCBjbGljayBvbiBoZWF0bWFwIGxlZ2VuZCAtIGFuZCBhbGxvdyBob3ZlciBvbmx5XG5cblxuICAgICAgdmFyIGNsaWNrQWxsb3dlZCA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdoZWF0bWFwJztcblxuICAgICAgaWYgKGNsaWNrQWxsb3dlZCAmJiB3LmNvbmZpZy5sZWdlbmQub25JdGVtQ2xpY2sudG9nZ2xlRGF0YVNlcmllcykge1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNlbGYub25MZWdlbmRDbGljaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQub25JdGVtSG92ZXIuaGlnaGxpZ2h0RGF0YVNlcmllcykge1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZWxmLm9uTGVnZW5kSG92ZXJlZCwgdHJ1ZSk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxXcmFwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgc2VsZi5vbkxlZ2VuZEhvdmVyZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZWdlbmRCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlZ2VuZEJCb3goKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1sZWdlbmQnKTtcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBSZWN0ID0gY3VyckxlZ2VuZHNXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGN1cnJMZWdlbmRzV3JhcFdpZHRoID0gY3VyckxlZ2VuZHNXcmFwUmVjdC53aWR0aDtcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBIZWlnaHQgPSBjdXJyTGVnZW5kc1dyYXBSZWN0LmhlaWdodDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsd2g6IGN1cnJMZWdlbmRzV3JhcEhlaWdodCxcbiAgICAgICAgY2x3dzogY3VyckxlZ2VuZHNXcmFwV2lkdGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExlZ2VuZFdyYXBYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZWdlbmRXcmFwWFkob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxMZWdlbmRXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICB2YXIgbGVnZW5kUmVjdCA9IGVsTGVnZW5kV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSA9IHkgKyAody5nbG9iYWxzLnN2Z0hlaWdodCAtIGxlZ2VuZFJlY3QuaGVpZ2h0IC8gMik7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdmFyIGRpbSA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHRpdGxlSCA9IGRpbS5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCd0aXRsZScpLmhlaWdodDtcbiAgICAgICAgdmFyIHN1YnRpdGxlSCA9IGRpbS5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpLmhlaWdodDtcbiAgICAgICAgeSA9IHkgKyAodGl0bGVIID4gMCA/IHRpdGxlSCAtIDEwIDogMCkgKyAoc3VidGl0bGVIID4gMCA/IHN1YnRpdGxlSCAtIDEwIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB4ID0geCArIG9mZnNldFggKyB3LmNvbmZpZy5sZWdlbmQub2Zmc2V0WDtcbiAgICAgIHkgPSB5ICsgb2Zmc2V0WSArIHcuY29uZmlnLmxlZ2VuZC5vZmZzZXRZO1xuICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmJvdHRvbSA9IDEwICsgdy5jb25maWcubGVnZW5kLm9mZnNldFkgKyAncHgnO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5yaWdodCA9IDI1ICsgdy5jb25maWcubGVnZW5kLm9mZnNldFggKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMZWdlbmRXcmFwLnN0eWxlLndpZHRoKSB7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS53aWR0aCA9IHBhcnNlSW50KHcuY29uZmlnLmxlZ2VuZC53aWR0aCkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCkge1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUuaGVpZ2h0ID0gcGFyc2VJbnQody5jb25maWcubGVnZW5kLmhlaWdodCkgKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWdlbmRBbGlnbkhvcml6b250YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVnZW5kQWxpZ25Ib3Jpem9udGFsKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxMZWdlbmRXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICBlbExlZ2VuZFdyYXAuc3R5bGUucmlnaHQgPSAwO1xuICAgICAgdmFyIGxSZWN0ID0gdGhpcy5nZXRMZWdlbmRCQm94KCk7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHRoaXMuY3R4KTtcbiAgICAgIHZhciB0aXRsZVJlY3QgPSBkaW1lbnNpb25zLmdldFRpdGxlU3VidGl0bGVDb29yZHMoJ3RpdGxlJyk7XG4gICAgICB2YXIgc3VidGl0bGVSZWN0ID0gZGltZW5zaW9ucy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCdzdWJ0aXRsZScpO1xuICAgICAgdmFyIG9mZnNldFggPSAyMDtcbiAgICAgIHZhciBvZmZzZXRZID0gMDsgLy8gdGhlIHdob2xlIGxlZ2VuZCBib3ggaXMgc2V0IHRvIGJvdHRvbVxuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICBvZmZzZXRZID0gLWxSZWN0LmNsd2ggLyAxLjg7XG4gICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgb2Zmc2V0WSA9IHRpdGxlUmVjdC5oZWlnaHQgKyBzdWJ0aXRsZVJlY3QuaGVpZ2h0ICsgdy5jb25maWcudGl0bGUubWFyZ2luICsgdy5jb25maWcuc3VidGl0bGUubWFyZ2luIC0gMTU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0TGVnZW5kV3JhcFhZKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWdlbmRBbGlnblZlcnRpY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlZ2VuZEFsaWduVmVydGljYWwoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBsUmVjdCA9IHRoaXMuZ2V0TGVnZW5kQkJveCgpO1xuICAgICAgdmFyIG9mZnNldFkgPSAyMDtcbiAgICAgIHZhciBvZmZzZXRYID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIG9mZnNldFggPSAyMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBvZmZzZXRYID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC0gbFJlY3QuY2x3dyAtIDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldExlZ2VuZFdyYXBYWShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWdlbmRIb3ZlcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGVnZW5kSG92ZXJlZChlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBob3Zlck92ZXJMZWdlbmQgPSBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKSB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLW1hcmtlcicpO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgIGlmICghZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbmFjdGl2ZS1sZWdlbmQnKSAmJiBob3Zlck92ZXJMZWdlbmQpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICAgICAgc2VyaWVzLnRvZ2dsZVNlcmllc09uSG92ZXIoZSwgZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgaGVhdG1hcCBoYW5kbGluZ1xuICAgICAgICBpZiAoaG92ZXJPdmVyTGVnZW5kKSB7XG4gICAgICAgICAgdmFyIHNlcmllc0NudCA9IHBhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2xlZ2VuZEhvdmVyJywgW3RoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMud10pO1xuXG4gICAgICAgICAgdmFyIF9zZXJpZXMgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcblxuICAgICAgICAgIF9zZXJpZXMuaGlnaGxpZ2h0UmFuZ2VJblNlcmllcyhlLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWdlbmRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlZ2VuZENsaWNrKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLXRleHQnKSB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLW1hcmtlcicpKSB7XG4gICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YTpjb2xsYXBzZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgICB2YXIgbGVnZW5kQ2xpY2sgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5sZWdlbmRDbGljaztcblxuICAgICAgICBpZiAodHlwZW9mIGxlZ2VuZENsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGVnZW5kQ2xpY2sodGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnbGVnZW5kQ2xpY2snLCBbdGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53XSk7XG4gICAgICAgIHZhciBtYXJrZXJDbGljayA9IHRoaXMudy5jb25maWcubGVnZW5kLm1hcmtlcnMub25DbGljaztcblxuICAgICAgICBpZiAodHlwZW9mIG1hcmtlckNsaWNrID09PSAnZnVuY3Rpb24nICYmIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJykpIHtcbiAgICAgICAgICBtYXJrZXJDbGljayh0aGlzLmN0eCwgc2VyaWVzQ250LCB0aGlzLncpO1xuICAgICAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnbGVnZW5kTWFya2VyQ2xpY2snLCBbdGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvZ2dsZURhdGFTZXJpZXMoc2VyaWVzQ250LCBpc0hpZGRlbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExlZ2VuZFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWdlbmRTdHlsZXMoKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXNoZWV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgdmFyIHRleHQgPSBcIlxcbiAgICBcXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgcGFkZGluZzogMCAxMHB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tLCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tdG9wIHtcXG4gICAgICAgIGZsZXgtd3JhcDogd3JhcFxcbiAgICAgIH1cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tcmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1sZWZ0IHtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1ib3R0b20ubGVmdCwgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLXRvcC5sZWZ0LCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tcmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1sZWZ0IHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLWJvdHRvbS5jZW50ZXIsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AuY2VudGVyIHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyAgXFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1ib3R0b20ucmlnaHQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AucmlnaHQge1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllcyB7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AgLmFwZXhjaGFydHMtbGVnZW5kLXNlcmllc3tcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0ICosIC5hcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXIgKiB7XFxuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLW1hcmtlciB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnJpZ2h0IC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5sZWZ0IC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXN7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMubm8tY2xpY2sge1xcbiAgICAgICAgY3Vyc29yOiBhdXRvO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQgLmFwZXhjaGFydHMtaGlkZGVuLXplcm8tc2VyaWVzLCAuYXBleGNoYXJ0cy1sZWdlbmQgLmFwZXhjaGFydHMtaGlkZGVuLW51bGwtc2VyaWVzIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICB9XFxuXFxuICAgICAgLmluYWN0aXZlLWxlZ2VuZCB7XFxuICAgICAgICBvcGFjaXR5OiAwLjQ1O1xcbiAgICAgIH1cIjtcbiAgICAgIHZhciBydWxlcyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgc3R5bGVzaGVldC5hcHBlbmRDaGlsZChydWxlcyk7XG4gICAgICByZXR1cm4gc3R5bGVzaGVldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRUb2dnbGVEYXRhU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0VG9nZ2xlRGF0YVNlcmllcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNlcmllc0VscyA9IG51bGw7XG4gICAgICB2YXIgcmVhbEluZGV4ZXMgPSBbXTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4XVwiKTtcbiAgICAgICAgc2VyaWVzRWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZWFsSW5kZXhlcy5wdXNoKHBhcnNlSW50KHYuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWxdXCIpO1xuICAgICAgICBzZXJpZXNFbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJlYWxJbmRleGVzLnB1c2gocGFyc2VJbnQodi5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVhbEluZGV4ZXMuc29ydCgpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByaXNpbmdTZXJpZXMgPSB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLnNsaWNlKCk7XG4gICAgICAgIHZhciBzZXJpZXMgPSB3LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWFsSW5kZXhlcy5pbmRleE9mKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY10uaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICAgIHNlcmllc1tpbmRleF0uZGF0YSA9IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMuc2xpY2UoKVtjXS5kYXRhLnNsaWNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXJpZXNbaW5kZXhdID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5zbGljZSgpW2NdLmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJpc2luZ1Nlcmllcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1NlcmllcyA9IHJpc2luZ1NlcmllcztcbiAgICAgICAgdy5jb25maWcuc2VyaWVzID0gc2VyaWVzO1xuXG4gICAgICAgIHRoaXMuY3R4Ll91cGRhdGVTZXJpZXMody5jb25maWcuc2VyaWVzLCB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZURhdGFTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRGF0YVNlcmllcyhzZXJpZXNDbnQsIGlzSGlkZGVuKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgIHcuZ2xvYmFscy5yZXNpemVkID0gdHJ1ZTsgLy8gd2UgZG9uJ3Qgd2FudCBpbml0aWFsIGFuaW1hdGlvbnMgYWdhaW5cblxuICAgICAgICB2YXIgc2VyaWVzRWwgPSBudWxsO1xuICAgICAgICB2YXIgcmVhbEluZGV4ID0gbnVsbDsgLy8geWVzLCBtYWtlIGl0IG51bGwuIDEgc2VyaWVzIHdpbGwgcmlzZSBhdCBhIHRpbWVcblxuICAgICAgICB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzID0gW107XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0NudCwgXCInXVwiKSk7XG4gICAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc2VyaWVzRWwuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXVwiKSk7XG4gICAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc2VyaWVzRWwuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5yaXNlQ29sbGFwc2VkU2VyaWVzKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMsIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLCByZWFsSW5kZXgpO1xuICAgICAgICAgIHRoaXMucmlzZUNvbGxhcHNlZFNlcmllcyh3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzLCB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcywgcmVhbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGROb3RIaWRlWUF4aXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0gJiYgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5zaG93ICYmIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uc2hvd0Fsd2F5cykge1xuICAgICAgICAgICAgICBzaG91bGROb3RIaWRlWUF4aXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKHJlYWxJbmRleCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5wdXNoKHJlYWxJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzaG91bGROb3RIaWRlWUF4aXMpIHtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGEuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBzZXJpZXNFbC5wYXJlbnROb2RlLmNsYXNzTmFtZS5iYXNlVmFsLnNwbGl0KCctJylbMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4T2ZSaXNpbmcgPSB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLmluZGV4T2YocmVhbEluZGV4KTtcbiAgICAgICAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1Nlcmllcy5zcGxpY2UocmVtb3ZlSW5kZXhPZlJpc2luZywgMSk7XG4gICAgICAgICAgICB9IC8vIFRPRE86IEFWT0lEIG11dGF0aW5nIHRoZSB1c2VyJ3MgY29uZmlnIG9iamVjdCBiZWxvd1xuXG5cbiAgICAgICAgICAgIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdLmRhdGEgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgZGF0YTogdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzZXJpZXNDaGlsZHJlbiA9IHNlcmllc0VsLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBzYyA9IDA7IHNjIDwgc2VyaWVzQ2hpbGRyZW4ubGVuZ3RoOyBzYysrKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2Vycy13cmFwJykpIHtcbiAgICAgICAgICAgICAgaWYgKHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtaGlkZScpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzQ2hpbGRyZW5bc2NdLmNsYXNzTGlzdC5yZW1vdmUoJ2FwZXhjaGFydHMtaGlkZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWhpZGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA9PT0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgICAgICB0aGlzLmN0eC5fdXBkYXRlU2VyaWVzKHcuY29uZmlnLnNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3Igbm9uLWF4aXMgY2hhcnRzIGkuZSBwaWUgLyBkb251dHNcbiAgICAgICAgdmFyIF9zZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddIHBhdGhcIikpO1xuXG4gICAgICAgIF9zZXJpZXNFbC5maXJlKCdjbGljaycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyaXNlQ29sbGFwc2VkU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJpc2VDb2xsYXBzZWRTZXJpZXMoc2VyaWVzLCBzZXJpZXNJbmRpY2VzLCByZWFsSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzZXJpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBpZiAoc2VyaWVzW2NdLmluZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhID0gc2VyaWVzW2NdLmRhdGEuc2xpY2UoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNwbGljZShjLCAxKTtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kaWNlcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0gPSBzZXJpZXNbY10uZGF0YTtcbiAgICAgICAgICAgICAgc2VyaWVzLnNwbGljZShjLCAxKTtcbiAgICAgICAgICAgICAgc2VyaWVzSW5kaWNlcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN0eC5fdXBkYXRlU2VyaWVzKHcuY29uZmlnLnNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZWdlbmQ7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSZXNwb25zaXZlIENsYXNzIHRvIG92ZXJyaWRlIG9wdGlvbnMgZm9yIGRpZmZlcmVudCBzY3JlZW4gc2l6ZXMuXG4gKlxuICogQG1vZHVsZSBSZXNwb25zaXZlXG4gKiovXG5cbnZhciBSZXNwb25zaXZlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfSAvLyB0aGUgb3B0cyBwYXJhbWV0ZXIgaWYgbm90IG51bGwgaGFzIHRvIGJlIHNldCBvdmVycmlkaW5nIGV2ZXJ5dGhpbmdcbiAgLy8gYXMgdGhlIG9wdHMgaXMgc2V0IGJ5IHVzZXIgZXh0ZXJuYWxseVxuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmUsIFt7XG4gICAga2V5OiBcImNoZWNrUmVzcG9uc2l2ZUNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc3BvbnNpdmVDb25maWcob3B0cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7IC8vIGNoZWNrIGlmIHJlc3BvbnNpdmUgY29uZmlnIGV4aXN0c1xuXG4gICAgICBpZiAoY25mLnJlc3BvbnNpdmUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmVzID0gY25mLnJlc3BvbnNpdmUuc2xpY2UoKTtcbiAgICAgIHJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJyZWFrcG9pbnQgPiBiLmJyZWFrcG9pbnQgPyAxIDogYi5icmVha3BvaW50ID4gYS5icmVha3BvaW50ID8gLTEgOiAwO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBDb25maWcoe30pO1xuXG4gICAgICB2YXIgaXRlcmF0ZVJlc3BvbnNpdmVPcHRpb25zID0gZnVuY3Rpb24gaXRlcmF0ZVJlc3BvbnNpdmVPcHRpb25zKCkge1xuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBsYXJnZXN0QnJlYWtwb2ludCA9IHJlc1swXS5icmVha3BvaW50O1xuICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA+IDAgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHNjcmVlbi53aWR0aDtcblxuICAgICAgICBpZiAod2lkdGggPiBsYXJnZXN0QnJlYWtwb2ludCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gQ29yZVV0aWxzLmV4dGVuZEFycmF5UHJvcHMoY29uZmlnLCB3Lmdsb2JhbHMuaW5pdGlhbENvbmZpZyk7XG4gICAgICAgICAgbmV3T3B0aW9ucyA9IFV0aWxzLmV4dGVuZChvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICBuZXdPcHRpb25zID0gVXRpbHMuZXh0ZW5kKHcuY29uZmlnLCBuZXdPcHRpb25zKTtcblxuICAgICAgICAgIF90aGlzLm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IHJlc1tpXS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscy5leHRlbmQoY29uZmlnLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKG5ld09wdGlvbnMsIHJlc1tpXS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh3LmNvbmZpZywgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMub3ZlcnJpZGVSZXNwb25zaXZlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gQ29yZVV0aWxzLmV4dGVuZEFycmF5UHJvcHMoY29uZmlnLCBvcHRzKTtcbiAgICAgICAgb3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh3LmNvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBVdGlscy5leHRlbmQob3B0aW9ucywgb3B0cyk7XG4gICAgICAgIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyh7fSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGVSZXNwb25zaXZlT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgbmV3Q29uZmlnID0gbmV3IENvbmZpZyhuZXdPcHRpb25zKS5pbml0KCk7XG4gICAgICB0aGlzLncuY29uZmlnID0gbmV3Q29uZmlnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zaXZlO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVGhlbWUgQ2xhc3MgZm9yIHNldHRpbmcgdGhlIGNvbG9ycyBhbmQgcGFsZXR0ZXMuXG4gKlxuICogQG1vZHVsZSBUaGVtZVxuICoqL1xuXG52YXIgVGhlbWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaGVtZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaGVtZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERlZmF1bHRDb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxzKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gdGhpcy5wcmVkZWZpbmVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gdy5jb25maWcuY29sb3JzO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcudGhlbWUubW9ub2Nocm9tZS5lbmFibGVkKSB7XG4gICAgICAgIHZhciBtb25vQXJyID0gW107XG4gICAgICAgIHZhciBnbHNDbnQgPSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmRpc3RyaWJ1dGVkICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgZ2xzQ250ID0gdy5nbG9iYWxzLnNlcmllc1swXS5sZW5ndGggKiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYWluQ29sb3IgPSB3LmNvbmZpZy50aGVtZS5tb25vY2hyb21lLmNvbG9yO1xuICAgICAgICB2YXIgcGFydCA9IDEgLyAoZ2xzQ250IC8gdy5jb25maWcudGhlbWUubW9ub2Nocm9tZS5zaGFkZUludGVuc2l0eSk7XG4gICAgICAgIHZhciBzaGFkZSA9IHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuc2hhZGVUbztcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGdzbCA9IDA7IGdzbCA8IGdsc0NudDsgZ3NsKyspIHtcbiAgICAgICAgICB2YXIgbmV3Q29sb3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAoc2hhZGUgPT09ICdkYXJrJykge1xuICAgICAgICAgICAgbmV3Q29sb3IgPSB1dGlscy5zaGFkZUNvbG9yKHBlcmNlbnQgKiAtMSwgbWFpbkNvbG9yKTtcbiAgICAgICAgICAgIHBlcmNlbnQgPSBwZXJjZW50ICsgcGFydDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29sb3IgPSB1dGlscy5zaGFkZUNvbG9yKHBlcmNlbnQsIG1haW5Db2xvcik7XG4gICAgICAgICAgICBwZXJjZW50ID0gcGVyY2VudCArIHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9ub0Fyci5wdXNoKG5ld0NvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5jb2xvcnMgPSBtb25vQXJyLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWZhdWx0Q29sb3JzID0gdy5nbG9iYWxzLmNvbG9ycy5zbGljZSgpOyAvLyBpZiB1c2VyIHNwZWNmaWVkIGxlc3MgY29sb3JzIHRoYW4gbm8uIG9mIHNlcmllcywgcHVzaCB0aGUgc2FtZSBjb2xvcnMgYWdhaW5cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLmNvbG9ycyk7IC8vIFRoZSBCb3JkZXIgY29sb3JzXG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdHJva2UuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgPSB3LmNvbmZpZy5zdHJva2UuY29sb3JzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyk7IC8vIFRoZSBGSUxMIGNvbG9yc1xuXG4gICAgICBpZiAody5jb25maWcuZmlsbC5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMuZmlsbC5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLmZpbGwuY29sb3JzID0gdy5jb25maWcuZmlsbC5jb2xvcnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5maWxsLmNvbG9ycyk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycyA9IGRlZmF1bHRDb2xvcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzLCA1MCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucy5maWxsLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy5yYWRhclBvbHlnb25zLmZpbGwuY29sb3JzID0gWycjZmZmJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMucmFkYXJQb2x5Z29ucy5maWxsLmNvbG9ycyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGFyLnBvbHlnb25zLmZpbGwuY29sb3JzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHMucmFkYXJQb2x5Z29ucy5maWxsLmNvbG9ycywgMjApOyAvLyBUaGUgcG9pbnQgY29sb3JzXG5cbiAgICAgIGlmICh3LmNvbmZpZy5tYXJrZXJzLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy5tYXJrZXJzLmNvbG9ycyA9IGRlZmF1bHRDb2xvcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnMgPSB3LmNvbmZpZy5tYXJrZXJzLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLm1hcmtlcnMuY29sb3JzKTtcbiAgICB9IC8vIFdoZW4gdGhlIG51bWJlciBvZiBjb2xvcnMgcHJvdmlkZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2Ygc2VyaWVzLCB0aGlzIG1ldGhvZFxuICAgIC8vIHdpbGwgcHVzaCBzYW1lIGNvbG9ycyB0byB0aGUgbGlzdFxuICAgIC8vIHBhcmFtczpcbiAgICAvLyBkaXN0cmlidXRlZCBpcyBvbmx5IHZhbGlkIGZvciBkaXN0cmlidXRlZCBjb2x1bW4vYmFyIGNoYXJ0c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaEV4dHJhQ29sb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hFeHRyYUNvbG9ycyhjb2xvclNlcmllcywgbGVuZ3RoKSB7XG4gICAgICB2YXIgZGlzdHJpYnV0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggfHwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgIGlmIChkaXN0cmlidXRlZCA9PT0gbnVsbCkge1xuICAgICAgICBkaXN0cmlidXRlZCA9IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcgJiYgdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5jb2xvclNjYWxlLmludmVyc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXN0cmlidXRlZCkge1xuICAgICAgICBsZW4gPSB3Lmdsb2JhbHMuc2VyaWVzWzBdLmxlbmd0aCAqIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3JTZXJpZXMubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIHZhciBkaWZmID0gbGVuIC0gY29sb3JTZXJpZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgY29sb3JTZXJpZXMucHVzaChjb2xvclNlcmllc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkZWZpbmVkKCkge1xuICAgICAgdmFyIHBhbGV0dGUgPSB0aGlzLncuY29uZmlnLnRoZW1lLnBhbGV0dGU7IC8vIEQ2RTNGOCwgRkNFRkVGLCBEQ0UwRDksIEE1OTc4QiwgRUREREQ0LCBENkUzRjgsIEZFRjVFRlxuXG4gICAgICBzd2l0Y2ggKHBhbGV0dGUpIHtcbiAgICAgICAgY2FzZSAncGFsZXR0ZTEnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjMDA4RkZCJywgJyMwMEUzOTYnLCAnI0ZFQjAxOScsICcjRkY0NTYwJywgJyM3NzVERDAnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlMic6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMzZjUxYjUnLCAnIzAzYTlmNCcsICcjNGNhZjUwJywgJyNmOWNlMWQnLCAnI0ZGOTgwMCddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGUzJzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzMzYjJkZicsICcjNTQ2RTdBJywgJyNkNDUyNmUnLCAnIzEzZDhhYScsICcjQTU5NzhCJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTQnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjNTQ2RTdBJywgJyM0ZWNkYzQnLCAnI2M3ZjQ2NCcsICcjODFENEZBJywgJyNmZDZhNmEnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlNSc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMyYjkwOGYnLCAnI2Y5YTNhNCcsICcjOTBlZTdlJywgJyNmYTQ0NDMnLCAnIzY5ZDJlNyddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU2JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzQ0OUREMScsICcjRjg2NjI0JywgJyNFQTM1NDYnLCAnIzY2MkU5QicsICcjQzVEODZEJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTcnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjRDcyNjNEJywgJyMxQjk5OEInLCAnIzJFMjk0RScsICcjRjQ2MDM2JywgJyNFMkMwNDQnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlOCc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyM2NjJFOUInLCAnI0Y4NjYyNCcsICcjRjlDODBFJywgJyNFQTM1NDYnLCAnIzQzQkNDRCddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU5JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzVDNDc0MicsICcjQTU5NzhCJywgJyM4RDVCNEMnLCAnIzVBMkEyNycsICcjQzRCQkFGJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTEwJzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnI0EzMDBENicsICcjN0QwMkVCJywgJyM1NjUzRkUnLCAnIzI5ODNGRicsICcjMDBCMUYyJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzAwOEZGQicsICcjMDBFMzk2JywgJyNGRUIwMTknLCAnI0ZGNDU2MCcsICcjNzc1REQwJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbG9ycztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGhlbWU7XG59KCk7XG5cbnZhciBVdGlscyQxID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHModG9vbHRpcENvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuXG4gICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gICAgdGhpcy5jdHggPSB0b29sdGlwQ29udGV4dC5jdHg7XG4gIH1cbiAgLyoqXG4gICAqKiBXaGVuIGhvdmVyaW5nIG92ZXIgc2VyaWVzLCB5b3UgbmVlZCB0byBjYXB0dXJlIHdoaWNoIHNlcmllcyBpcyBiZWluZyBob3ZlcmVkIG9uLlxuICAgKiogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBib3RoIGNhcHR1cmVkc2VyaWVzIGluZGV4IGFzIHdlbGwgYXMgaW5uZXIgaW5kZXggb2YgdGhhdCBzZXJpZXNcbiAgICogQG1lbWJlcm9mIFV0aWxzXG4gICAqIEBwYXJhbSB7b2JqZWN0fVxuICAgKiAtIGhvdmVyQXJlYSA9IHRoZSByZWN0IG9uIHdoaWNoIHVzZXIgaG92ZXJzXG4gICAqIC0gZWxHcmlkID0gZGltZW5zaW9ucyBvZiB0aGUgaG92ZXIgcmVjdCAoaXQgY2FuIGJlIGRpZmZlcmVudCB0aGFuIGhvdmVyYXJlYSlcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVXRpbHMsIFt7XG4gICAga2V5OiBcImdldE5lYXJlc3RWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmVhcmVzdFZhbHVlcyhfcmVmKSB7XG4gICAgICB2YXIgaG92ZXJBcmVhID0gX3JlZi5ob3ZlckFyZWEsXG4gICAgICAgICAgZWxHcmlkID0gX3JlZi5lbEdyaWQsXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZLFxuICAgICAgICAgIGhhc0JhcnMgPSBfcmVmLmhhc0JhcnM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBob3ZlcldpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aDtcbiAgICAgIHZhciB4RGl2aXNvciA9IGhvdmVyV2lkdGggLyAody5nbG9iYWxzLmRhdGFQb2ludHMgLSAxKTtcbiAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGhhc0JhcnMgJiYgdy5nbG9iYWxzLmNvbWJvQ2hhcnRzIHx8IGhhc0JhcnMpIHtcbiAgICAgICAgeERpdmlzb3IgPSBob3ZlcldpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBob3ZlclggPSBjbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdDtcbiAgICAgIHZhciBob3ZlclkgPSBjbGllbnRZIC0gc2VyaWVzQm91bmQudG9wO1xuICAgICAgdmFyIGluUmVjdCA9IGhvdmVyWCA8IDAgfHwgaG92ZXJZIDwgMCB8fCBob3ZlclggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIHx8IGhvdmVyWSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuXG4gICAgICBpZiAoaW5SZWN0KSB7XG4gICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy16b29tJyk7XG4gICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy1wYW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXJpbmctcGFuJyk7XG4gICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5hZGQoJ2hvdmVyaW5nLXpvb20nKTtcbiAgICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMucGFuRW5hYmxlZCkge1xuICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmluZy16b29tJyk7XG4gICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5hZGQoJ2hvdmVyaW5nLXBhbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBqID0gTWF0aC5yb3VuZChob3ZlclggLyB4RGl2aXNvcik7XG5cbiAgICAgIGlmIChoYXNCYXJzKSB7XG4gICAgICAgIGogPSBNYXRoLmNlaWwoaG92ZXJYIC8geERpdmlzb3IpO1xuICAgICAgICBqID0gaiAtIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZFNlcmllcyA9IG51bGw7XG4gICAgICB2YXIgY2xvc2VzdCA9IG51bGw7XG4gICAgICB2YXIgc2VyaWVzWFZhbEFyciA9IFtdO1xuICAgICAgdmFyIHNlcmllc1lWYWxBcnIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICBzZXJpZXNYVmFsQXJyLnB1c2goW3cuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3NdWzBdIC0gMC4wMDAwMDFdLmNvbmNhdCh3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tzXSkpO1xuICAgICAgfVxuXG4gICAgICBzZXJpZXNYVmFsQXJyID0gc2VyaWVzWFZhbEFyci5tYXAoZnVuY3Rpb24gKHNlcmllc1hWYWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc1hWYWwuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXJpZXNZVmFsQXJyID0gdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXMubWFwKGZ1bmN0aW9uIChzZXJpZXNZVmFsKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNZVmFsLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBpZiBYIGF4aXMgdHlwZSBpcyBub3QgY2F0ZWdvcnkgYW5kIHRvb2x0aXAgaXMgbm90IHNoYXJlZCwgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgdGhlIGN1cnNvciBwb3NpdGlvbiBhbmQgZ2V0IHRoZSBuZWFyZXN0IHZhbHVlXG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBjbG9zZXN0ID0gdGhpcy5jbG9zZXN0SW5NdWx0aUFycmF5KGhvdmVyWCwgaG92ZXJZLCBzZXJpZXNYVmFsQXJyLCBzZXJpZXNZVmFsQXJyKTtcbiAgICAgICAgY2FwdHVyZWRTZXJpZXMgPSBjbG9zZXN0LmluZGV4O1xuICAgICAgICBqID0gY2xvc2VzdC5qO1xuXG4gICAgICAgIGlmIChjYXB0dXJlZFNlcmllcyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGluaXRpYWwgcHVzaCwgaXQgc2hvdWxkIGJlIGEgbGl0dGxlIHNtYWxsZXIgdGhhbiB0aGUgMXN0IHZhbFxuICAgICAgICAgIHNlcmllc1hWYWxBcnIgPSB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tjYXB0dXJlZFNlcmllc107XG4gICAgICAgICAgY2xvc2VzdCA9IHRoaXMuY2xvc2VzdEluQXJyYXkoaG92ZXJYLCBzZXJpZXNYVmFsQXJyKTtcbiAgICAgICAgICBqID0gY2xvc2VzdC5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWogfHwgaiA8IDEpIGogPSAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FwdHVyZWRTZXJpZXM6IGNhcHR1cmVkU2VyaWVzLFxuICAgICAgICBqOiBqLFxuICAgICAgICBob3Zlclg6IGhvdmVyWCxcbiAgICAgICAgaG92ZXJZOiBob3ZlcllcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3Nlc3RJbk11bHRpQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VzdEluTXVsdGlBcnJheShob3ZlclgsIGhvdmVyWSwgWGFycmF5cywgWWFycmF5cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuICAgICAgdmFyIGN1cnJJbmRleCA9IG51bGw7XG4gICAgICB2YXIgaiA9IC0xO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRGaXJzdEFjdGl2ZVhBcnJheShYYXJyYXlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyWSA9IFlhcnJheXNbYWN0aXZlSW5kZXhdWzBdO1xuICAgICAgdmFyIGN1cnJYID0gWGFycmF5c1thY3RpdmVJbmRleF1bMF07XG4gICAgICB2YXIgZGlmZlggPSBNYXRoLmFicyhob3ZlclggLSBjdXJyWCk7XG4gICAgICB2YXIgZGlmZlkgPSBNYXRoLmFicyhob3ZlclkgLSBjdXJyWSk7XG4gICAgICB2YXIgZGlmZiA9IGRpZmZZICsgZGlmZlg7XG4gICAgICBZYXJyYXlzLm1hcChmdW5jdGlvbiAoYXJyWSwgYXJySW5kZXgpIHtcbiAgICAgICAgYXJyWS5tYXAoZnVuY3Rpb24gKHksIGlubmVyS2V5KSB7XG4gICAgICAgICAgdmFyIG5ld2RpZmZZID0gTWF0aC5hYnMoaG92ZXJZIC0gWWFycmF5c1thcnJJbmRleF1baW5uZXJLZXldKTtcbiAgICAgICAgICB2YXIgbmV3ZGlmZlggPSBNYXRoLmFicyhob3ZlclggLSBYYXJyYXlzW2FyckluZGV4XVtpbm5lcktleV0pO1xuICAgICAgICAgIHZhciBuZXdkaWZmID0gbmV3ZGlmZlggKyBuZXdkaWZmWTtcblxuICAgICAgICAgIGlmIChuZXdkaWZmIDwgZGlmZikge1xuICAgICAgICAgICAgZGlmZiA9IG5ld2RpZmY7XG4gICAgICAgICAgICBkaWZmWCA9IG5ld2RpZmZYO1xuICAgICAgICAgICAgZGlmZlkgPSBuZXdkaWZmWTtcbiAgICAgICAgICAgIGN1cnJJbmRleCA9IGFyckluZGV4O1xuICAgICAgICAgICAgaiA9IGlubmVyS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBjdXJySW5kZXgsXG4gICAgICAgIGo6IGpcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpcnN0QWN0aXZlWEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0QWN0aXZlWEFycmF5KFhhcnJheXMpIHtcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IDA7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlyc3RBY3RpdmVTZXJpZXNJbmRleCA9IFhhcnJheXMubWFwKGZ1bmN0aW9uICh4YXJyLCBpbmRleCkge1xuICAgICAgICBpZiAoeGFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgZmlyc3RBY3RpdmVTZXJpZXNJbmRleC5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgdG90YWwgPSBjb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxCeUluZGV4KGEpO1xuXG4gICAgICAgIGlmIChmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdICE9PSAtMSAmJiB0b3RhbCAhPT0gMCAmJiAhY29yZVV0aWxzLnNlcmllc0hhdmVTYW1lVmFsdWVzKGEpKSB7XG4gICAgICAgICAgYWN0aXZlSW5kZXggPSBmaXJzdEFjdGl2ZVNlcmllc0luZGV4W2FdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3RpdmVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdEluQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VzdEluQXJyYXkodmFsLCBhcnIpIHtcbiAgICAgIHZhciBjdXJyID0gYXJyWzBdO1xuICAgICAgdmFyIGN1cnJJbmRleCA9IG51bGw7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHZhbCAtIGN1cnIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3ZGlmZiA9IE1hdGguYWJzKHZhbCAtIGFycltpXSk7XG5cbiAgICAgICAgaWYgKG5ld2RpZmYgPCBkaWZmKSB7XG4gICAgICAgICAgZGlmZiA9IG5ld2RpZmY7XG4gICAgICAgICAgY3VyciA9IGFycltpXTtcbiAgICAgICAgICBjdXJySW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBjdXJySW5kZXhcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHNlcmllcywgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBkaWZmZXJlbnQgeCB2YWx1ZXMgZm9yIGVhY2ggc2VyaWVzLlxuICAgICAqIEJ1dCBpdCBtYXkgYmUgcG9zc2libGUgaW4gdGhvc2UgbXVsdGlwbGUgc2VyaWVzLCB0aGF0IHRoZXJlIGlzIHNhbWUgeCB2YWx1ZSBmb3IgMiBvciBtb3JlXG4gICAgICogc2VyaWVzLlxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xuICAgICAqIEBwYXJhbSB7aW50fVxuICAgICAqIC0gaiA9IGlzIHRoZSBpbm5lciBpbmRleCBvZiBzZXJpZXMgLT4gKHNlcmllc1tpXVtqXSlcbiAgICAgKiBAcmV0dXJuIHtib29sfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNYb3ZlcmxhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1hvdmVybGFwKGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhTYW1lRm9yQWxsU2VyaWVzSkFyciA9IFtdO1xuICAgICAgdmFyIHNlcmllc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzWzBdICE9PSAndW5kZWZpbmVkJztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VyaWVzWC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzWC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc1hbaV1bal0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzZXJpZXNYW2kgKyAxXVtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNYW2ldW2pdICE9PSBzZXJpZXNYW2kgKyAxXVtqXSkge1xuICAgICAgICAgICAgICB4U2FtZUZvckFsbFNlcmllc0pBcnIucHVzaCgndW5FcXVhbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeFNhbWVGb3JBbGxTZXJpZXNKQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc2luaXRpYWxTZXJpZXNTYW1lTGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzaW5pdGlhbFNlcmllc1NhbWVMZW4oKSB7XG4gICAgICB2YXIgc2FtZUxlbiA9IHRydWU7XG4gICAgICB2YXIgaW5pdGlhbFNlcmllcyA9IHRoaXMudy5nbG9iYWxzLmluaXRpYWxTZXJpZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbFNlcmllcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGluaXRpYWxTZXJpZXNbaV0uZGF0YS5sZW5ndGggIT09IGluaXRpYWxTZXJpZXNbaSArIDFdLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgc2FtZUxlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzYW1lTGVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXJzSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhcnNIZWlnaHQoYWxsYmFycykge1xuICAgICAgdmFyIGJhcnMgPSBfdG9Db25zdW1hYmxlQXJyYXkoYWxsYmFycyk7XG5cbiAgICAgIHZhciB0b3RhbEhlaWdodCA9IGJhcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGJhcikge1xuICAgICAgICByZXR1cm4gYWNjICsgYmFyLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlQWxsVG9vbHRpcFNlcmllc0dyb3Vwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzKHN0YXRlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh0dEN0eC5hbGxUb29sdGlwU2VyaWVzR3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0dEN0eC5hbGxUb29sdGlwU2VyaWVzR3JvdXBzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbFRvb2x0aXBTZXJpZXNHcm91cHMgPSB0dEN0eC5hbGxUb29sdGlwU2VyaWVzR3JvdXBzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFRvb2x0aXBTZXJpZXNHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZW5hYmxlJykge1xuICAgICAgICAgIGFsbFRvb2x0aXBTZXJpZXNHcm91cHNbaV0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5zdHlsZS5kaXNwbGF5ID0gdy5jb25maWcudG9vbHRpcC5pdGVtcy5kaXNwbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbFRvb2x0aXBTZXJpZXNHcm91cHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgYWxsVG9vbHRpcFNlcmllc0dyb3Vwc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFV0aWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVG9vbHRpcC5MYWJlbHMgQ2xhc3MgdG8gZHJhdyB0ZXh0cyBvbiB0aGUgdG9vbHRpcC5cbiAqXG4gKiBAbW9kdWxlIFRvb2x0aXAuTGFiZWxzXG4gKiovXG5cbnZhciBMYWJlbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYWJlbHModG9vbHRpcENvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxzKTtcblxuICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gICAgdGhpcy5jdHggPSB0b29sdGlwQ29udGV4dC5jdHg7XG4gICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICAgIHRoaXMudG9vbHRpcFV0aWwgPSBuZXcgVXRpbHMkMSh0b29sdGlwQ29udGV4dCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGFiZWxzLCBbe1xuICAgIGtleTogXCJkcmF3U2VyaWVzVGV4dHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1Nlcmllc1RleHRzKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmJHNoYXJlZCA9IF9yZWYuc2hhcmVkLFxuICAgICAgICAgIHNoYXJlZCA9IF9yZWYkc2hhcmVkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRzaGFyZWQsXG4gICAgICAgICAgdHRJdGVtcyA9IF9yZWYudHRJdGVtcyxcbiAgICAgICAgICBfcmVmJGkgPSBfcmVmLmksXG4gICAgICAgICAgaSA9IF9yZWYkaSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkaSxcbiAgICAgICAgICBfcmVmJGogPSBfcmVmLmosXG4gICAgICAgICAgaiA9IF9yZWYkaiA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkajtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC5jdXN0b20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUN1c3RvbVRvb2x0aXAoe1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogalxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXMoc2hhcmVkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzVG9QcmludCh7XG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGpcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmludExhYmVscyh7XG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGosXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICBzaGFyZWQ6IHNoYXJlZFxuICAgICAgfSk7IC8vIFJlLWNhbGN1bGF0ZSB0b29sdGlwIGRpbWVuc2lvbnMgbm93IHRoYXQgd2UgaGF2ZSBkcmF3biB0aGUgdGV4dFxuXG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy50dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHRoaXMudHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aCA9IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHRoaXMudHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgPSB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmludExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludExhYmVscyhfcmVmMikge1xuICAgICAgdmFyIGkgPSBfcmVmMi5pLFxuICAgICAgICAgIGogPSBfcmVmMi5qLFxuICAgICAgICAgIHZhbHVlcyA9IF9yZWYyLnZhbHVlcyxcbiAgICAgICAgICB0dEl0ZW1zID0gX3JlZjIudHRJdGVtcyxcbiAgICAgICAgICBzaGFyZWQgPSBfcmVmMi5zaGFyZWQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB2YWw7XG4gICAgICB2YXIgeFZhbCA9IHZhbHVlcy54VmFsLFxuICAgICAgICAgIHpWYWwgPSB2YWx1ZXMuelZhbCxcbiAgICAgICAgICB4QXhpc1RUVmFsID0gdmFsdWVzLnhBeGlzVFRWYWw7XG4gICAgICB2YXIgc2VyaWVzTmFtZSA9ICcnO1xuICAgICAgdmFyIHBDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbaV07XG5cbiAgICAgIGlmIChqICE9PSBudWxsICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCkge1xuICAgICAgICBwQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW2pdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciB0ID0gMCwgaW52ZXJzZXQgPSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCAtIDE7IHQgPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgdCsrLCBpbnZlcnNldC0tKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRGb3JtYXR0ZXJzKGkpO1xuICAgICAgICBzZXJpZXNOYW1lID0gdGhpcy5nZXRTZXJpZXNOYW1lKHtcbiAgICAgICAgICBmbjogZi55TGJUaXRsZUZvcm1hdHRlcixcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBqOiBqXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICB2YXIgdEluZGV4ID0gdy5jb25maWcudG9vbHRpcC5pbnZlcnNlT3JkZXIgPyBpbnZlcnNldCA6IHQ7XG4gICAgICAgICAgZiA9IHRoaXMuZ2V0Rm9ybWF0dGVycyh0SW5kZXgpO1xuICAgICAgICAgIHNlcmllc05hbWUgPSB0aGlzLmdldFNlcmllc05hbWUoe1xuICAgICAgICAgICAgZm46IGYueUxiVGl0bGVGb3JtYXR0ZXIsXG4gICAgICAgICAgICBpbmRleDogdEluZGV4LFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBqOiBqXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1t0SW5kZXhdOyAvLyBmb3IgcGxvdCBjaGFydHMsIG5vdCBmb3IgcGllL2RvbnV0c1xuXG4gICAgICAgICAgdmFsID0gZi55TGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1t0SW5kZXhdW2pdLCB7XG4gICAgICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pOyAvLyBkaXNjYXJkIDAgdmFsdWVzIGluIEJBUlNcblxuICAgICAgICAgIGlmICh0aGlzLnR0Q3R4Lmhhc0JhcnMoKSAmJiB3LmNvbmZpZy5jaGFydC5zdGFja2VkICYmIHcuZ2xvYmFscy5zZXJpZXNbdEluZGV4XVtqXSA9PT0gMCB8fCB0eXBlb2Ygdy5nbG9iYWxzLnNlcmllc1t0SW5kZXhdW2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBmLnlMYkZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdLCB7XG4gICAgICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgICAgdzogd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGZvciBwaWUgLyBkb251dHNcblxuXG4gICAgICAgIGlmIChqID09PSBudWxsKSB7XG4gICAgICAgICAgdmFsID0gZi55TGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1tpXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLkRPTUhhbmRsaW5nKHtcbiAgICAgICAgICB0OiB0LFxuICAgICAgICAgIHR0SXRlbXM6IHR0SXRlbXMsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIHhWYWw6IHhWYWwsXG4gICAgICAgICAgICB4QXhpc1RUVmFsOiB4QXhpc1RUVmFsLFxuICAgICAgICAgICAgelZhbDogelZhbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICBzaGFyZWQ6IHNoYXJlZCxcbiAgICAgICAgICBwQ29sb3I6IHBDb2xvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0dGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZXJzKGkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzW2ldO1xuICAgICAgdmFyIHlMYlRpdGxlRm9ybWF0dGVyO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnR0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5nbG9iYWxzLnR0VmFsKSkge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbFtpXSAmJiB3Lmdsb2JhbHMudHRWYWxbaV0uZm9ybWF0dGVyO1xuICAgICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0VmFsW2ldICYmIHcuZ2xvYmFscy50dFZhbFtpXS50aXRsZSAmJiB3Lmdsb2JhbHMudHRWYWxbaV0udGl0bGUuZm9ybWF0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbC5mb3JtYXR0ZXI7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy50dFZhbC50aXRsZS5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0VmFsLnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyID0gdy5jb25maWcudG9vbHRpcC55LnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB5TGJGb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdKSB7XG4gICAgICAgICAgeUxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeUxiRm9ybWF0dGVyID0gZnVuY3Rpb24geUxiRm9ybWF0dGVyKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHlMYlRpdGxlRm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHlMYlRpdGxlRm9ybWF0dGVyID0gZnVuY3Rpb24geUxiVGl0bGVGb3JtYXR0ZXIobGFiZWwpIHtcbiAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHlMYkZvcm1hdHRlcjogeUxiRm9ybWF0dGVyLFxuICAgICAgICB5TGJUaXRsZUZvcm1hdHRlcjogeUxiVGl0bGVGb3JtYXR0ZXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc05hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzTmFtZShfcmVmMykge1xuICAgICAgdmFyIGZuID0gX3JlZjMuZm4sXG4gICAgICAgICAgaW5kZXggPSBfcmVmMy5pbmRleCxcbiAgICAgICAgICBzZXJpZXNJbmRleCA9IF9yZWYzLnNlcmllc0luZGV4LFxuICAgICAgICAgIGogPSBfcmVmMy5qO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICByZXR1cm4gZm4oU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpbmRleF0pLCB7XG4gICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRPTUhhbmRsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIERPTUhhbmRsaW5nKF9yZWY0KSB7XG4gICAgICB2YXIgdCA9IF9yZWY0LnQsXG4gICAgICAgICAgdHRJdGVtcyA9IF9yZWY0LnR0SXRlbXMsXG4gICAgICAgICAgdmFsdWVzID0gX3JlZjQudmFsdWVzLFxuICAgICAgICAgIHNlcmllc05hbWUgPSBfcmVmNC5zZXJpZXNOYW1lLFxuICAgICAgICAgIHNoYXJlZCA9IF9yZWY0LnNoYXJlZCxcbiAgICAgICAgICBwQ29sb3IgPSBfcmVmNC5wQ29sb3I7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdmFsID0gdmFsdWVzLnZhbCxcbiAgICAgICAgICB4VmFsID0gdmFsdWVzLnhWYWwsXG4gICAgICAgICAgeEF4aXNUVFZhbCA9IHZhbHVlcy54QXhpc1RUVmFsLFxuICAgICAgICAgIHpWYWwgPSB2YWx1ZXMuelZhbDtcbiAgICAgIHZhciB0dEl0ZW1zQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgdHRJdGVtc0NoaWxkcmVuID0gdHRJdGVtc1t0XS5jaGlsZHJlbjtcblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuZmlsbFNlcmllc0NvbG9yKSB7XG4gICAgICAgIC8vICBlbFRvb2x0aXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcENvbG9yXG4gICAgICAgIHR0SXRlbXNbdF0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcENvbG9yO1xuICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR0Q3R4LnNob3dUb29sdGlwVGl0bGUpIHtcbiAgICAgICAgaWYgKHR0Q3R4LnRvb2x0aXBUaXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGdldCBpdCBvbmNlIGlmIG51bGwsIGFuZCBzdG9yZSBpdCBpbiBjbGFzcyBwcm9wZXJ0eVxuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBUaXRsZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR0Q3R4LnRvb2x0aXBUaXRsZS5pbm5lckhUTUwgPSB4VmFsO1xuICAgICAgfSAvLyBpZiB4YXhpcyB0b29sdGlwIGlzIGNvbnN0cnVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGlubmVySFRNTFxuXG5cbiAgICAgIGlmICh0dEN0eC5ibHhheGlzVG9vbHRpcCkge1xuICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LmlubmVySFRNTCA9IHhBeGlzVFRWYWwgIT09ICcnID8geEF4aXNUVFZhbCA6IHhWYWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB0dFlMYWJlbCA9IHR0SXRlbXNbdF0ucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LWxhYmVsJyk7XG5cbiAgICAgIGlmICh0dFlMYWJlbCkge1xuICAgICAgICB0dFlMYWJlbC5pbm5lckhUTUwgPSBzZXJpZXNOYW1lID8gc2VyaWVzTmFtZSArICc6ICcgOiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHR0WVZhbCA9IHR0SXRlbXNbdF0ucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXZhbHVlJyk7XG5cbiAgICAgIGlmICh0dFlWYWwpIHtcbiAgICAgICAgdHRZVmFsLmlubmVySFRNTCA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR0SXRlbXNDaGlsZHJlblswXSAmJiB0dEl0ZW1zQ2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyJykpIHtcbiAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF3LmNvbmZpZy50b29sdGlwLm1hcmtlci5zaG93KSB7XG4gICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoelZhbCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdHRaTGFiZWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LWxhYmVsJyk7XG4gICAgICAgIHR0WkxhYmVsLmlubmVySFRNTCA9IHcuY29uZmlnLnRvb2x0aXAuei50aXRsZTtcbiAgICAgICAgdmFyIHR0WlZhbCA9IHR0SXRlbXNbdF0ucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotdmFsdWUnKTtcbiAgICAgICAgdHRaVmFsLmlubmVySFRNTCA9IHpWYWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFyZWQgJiYgdHRJdGVtc0NoaWxkcmVuWzBdKSB7XG4gICAgICAgIC8vIGhpZGUgd2hlbiBubyBWYWwgb3Igc2VyaWVzIGNvbGxhcHNlZFxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsID09PSBudWxsIHx8IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YodCkgPiAtMSkge1xuICAgICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9IHcuY29uZmlnLnRvb2x0aXAuaXRlbXMuZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVBY3RpdmVJbmFjdGl2ZVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVBY3RpdmVJbmFjdGl2ZVNlcmllcyhzaGFyZWQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoc2hhcmVkKSB7XG4gICAgICAgIC8vIG1ha2UgYWxsIHRvb2x0aXBzIGFjdGl2ZVxuICAgICAgICB0aGlzLnRvb2x0aXBVdGlsLnRvZ2dsZUFsbFRvb2x0aXBTZXJpZXNHcm91cHMoJ2VuYWJsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlzYWJsZSBhbGwgdG9vbHRpcCB0ZXh0IGdyb3Vwc1xuICAgICAgICB0aGlzLnRvb2x0aXBVdGlsLnRvZ2dsZUFsbFRvb2x0aXBTZXJpZXNHcm91cHMoJ2Rpc2FibGUnKTsgLy8gZW5hYmxlIHRoZSBmaXJzdCB0b29sdGlwIHRleHQgZ3JvdXBcblxuICAgICAgICB2YXIgZmlyc3RUb29sdGlwU2VyaWVzR3JvdXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cCcpO1xuXG4gICAgICAgIGlmIChmaXJzdFRvb2x0aXBTZXJpZXNHcm91cCkge1xuICAgICAgICAgIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwLnN0eWxlLmRpc3BsYXkgPSB3LmNvbmZpZy50b29sdGlwLml0ZW1zLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVzVG9QcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZXNUb1ByaW50KF9yZWY1KSB7XG4gICAgICB2YXIgaSA9IF9yZWY1LmksXG4gICAgICAgICAgaiA9IF9yZWY1Lmo7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJlZFNlcmllc1ggPSB0aGlzLmN0eC5zZXJpZXMuZmlsdGVyZWRTZXJpZXNYKCk7XG4gICAgICB2YXIgeFZhbCA9ICcnO1xuICAgICAgdmFyIHhBeGlzVFRWYWwgPSAnJztcbiAgICAgIHZhciB6VmFsID0gbnVsbDtcbiAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgdmFyIGN1c3RvbUZvcm1hdHRlck9wdHMgPSB7XG4gICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9O1xuICAgICAgdmFyIHpGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRaRm9ybWF0dGVyO1xuXG4gICAgICBpZiAoaiA9PT0gbnVsbCkge1xuICAgICAgICB2YWwgPSB3Lmdsb2JhbHMuc2VyaWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeFZhbCA9IGZpbHRlcmVkU2VyaWVzWFtpXVtqXTtcblxuICAgICAgICAgIGlmIChmaWx0ZXJlZFNlcmllc1hbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBhIHNlcmllcyAocG9zc2libHkgdGhlIGZpcnN0IG9uZSkgbWlnaHQgYmUgY29sbGFwc2VkLCBzbyBnZXQgdGhlIG5leHQgYWN0aXZlIGluZGV4XG4gICAgICAgICAgICB2YXIgZmlyc3RBY3RpdmVTZXJpZXNJbmRleCA9IHRoaXMudG9vbHRpcFV0aWwuZ2V0Rmlyc3RBY3RpdmVYQXJyYXkoZmlsdGVyZWRTZXJpZXNYKTtcbiAgICAgICAgICAgIHhWYWwgPSBmaWx0ZXJlZFNlcmllc1hbZmlyc3RBY3RpdmVTZXJpZXNJbmRleF1bal07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhWYWwgPSB0eXBlb2Ygdy5nbG9iYWxzLmxhYmVsc1tqXSAhPT0gJ3VuZGVmaW5lZCcgPyB3Lmdsb2JhbHMubGFiZWxzW2pdIDogJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlclhWYWwgPSB4VmFsO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICB2YXIgeEZvcm1hdCA9IG5ldyBGb3JtYXR0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgeFZhbCA9IHhGb3JtYXQueExhYmVsRm9ybWF0KHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciwgYnVmZmVyWFZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4VmFsID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcihidWZmZXJYVmFsLCBjdXN0b21Gb3JtYXR0ZXJPcHRzKTtcbiAgICAgIH0gLy8gb3ZlcnJpZGUgZGVmYXVsdCB4LWF4aXMgZm9ybWF0dGVyIHdpdGggdG9vbHRpcCBmb3JtYXR0ZXJcblxuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC54LmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHhWYWwgPSB3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIoYnVmZmVyWFZhbCwgY3VzdG9tRm9ybWF0dGVyT3B0cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzWi5sZW5ndGggPiAwICYmIHcuZ2xvYmFscy5zZXJpZXNaWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgelZhbCA9IHpGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1pbaV1bal0sIHcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHhBeGlzVFRWYWwgPSB3Lmdsb2JhbHMueGF4aXNUb29sdGlwRm9ybWF0dGVyKGJ1ZmZlclhWYWwsIGN1c3RvbUZvcm1hdHRlck9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeEF4aXNUVFZhbCA9IHhWYWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbDogdmFsLFxuICAgICAgICB4VmFsOiB4VmFsLFxuICAgICAgICB4QXhpc1RUVmFsOiB4QXhpc1RUVmFsLFxuICAgICAgICB6VmFsOiB6VmFsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDdXN0b21Ub29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUN1c3RvbVRvb2x0aXAoX3JlZjYpIHtcbiAgICAgIHZhciBpID0gX3JlZjYuaSxcbiAgICAgICAgICBqID0gX3JlZjYuajtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMudHRDdHguZ2V0RWxUb29sdGlwKCk7IC8vIG92ZXJyaWRlIGV2ZXJ5dGhpbmcgd2l0aCBhIGN1c3RvbSBodG1sIHRvb2x0aXAgYW5kIHJlcGxhY2UgaXRcblxuICAgICAgdG9vbHRpcEVsLmlubmVySFRNTCA9IHcuY29uZmlnLnRvb2x0aXAuY3VzdG9tKHtcbiAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYWJlbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sdGlwLlBvc2l0aW9uIENsYXNzIHRvIG1vdmUgdGhlIHRvb2x0aXAgYmFzZWQgb24geCBhbmQgeSBwb3NpdGlvbi5cbiAqXG4gKiBAbW9kdWxlIFRvb2x0aXAuUG9zaXRpb25cbiAqKi9cblxudmFyIFBvc2l0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9zaXRpb24odG9vbHRpcENvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb24pO1xuXG4gICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICAgIHRoaXMuY3R4ID0gdG9vbHRpcENvbnRleHQuY3R4O1xuICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBtb3ZlIHRoZSBjcm9zc2hhaXIgKHRoZSB2ZXJ0aWNhbC9ob3J6IGxpbmUgdGhhdCBtb3ZlcyBhbG9uZyB3aXRoIG1vdXNlKVxuICAgKiBBbG9uZyB3aXRoIHRoaXMsIHRoaXMgZnVuY3Rpb24gYWxzbyBjYWxscyB0aGUgeGF4aXNNb3ZlIGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIGNyb3NzaGFpclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQb3NpdGlvbiwgW3tcbiAgICBrZXk6IFwibW92ZVhDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVYQ3Jvc3NoYWlycyhjeCkge1xuICAgICAgdmFyIGogPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeGNyb3NzaGFpcnMgPSB0dEN0eC5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICB2YXIgeCA9IGN4IC0gdHRDdHgueGNyb3NzaGFpcnNXaWR0aCAvIDI7XG4gICAgICB2YXIgdGlja0Ftb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKS5sZW5ndGg7XG5cbiAgICAgIGlmIChqICE9PSBudWxsKSB7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGlja0Ftb3VudCAqIGo7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAndGlja1dpZHRoJyB8fCB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAnYmFyV2lkdGgnKSB7XG4gICAgICAgIGlmICh4ICsgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAtIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqICE9PSBudWxsKSB7XG4gICAgICAgICAgeCA9IHggKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGlja0Ftb3VudCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3gnLCB4KTtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4MScsIHgpO1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3gyJywgeCk7XG4gICAgICAgIHhjcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneTInLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIHhjcm9zc2hhaXJzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHRDdHguYmx4YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgdmFyIHR4ID0geDtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcgfHwgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgIHR4ID0geCArIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlWEF4aXNUb29sdGlwKHR4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIG1vdmUgdGhlIGNyb3NzaGFpciAodGhlIHZlcnRpY2FsL2hvcnogbGluZSB0aGF0IG1vdmVzIGFsb25nIHdpdGggbW91c2UpXG4gICAgICogQWxvbmcgd2l0aCB0aGlzLCB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdGhlIHhheGlzTW92ZSBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7aW50fSAtIGN4ID0gcG9pbnQncyB4IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHggaXMsIHlvdSBuZWVkIHRvIG1vdmUgY3Jvc3NoYWlyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlWUNyb3NzaGFpcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVlDcm9zc2hhaXJzKGN5KSB7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBpZiAodHRDdHgueWNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnModHRDdHgueWNyb3NzaGFpcnMsIHtcbiAgICAgICAgICB5MTogY3ksXG4gICAgICAgICAgeTI6IGN5XG4gICAgICAgIH0pO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0dEN0eC55Y3Jvc3NoYWlyc0hpZGRlbiwge1xuICAgICAgICAgIHkxOiBjeSxcbiAgICAgICAgICB5MjogY3lcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqKiBBeGlzVG9vbHRpcCBpcyB0aGUgc21hbGwgcmVjdGFuZ2xlIHdoaWNoIGFwcGVhcnMgb24geCBheGlzIHdpdGggeCB2YWx1ZSwgd2hlbiB1c2VyIG1vdmVzXG4gICAgICogQG1lbWJlcm9mIFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtpbnR9IC0gY3ggPSBwb2ludCdzIHggcG9zaXRpb24sIHdoZXJldmVyIHBvaW50J3MgeCBpcywgeW91IG5lZWQgdG8gbW92ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVhBeGlzVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWEF4aXNUb29sdGlwKGN4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh0dEN0eC54YXhpc1Rvb2x0aXAgIT09IG51bGwpIHtcbiAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB2YXIgY3kgPSB0dEN0eC54YXhpc09mZlkgKyB3LmNvbmZpZy54YXhpcy50b29sdGlwLm9mZnNldFkgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIDEgKyB3LmNvbmZpZy54YXhpcy5vZmZzZXRZO1xuICAgICAgICB2YXIgeGF4aXNUVFRleHQgPSB0dEN0eC54YXhpc1Rvb2x0aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB4YXhpc1RUVGV4dFdpZHRoID0geGF4aXNUVFRleHQud2lkdGg7XG4gICAgICAgIGN4ID0gY3ggLSB4YXhpc1RUVGV4dFdpZHRoIC8gMjtcblxuICAgICAgICBpZiAoIWlzTmFOKGN4KSkge1xuICAgICAgICAgIGN4ID0gY3ggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWDtcbiAgICAgICAgICB2YXIgdGV4dFJlY3QgPSAwO1xuICAgICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgICAgdGV4dFJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModHRDdHgueGF4aXNUb29sdGlwVGV4dC5pbm5lckhUTUwpO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuc3R5bGUubWluV2lkdGggPSB0ZXh0UmVjdC53aWR0aCArICdweCc7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLnN0eWxlLmxlZnQgPSBjeCArICdweCc7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLnN0eWxlLnRvcCA9IGN5ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlWUF4aXNUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVZQXhpc1Rvb2x0aXAoaW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgaWYgKHR0Q3R4LnlheGlzVFRFbHMgPT09IG51bGwpIHtcbiAgICAgICAgdHRDdHgueWF4aXNUVEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeWNyb3NzaGFpcnNIaWRkZW5SZWN0WTEgPSBwYXJzZUludCh0dEN0eC55Y3Jvc3NoYWlyc0hpZGRlbi5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xuICAgICAgdmFyIGN5ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVkgKyB5Y3Jvc3NoYWlyc0hpZGRlblJlY3RZMTtcbiAgICAgIHZhciB5QXhpc1RUUmVjdCA9IHR0Q3R4LnlheGlzVFRFbHNbaW5kZXhdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHlBeGlzVFRIZWlnaHQgPSB5QXhpc1RUUmVjdC5oZWlnaHQ7XG4gICAgICB2YXIgY3ggPSB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW2luZGV4XSAtIDI7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tpbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgY3ggPSBjeCAtIDI2O1xuICAgICAgfVxuXG4gICAgICBjeSA9IGN5IC0geUF4aXNUVEhlaWdodCAvIDI7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uc3R5bGUudG9wID0gY3kgKyAncHgnO1xuICAgICAgICB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5zdHlsZS5sZWZ0ID0gY3ggKyB3LmNvbmZpZy55YXhpc1tpbmRleF0udG9vbHRpcC5vZmZzZXRYICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR0Q3R4LnlheGlzVFRFbHNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiogbW92ZXMgdGhlIHdob2xlIHRvb2x0aXAgYnkgY2hhbmdpbmcgeCwgeSBhdHRyc1xuICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7aW50fSAtIGN4ID0gcG9pbnQncyB4IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHggaXMsIHlvdSBuZWVkIHRvIG1vdmUgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7aW50fSAtIGN5ID0gcG9pbnQncyB5IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHkgaXMsIHlvdSBuZWVkIHRvIG1vdmUgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7aW50fSAtIHIgPSBwb2ludCdzIHJhZGl1c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvb2x0aXAoY3gsIGN5KSB7XG4gICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciB0b29sdGlwUmVjdCA9IHR0Q3R4LnRvb2x0aXBSZWN0O1xuICAgICAgdmFyIHBvaW50UiA9IHIgIT09IG51bGwgPyBwYXJzZUludChyKSA6IDE7XG4gICAgICB2YXIgeCA9IHBhcnNlSW50KGN4KSArIHBvaW50UiArIDU7XG4gICAgICB2YXIgeSA9IHBhcnNlSW50KGN5KSArIHBvaW50UiAvIDI7IC8vIC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyXG5cbiAgICAgIGlmICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIpIHtcbiAgICAgICAgeCA9IHggLSB0b29sdGlwUmVjdC50dFdpZHRoIC0gcG9pbnRSIC0gMTU7XG4gICAgICB9XG5cbiAgICAgIGlmICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAtIHRvb2x0aXBSZWN0LnR0V2lkdGggLSAxMCkge1xuICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAtIHRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgLTIwKSB7XG4gICAgICAgIHggPSAtMjA7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25DaGVja3ModG9vbHRpcFJlY3QsIHgsIHkpO1xuICAgICAgeCA9IG5ld1Bvc2l0aW9ucy54O1xuICAgICAgeSA9IG5ld1Bvc2l0aW9ucy55O1xuXG4gICAgICBpZiAoIWlzTmFOKHgpKSB7XG4gICAgICAgIHggPSB4ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVg7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25DaGVja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25DaGVja3ModG9vbHRpcFJlY3QsIHgsIHkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAodG9vbHRpcFJlY3QudHRIZWlnaHQgKyB5ID4gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIHtcbiAgICAgICAgeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTWFya2VycyhpLCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldID4gMCkge1xuICAgICAgICB2YXIgYWxsUG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIiAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoaSwgXCInXSAuYXBleGNoYXJ0cy1tYXJrZXJcIikpO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYWxsUG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgaWYgKHBhcnNlSW50KGFsbFBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSA9PT0gaikge1xuICAgICAgICAgICAgdHRDdHgubWFya2VyLnJlc2V0UG9pbnRzU2l6ZSgpO1xuICAgICAgICAgICAgdHRDdHgubWFya2VyLmVubGFyZ2VDdXJyZW50UG9pbnQoaiwgYWxsUG9pbnRzW3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR0Q3R4Lm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgICAgdGhpcy5tb3ZlRHluYW1pY1BvaW50T25Ib3ZlcihqLCBpKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIHNob3cgbWFya2Vycy9wb2ludHMgb25seSBvbiBob3ZlciAtXG4gICAgLy8gRElGRkVSRU5UIFggVkFMVUVTIGluIG11bHRpcGxlIHNlcmllc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZUR5bmFtaWNQb2ludE9uSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUR5bmFtaWNQb2ludE9uSG92ZXIoaiwgY2FwdHVyZWRTZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciBjeCA9IDA7XG4gICAgICB2YXIgY3kgPSAwO1xuICAgICAgdmFyIHBvaW50c0FyciA9IHcuZ2xvYmFscy5wb2ludHNBcnJheTtcbiAgICAgIHZhciBob3ZlclNpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG5cbiAgICAgIGlmIChob3ZlclNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBob3ZlclNpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2NhcHR1cmVkU2VyaWVzXSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY3ggPSBwb2ludHNBcnJbY2FwdHVyZWRTZXJpZXNdW2pdWzBdO1xuICAgICAgY3kgPSBwb2ludHNBcnJbY2FwdHVyZWRTZXJpZXNdW2pdWzFdID8gcG9pbnRzQXJyW2NhcHR1cmVkU2VyaWVzXVtqXVsxXSA6IDA7XG4gICAgICB2YXIgcG9pbnQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGNhcHR1cmVkU2VyaWVzLCBcIiddIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIGNpcmNsZVwiKSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBob3ZlclNpemUpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlKCdjeCcsIGN4KTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZSgnY3knLCBjeSk7IC8vIHBvaW50LnN0eWxlLm9wYWNpdHkgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLm9wYWNpdHlcblxuICAgICAgdGhpcy5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICBpZiAoIXR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGN4LCBjeSwgaG92ZXJTaXplKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIHNob3cgbWFya2Vycy9wb2ludHMgb25seSBvbiBob3ZlciAtXG4gICAgLy8gU0FNRSBYIFZBTFVFUyBpbiBtdWx0aXBsZSBzZXJpZXNcblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVEeW5hbWljUG9pbnRzT25Ib3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlRHluYW1pY1BvaW50c09uSG92ZXIoaikge1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdHRDdHgudztcbiAgICAgIHZhciBjeCA9IDA7XG4gICAgICB2YXIgY3kgPSAwO1xuICAgICAgdmFyIGFjdGl2ZVNlcmllcyA9IDA7XG4gICAgICB2YXIgcG9pbnRzQXJyID0gdy5nbG9iYWxzLnBvaW50c0FycmF5O1xuICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgYWN0aXZlU2VyaWVzID0gc2VyaWVzLmdldEFjdGl2ZVNlcmllc0luZGV4KCk7XG4gICAgICB2YXIgaG92ZXJTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICBpZiAoaG92ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG92ZXJTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVthY3RpdmVTZXJpZXNdICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRzQXJyW2FjdGl2ZVNlcmllc10pIHtcbiAgICAgICAgY3ggPSBwb2ludHNBcnJbYWN0aXZlU2VyaWVzXVtqXVswXTtcbiAgICAgICAgY3kgPSBwb2ludHNBcnJbYWN0aXZlU2VyaWVzXVtqXVsxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50cyA9IG51bGw7XG4gICAgICB2YXIgYWxsUG9pbnRzID0gdHRDdHguZ2V0QWxsTWFya2VycygpO1xuXG4gICAgICBpZiAoYWxsUG9pbnRzICE9PSBudWxsKSB7XG4gICAgICAgIHBvaW50cyA9IGFsbFBvaW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIGNpcmNsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRzICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50QXJyID0gcG9pbnRzQXJyW3BdO1xuXG4gICAgICAgICAgaWYgKHBvaW50QXJyICYmIHBvaW50QXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBjeSA9IHBvaW50c0FycltwXVtqXVsxXTtcbiAgICAgICAgICAgIHBvaW50c1twXS5zZXRBdHRyaWJ1dGUoJ2N4JywgY3gpO1xuICAgICAgICAgICAgdmFyIHJlYWxJbmRleCA9IHBhcnNlSW50KHBvaW50c1twXS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuXG4gICAgICAgICAgICBpZiAocGN5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvaW50c1tyZWFsSW5kZXhdICYmIHBvaW50c1tyZWFsSW5kZXhdLnNldEF0dHJpYnV0ZSgncicsIGhvdmVyU2l6ZSk7XG4gICAgICAgICAgICAgIHBvaW50c1tyZWFsSW5kZXhdICYmIHBvaW50c1tyZWFsSW5kZXhdLnNldEF0dHJpYnV0ZSgnY3knLCBwY3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9pbnRzW3JlYWxJbmRleF0gJiYgcG9pbnRzW3JlYWxJbmRleF0uc2V0QXR0cmlidXRlKCdyJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgdmFyIHRjeSA9IGN5IHx8IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGN4LCB0Y3ksIGhvdmVyU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVN0aWNreVRvb2x0aXBPdmVyQmFycyhqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgakJhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1iYXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9JzEnXSBwYXRoW2o9J1wiLmNvbmNhdChqLCBcIiddLCAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nMSddIHBhdGhbaj0nXCIpLmNvbmNhdChqLCBcIiddXCIpKTtcbiAgICAgIHZhciBiY3ggPSBqQmFyID8gcGFyc2VGbG9hdChqQmFyLmdldEF0dHJpYnV0ZSgnY3gnKSkgOiAwO1xuICAgICAgdmFyIGJjeSA9IDA7XG4gICAgICB2YXIgYncgPSBqQmFyID8gcGFyc2VGbG9hdChqQmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSkgOiAwO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgYmN4ID0gYmN4IC0gYncgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmN4ID0gdHRDdHgueEF4aXNUaWNrc1Bvc2l0aW9uc1tqIC0gMV0gKyB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoIC8gMjtcblxuICAgICAgICBpZiAoaXNOYU4oYmN4KSkge1xuICAgICAgICAgIGJjeCA9IHR0Q3R4LnhBeGlzVGlja3NQb3NpdGlvbnNbal0gLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0b29sdGlwIHdpbGwgbW92ZSB2ZXJ0aWNhbGx5IGFsb25nIHdpdGggbW91c2UgYXMgaXQgaXMgYSBzaGFyZWQgdG9vbHRpcFxuXG5cbiAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJjeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMubW92ZVhDcm9zc2hhaXJzKGJjeCk7XG5cbiAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgIHZhciB0Y3kgPSBiY3kgfHwgdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICAgIHRoaXMubW92ZVRvb2x0aXAoYmN4LCB0Y3kpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3NpdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuTWFya2VyIENsYXNzIHRvIGRyYXcgdGV4dHMgb24gdGhlIHRvb2x0aXAuXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLk1hcmtlclxuICoqL1xuXG52YXIgTWFya2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFya2VyKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtlcik7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0b29sdGlwQ29udGV4dCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya2VyLCBbe1xuICAgIGtleTogXCJkcmF3RHluYW1pY1BvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RHluYW1pY1BvaW50cygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBtYXJrZXIgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxzU2VyaWVzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IHBhcnNlSW50KGVsc1Nlcmllc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuICAgICAgICB2YXIgcG9pbnRzTWFpbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoc2VyaWVzSW5kZXgsIFwiJ10gLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcFwiKSk7XG5cbiAgICAgICAgaWYgKHBvaW50c01haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpdCBjYW4gYmUgbnVsbCBhcyB3ZSBoYXZlIHRvb2x0aXBzIGluIGRvbnV0L2JhciBjaGFydHNcbiAgICAgICAgICB2YXIgcG9pbnQgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIFBvaW50Q2xhc3NlcyA9IFwiYXBleGNoYXJ0cy1tYXJrZXIgd1wiLmNvbmNhdCgoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCkpO1xuXG4gICAgICAgICAgaWYgKCh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnbGluZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2FyZWEnKSAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF3LmNvbmZpZy50b29sdGlwLmludGVyc2VjdCkge1xuICAgICAgICAgICAgUG9pbnRDbGFzc2VzICs9ICcgbm8tcG9pbnRlci1ldmVudHMnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbFBvaW50T3B0aW9ucyA9IG1hcmtlci5nZXRNYXJrZXJDb25maWcoUG9pbnRDbGFzc2VzLCBzZXJpZXNJbmRleCk7XG4gICAgICAgICAgcG9pbnQgPSBncmFwaGljcy5kcmF3TWFya2VyKDAsIDAsIGVsUG9pbnRPcHRpb25zKTtcbiAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIDApO1xuICAgICAgICAgIHZhciBlbFBvaW50c0cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAnZycpO1xuICAgICAgICAgIGVsUG9pbnRzRy5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJyk7XG4gICAgICAgICAgZWxQb2ludHNHLmFwcGVuZENoaWxkKHBvaW50Lm5vZGUpO1xuICAgICAgICAgIHBvaW50c01haW4uYXBwZW5kQ2hpbGQoZWxQb2ludHNHKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmxhcmdlQ3VycmVudFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVubGFyZ2VDdXJyZW50UG9pbnQocmVsLCBwb2ludCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnYnViYmxlJykge1xuICAgICAgICB0aGlzLm5ld1BvaW50U2l6ZShyZWwsIHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN4ID0gcG9pbnQuZ2V0QXR0cmlidXRlKCdjeCcpO1xuICAgICAgdmFyIGN5ID0gcG9pbnQuZ2V0QXR0cmlidXRlKCdjeScpO1xuICAgICAgdGhpcy50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgaWYgKCF0aGlzLmZpeGVkVG9vbHRpcCkge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGFyJykge1xuICAgICAgICAgIHZhciBlbEdyaWQgPSB0aGlzLnR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjeCA9IHRoaXMudHRDdHguZS5jbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uLm1vdmVUb29sdGlwKGN4LCBjeSwgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5sYXJnZVBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmxhcmdlUG9pbnRzKGopIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgY29sID0gajtcbiAgICAgIHZhciBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXM6bm90KC5hcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQpIC5hcGV4Y2hhcnRzLW1hcmtlcicpO1xuICAgICAgdmFyIG5ld1NpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciByZWwgPSBwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdyZWwnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnaW5kZXgnKTtcblxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3U2l6ZSA9IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaW5kZXhdICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbCA9PT0gcGFyc2VJbnQocmVsKSkge1xuICAgICAgICAgIG1lLm5ld1BvaW50U2l6ZShjb2wsIHBvaW50c1twXSk7XG4gICAgICAgICAgdmFyIGN4ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3gnKTtcbiAgICAgICAgICB2YXIgY3kgPSBwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeScpO1xuICAgICAgICAgIG1lLnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3gpO1xuXG4gICAgICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgICAgIG1lLnRvb2x0aXBQb3NpdGlvbi5tb3ZlVG9vbHRpcChjeCwgY3ksIG5ld1NpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS5vbGRQb2ludFNpemUocG9pbnRzW3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXdQb2ludFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3UG9pbnRTaXplKHJlbCwgcG9pbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG5ld1NpemUgPSB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemU7XG4gICAgICB2YXIgZWxQb2ludCA9IG51bGw7XG5cbiAgICAgIGlmIChyZWwgPT09IDApIHtcbiAgICAgICAgZWxQb2ludCA9IHBvaW50LnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsUG9pbnQgPSBwb2ludC5wYXJlbnROb2RlLmxhc3RDaGlsZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZWxQb2ludC5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuXG4gICAgICBpZiAobmV3U2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1NpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2luZGV4XSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZWxQb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBuZXdTaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2xkUG9pbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9sZFBvaW50U2l6ZShwb2ludCkge1xuICAgICAgdmFyIHNpemUgPSBwYXJzZUludChwb2ludC5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnKSk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ3InLCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRQb2ludHNTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0UG9pbnRzU2l6ZSgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllczpub3QoLmFwZXhjaGFydHMtc2VyaWVzLWNvbGxhcHNlZCkgLmFwZXhjaGFydHMtbWFya2VyJyk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQocG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScpKTtcblxuICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoc2l6ZSkpIHtcbiAgICAgICAgICBwb2ludHNbcF0uc2V0QXR0cmlidXRlKCdyJywgc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRzW3BdLnNldEF0dHJpYnV0ZSgncicsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmtlcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuSW50ZXJzZWN0IENsYXNzLlxuICpcbiAqIEBtb2R1bGUgVG9vbHRpcC5JbnRlcnNlY3RcbiAqKi9cblxudmFyIEludGVyc2VjdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVyc2VjdCh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcnNlY3QpO1xuXG4gICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJzZWN0LCBbe1xuICAgIGtleTogXCJnZXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHIoZSwgYXR0cikge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlSGVhdFRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSGVhdFRvb2x0aXAoX3JlZikge1xuICAgICAgdmFyIGUgPSBfcmVmLmUsXG4gICAgICAgICAgb3B0ID0gX3JlZi5vcHQsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWhlYXRtYXAtcmVjdCcpKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRBdHRyKGUsICdpJyk7XG4gICAgICAgIHZhciBqID0gdGhpcy5nZXRBdHRyKGUsICdqJyk7XG4gICAgICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cihlLCAnY3gnKTtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyKGUsICdjeScpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldEF0dHIoZSwgJ3dpZHRoJyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEF0dHIoZSwgJ2hlaWdodCcpO1xuICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHggPSBjeCArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGggLyAyICsgd2lkdGg7XG4gICAgICAgIHkgPSBjeSArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiAtIGhlaWdodCAvIDI7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoY3ggKyB3aWR0aCAvIDIpO1xuXG4gICAgICAgIGlmICh4ID4gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIpIHtcbiAgICAgICAgICB4ID0gY3ggLSB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoIC8gMiArIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LncuY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8geCA9IHR0Q3R4LmUuY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnRcblxuICAgICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAvIDIgLSAxMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNYXJrZXJUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1hcmtlclRvb2x0aXAoX3JlZjIpIHtcbiAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMi5vcHQsXG4gICAgICAgICAgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnk7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBqO1xuXG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLW1hcmtlcicpKSB7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlSW50KG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgndmFsJykpO1xuICAgICAgICBqID0gcGFyc2VJbnQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgncmVsJykpO1xuICAgICAgICBpID0gcGFyc2VJbnQob3B0LnBhdGhzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcblxuICAgICAgICBpZiAodHRDdHguaW50ZXJzZWN0KSB7XG4gICAgICAgICAgdmFyIGVsID0gVXRpbHMuZmluZEFuY2VzdG9yKG9wdC5wYXRocywgJ2FwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGkgPSBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICB0dEl0ZW1zOiBvcHQudHRJdGVtcyxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgc2hhcmVkOiB0dEN0eC5pbnRlcnNlY3QgPyBmYWxzZSA6IHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICB0dEN0eC5tYXJrZXIuZW5sYXJnZUN1cnJlbnRQb2ludChqLCBvcHQucGF0aHMpO1xuICAgICAgICB4ID0gY3g7XG4gICAgICAgIHkgPSBjeSAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ICogMS40O1xuXG4gICAgICAgIGlmICh0dEN0eC53LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgeSA9IGN5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUJhclRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQmFyVG9vbHRpcChfcmVmMykge1xuICAgICAgdmFyIGUgPSBfcmVmMy5lLFxuICAgICAgICAgIG9wdCA9IF9yZWYzLm9wdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0dEN0eC5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciBieCA9IDA7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7IC8vIGxldCBiVyA9IDBcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGJhclhZID0gdGhpcy5nZXRCYXJUb29sdGlwWFkoe1xuICAgICAgICBlOiBlLFxuICAgICAgICBvcHQ6IG9wdFxuICAgICAgfSk7XG4gICAgICBpID0gYmFyWFkuaTtcbiAgICAgIHZhciBiYXJIZWlnaHQgPSBiYXJYWS5iYXJIZWlnaHQ7XG4gICAgICB2YXIgaiA9IGJhclhZLmo7XG5cbiAgICAgIGlmICh0dEN0eC5pc0Jhckhvcml6b250YWwgJiYgdHRDdHguaGFzQmFycygpIHx8ICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICB4ID0gYmFyWFkueDtcbiAgICAgICAgeSA9IGJhclhZLnk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2Uud2lkdGgpID8gdy5jb25maWcuc3Ryb2tlLndpZHRoW2ldIDogdy5jb25maWcuc3Ryb2tlLndpZHRoOyAvLyBiVyA9IGJhclhZLmJhcldpZHRoXG5cbiAgICAgICAgYnggPSB4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgICAgYnggPSBieCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8geSBpcyBOYU4sIG1ha2UgaXQgdG91Y2ggdGhlIGJvdHRvbSBvZiBncmlkIGFyZWFcblxuXG4gICAgICBpZiAoaXNOYU4oeSkpIHtcbiAgICAgICAgeSA9IHcuZ2xvYmFscy5zdmdIZWlnaHQgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodDtcbiAgICAgIH0gLy8geCBleGNlZWRzIGdyaWRXaWR0aFxuXG5cbiAgICAgIGlmICh4ICsgdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aCA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHtcbiAgICAgICAgeCA9IHggLSB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoO1xuICAgICAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgICAgICB4ID0geCArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEN0eC53LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgeSA9IHR0Q3R4LmUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcDtcbiAgICAgIH0gLy8gaWYgdG9vbHRpcCBpcyBzdGlsbCBudWxsLCBxdWVyeVNlbGVjdG9yXG5cblxuICAgICAgaWYgKHR0Q3R4LnRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgdHRDdHgudG9vbHRpcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzSGFzQmFycykge1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoYnggKyBzdHJva2VXaWR0aCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWENyb3NzaGFpcnMoYngpO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1vdmUgdG9vbHRpcCBoZXJlXG5cblxuICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXAgJiYgKCF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCB8fCB0dEN0eC5pc0Jhckhvcml6b250YWwgJiYgdHRDdHguaGFzQmFycygpKSkge1xuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArIHcuZ2xvYmFscy50cmFuc2xhdGVYICsgJ3B4JztcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gcGFyc2VJbnQob3B0LnBhdGhzLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgdmFyIGlzUmV2ZXJzZWQgPSB3Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzID8gdy5jb25maWcueWF4aXNbc2VyaWVzSW5kZXhdLnJldmVyc2VkIDogdy5jb25maWcueWF4aXNbMF0ucmV2ZXJzZWQ7XG5cbiAgICAgICAgaWYgKGlzUmV2ZXJzZWQgJiYgISh0dEN0eC5pc0Jhckhvcml6b250YWwgJiYgdHRDdHguaGFzQmFycygpKSkge1xuICAgICAgICAgIHkgPSB5ICsgYmFySGVpZ2h0IC0gKHcuZ2xvYmFscy5zZXJpZXNbaV1bal0gPCAwID8gYmFySGVpZ2h0IDogMCkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgeSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSB7XG4gICAgICAgICAgeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcbiAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFyVG9vbHRpcFhZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhclRvb2x0aXBYWShfcmVmNCkge1xuICAgICAgdmFyIGUgPSBfcmVmNC5lLFxuICAgICAgICAgIG9wdCA9IF9yZWY0Lm9wdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGogPSBudWxsO1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG4gICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgIHZhciBjbCA9IGUudGFyZ2V0LmNsYXNzTGlzdDtcblxuICAgICAgaWYgKGNsLmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWJhci1hcmVhJykgfHwgY2wuY29udGFpbnMoJ2FwZXhjaGFydHMtY2FuZGxlc3RpY2stYXJlYScpKSB7XG4gICAgICAgIHZhciBiYXIgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGJhclJlY3QgPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IG9wdC5lbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBiaCA9IGJhclJlY3QuaGVpZ2h0O1xuICAgICAgICBiYXJIZWlnaHQgPSBiYXJSZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIGJ3ID0gYmFyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGN4ID0gcGFyc2VJbnQoYmFyLmdldEF0dHJpYnV0ZSgnY3gnKSk7XG4gICAgICAgIHZhciBjeSA9IHBhcnNlSW50KGJhci5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuICAgICAgICBiYXJXaWR0aCA9IHBhcnNlRmxvYXQoYmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSk7XG4gICAgICAgIHZhciBjbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuICAgICAgICBqID0gcGFyc2VJbnQoYmFyLmdldEF0dHJpYnV0ZSgnaicpKTtcbiAgICAgICAgaSA9IHBhcnNlSW50KGJhci5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgICAgaSA9IHBhcnNlSW50KGJhci5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICAgIH0gLy8gaWYgKHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIC8vIHRoaXMgY2hlY2sgbm90IG5lZWRlZCAgYXQgdGhlIG1vbWVudFxuICAgICAgICAvLyAgIGNvbnN0IHlEaXZpc29yID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAody5nbG9iYWxzLnNlcmllcy5sZW5ndGgpXG4gICAgICAgIC8vICAgY29uc3QgaG92ZXJZID0gdHRDdHguY2xpZW50WSAtIHR0Q3R4LnNlcmllc0JvdW5kLnRvcFxuICAgICAgICAvLyAgIGogPSBNYXRoLmNlaWwoaG92ZXJZIC8geURpdmlzb3IpXG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIHR0Q3R4LnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICB0dEl0ZW1zOiBvcHQudHRJdGVtcyxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgc2hhcmVkOiB0dEN0eC5zaG93T25JbnRlcnNlY3QgPyBmYWxzZSA6IHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgeCA9IGNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0ICsgMTU7XG4gICAgICAgICAgICB5ID0gY3kgLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZEhlaWdodCArIGJoIC8gMiAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICAgIHggPSBjeCAtIGJ3IC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHggPSBjeCAtIHR0Q3R4LmRhdGFQb2ludHNEaXZpZGVkV2lkdGggKyBidyAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDIgLSAxNTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4ID0gY3g7XG5cbiAgICAgICAgICAgIGlmICh4IDwgdHRDdHgueHlSYXRpb3MuYmFzZUxpbmVJbnZlcnRlZFkpIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9IGN5IC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRIZWlnaHQgKyBiaCAvIDIgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGNvbHVtbnNcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgICB4ID0gY3ggLSBidyAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4ID0gY3ggLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoICsgYncgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5ID0gY3k7IC8vIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyICsgMTBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgaTogaSxcbiAgICAgICAgajogalxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJzZWN0O1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVG9vbHRpcC5BeGVzVG9vbHRpcCBDbGFzcy5cbiAqXG4gKiBAbW9kdWxlIFRvb2x0aXAuQXhlc1Rvb2x0aXBcbiAqKi9cbnZhciBBeGVzVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4ZXNUb29sdGlwKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF4ZXNUb29sdGlwKTtcblxuICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIHRoZSBzZWNvbmRhcnkgdG9vbHRpcCB3aGljaCBhcHBlYXJzIGJlbG93IHggYXhpc1xuICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgKiovXG5cblxuICBfY3JlYXRlQ2xhc3MoQXhlc1Rvb2x0aXAsIFt7XG4gICAga2V5OiBcImRyYXdYYXhpc1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hheGlzVG9vbHRpcCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciBpc0JvdHRvbSA9IHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgICAgIHR0Q3R4LnhheGlzT2ZmWSA9IGlzQm90dG9tID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyAxIDogMTtcbiAgICAgIHZhciB0b29sdGlwQ3NzQ2xhc3MgPSBpc0JvdHRvbSA/ICdhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b20nIDogJ2FwZXhjaGFydHMteGF4aXN0b29sdGlwIGFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcCc7XG4gICAgICB2YXIgcmVuZGVyVG8gPSB3Lmdsb2JhbHMuZG9tLmVsV3JhcDtcblxuICAgICAgaWYgKHR0Q3R4LmJseGF4aXNUb29sdGlwKSB7XG4gICAgICAgIHZhciB4YXhpc1Rvb2x0aXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAnKTtcblxuICAgICAgICBpZiAoeGF4aXNUb29sdGlwID09PSBudWxsKSB7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0b29sdGlwQ3NzQ2xhc3MpO1xuICAgICAgICAgIHJlbmRlclRvLmFwcGVuZENoaWxkKHR0Q3R4LnhheGlzVG9vbHRpcCk7XG4gICAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdGV4dCcpO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuc3R5bGUuZm9udEZhbWlseSA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuc3R5bGUuZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuc3R5bGUuZm9udFNpemUgPSB3LmNvbmZpZy54YXhpcy50b29sdGlwLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5hcHBlbmRDaGlsZCh0dEN0eC54YXhpc1Rvb2x0aXBUZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIHRoZSBzZWNvbmRhcnkgdG9vbHRpcCB3aGljaCBhcHBlYXJzIGJlbG93IHggYXhpc1xuICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lheGlzVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXNUb29sdGlwKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcuY29uZmlnLnlheGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0ID0gdy5jb25maWcueWF4aXNbaV0ub3Bwb3NpdGUgfHwgdy5jb25maWcueWF4aXNbaV0uY3Jvc3NoYWlycy5vcHBvc2l0ZTtcbiAgICAgICAgdHRDdHgueWF4aXNPZmZYID0gaXNSaWdodCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggKyAxIDogMTtcbiAgICAgICAgdmFyIHRvb2x0aXBDc3NDbGFzcyA9IGlzUmlnaHQgPyBcImFwZXhjaGFydHMteWF4aXN0b29sdGlwIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLVwiLmNvbmNhdChpLCBcIiBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodFwiKSA6IFwiYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtXCIuY29uY2F0KGksIFwiIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnRcIik7XG4gICAgICAgIHZhciByZW5kZXJUbyA9IHcuZ2xvYmFscy5kb20uZWxXcmFwO1xuXG4gICAgICAgIGlmICh0dEN0eC5ibHlheGlzVG9vbHRpcCkge1xuICAgICAgICAgIHZhciB5YXhpc1Rvb2x0aXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXN0b29sdGlwIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLVwiLmNvbmNhdChpKSk7XG5cbiAgICAgICAgICBpZiAoeWF4aXNUb29sdGlwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdG9vbHRpcENzc0NsYXNzKTtcbiAgICAgICAgICAgIHJlbmRlclRvLmFwcGVuZENoaWxkKHR0Q3R4LnlheGlzVG9vbHRpcCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgdHRDdHgueWF4aXNUb29sdGlwVGV4dCA9IFtdO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwVGV4dC5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcFRleHRbaV0uY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtdGV4dCcpO1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwLmFwcGVuZENoaWxkKHR0Q3R4LnlheGlzVG9vbHRpcFRleHRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFhDcm9zc2hhaXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRYQ3Jvc3NoYWlyV2lkdGgoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7IC8vIHNldCB4Y3Jvc3NoYWlycyB3aWR0aFxuXG4gICAgICB2YXIgeGNyb3NzaGFpcnMgPSB0dEN0eC5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gcGFyc2VJbnQody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCk7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAndGlja1dpZHRoJykge1xuICAgICAgICAgIHZhciBjb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gY291bnQ7XG4gICAgICAgIH0gZWxzZSBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgIHZhciBiYXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1iYXItYXJlYScpO1xuXG4gICAgICAgICAgaWYgKGJhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VGbG9hdChiYXIuZ2V0QXR0cmlidXRlKCdiYXJXaWR0aCcpKTtcbiAgICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSBiYXJXaWR0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2JhciA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWJhci1hcmVhJyk7XG5cbiAgICAgICAgaWYgKF9iYXIgIT09IG51bGwgJiYgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICAgIHZhciBfYmFyV2lkdGggPSBwYXJzZUZsb2F0KF9iYXIuZ2V0QXR0cmlidXRlKCdiYXJXaWR0aCcpKTtcblxuICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSBfYmFyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICd0aWNrV2lkdGgnKSB7XG4gICAgICAgICAgICB2YXIgX2NvdW50ID0gdy5nbG9iYWxzLmxhYmVscy5sZW5ndGg7XG4gICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIF9jb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKSB7XG4gICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwgJiYgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA+IDApIHtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVZQ3Jvc3NoYWlyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVlDcm9zc2hhaXIoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7IC8vIHNldCB5Y3Jvc3NoYWlycyBoZWlnaHRcblxuICAgICAgdHRDdHgueWNyb3NzaGFpcnMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycycpO1xuICAgICAgdHRDdHgueWNyb3NzaGFpcnNIaWRkZW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lheGlzVG9vbHRpcFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzVG9vbHRpcFRleHQoaW5kZXgsIGNsaWVudFksIHh5UmF0aW9zKSB7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpbmRleF07XG5cbiAgICAgIGlmICh0dEN0eC5ibHlheGlzVG9vbHRpcCkge1xuICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGhvdmVyWSA9IChjbGllbnRZIC0gc2VyaWVzQm91bmQudG9wKSAqIHh5UmF0aW9zLnlSYXRpb1tpbmRleF07XG4gICAgICAgIHZhciBoZWlnaHQgPSB3Lmdsb2JhbHMubWF4WUFycltpbmRleF0gLSB3Lmdsb2JhbHMubWluWUFycltpbmRleF07XG4gICAgICAgIHZhciB2YWwgPSB3Lmdsb2JhbHMubWluWUFycltpbmRleF0gKyAoaGVpZ2h0IC0gaG92ZXJZKTtcbiAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVZQ3Jvc3NoYWlycyhjbGllbnRZIC0gc2VyaWVzQm91bmQudG9wKTtcbiAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwVGV4dFtpbmRleF0uaW5uZXJIVE1MID0gbGJGb3JtYXR0ZXIodmFsKTtcbiAgICAgICAgdHRDdHgudG9vbHRpcFBvc2l0aW9uLm1vdmVZQXhpc1Rvb2x0aXAoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBeGVzVG9vbHRpcDtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIENvcmUgVG9vbHRpcCBDbGFzcyB0byBoYW5kbGUgdGhlIHRvb2x0aXAgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIFRvb2x0aXBcbiAqKi9cblxudmFyIFRvb2x0aXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb29sdGlwKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMudG9vbHRpcFV0aWwgPSBuZXcgVXRpbHMkMSh0aGlzKTtcbiAgICB0aGlzLnRvb2x0aXBMYWJlbHMgPSBuZXcgTGFiZWxzKHRoaXMpO1xuICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHRoaXMpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IE1hcmtlcih0aGlzKTtcbiAgICB0aGlzLmludGVyc2VjdCA9IG5ldyBJbnRlcnNlY3QodGhpcyk7XG4gICAgdGhpcy5heGVzVG9vbHRpcCA9IG5ldyBBeGVzVG9vbHRpcCh0aGlzKTtcbiAgICB0aGlzLnNob3dPbkludGVyc2VjdCA9IHcuY29uZmlnLnRvb2x0aXAuaW50ZXJzZWN0O1xuICAgIHRoaXMuc2hvd1Rvb2x0aXBUaXRsZSA9IHcuY29uZmlnLnRvb2x0aXAueC5zaG93O1xuICAgIHRoaXMuZml4ZWRUb29sdGlwID0gdy5jb25maWcudG9vbHRpcC5maXhlZC5lbmFibGVkO1xuICAgIHRoaXMueGF4aXNUb29sdGlwID0gbnVsbDtcbiAgICB0aGlzLnlheGlzVFRFbHMgPSBudWxsO1xuICAgIHRoaXMuaXNCYXJIb3Jpem9udGFsID0gdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw7XG4gICAgdGhpcy5pc0JhclNoYXJlZCA9ICF3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCAmJiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xuICAgIGtleTogXCJnZXRFbFRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxUb29sdGlwKGN0eCkge1xuICAgICAgaWYgKCFjdHgpIGN0eCA9IHRoaXM7XG4gICAgICByZXR1cm4gY3R4LncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxYQ3Jvc3NoYWlyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbFhDcm9zc2hhaXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGNyb3NzaGFpcnMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxHcmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsR3JpZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWdyaWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1Rvb2x0aXAoeHlSYXRpb3MpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy54eVJhdGlvcyA9IHh5UmF0aW9zO1xuICAgICAgdGhpcy5ibHhheGlzVG9vbHRpcCA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZW5hYmxlZCAmJiB3Lmdsb2JhbHMuYXhpc0NoYXJ0cztcbiAgICAgIHRoaXMuYmx5YXhpc1Rvb2x0aXAgPSB3LmNvbmZpZy55YXhpc1swXS50b29sdGlwLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmF4aXNDaGFydHM7XG4gICAgICB0aGlzLmFsbFRvb2x0aXBTZXJpZXNHcm91cHMgPSBbXTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwVGl0bGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvb2x0aXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcCcpO1xuICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQody5jb25maWcudG9vbHRpcC50aGVtZSk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hcHBlbmRDaGlsZCh0b29sdGlwRWwpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdGhpcy5heGVzVG9vbHRpcC5kcmF3WGF4aXNUb29sdGlwKCk7XG4gICAgICAgIHRoaXMuYXhlc1Rvb2x0aXAuZHJhd1lheGlzVG9vbHRpcCgpO1xuICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLnNldFhDcm9zc2hhaXJXaWR0aCgpO1xuICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLmhhbmRsZVlDcm9zc2hhaXIoKTtcbiAgICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy54QXhpc1RpY2tzUG9zaXRpb25zID0geEF4aXMuZ2V0WEF4aXNUaWNrc1Bvc2l0aW9ucygpO1xuICAgICAgfSAvLyB3ZSBmb3JjZWZ1bGx5IHNldCBpbnRlcnNlY3QgdHJ1ZSBmb3IgdGhlc2UgY29uZGl0aW9uc1xuXG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkIHx8IHcuY29uZmlnLnRvb2x0aXAuaW50ZXJzZWN0ICYmICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgdGhpcy5zaG93T25JbnRlcnNlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcubWFya2Vycy5zaXplID09PSAwIHx8IHcuZ2xvYmFscy5tYXJrZXJzLmxhcmdlc3RTaXplID09PSAwKSB7XG4gICAgICAgIC8vIHdoZW4gdXNlciBkb24ndCB3YW50IHRvIHNob3cgcG9pbnRzIGFsbCB0aGUgdGltZSwgYnV0IG9ubHkgb24gd2hlbiBob3ZlcmluZyBvbiBzZXJpZXNcbiAgICAgICAgdGhpcy5tYXJrZXIuZHJhd0R5bmFtaWNQb2ludHModGhpcyk7XG4gICAgICB9IC8vIG5vIHZpc2libGUgc2VyaWVzLCBleGl0XG5cblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoID09PSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzRGl2aWRlZEhlaWdodCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICB0aGlzLmRhdGFQb2ludHNEaXZpZGVkV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG5cbiAgICAgIGlmICh0aGlzLnNob3dUb29sdGlwVGl0bGUpIHtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLnN0eWxlLmZvbnRGYW1pbHkgPSB3LmNvbmZpZy50b29sdGlwLnN0eWxlLmZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUuc3R5bGUuZm9udFNpemUgPSB3LmNvbmZpZy50b29sdGlwLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICB0b29sdGlwRWwuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwVGl0bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRJdGVtc0NudCA9IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyAvLyB3aGV0aGVyIHNoYXJlZCBvciBub3QsIGRlZmF1bHQgaXMgc2hhcmVkXG5cbiAgICAgIGlmICgody5nbG9iYWxzLnh5Q2hhcnRzIHx8IHcuZ2xvYmFscy5jb21ib0NoYXJ0cykgJiYgdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dPbkludGVyc2VjdCkge1xuICAgICAgICAgIHR0SXRlbXNDbnQgPSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dEl0ZW1zQ250ID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnR0SXRlbXMgPSB0aGlzLmNyZWF0ZVRURWxlbWVudHModHRJdGVtc0NudCk7XG4gICAgICB0aGlzLmFkZFNWR0V2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUVEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRURWxlbWVudHModHRJdGVtc0NudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRJdGVtcyA9IFtdO1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHRJdGVtc0NudDsgaSsrKSB7XG4gICAgICAgIHZhciBnVHh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGdUeHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cCcpO1xuICAgICAgICB2YXIgcG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHBvaW50LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC1tYXJrZXInKTtcbiAgICAgICAgcG9pbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tpXTtcbiAgICAgICAgZ1R4dC5hcHBlbmRDaGlsZChwb2ludCk7XG4gICAgICAgIHZhciBnWVogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ1laLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0Jyk7XG4gICAgICAgIGdZWi5zdHlsZS5mb250RmFtaWx5ID0gdy5jb25maWcudG9vbHRpcC5zdHlsZS5mb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgIGdZWi5zdHlsZS5mb250U2l6ZSA9IHcuY29uZmlnLnRvb2x0aXAuc3R5bGUuZm9udFNpemU7IC8vIHkgdmFsdWVzIGdyb3VwXG5cbiAgICAgICAgdmFyIGdZVmFsVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnWVZhbFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXktZ3JvdXAnKTtcbiAgICAgICAgdmFyIHR4dExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0eHRMYWJlbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1sYWJlbCcpO1xuICAgICAgICBnWVZhbFRleHQuYXBwZW5kQ2hpbGQodHh0TGFiZWwpO1xuICAgICAgICB2YXIgdHh0VmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHR4dFZhbHVlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXZhbHVlJyk7XG4gICAgICAgIGdZVmFsVGV4dC5hcHBlbmRDaGlsZCh0eHRWYWx1ZSk7IC8vIHogdmFsdWVzIGdyb3VwXG5cbiAgICAgICAgdmFyIGdaVmFsVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnWlZhbFRleHQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXotZ3JvdXAnKTtcbiAgICAgICAgdmFyIHR4dFpMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdHh0WkxhYmVsLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotbGFiZWwnKTtcbiAgICAgICAgZ1pWYWxUZXh0LmFwcGVuZENoaWxkKHR4dFpMYWJlbCk7XG4gICAgICAgIHZhciB0eHRaVmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHR4dFpWYWx1ZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlJyk7XG4gICAgICAgIGdaVmFsVGV4dC5hcHBlbmRDaGlsZCh0eHRaVmFsdWUpO1xuICAgICAgICBnWVouYXBwZW5kQ2hpbGQoZ1lWYWxUZXh0KTtcbiAgICAgICAgZ1laLmFwcGVuZENoaWxkKGdaVmFsVGV4dCk7XG4gICAgICAgIGdUeHQuYXBwZW5kQ2hpbGQoZ1laKTtcbiAgICAgICAgdG9vbHRpcEVsLmFwcGVuZENoaWxkKGdUeHQpO1xuICAgICAgICB0dEl0ZW1zLnB1c2goZ1R4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0dEl0ZW1zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTVkdFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU1ZHRXZlbnRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHlwZSA9IHcuY29uZmlnLmNoYXJ0LnR5cGU7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciBiYXJPckNhbmRsZXN0aWNrID0gISEodHlwZSA9PT0gJ2JhcicgfHwgdHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyk7XG4gICAgICB2YXIgaG92ZXJBcmVhID0gdy5nbG9iYWxzLmRvbS5QYXBlci5ub2RlO1xuICAgICAgdmFyIGVsR3JpZCA9IHRoaXMuZ2V0RWxHcmlkKCk7XG5cbiAgICAgIGlmIChlbEdyaWQpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNCb3VuZCA9IGVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvb2x0aXBZID0gW107XG4gICAgICB2YXIgdG9vbHRpcFggPSBbXTtcbiAgICAgIHZhciBzZXJpZXNIb3ZlclBhcmFtcyA9IHtcbiAgICAgICAgaG92ZXJBcmVhOiBob3ZlckFyZWEsXG4gICAgICAgIGVsR3JpZDogZWxHcmlkLFxuICAgICAgICB0b29sdGlwRWw6IHRvb2x0aXBFbCxcbiAgICAgICAgdG9vbHRpcFk6IHRvb2x0aXBZLFxuICAgICAgICB0b29sdGlwWDogdG9vbHRpcFgsXG4gICAgICAgIHR0SXRlbXM6IHRoaXMudHRJdGVtc1xuICAgICAgfTtcbiAgICAgIHZhciBwb2ludHM7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdsaW5lJyB8fCB0eXBlID09PSAnc2NhdHRlcicgfHwgdHlwZSA9PT0gJ2J1YmJsZScpIHtcbiAgICAgICAgICBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOmxvbmdlc3RTZXJpZXM9J3RydWUnXSAuYXBleGNoYXJ0cy1tYXJrZXJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFyT3JDYW5kbGVzdGljaykge1xuICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1iYXItYXJlYScsICcuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stYXJlYScpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1oZWF0bWFwJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGFyJykge1xuICAgICAgICAgIHBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcG9pbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB0b29sdGlwWS5wdXNoKHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuICAgICAgICAgICAgdG9vbHRpcFgucHVzaChwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbGlkU2hhcmVkQ2hhcnRUeXBlcyA9IHcuZ2xvYmFscy54eUNoYXJ0cyAmJiAhdGhpcy5zaG93T25JbnRlcnNlY3QgfHwgdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF0aGlzLnNob3dPbkludGVyc2VjdCB8fCBiYXJPckNhbmRsZXN0aWNrICYmIHRoaXMuaGFzQmFycygpICYmIHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkO1xuXG4gICAgICBpZiAodmFsaWRTaGFyZWRDaGFydFR5cGVzKSB7XG4gICAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhbaG92ZXJBcmVhXSwgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChiYXJPckNhbmRsZXN0aWNrICYmICF3Lmdsb2JhbHMuY29tYm9DaGFydHMpIHtcbiAgICAgICAgdGhpcy5hZGRCYXJzRXZlbnRMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYnViYmxlJyB8fCB0eXBlID09PSAnc2NhdHRlcicgfHwgdHlwZSA9PT0gJ3JhZGFyJyB8fCB0aGlzLnNob3dPbkludGVyc2VjdCAmJiAodHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdsaW5lJykpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludHNFdmVudHNMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMgfHwgdHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgIHZhciBzZXJpZXNBbGwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMnKTtcbiAgICAgICAgdGhpcy5hZGRQYXRoc0V2ZW50TGlzdGVuZXJzKHNlcmllc0FsbCwgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93T25JbnRlcnNlY3QpIHtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1saW5lLXNlcmllcyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcblxuICAgICAgICBpZiAobGluZVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhbnkgbGluZVNlcmllcywgYWRkRXZlbnRMaXN0ZW5lcnMgZm9yIHRoZW1cbiAgICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMobGluZVBvaW50cywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZWFQb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcblxuICAgICAgICBpZiAoYXJlYVBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhbnkgYXJlYVNlcmllcywgYWRkRXZlbnRMaXN0ZW5lcnMgZm9yIHRoZW1cbiAgICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoYXJlYVBvaW50cywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9IC8vIGNvbWJvIGNoYXJ0cyBtYXkgaGF2ZSBiYXJzLCBzbyBhZGQgZXZlbnQgbGlzdGVuZXJzIGhlcmUgdG9vXG5cblxuICAgICAgICBpZiAodGhpcy5oYXNCYXJzKCkgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgICAgdGhpcy5hZGRCYXJzRXZlbnRMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdGaXhlZFRvb2x0aXBSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdGaXhlZFRvb2x0aXBSZWN0KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdGhpcy5nZXRFbFRvb2x0aXAoKTtcbiAgICAgIHZhciB0b29sdGlwUmVjdCA9IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0dFdpZHRoID0gdG9vbHRpcFJlY3Qud2lkdGggKyAxMDtcbiAgICAgIHZhciB0dEhlaWdodCA9IHRvb2x0aXBSZWN0LmhlaWdodCArIDEwO1xuICAgICAgdmFyIHggPSB3LmNvbmZpZy50b29sdGlwLmZpeGVkLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IHcuY29uZmlnLnRvb2x0aXAuZml4ZWQub2Zmc2V0WTtcblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuZml4ZWQucG9zaXRpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyaWdodCcpID4gLTEpIHtcbiAgICAgICAgeCA9IHggKyB3Lmdsb2JhbHMuc3ZnV2lkdGggLSB0dFdpZHRoICsgMTA7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZpeGVkLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xuICAgICAgICB5ID0geSArIHcuZ2xvYmFscy5zdmdIZWlnaHQgLSB0dEhlaWdodCAtIDEwO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgdHRXaWR0aDogdHRXaWR0aCxcbiAgICAgICAgdHRIZWlnaHQ6IHR0SGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQb2ludHNFdmVudHNMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRzRXZlbnRzTGlzdGVuZXJzKHNlcmllc0hvdmVyUGFyYW1zKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcbiAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhwb2ludHMsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQmFyc0V2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJhcnNFdmVudExpc3RlbmVycyhzZXJpZXNIb3ZlclBhcmFtcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYmFycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJhci1hcmVhLCAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1hcmVhJyk7XG4gICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoYmFycywgc2VyaWVzSG92ZXJQYXJhbXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQYXRoc0V2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMocGF0aHMsIG9wdHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocCkge1xuICAgICAgICB2YXIgZXh0ZW5kZWRPcHRzID0ge1xuICAgICAgICAgIHBhdGhzOiBwYXRoc1twXSxcbiAgICAgICAgICB0b29sdGlwRWw6IG9wdHMudG9vbHRpcEVsLFxuICAgICAgICAgIHRvb2x0aXBZOiBvcHRzLnRvb2x0aXBZLFxuICAgICAgICAgIHRvb2x0aXBYOiBvcHRzLnRvb2x0aXBYLFxuICAgICAgICAgIGVsR3JpZDogb3B0cy5lbEdyaWQsXG4gICAgICAgICAgaG92ZXJBcmVhOiBvcHRzLmhvdmVyQXJlYSxcbiAgICAgICAgICB0dEl0ZW1zOiBvcHRzLnR0SXRlbXNcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudy5nbG9iYWxzLnRvb2x0aXBPcHRzID0gZXh0ZW5kZWRPcHRzO1xuICAgICAgICB2YXIgZXZlbnRzID0gWydtb3VzZW1vdmUnLCAndG91Y2htb3ZlJywgJ21vdXNlb3V0JywgJ3RvdWNoZW5kJ107XG4gICAgICAgIGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGhzW3BdLmFkZEV2ZW50TGlzdGVuZXIoZXYsIHNlbGYuc2VyaWVzSG92ZXIuYmluZChzZWxmLCBleHRlbmRlZE9wdHMpLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIF9sb29wKHApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAqKiBUaGUgYWN0dWFsIHNlcmllcyBob3ZlciBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWVzSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWVzSG92ZXIob3B0LCBlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNoYXJ0R3JvdXBzID0gW107XG4gICAgICB2YXIgdyA9IHRoaXMudzsgLy8gaWYgdXNlciBoYXMgbW9yZSB0aGFuIG9uZSBjaGFydHMgaW4gZ3JvdXAsIHdlIG5lZWQgdG8gc3luY1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuZ3JvdXApIHtcbiAgICAgICAgY2hhcnRHcm91cHMgPSB0aGlzLmN0eC5nZXRHcm91cGVkQ2hhcnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyAmJiAody5nbG9iYWxzLm1pblggPT09IC1JbmZpbml0eSAmJiB3Lmdsb2JhbHMubWF4WCA9PT0gSW5maW5pdHkgfHwgdy5nbG9iYWxzLmRhdGFQb2ludHMgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0R3JvdXBzLmxlbmd0aCkge1xuICAgICAgICBjaGFydEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIHZhciB0b29sdGlwRWwgPSBfdGhpczIuZ2V0RWxUb29sdGlwKGNoKTtcblxuICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgcGF0aHM6IG9wdC5wYXRocyxcbiAgICAgICAgICAgIHRvb2x0aXBFbDogdG9vbHRpcEVsLFxuICAgICAgICAgICAgdG9vbHRpcFk6IG9wdC50b29sdGlwWSxcbiAgICAgICAgICAgIHRvb2x0aXBYOiBvcHQudG9vbHRpcFgsXG4gICAgICAgICAgICBlbEdyaWQ6IG9wdC5lbEdyaWQsXG4gICAgICAgICAgICBob3ZlckFyZWE6IG9wdC5ob3ZlckFyZWEsXG4gICAgICAgICAgICB0dEl0ZW1zOiBjaC53Lmdsb2JhbHMudG9vbHRpcC50dEl0ZW1zIC8vIGFsbCB0aGUgY2hhcnRzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG1pblggYW5kIG1heFggKHNhbWUgeGF4aXMpIGZvciBtdWx0aXBsZSB0b29sdGlwcyB0byB3b3JrIGNvcnJlY3RseVxuXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChjaC53Lmdsb2JhbHMubWluWCA9PT0gX3RoaXMyLncuZ2xvYmFscy5taW5YICYmIGNoLncuZ2xvYmFscy5tYXhYID09PSBfdGhpczIudy5nbG9iYWxzLm1heFgpIHtcbiAgICAgICAgICAgIGNoLncuZ2xvYmFscy50b29sdGlwLnNlcmllc0hvdmVyQnlDb250ZXh0KHtcbiAgICAgICAgICAgICAgY2hhcnRDdHg6IGNoLFxuICAgICAgICAgICAgICB0dEN0eDogY2gudy5nbG9iYWxzLnRvb2x0aXAsXG4gICAgICAgICAgICAgIG9wdDogbmV3T3B0cyxcbiAgICAgICAgICAgICAgZTogZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VyaWVzSG92ZXJCeUNvbnRleHQoe1xuICAgICAgICAgIGNoYXJ0Q3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICB0dEN0eDogdGhpcy53Lmdsb2JhbHMudG9vbHRpcCxcbiAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICBlOiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpZXNIb3ZlckJ5Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpZXNIb3ZlckJ5Q29udGV4dChfcmVmKSB7XG4gICAgICB2YXIgY2hhcnRDdHggPSBfcmVmLmNoYXJ0Q3R4LFxuICAgICAgICAgIHR0Q3R4ID0gX3JlZi50dEN0eCxcbiAgICAgICAgICBvcHQgPSBfcmVmLm9wdCxcbiAgICAgICAgICBlID0gX3JlZi5lO1xuICAgICAgdmFyIHcgPSBjaGFydEN0eC53O1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7IC8vIHRvb2x0aXBSZWN0IGlzIGNhbGN1bGF0ZWQgb24gZXZlcnkgbW91c2Vtb3ZlLCBiZWNhdXNlIHRoZSB0ZXh0IGlzIGR5bmFtaWNcblxuICAgICAgdHRDdHgudG9vbHRpcFJlY3QgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHR0V2lkdGg6IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgdHRIZWlnaHQ6IHRvb2x0aXBFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIH07XG4gICAgICB0dEN0eC5lID0gZTsgLy8gaGlnaGxpZ2h0IHRoZSBjdXJyZW50IGhvdmVyZWQgYmFyc1xuXG4gICAgICBpZiAodHRDdHguaGFzQmFycygpICYmICF3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgIXR0Q3R4LmlzQmFyU2hhcmVkKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLm9uRGF0YXNldEhvdmVyLmhpZ2hsaWdodERhdGFTZXJpZXMpIHtcbiAgICAgICAgICB2YXIgc2VyaWVzID0gbmV3IFNlcmllcyhjaGFydEN0eCk7XG4gICAgICAgICAgc2VyaWVzLnRvZ2dsZVNlcmllc09uSG92ZXIoZSwgZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICB0dEN0eC5kcmF3Rml4ZWRUb29sdGlwUmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdHRDdHguYXhpc0NoYXJ0c1Rvb2x0aXBzKHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgIHRvb2x0aXBSZWN0OiB0dEN0eC50b29sdGlwUmVjdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbi1wbG90IGNoYXJ0cyBpLmUgcGllL2RvbnV0L2NpcmNsZVxuICAgICAgICB0dEN0eC5ub25BeGlzQ2hhcnRzVG9vbHRpcHMoe1xuICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgdG9vbHRpcFJlY3Q6IHR0Q3R4LnRvb2x0aXBSZWN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gdG9vbHRpcCBoYW5kbGluZyBmb3IgbGluZS9hcmVhL2Jhci9jb2x1bW5zL3NjYXR0ZXJcblxuICB9LCB7XG4gICAga2V5OiBcImF4aXNDaGFydHNUb29sdGlwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBheGlzQ2hhcnRzVG9vbHRpcHMoX3JlZjIpIHtcbiAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMi5vcHQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBqLCB4LCB5O1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNhcGogPSBudWxsO1xuICAgICAgdmFyIHNlcmllc0JvdW5kID0gb3B0LmVsR3JpZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuICAgICAgdmFyIGNsaWVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG4gICAgICB0aGlzLmNsaWVudFkgPSBjbGllbnRZO1xuICAgICAgdGhpcy5jbGllbnRYID0gY2xpZW50WDtcblxuICAgICAgaWYgKGNsaWVudFkgPCBzZXJpZXNCb3VuZC50b3AgfHwgY2xpZW50WSA+IHNlcmllc0JvdW5kLnRvcCArIHNlcmllc0JvdW5kLmhlaWdodCkge1xuICAgICAgICBzZWxmLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgeGNyb3NzaGFpcnMgPSB0aGlzLmdldEVsWENyb3NzaGFpcnMoKTtcbiAgICAgIHZhciBpc1N0aWNreVRvb2x0aXAgPSB3Lmdsb2JhbHMueHlDaGFydHMgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgIXRoaXMuaXNCYXJIb3Jpem9udGFsICYmIHRoaXMuaGFzQmFycygpICYmIHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkIHx8IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiB0aGlzLmhhc0JhcnM7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLmlzQmFySG9yaXpvbnRhbCAmJiB0aGlzLmhhc0JhcnMoKSkge1xuICAgICAgICBpc1N0aWNreVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnljcm9zc2hhaXJzICE9PSBudWxsICYmIHNlbGYuYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgICBzZWxmLnljcm9zc2hhaXJzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3RpY2t5VG9vbHRpcCAmJiAhc2VsZi5zaG93T25JbnRlcnNlY3QpIHtcbiAgICAgICAgICBjYXBqID0gc2VsZi50b29sdGlwVXRpbC5nZXROZWFyZXN0VmFsdWVzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlbGYsXG4gICAgICAgICAgICBob3ZlckFyZWE6IG9wdC5ob3ZlckFyZWEsXG4gICAgICAgICAgICBlbEdyaWQ6IG9wdC5lbEdyaWQsXG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WSxcbiAgICAgICAgICAgIGhhc0JhcnM6IHNlbGYuaGFzQmFyc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGogPSBjYXBqLmo7XG4gICAgICAgICAgdmFyIGNhcHR1cmVkU2VyaWVzID0gY2Fwai5jYXB0dXJlZFNlcmllcztcblxuICAgICAgICAgIGlmIChjYXBqLmhvdmVyWCA8IDAgfHwgY2Fwai5ob3ZlclggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhcHR1cmVkU2VyaWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaWdub3JlTnVsbCA9IHcuZ2xvYmFscy5zZXJpZXNbY2FwdHVyZWRTZXJpZXNdW2pdID09PSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlTnVsbCkge1xuICAgICAgICAgICAgICBvcHQudG9vbHRpcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnNlcmllc1tjYXB0dXJlZFNlcmllc11bal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLnNoYXJlZCAmJiB0aGlzLnRvb2x0aXBVdGlsLmlzWG92ZXJsYXAoaikgJiYgdGhpcy50b29sdGlwVXRpbC5pc2luaXRpYWxTZXJpZXNTYW1lTGVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShzZWxmLCBjYXB0dXJlZFNlcmllcywgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKHNlbGYsIGNhcHR1cmVkU2VyaWVzLCBqLCBvcHQudHRJdGVtcywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy50b29sdGlwVXRpbC5pc1hvdmVybGFwKGopKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jcmVhdGUoc2VsZiwgMCwgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvdWxkbid0IGNhcHR1cmUgYW55IHNlcmllcy4gY2hlY2sgaWYgc2hhcmVkIFggaXMgc2FtZSxcbiAgICAgICAgICAgIC8vIGlmIHllcywgZHJhdyBhIGdyb3VwZWQgdG9vbHRpcFxuICAgICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaXNYb3ZlcmxhcChqKSkge1xuICAgICAgICAgICAgICBzZWxmLmNyZWF0ZShzZWxmLCAwLCBqLCBvcHQudHRJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJYWSA9IHRoaXMuaW50ZXJzZWN0LmhhbmRsZUhlYXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeCA9IG1hcmtlclhZLng7XG4gICAgICAgICAgICB5ID0gbWFya2VyWFkueTtcbiAgICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0JhcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QuaGFuZGxlQmFyVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBvcHQ6IG9wdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTWFya2Vycykge1xuICAgICAgICAgICAgICAvLyBpbnRlcnNlY3QgLSBsaW5lL2FyZWEvc2NhdHRlci9idWJibGVcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QuaGFuZGxlTWFya2VyVG9vbHRpcCh7XG4gICAgICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgICBmb3IgKHZhciB5dCA9IDA7IHl0IDwgdy5jb25maWcueWF4aXMubGVuZ3RoOyB5dCsrKSB7XG4gICAgICAgICAgICBzZWxmLmF4ZXNUb29sdGlwLmRyYXdZYXhpc1Rvb2x0aXBUZXh0KHl0LCBjbGllbnRZLCBzZWxmLnh5UmF0aW9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQudG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VPdXQob3B0KTtcbiAgICAgIH1cbiAgICB9IC8vIHRvb2x0aXAgaGFuZGxpbmcgZm9yIHBpZS9kb251dHNcblxuICB9LCB7XG4gICAga2V5OiBcIm5vbkF4aXNDaGFydHNUb29sdGlwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub25BeGlzQ2hhcnRzVG9vbHRpcHMoX3JlZjMpIHtcbiAgICAgIHZhciBlID0gX3JlZjMuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMy5vcHQsXG4gICAgICAgICAgdG9vbHRpcFJlY3QgPSBfcmVmMy50b29sdGlwUmVjdDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJlbCA9IG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgdHJYID0gMDtcbiAgICAgIHZhciB0clkgPSAwO1xuICAgICAgdmFyIGVsUGllID0gbnVsbDtcbiAgICAgIHZhciBjbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGlhbEJhcicpIHtcbiAgICAgICAgZWxQaWUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1yYWRpYWxiYXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsUGllID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtcGllJyk7XG4gICAgICAgIHRyWCA9IHBhcnNlSW50KGVsUGllLmdldEF0dHJpYnV0ZSgnZGF0YTppbm5lclRyYW5zbGF0ZVgnKSk7XG4gICAgICAgIHRyWSA9IHBhcnNlSW50KGVsUGllLmdldEF0dHJpYnV0ZSgnZGF0YTppbm5lclRyYW5zbGF0ZVknKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpZXNCb3VuZCA9IGVsUGllLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgaTogcGFyc2VJbnQocmVsKSAtIDEsXG4gICAgICAgICAgc2hhcmVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHggPSBjbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdCAtIHRvb2x0aXBSZWN0LnR0V2lkdGggLyAyLjIgKyB0clg7XG4gICAgICAgIHZhciB5ID0gZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wIC0gdG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyIC0gMTUgKyB0clk7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeCArIHRvb2x0aXBSZWN0LnR0V2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgeCA9IGNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0IC0gdG9vbHRpcFJlY3QudHRXaWR0aCArIHRyWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgMCkgeSA9IHRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgMjA7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0geCArIHcuZ2xvYmFscy50cmFuc2xhdGVYICsgJ3B4JztcbiAgICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZUhvdmVyRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVIb3ZlckZpbHRlcigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBhbGxQYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiLmFwZXhjaGFydHMtYmFyLWFyZWFcIik7XG5cbiAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYWxsUGF0aHMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUoYWxsUGF0aHNbYl0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3VzZU91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZU91dChvcHQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdGhpcy5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICBvcHQudG9vbHRpcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgdGhpcy5kZWFjdGl2YXRlSG92ZXJGaWx0ZXIoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnKSB7XG4gICAgICAgIHRoaXMubWFya2VyLnJlc2V0UG9pbnRzU2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgeGNyb3NzaGFpcnMuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnljcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMueWNyb3NzaGFpcnMuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJseGF4aXNUb29sdGlwKSB7XG4gICAgICAgIHRoaXMueGF4aXNUb29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ibHlheGlzVG9vbHRpcCkge1xuICAgICAgICBpZiAodGhpcy55YXhpc1RURWxzID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy55YXhpc1RURWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteWF4aXN0b29sdGlwJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueWF4aXNUVEVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMueWF4aXNUVEVsc1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxNYXJrZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFsbE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsTWFya2VycygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIC5hcGV4Y2hhcnRzLW1hcmtlcicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc01hcmtlcnMoKSB7XG4gICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0RWxNYXJrZXJzKCk7XG4gICAgICByZXR1cm4gbWFya2Vycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbEJhcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxCYXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtYmFyLXNlcmllcywgIC5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0JhcnMoKSB7XG4gICAgICB2YXIgYmFycyA9IHRoaXMuZ2V0RWxCYXJzKCk7XG4gICAgICByZXR1cm4gYmFycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKGNvbnRleHQsIGNhcHR1cmVkU2VyaWVzLCBqLCB0dEl0ZW1zKSB7XG4gICAgICB2YXIgc2hhcmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2VsZiA9IGNvbnRleHQ7XG4gICAgICBpZiAoc2hhcmVkID09PSBudWxsKSBzaGFyZWQgPSB3LmNvbmZpZy50b29sdGlwLnNoYXJlZDtcbiAgICAgIHZhciBoYXNNYXJrZXJzID0gdGhpcy5oYXNNYXJrZXJzKCk7XG4gICAgICB2YXIgYmFycyA9IHRoaXMuZ2V0RWxCYXJzKCk7XG5cbiAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgc2VsZi50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogdHRJdGVtcyxcbiAgICAgICAgICBpOiBjYXB0dXJlZFNlcmllcyxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNoYXJlZDogdGhpcy5zaG93T25JbnRlcnNlY3QgPyBmYWxzZSA6IHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLmxhcmdlc3RTaXplID4gMCkge1xuICAgICAgICAgICAgc2VsZi5tYXJrZXIuZW5sYXJnZVBvaW50cyhqKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi50b29sdGlwUG9zaXRpb24ubW92ZUR5bmFtaWNQb2ludHNPbkhvdmVyKGopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0JhcnMoKSkge1xuICAgICAgICAgIHRoaXMuYmFyU2VyaWVzSGVpZ2h0ID0gdGhpcy50b29sdGlwVXRpbC5nZXRCYXJzSGVpZ2h0KGJhcnMpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYmFyU2VyaWVzSGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgLy8gaG92ZXIgc3RhdGUsIGFjdGl2YXRlIHNuYXAgZmlsdGVyXG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdy5nbG9iYWxzLmRvbS5QYXBlci5zZWxlY3QoXCIuYXBleGNoYXJ0cy1iYXItYXJlYVtqPSdcIi5jb25jYXQoaiwgXCInXVwiKSk7IC8vIGRlLWFjdGl2YXRlIGZpcnN0XG5cbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUhvdmVyRmlsdGVyKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbi5tb3ZlU3RpY2t5VG9vbHRpcE92ZXJCYXJzKGopO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHBhdGhzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyKHBhdGhzW2JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgdHRJdGVtczogdHRJdGVtcyxcbiAgICAgICAgICBpOiBjYXB0dXJlZFNlcmllcyxcbiAgICAgICAgICBqOiBqXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0JhcnMoKSkge1xuICAgICAgICAgIHNlbGYudG9vbHRpcFBvc2l0aW9uLm1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnMoaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgICAgIHNlbGYudG9vbHRpcFBvc2l0aW9uLm1vdmVNYXJrZXJzKGNhcHR1cmVkU2VyaWVzLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb29sdGlwO1xufSgpO1xuXG52YXIgaWNvUGFuID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIGZpbGw9XFxcIiMwMDAwMDBcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgd2lkdGg9XFxcIjI0XFxcIj5cXG4gICAgPGRlZnM+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBpZD1cXFwiYVxcXCIvPlxcbiAgICA8L2RlZnM+XFxuICAgIDxjbGlwUGF0aCBpZD1cXFwiYlxcXCI+XFxuICAgICAgICA8dXNlIG92ZXJmbG93PVxcXCJ2aXNpYmxlXFxcIiB4bGluazpocmVmPVxcXCIjYVxcXCIvPlxcbiAgICA8L2NsaXBQYXRoPlxcbiAgICA8cGF0aCBjbGlwLXBhdGg9XFxcInVybCgjYilcXFwiIGQ9XFxcIk0yMyA1LjVWMjBjMCAyLjItMS44IDQtNCA0aC03LjNjLTEuMDggMC0yLjEtLjQzLTIuODUtMS4xOUwxIDE0LjgzczEuMjYtMS4yMyAxLjMtMS4yNWMuMjItLjE5LjQ5LS4yOS43OS0uMjkuMjIgMCAuNDIuMDYuNi4xNi4wNC4wMSA0LjMxIDIuNDYgNC4zMSAyLjQ2VjRjMC0uODMuNjctMS41IDEuNS0xLjVTMTEgMy4xNyAxMSA0djdoMVYxLjVjMC0uODMuNjctMS41IDEuNS0xLjVTMTUgLjY3IDE1IDEuNVYxMWgxVjIuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNVYxMWgxVjUuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNXpcXFwiLz5cXG48L3N2Zz5cIjtcblxudmFyIGljb1pvb20gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBmaWxsPVxcXCIjMDAwMDAwXFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0elxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDBWMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTEyIDEwaC0ydjJIOXYtMkg3VjloMlY3aDF2MmgydjF6XFxcIi8+XFxuPC9zdmc+XCI7XG5cbnZhciBpY29SZXNldCA9IFwiPHN2ZyBmaWxsPVxcXCIjMDAwMDAwXFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTEwIDIwdi02aDR2Nmg1di04aDNMMTIgMyAyIDEyaDN2OHpcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbjwvc3ZnPlwiO1xuXG52YXIgaWNvWm9vbUluID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBmaWxsPVxcXCJub25lXFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMyA3aC0ydjRIN3YyaDR2NGgydi00aDR2LTJoLTRWN3ptLTEtNUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XFxcIi8+XFxuPC9zdmc+XFxuXCI7XG5cbnZhciBpY29ab29tT3V0ID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBmaWxsPVxcXCJub25lXFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk03IDExdjJoMTB2LTJIN3ptNS05QzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHpcXFwiLz5cXG48L3N2Zz5cXG5cIjtcblxudmFyIGljb1NlbGVjdCA9IFwiPHN2ZyBmaWxsPVxcXCIjNkU4MTkyXFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNMyA1aDJWM2MtMS4xIDAtMiAuOS0yIDJ6bTAgOGgydi0ySDN2MnptNCA4aDJ2LTJIN3Yyek0zIDloMlY3SDN2MnptMTAtNmgtMnYyaDJWM3ptNiAwdjJoMmMwLTEuMS0uOS0yLTItMnpNNSAyMXYtMkgzYzAgMS4xLjkgMiAyIDJ6bS0yLTRoMnYtMkgzdjJ6TTkgM0g3djJoMlYzem0yIDE4aDJ2LTJoLTJ2MnptOC04aDJ2LTJoLTJ2MnptMCA4YzEuMSAwIDItLjkgMi0yaC0ydjJ6bTAtMTJoMlY3aC0ydjJ6bTAgOGgydi0yaC0ydjJ6bS00IDRoMnYtMmgtMnYyem0wLTE2aDJWM2gtMnYyelxcXCIvPlxcbjwvc3ZnPlwiO1xuXG52YXIgaWNvTWVudSA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBkPVxcXCJNMCAwaDI0djI0SDBWMHpcXFwiLz48cGF0aCBkPVxcXCJNMyAxOGgxOHYtMkgzdjJ6bTAtNWgxOHYtMkgzdjJ6bTAtN3YyaDE4VjZIM3pcXFwiLz48L3N2Zz5cIjtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2xiYXIgQ2xhc3MgZm9yIGNyZWF0aW5nIHRvb2xiYXIgaW4gYXhpcyBiYXNlZCBjaGFydHMuXG4gKlxuICogQG1vZHVsZSBUb29sYmFyXG4gKiovXG5cbnZhciBUb29sYmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbGJhcihjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbGJhcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmV2ID0gdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHM7XG4gICAgdGhpcy5sb2NhbGVWYWx1ZXMgPSB0aGlzLncuZ2xvYmFscy5sb2NhbGUudG9vbGJhcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb29sYmFyLCBbe1xuICAgIGtleTogXCJjcmVhdGVUb29sYmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRvb2xiYXIoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbFRvb2xiYXJXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBlbFRvb2xiYXJXcmFwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYXBleGNoYXJ0cy10b29sYmFyJyk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hcHBlbmRDaGlsZChlbFRvb2xiYXJXcmFwKTtcbiAgICAgIHRoaXMuZWxab29tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmVsWm9vbUluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmVsWm9vbU91dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFBhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFpvb21SZXNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbE1lbnVJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmVsTWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbEN1c3RvbUljb25zID0gW107XG4gICAgICB0aGlzLnQgPSB3LmNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnQuY3VzdG9tSWNvbnMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50LmN1c3RvbUljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5lbEN1c3RvbUljb25zLnB1c2goZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxNZW51SXRlbXMgPSBbXTtcbiAgICAgIHZhciB0b29sYmFyQ29udHJvbHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMudC56b29taW4gJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFpvb21JbixcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50Lnpvb21pbiA9PT0gJ3N0cmluZycgPyB0aGlzLnQuem9vbWluIDogaWNvWm9vbUluLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy56b29tSW4sXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXpvb20taW4taWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnQuem9vbW91dCAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsWm9vbU91dCxcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50Lnpvb21vdXQgPT09ICdzdHJpbmcnID8gdGhpcy50Lnpvb21vdXQgOiBpY29ab29tT3V0LFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy56b29tT3V0LFxuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy16b29tLW91dC1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC56b29tICYmIHcuY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxab29tLFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQuem9vbSA9PT0gJ3N0cmluZycgPyB0aGlzLnQuem9vbSA6IGljb1pvb20sXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLnNlbGVjdGlvblpvb20sXG4gICAgICAgICAgY2xhc3M6IHcuZ2xvYmFscy5pc1RvdWNoRGV2aWNlID8gJ2hpZGRlbicgOiAnYXBleGNoYXJ0cy16b29tLWljb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50LnNlbGVjdGlvbiAmJiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxTZWxlY3Rpb24sXG4gICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC5zZWxlY3Rpb24gPT09ICdzdHJpbmcnID8gdGhpcy50LnNlbGVjdGlvbiA6IGljb1NlbGVjdCxcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuc2VsZWN0aW9uLFxuICAgICAgICAgIGNsYXNzOiB3Lmdsb2JhbHMuaXNUb3VjaERldmljZSA/ICdoaWRkZW4nIDogJ2FwZXhjaGFydHMtc2VsZWN0aW9uLWljb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50LnBhbiAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsUGFuLFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQucGFuID09PSAnc3RyaW5nJyA/IHRoaXMudC5wYW4gOiBpY29QYW4sXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLnBhbixcbiAgICAgICAgICBjbGFzczogdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UgPyAnaGlkZGVuJyA6ICdhcGV4Y2hhcnRzLXBhbi1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5yZXNldCAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsWm9vbVJlc2V0LFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQucmVzZXQgPT09ICdzdHJpbmcnID8gdGhpcy50LnJlc2V0IDogaWNvUmVzZXQsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLnJlc2V0LFxuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50LmRvd25sb2FkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbE1lbnVJY29uLFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQuZG93bmxvYWQgPT09ICdzdHJpbmcnID8gdGhpcy50LmRvd25sb2FkIDogaWNvTWVudSxcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMubWVudSxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtbWVudS1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuZWxDdXN0b21JY29ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsQ3VzdG9tSWNvbnNbX2ldLFxuICAgICAgICAgIGljb246IHRoaXMudC5jdXN0b21JY29uc1tfaV0uaWNvbixcbiAgICAgICAgICB0aXRsZTogdGhpcy50LmN1c3RvbUljb25zW19pXS50aXRsZSxcbiAgICAgICAgICBpbmRleDogdGhpcy50LmN1c3RvbUljb25zW19pXS5pbmRleCxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtdG9vbGJhci1jdXN0b20taWNvbiAnICsgdGhpcy50LmN1c3RvbUljb25zW19pXS5jbGFzc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdG9vbGJhckNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKHQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0LmluZGV4KSB7XG4gICAgICAgICAgVXRpbHMubW92ZUluZGV4SW5BcnJheSh0b29sYmFyQ29udHJvbHMsIGluZGV4LCB0LmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRvb2xiYXJDb250cm9scy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHRvb2xiYXJDb250cm9sc1tfaTJdLmVsLCB7XG4gICAgICAgICAgY2xhc3M6IHRvb2xiYXJDb250cm9sc1tfaTJdLmNsYXNzLFxuICAgICAgICAgIHRpdGxlOiB0b29sYmFyQ29udHJvbHNbX2kyXS50aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzW19pMl0uZWwuaW5uZXJIVE1MID0gdG9vbGJhckNvbnRyb2xzW19pMl0uaWNvbjtcbiAgICAgICAgZWxUb29sYmFyV3JhcC5hcHBlbmRDaGlsZCh0b29sYmFyQ29udHJvbHNbX2kyXS5lbCk7XG4gICAgICB9XG5cbiAgICAgIGVsVG9vbGJhcldyYXAuYXBwZW5kQ2hpbGQodGhpcy5lbE1lbnUpO1xuICAgICAgR3JhcGhpY3Muc2V0QXR0cnModGhpcy5lbE1lbnUsIHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLW1lbnUnXG4gICAgICB9KTtcbiAgICAgIHZhciBtZW51SXRlbXMgPSBbe1xuICAgICAgICBuYW1lOiAnZXhwb3J0U1ZHJyxcbiAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLmV4cG9ydFRvU1ZHXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdleHBvcnRQTkcnLFxuICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuZXhwb3J0VG9QTkdcbiAgICAgIH1dO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBtZW51SXRlbXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB0aGlzLmVsTWVudUl0ZW1zLnB1c2goZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICB0aGlzLmVsTWVudUl0ZW1zW19pM10uaW5uZXJIVE1MID0gbWVudUl0ZW1zW19pM10udGl0bGU7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHRoaXMuZWxNZW51SXRlbXNbX2kzXSwge1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtbWVudS1pdGVtIFwiLmNvbmNhdChtZW51SXRlbXNbX2kzXS5uYW1lKSxcbiAgICAgICAgICB0aXRsZTogbWVudUl0ZW1zW19pM10udGl0bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxNZW51LmFwcGVuZENoaWxkKHRoaXMuZWxNZW51SXRlbXNbX2kzXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnBhbkVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbFBhbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkVG9vbGJhckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRvb2xiYXJFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb29sYmFyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmVsWm9vbVJlc2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tUmVzZXQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsU2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVTZWxlY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsWm9vbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlWm9vbWluZy5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxab29tSW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVpvb21Jbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxab29tT3V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tT3V0LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbFBhbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlUGFubmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxNZW51SWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxNZW51SXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydFNWRycpKSB7XG4gICAgICAgICAgbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLmRvd25sb2FkU1ZHLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtLmNsYXNzTGlzdC5jb250YWlucygnZXhwb3J0UE5HJykpIHtcbiAgICAgICAgICBtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMuZG93bmxvYWRQTkcuYmluZChfdGhpcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQuY3VzdG9tSWNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbEN1c3RvbUljb25zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50LmN1c3RvbUljb25zW2ldLmNsaWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCA9ICF0aGlzLncuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkO1xuXG4gICAgICBpZiAoIXRoaXMuZWxTZWxlY3Rpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuZWxTZWxlY3Rpb24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxTZWxlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlWm9vbWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVab29taW5nKCkge1xuICAgICAgdGhpcy50b2dnbGVPdGhlckNvbnRyb2xzKCk7XG4gICAgICB0aGlzLncuZ2xvYmFscy56b29tRW5hYmxlZCA9ICF0aGlzLncuZ2xvYmFscy56b29tRW5hYmxlZDtcblxuICAgICAgaWYgKCF0aGlzLmVsWm9vbS5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvb2xiYXJJY29uc1JlZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb29sYmFySWNvbnNSZWZlcmVuY2UoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCF0aGlzLmVsWm9vbSkge1xuICAgICAgICB0aGlzLmVsWm9vbSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXpvb20taWNvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWxQYW4pIHtcbiAgICAgICAgdGhpcy5lbFBhbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXBhbi1pY29uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlWm9vbWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVab29taW5nKCkge1xuICAgICAgdGhpcy50b2dnbGVPdGhlckNvbnRyb2xzKCk7XG4gICAgICB0aGlzLncuZ2xvYmFscy56b29tRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmVsWm9vbSkge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbFBhbikge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVBhbm5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlUGFubmluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMucGFuRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmVsUGFuKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxab29tKSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVBhbm5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlUGFubmluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMucGFuRW5hYmxlZCA9ICF0aGlzLncuZ2xvYmFscy5wYW5FbmFibGVkO1xuXG4gICAgICBpZiAoIXRoaXMuZWxQYW4uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlT3RoZXJDb250cm9sc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVPdGhlckNvbnRyb2xzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMucGFuRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLnpvb21FbmFibGVkID0gZmFsc2U7XG4gICAgICB3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5nZXRUb29sYmFySWNvbnNSZWZlcmVuY2UoKTtcblxuICAgICAgaWYgKHRoaXMuZWxQYW4pIHtcbiAgICAgICAgdGhpcy5lbFBhbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsWm9vbSkge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVab29tSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlWm9vbUluKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY2VudGVyWCA9ICh3Lmdsb2JhbHMubWluWCArIHcuZ2xvYmFscy5tYXhYKSAvIDI7XG4gICAgICB2YXIgbmV3TWluWCA9ICh3Lmdsb2JhbHMubWluWCArIGNlbnRlclgpIC8gMjtcbiAgICAgIHZhciBuZXdNYXhYID0gKHcuZ2xvYmFscy5tYXhYICsgY2VudGVyWCkgLyAyO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5kaXNhYmxlWm9vbUluKSB7XG4gICAgICAgIHRoaXMuem9vbVVwZGF0ZU9wdGlvbnMobmV3TWluWCwgbmV3TWF4WCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVpvb21PdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlWm9vbU91dCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBhdm9pZCB6b29taW5nIG91dCBiZXlvbmQgMTAwMCB3aGljaCBtYXkgcmVzdWx0IGluIE5hTiB2YWx1ZXMgYmVpbmcgcHJpbnRlZCBvbiB4LWF4aXNcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScgJiYgbmV3IERhdGUody5nbG9iYWxzLm1pblgpLmdldFVUQ0Z1bGxZZWFyKCkgPCAxMDAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbnRlclggPSAody5nbG9iYWxzLm1pblggKyB3Lmdsb2JhbHMubWF4WCkgLyAyO1xuICAgICAgdmFyIG5ld01pblggPSB3Lmdsb2JhbHMubWluWCAtIChjZW50ZXJYIC0gdy5nbG9iYWxzLm1pblgpO1xuICAgICAgdmFyIG5ld01heFggPSB3Lmdsb2JhbHMubWF4WCAtIChjZW50ZXJYIC0gdy5nbG9iYWxzLm1heFgpO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5kaXNhYmxlWm9vbU91dCkge1xuICAgICAgICB0aGlzLnpvb21VcGRhdGVPcHRpb25zKG5ld01pblgsIG5ld01heFgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tVXBkYXRlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tVXBkYXRlT3B0aW9ucyhuZXdNaW5YLCBuZXdNYXhYKSB7XG4gICAgICB2YXIgeGF4aXMgPSB7XG4gICAgICAgIG1pbjogbmV3TWluWCxcbiAgICAgICAgbWF4OiBuZXdNYXhYXG4gICAgICB9O1xuICAgICAgdmFyIGJlZm9yZVpvb21SYW5nZSA9IHRoaXMuZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzKTtcblxuICAgICAgaWYgKGJlZm9yZVpvb21SYW5nZSkge1xuICAgICAgICB4YXhpcyA9IGJlZm9yZVpvb21SYW5nZS54YXhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbWVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5jdHguX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgIH0sIGZhbHNlLCB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcblxuICAgICAgdGhpcy56b29tQ2FsbGJhY2soeGF4aXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbUNhbGxiYWNrKHhheGlzLCB5YXhpcykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmV2Lnpvb21lZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmV2Lnpvb21lZCh0aGlzLmN0eCwge1xuICAgICAgICAgIHhheGlzOiB4YXhpcyxcbiAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJlZm9yZVpvb21SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCZWZvcmVab29tUmFuZ2UoeGF4aXMsIHlheGlzKSB7XG4gICAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuZXYuYmVmb3JlWm9vbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBuZXdSYW5nZSA9IHRoaXMuZXYuYmVmb3JlWm9vbSh0aGlzLCB7XG4gICAgICAgICAgeGF4aXM6IHhheGlzLFxuICAgICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1JhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XG4gICAgICBpZiAodGhpcy5lbE1lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKCdvcGVuJykpIHtcbiAgICAgICAgdGhpcy5lbE1lbnUuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbE1lbnUuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb3dubG9hZFBOR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3dubG9hZFBORygpIHtcbiAgICAgIHZhciBkb3dubG9hZFBORyA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcbiAgICAgIGRvd25sb2FkUE5HLmV4cG9ydFRvUG5nKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMudG9nZ2xlTWVudSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb3dubG9hZFNWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3dubG9hZFNWRygpIHtcbiAgICAgIHZhciBkb3dubG9hZFNWRyA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcbiAgICAgIGRvd25sb2FkU1ZHLmV4cG9ydFRvU1ZHKCk7XG4gICAgICB0aGlzLnRvZ2dsZU1lbnUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlWm9vbVJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21SZXNldChlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNoYXJ0cyA9IHRoaXMuY3R4LmdldFN5bmNlZENoYXJ0cygpO1xuICAgICAgY2hhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciB3ID0gY2gudztcblxuICAgICAgICBpZiAody5nbG9iYWxzLm1pblggIT09IHcuZ2xvYmFscy5pbml0aWFsbWluWCAmJiB3Lmdsb2JhbHMubWF4WCAhPT0gdy5nbG9iYWxzLmluaXRpYWxtYXhYKSB7XG4gICAgICAgICAgY2gucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnpvb21lZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX3RoaXMyLnpvb21DYWxsYmFjayh7XG4gICAgICAgICAgICAgIG1pbjogdy5jb25maWcueGF4aXMubWluLFxuICAgICAgICAgICAgICBtYXg6IHcuY29uZmlnLnhheGlzLm1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnpvb21lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY2guX3VwZGF0ZVNlcmllcyh3Lmdsb2JhbHMuaW5pdGlhbFNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZWxab29tUmVzZXQpIHtcbiAgICAgICAgdGhpcy5lbFpvb21SZXNldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbVJlc2V0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVTZWxlY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWxab29tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVab29taW5nLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbUluLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tSW4uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWxab29tT3V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tT3V0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsUGFuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVQYW5uaW5nLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsTWVudUljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxab29tID0gbnVsbDtcbiAgICAgIHRoaXMuZWxab29tSW4gPSBudWxsO1xuICAgICAgdGhpcy5lbFpvb21PdXQgPSBudWxsO1xuICAgICAgdGhpcy5lbFBhbiA9IG51bGw7XG4gICAgICB0aGlzLmVsU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuZWxab29tUmVzZXQgPSBudWxsO1xuICAgICAgdGhpcy5lbE1lbnVJY29uID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbGJhcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFpvb20gQ2xhc3MgZm9yIGhhbmRsaW5nIHpvb21pbmcgYW5kIHBhbm5pbmcgb24gYXhlcyBiYXNlZCBjaGFydHMuXG4gKlxuICogQG1vZHVsZSBab29tUGFuU2VsZWN0aW9uXG4gKiovXG5cbnZhciBab29tUGFuU2VsZWN0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfVG9vbGJhcikge1xuICBfaW5oZXJpdHMoWm9vbVBhblNlbGVjdGlvbiwgX1Rvb2xiYXIpO1xuXG4gIGZ1bmN0aW9uIFpvb21QYW5TZWxlY3Rpb24oY3R4KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvb21QYW5TZWxlY3Rpb24pO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoWm9vbVBhblNlbGVjdGlvbikuY2FsbCh0aGlzLCBjdHgpKTtcbiAgICBfdGhpcy5jdHggPSBjdHg7XG4gICAgX3RoaXMudyA9IGN0eC53O1xuICAgIF90aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyhfdGhpcy5jdHgpO1xuICAgIF90aGlzLmV2ZW50TGlzdCA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICdtb3VzZXVwJywgJ3RvdWNoZW5kJ107XG4gICAgX3RoaXMuY2xpZW50WCA9IDA7XG4gICAgX3RoaXMuY2xpZW50WSA9IDA7XG4gICAgX3RoaXMuc3RhcnRYID0gMDtcbiAgICBfdGhpcy5lbmRYID0gMDtcbiAgICBfdGhpcy5kcmFnWCA9IDA7XG4gICAgX3RoaXMuc3RhcnRZID0gMDtcbiAgICBfdGhpcy5lbmRZID0gMDtcbiAgICBfdGhpcy5kcmFnWSA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFpvb21QYW5TZWxlY3Rpb24sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHh5UmF0aW9zID0gX3JlZi54eVJhdGlvcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICAgIHRoaXMuem9vbVJlY3QgPSB0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIDAsIDApO1xuICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgIHRoaXMuZ3JpZFJlY3QgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1ncmlkJyk7XG4gICAgICB0aGlzLnpvb21SZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy16b29tLXJlY3QnKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtc2VsZWN0aW9uLXJlY3QnKTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHRoaXMuem9vbVJlY3QpO1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQodGhpcy5zZWxlY3Rpb25SZWN0KTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi50eXBlID09PSAneCcpIHtcbiAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3QgPSB0aGlzLnNlbGVjdGlvblJlY3QuZHJhZ2dhYmxlKHtcbiAgICAgICAgICBtaW5YOiAwLFxuICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgbWF4WDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICBtYXhZOiB3Lmdsb2JhbHMuZ3JpZEhlaWdodFxuICAgICAgICB9KS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24udHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0LmRyYWdnYWJsZSh7XG4gICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICBtYXhYOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoXG4gICAgICAgIH0pLm9uKCdkcmFnbW92ZScsIHRoaXMuc2VsZWN0aW9uRHJhZ2dpbmcuYmluZCh0aGlzLCAnZHJhZ2dpbmcnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdC5kcmFnZ2FibGUoKS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXNlbGVjdGVkU2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLmhvdmVyQXJlYSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3Iody5nbG9iYWxzLmNoYXJ0Q2xhc3MpO1xuICAgICAgdGhpcy5ob3ZlckFyZWEuY2xhc3NMaXN0LmFkZCgnem9vbWFibGUnKTtcbiAgICAgIHRoaXMuZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMi5ob3ZlckFyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbWUuc3ZnTW91c2VFdmVudHMuYmluZChtZSwgeHlSYXRpb3MpLCB7XG4gICAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnMgd2hpY2ggd2VyZSBwcmV2aW91c2x5IGFkZGVkIG9uIGhvdmVyIGFyZWFcblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdGhpcy5ldmVudExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzMy5ob3ZlckFyZWEpIHtcbiAgICAgICAgICBfdGhpczMuaG92ZXJBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG1lLnN2Z01vdXNlRXZlbnRzLmJpbmQobWUsIG1lLnh5UmF0aW9zKSwge1xuICAgICAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zbERyYWdnYWJsZVJlY3QpIHtcbiAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3QuZHJhZ2dhYmxlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3Qub2ZmKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdC5vZmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuem9vbVJlY3QgPSBudWxsO1xuICAgICAgdGhpcy5ncmlkUmVjdCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN2Z01vdXNlRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN2Z01vdXNlRXZlbnRzKHh5UmF0aW9zLCBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgdG9vbGJhciA9IHRoaXMuY3R4LnRvb2xiYXI7XG4gICAgICB2YXIgem9vbXR5cGUgPSB3Lmdsb2JhbHMuem9vbUVuYWJsZWQgPyB3LmNvbmZpZy5jaGFydC56b29tLnR5cGUgOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24udHlwZTtcblxuICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5zaGlmdFdhc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICB0b29sYmFyLmVuYWJsZVBhbm5pbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnNoaWZ0V2FzUHJlc3NlZCkge1xuICAgICAgICAgIHRvb2xiYXIuZW5hYmxlWm9vbWluZygpO1xuICAgICAgICAgIHRoaXMuc2hpZnRXYXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZhbHNlUG9zaXRpdmVzID0gZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0JykgfHwgZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtdG9vbGJhcicpO1xuICAgICAgaWYgKGZhbHNlUG9zaXRpdmVzKSByZXR1cm47XG4gICAgICBtZS5jbGllbnRYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudG91Y2hlc1swXS5jbGllbnRYIDogZS50eXBlID09PSAndG91Y2hlbmQnID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYO1xuICAgICAgbWUuY2xpZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRvdWNoZXNbMF0uY2xpZW50WSA6IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSA6IGUuY2xpZW50WTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZS53aGljaCA9PT0gMSkge1xuICAgICAgICB2YXIgZ3JpZFJlY3REaW0gPSBtZS5ncmlkUmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbWUuc3RhcnRYID0gbWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQ7XG4gICAgICAgIG1lLnN0YXJ0WSA9IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3A7XG4gICAgICAgIG1lLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICBtZS5kcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnBhbkVuYWJsZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0aW9uID0gbnVsbDtcblxuICAgICAgICAgIGlmIChtZS53Lmdsb2JhbHMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICBtZS5wYW5EcmFnZ2luZyh7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgICAgICB6b29tdHlwZTogem9vbXR5cGUsXG4gICAgICAgICAgICAgIHh5UmF0aW9zOiB4eVJhdGlvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtZS53Lmdsb2JhbHMubW91c2Vkb3duICYmIHcuZ2xvYmFscy56b29tRW5hYmxlZCB8fCBtZS53Lmdsb2JhbHMubW91c2Vkb3duICYmIHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3Rpb24gPSBtZS5zZWxlY3Rpb25EcmF3aW5nKHtcbiAgICAgICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgICAgIHpvb210eXBlOiB6b29tdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gd2Ugd2lsbCBiZSBjYWxsaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBlYWNoIG1vdXNlZG93bi9tb3VzZW1vdmUvbW91c2V1cFxuICAgICAgICB2YXIgX2dyaWRSZWN0RGltID0gbWUuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKG1lLncuZ2xvYmFscy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAvLyB1c2VyIHJlbGVhc2VkIHRoZSBkcmFnLCBub3cgZG8gYWxsIHRoZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICBtZS5lbmRYID0gbWUuY2xpZW50WCAtIF9ncmlkUmVjdERpbS5sZWZ0O1xuICAgICAgICAgIG1lLmVuZFkgPSBtZS5jbGllbnRZIC0gX2dyaWRSZWN0RGltLnRvcDtcbiAgICAgICAgICBtZS5kcmFnWCA9IE1hdGguYWJzKG1lLmVuZFggLSBtZS5zdGFydFgpO1xuICAgICAgICAgIG1lLmRyYWdZID0gTWF0aC5hYnMobWUuZW5kWSAtIG1lLnN0YXJ0WSk7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkIHx8IHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3Rpb25EcmF3bih7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgICAgICB6b29tdHlwZTogem9vbXR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICBtZS5oaWRlU2VsZWN0aW9uUmVjdCh0aGlzLnNlbGVjdGlvblJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBtZS53Lmdsb2JhbHMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFrZVNlbGVjdGlvblJlY3REcmFnZ2FibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZVNlbGVjdGlvblJlY3REcmFnZ2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVNlbGVjdGlvblJlY3REcmFnZ2FibGUoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25SZWN0KSByZXR1cm47XG4gICAgICB2YXIgcmVjdERpbSA9IHRoaXMuc2VsZWN0aW9uUmVjdC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAocmVjdERpbS53aWR0aCA+IDAgJiYgcmVjdERpbS5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0LnNlbGVjdGl6ZSgpLnJlc2l6ZSh7XG4gICAgICAgICAgY29uc3RyYWludDoge1xuICAgICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgICBtYXhYOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgbWF4WTogdy5nbG9iYWxzLmdyaWRIZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdyZXNpemluZycsIHRoaXMuc2VsZWN0aW9uRHJhZ2dpbmcuYmluZCh0aGlzLCAncmVzaXppbmcnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXNlbGVjdGVkU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXNlbGVjdGVkU2VsZWN0aW9uKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy56b29tRW5hYmxlZCkge1xuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmRyYXdTZWxlY3Rpb25SZWN0KHcuZ2xvYmFscy5zZWxlY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluICE9PSB1bmRlZmluZWQgJiYgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgeCA9ICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluIC0gdy5nbG9iYWxzLm1pblgpIC8geHlSYXRpb3MueFJhdGlvO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAtICh3Lmdsb2JhbHMubWF4WCAtIHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5tYXgpIC8geHlSYXRpb3MueFJhdGlvIC0geDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SZWN0ID0ge1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRyYXdTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlY3QpO1xuICAgICAgICAgICAgdGhpcy5tYWtlU2VsZWN0aW9uUmVjdERyYWdnYWJsZSgpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbih0aGlzLmN0eCwge1xuICAgICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgICBtaW46IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5taW4sXG4gICAgICAgICAgICAgICAgICBtYXg6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5tYXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHlheGlzOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1NlbGVjdGlvblJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJlY3QoX3JlZjIpIHtcbiAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgICB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgICAgICB0cmFuc2xhdGVYID0gX3JlZjIudHJhbnNsYXRlWCxcbiAgICAgICAgICB0cmFuc2xhdGVZID0gX3JlZjIudHJhbnNsYXRlWTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHpvb21SZWN0ID0gdGhpcy56b29tUmVjdDtcbiAgICAgIHZhciBzZWxlY3Rpb25SZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0O1xuXG4gICAgICBpZiAodGhpcy5kcmFnZ2VkIHx8IHcuZ2xvYmFscy5zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHNjYWxpbmdBdHRycyA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVggKyAnLCAnICsgdHJhbnNsYXRlWSArICcpJyAvLyBjaGFuZ2Ugc3R5bGVzIGJhc2VkIG9uIHpvb20gb3Igc2VsZWN0aW9uXG4gICAgICAgICAgLy8gem9vbSBpcyBFbmFibGVkIGFuZCB1c2VyIGhhcyBkcmFnZ2VkLCBzbyBkcmF3IGJsdWUgcmVjdFxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCAmJiB0aGlzLmRyYWdnZWQpIHtcbiAgICAgICAgICB6b29tUmVjdC5hdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuZmlsbC5jb2xvcixcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuZmlsbC5vcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuc3Ryb2tlLmNvbG9yLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLmNoYXJ0Lnpvb20uem9vbWVkQXJlYS5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuc3Ryb2tlLm9wYWNpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh6b29tUmVjdC5ub2RlLCBzY2FsaW5nQXR0cnMpO1xuICAgICAgICB9IC8vIHNlbGVjdGlvbiBpcyBlbmFibGVkXG5cblxuICAgICAgICBpZiAody5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb25SZWN0LmF0dHIoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggPiAwID8gd2lkdGggOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPiAwID8gaGVpZ2h0IDogMCxcbiAgICAgICAgICAgIGZpbGw6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5maWxsLmNvbG9yLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5maWxsLm9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2U6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2UuY29sb3IsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS53aWR0aCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5Jzogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS5kYXNoQXJyYXksXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uc3Ryb2tlLm9wYWNpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhzZWxlY3Rpb25SZWN0Lm5vZGUsIHNjYWxpbmdBdHRycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVNlbGVjdGlvblJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZVNlbGVjdGlvblJlY3QocmVjdCkge1xuICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgcmVjdC5hdHRyKHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25EcmF3aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdGlvbkRyYXdpbmcoX3JlZjMpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gX3JlZjMuY29udGV4dCxcbiAgICAgICAgICB6b29tdHlwZSA9IF9yZWYzLnpvb210eXBlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgdmFyIGdyaWRSZWN0RGltID0gdGhpcy5ncmlkUmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzdGFydFggPSBtZS5zdGFydFggLSAxO1xuICAgICAgdmFyIHN0YXJ0WSA9IG1lLnN0YXJ0WTtcbiAgICAgIHZhciBzZWxlY3Rpb25XaWR0aCA9IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0IC0gc3RhcnRYO1xuICAgICAgdmFyIHNlbGVjdGlvbkhlaWdodCA9IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3AgLSBzdGFydFk7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IDA7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IDA7XG4gICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHt9O1xuXG4gICAgICBpZiAoTWF0aC5hYnMoc2VsZWN0aW9uV2lkdGggKyBzdGFydFgpID4gdy5nbG9iYWxzLmdyaWRXaWR0aCB8fCBtZS5jbGllbnRYIC0gZ3JpZFJlY3REaW0ubGVmdCA8IDApIHtcbiAgICAgICAgLy8gdXNlciBkcmFnZ2VkIHRoZSBtb3VzZSBvdXRzaWRlIGRyYXdpbmcgYXJlYVxuICAgICAgICAvLyBUT0RPOiB0ZXN0IHRoZSBzZWxlY3Rpb25SZWN0IGFuZCBtYWtlIHN1cmUgaXQgZG9lc24ndCBjcm9zc2VzIGRyYXdpbmcgYXJlYVxuICAgICAgICBtZS5oaWRlU2VsZWN0aW9uUmVjdCh0aGlzLnpvb21SZWN0KTtcbiAgICAgICAgbWUuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICBtZS53Lmdsb2JhbHMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgICB9IC8vIGludmVyc2Ugc2VsZWN0aW9uIFhcblxuXG4gICAgICBpZiAoc3RhcnRYID4gbWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQpIHtcbiAgICAgICAgc2VsZWN0aW9uV2lkdGggPSBNYXRoLmFicyhzZWxlY3Rpb25XaWR0aCk7XG4gICAgICAgIHRyYW5zbGF0ZVggPSAtc2VsZWN0aW9uV2lkdGg7XG4gICAgICB9IC8vIGludmVyc2Ugc2VsZWN0aW9uIFlcblxuXG4gICAgICBpZiAoc3RhcnRZID4gbWUuY2xpZW50WSAtIGdyaWRSZWN0RGltLnRvcCkge1xuICAgICAgICBzZWxlY3Rpb25IZWlnaHQgPSBNYXRoLmFicyhzZWxlY3Rpb25IZWlnaHQpO1xuICAgICAgICB0cmFuc2xhdGVZID0gLXNlbGVjdGlvbkhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb210eXBlID09PSAneCcpIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogc2VsZWN0aW9uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCxcbiAgICAgICAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoem9vbXR5cGUgPT09ICd5Jykge1xuICAgICAgICBzZWxlY3Rpb25SZWN0ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgIHdpZHRoOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2VsZWN0aW9uSGVpZ2h0LFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgIHdpZHRoOiBzZWxlY3Rpb25XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGVjdGlvbkhlaWdodCxcbiAgICAgICAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWUuZHJhd1NlbGVjdGlvblJlY3Qoc2VsZWN0aW9uUmVjdCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uUmVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uRHJhZ2dpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0aW9uRHJhZ2dpbmcodHlwZSwgZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcbiAgICAgIHZhciBzZWxSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0O1xuICAgICAgdmFyIHRpbWVySW50ZXJ2YWwgPSAwO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6aW5nJykge1xuICAgICAgICB0aW1lckludGVydmFsID0gMzA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBhIHNtYWxsIGRlYm91bmNlciBpcyByZXF1aXJlZCB3aGVuIHJlc2l6aW5nIHRvIGF2b2lkIGZyZWV6aW5nIHRoZSBjaGFydFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uUmVzaXplVGltZXIpO1xuICAgICAgICB0aGlzLncuZ2xvYmFscy5zZWxlY3Rpb25SZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZ3JpZFJlY3REaW0gPSBfdGhpczQuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHNlbFJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgbWluWCA9IHcuZ2xvYmFscy54QXhpc1NjYWxlLm5pY2VNaW4gKyAoc2VsZWN0aW9uUmVjdC5sZWZ0IC0gZ3JpZFJlY3REaW0ubGVmdCkgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgdmFyIG1heFggPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgKHNlbGVjdGlvblJlY3QucmlnaHQgLSBncmlkUmVjdERpbS5sZWZ0KSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgICB2YXIgbWluWSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gKyAoZ3JpZFJlY3REaW0uYm90dG9tIC0gc2VsZWN0aW9uUmVjdC5ib3R0b20pICogeHlSYXRpb3MueVJhdGlvWzBdO1xuICAgICAgICAgIHZhciBtYXhZID0gdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1heCAtIChzZWxlY3Rpb25SZWN0LnRvcCAtIGdyaWRSZWN0RGltLnRvcCkgKiB4eVJhdGlvcy55UmF0aW9bMF07XG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbihfdGhpczQuY3R4LCB7XG4gICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICBtaW46IG1pblgsXG4gICAgICAgICAgICAgIG1heDogbWF4WFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgIG1pbjogbWluWSxcbiAgICAgICAgICAgICAgbWF4OiBtYXhZXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRpbWVySW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25EcmF3blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3Rpb25EcmF3bihfcmVmNCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBfcmVmNC5jb250ZXh0LFxuICAgICAgICAgIHpvb210eXBlID0gX3JlZjQuem9vbXR5cGU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmN0eC50b29sYmFyO1xuXG4gICAgICBpZiAobWUuc3RhcnRYID4gbWUuZW5kWCkge1xuICAgICAgICB2YXIgdGVtcFggPSBtZS5zdGFydFg7XG4gICAgICAgIG1lLnN0YXJ0WCA9IG1lLmVuZFg7XG4gICAgICAgIG1lLmVuZFggPSB0ZW1wWDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lLnN0YXJ0WSA+IG1lLmVuZFkpIHtcbiAgICAgICAgdmFyIHRlbXBZID0gbWUuc3RhcnRZO1xuICAgICAgICBtZS5zdGFydFkgPSBtZS5lbmRZO1xuICAgICAgICBtZS5lbmRZID0gdGVtcFk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgbWUuc3RhcnRYICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgdmFyIHhIaWdoZXN0VmFsdWUgPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgbWUuZW5kWCAqIHh5UmF0aW9zLnhSYXRpbzsgLy8gVE9ETzogd2Ugd2lsbCBjb25zaWRlciB0aGUgMXN0IHkgYXhpcyB2YWx1ZXMgaGVyZSBmb3IgZ2V0dGluZyBoaWdoZXN0IGFuZCBsb3dlc3QgeVxuXG4gICAgICB2YXIgeUhpZ2hlc3RWYWx1ZSA9IFtdO1xuICAgICAgdmFyIHlMb3dlc3RWYWx1ZSA9IFtdO1xuICAgICAgdy5jb25maWcueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgeUhpZ2hlc3RWYWx1ZS5wdXNoKE1hdGguZmxvb3Iody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXggLSB4eVJhdGlvcy55UmF0aW9baW5kZXhdICogbWUuc3RhcnRZKSk7XG4gICAgICAgIHlMb3dlc3RWYWx1ZS5wdXNoKE1hdGguZmxvb3Iody5nbG9iYWxzLnlBeGlzU2NhbGVbaW5kZXhdLm5pY2VNYXggLSB4eVJhdGlvcy55UmF0aW9baW5kZXhdICogbWUuZW5kWSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtZS5kcmFnZ2VkICYmIChtZS5kcmFnWCA+IDEwIHx8IG1lLmRyYWdZID4gMTApICYmIHhMb3dlc3RWYWx1ZSAhPT0geEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHlheGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpOyAvLyBiZWZvcmUgem9vbWluZyBpbi9vdXQsIHN0b3JlIHRoZSBsYXN0IHlheGlzIGFuZCB4YXhpcyByYW5nZSwgc28gdGhhdCB3aGVuIHVzZXIgaGl0cyB0aGUgUkVTRVQgYnV0dG9uLCB3ZSBnZXQgdGhlIG9yaWdpbmFsIHJhbmdlXG4gICAgICAgICAgLy8gYWxzbyAtIG1ha2Ugc3VyZSB1c2VyIGlzIG5vdCBhbHJlYWR5IHpvb21lZCBpbi9vdXQgLSBvdGhlcndpc2Ugd2Ugd2lsbCBzdG9yZSB6b29tZWQgdmFsdWVzIGluIGxhc3RBeGlzXG5cbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy56b29tZWQpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5sYXN0WEF4aXMgPSBVdGlscy5jbG9uZSh3LmNvbmZpZy54YXhpcyk7XG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFlBeGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4YXhpcyA9IHtcbiAgICAgICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3h5JyB8fCB6b29tdHlwZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICB5YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgICAgICB5YXhpc1tpbmRleF0ubWluID0geUxvd2VzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgeWF4aXNbaW5kZXhdLm1heCA9IHlIaWdoZXN0VmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG5ldyBSYW5nZShtZS5jdHgpO1xuICAgICAgICAgICAgeWF4aXMgPSBzY2FsZS5hdXRvU2NhbGVZKG1lLmN0eCwge1xuICAgICAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgYmVmb3JlWm9vbVJhbmdlID0gdG9vbGJhci5nZXRCZWZvcmVab29tUmFuZ2UoeGF4aXMsIHlheGlzKTtcblxuICAgICAgICAgICAgaWYgKGJlZm9yZVpvb21SYW5nZSkge1xuICAgICAgICAgICAgICB4YXhpcyA9IGJlZm9yZVpvb21SYW5nZS54YXhpcyA/IGJlZm9yZVpvb21SYW5nZS54YXhpcyA6IHhheGlzO1xuICAgICAgICAgICAgICB5YXhpcyA9IGJlZm9yZVpvb21SYW5nZS55YXhpcyA/IGJlZm9yZVpvb21SYW5nZS55YXhlIDogeWF4aXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHpvb210eXBlID09PSAneCcpIHtcbiAgICAgICAgICAgIG1lLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHhheGlzOiB4YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIG1lLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgICAgIG1lLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgICAgICAgfSwgZmFsc2UsIG1lLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgeGF4aXM6IHhheGlzLFxuICAgICAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgICAgIH0sIGZhbHNlLCBtZS53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuem9vbWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b29sYmFyLnpvb21DYWxsYmFjayh4YXhpcywgeWF4aXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy56b29tZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgdmFyIF95YXhpcyA9IG51bGw7XG4gICAgICAgICAgdmFyIF94YXhpcyA9IG51bGw7XG4gICAgICAgICAgX3hheGlzID0ge1xuICAgICAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHpvb210eXBlID09PSAneHknIHx8IHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgICAgIF95YXhpcyA9IFV0aWxzLmNsb25lKHcuY29uZmlnLnlheGlzKTtcblxuICAgICAgICAgICAgX3lheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIF95YXhpc1tpbmRleF0ubWluID0geUxvd2VzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgX3lheGlzW2luZGV4XS5tYXggPSB5SGlnaGVzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3Rpb24gPSBtZS5zZWxlY3Rpb247XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24obWUuY3R4LCB7XG4gICAgICAgICAgICAgIHhheGlzOiBfeGF4aXMsXG4gICAgICAgICAgICAgIHlheGlzOiBfeWF4aXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5EcmFnZ2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5EcmFnZ2luZyhfcmVmNSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBfcmVmNS5jb250ZXh0LFxuICAgICAgICAgIHpvb210eXBlID0gX3JlZjUuem9vbXR5cGU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgbW92ZURpcmVjdGlvbjsgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIGRhdGEgdG8gY29tcGFyZSBhZ2FpbnN0XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbi54ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBnZXQgdGhlIGNoYW5nZSBmcm9tIGxhc3QgcG9zaXRpb24gdG8gdGhpcyBwb3NpdGlvblxuICAgICAgICB2YXIgZGVsdGFYID0gdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbi54IC0gbWUuY2xpZW50WDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24ueSAtIG1lLmNsaWVudFk7IC8vIGNoZWNrIHdoaWNoIGRpcmVjdGlvbiBoYWQgdGhlIGhpZ2hlc3QgYW1wbGl0dWRlIGFuZCB0aGVuIGZpZ3VyZSBvdXQgZGlyZWN0aW9uIGJ5IGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBpcyBncmVhdGVyIG9yIGxlc3MgdGhhbiB6ZXJvXG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA+IDApIHtcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhWCkgPiBNYXRoLmFicyhkZWx0YVkpICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSAmJiBkZWx0YVkgPiAwKSB7XG4gICAgICAgICAgbW92ZURpcmVjdGlvbiA9ICd1cCc7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgJiYgZGVsdGFZIDwgMCkge1xuICAgICAgICAgIG1vdmVEaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2V0IHRoZSBuZXcgbGFzdCBwb3NpdGlvbiB0byB0aGUgY3VycmVudCBmb3IgbmV4dCB0aW1lICh0byBnZXQgdGhlIHBvc2l0aW9uIG9mIGRyYWcpXG5cblxuICAgICAgdy5nbG9iYWxzLmxhc3RDbGllbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogbWUuY2xpZW50WCxcbiAgICAgICAgeTogbWUuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgIHZhciB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFg7XG4gICAgICB0aGlzLnBhblNjcm9sbGVkKG1vdmVEaXJlY3Rpb24sIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhblNjcm9sbGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhblNjcm9sbGVkKG1vdmVEaXJlY3Rpb24sIHhMb3dlc3RWYWx1ZSwgeEhpZ2hlc3RWYWx1ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLnh5UmF0aW9zO1xuICAgICAgdmFyIHlheGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpO1xuXG4gICAgICBpZiAobW92ZURpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy5taW5YICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFggKyB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTUgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICB9IGVsc2UgaWYgKG1vdmVEaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeExvd2VzdFZhbHVlID0gdy5nbG9iYWxzLm1pblggLSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTUgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgIHhIaWdoZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxNSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKHhMb3dlc3RWYWx1ZSA8IHcuZ2xvYmFscy5pbml0aWFsbWluWCB8fCB4SGlnaGVzdFZhbHVlID4gdy5nbG9iYWxzLmluaXRpYWxtYXhYKSB7XG4gICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy5taW5YO1xuICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFg7XG4gICAgICB9XG5cbiAgICAgIHZhciB4YXhpcyA9IHtcbiAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgIG1heDogeEhpZ2hlc3RWYWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gbmV3IFJhbmdlKG1lLmN0eCk7XG4gICAgICAgIHlheGlzID0gc2NhbGUuYXV0b1NjYWxlWShtZS5jdHgsIHtcbiAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICB9LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQodGhpcy5jdHgsIHtcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab29tUGFuU2VsZWN0aW9uO1xufShUb29sYmFyKTtcblxudmFyIFRpdGxlU3VidGl0bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaXRsZVN1YnRpdGxlKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaXRsZVN1YnRpdGxlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRpdGxlU3VidGl0bGUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuZHJhd1RpdGxlU3VidGl0bGUoJ3RpdGxlJyk7XG4gICAgICB0aGlzLmRyYXdUaXRsZVN1YnRpdGxlKCdzdWJ0aXRsZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGl0bGVTdWJ0aXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGl0bGVTdWJ0aXRsZSh0eXBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0c0NvbmZpZyA9IHR5cGUgPT09ICd0aXRsZScgPyB3LmNvbmZpZy50aXRsZSA6IHcuY29uZmlnLnN1YnRpdGxlO1xuICAgICAgdmFyIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSB0c0NvbmZpZy5vZmZzZXRZO1xuICAgICAgdmFyIHRleHRBbmNob3IgPSAnbWlkZGxlJztcblxuICAgICAgaWYgKHRzQ29uZmlnLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeCA9IDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSBpZiAodHNDb25maWcuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAtIDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgdHNDb25maWcub2Zmc2V0WDtcbiAgICAgIHkgPSB5ICsgcGFyc2VJbnQodHNDb25maWcuc3R5bGUuZm9udFNpemUpICsgMjtcblxuICAgICAgaWYgKHRzQ29uZmlnLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICB2YXIgdGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB0ZXh0OiB0c0NvbmZpZy50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgZm9udFNpemU6IHRzQ29uZmlnLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHRzQ29uZmlnLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9yZUNvbG9yOiB0c0NvbmZpZy5zdHlsZS5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZVRleHQubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi10ZXh0XCIpKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGl0bGVTdWJ0aXRsZTtcbn0oKTtcblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXhwb3J0cykpID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcm9vdC5kb2N1bWVudCA/IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCkgOiBmdW5jdGlvbiAodykge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkodywgdy5kb2N1bWVudCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByb290LlNWRyA9IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCk7XG4gIH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkLCBmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCkge1xuICAvLyBGaW5kIGdsb2JhbCByZWZlcmVuY2UgLSB1c2VzICd0aGlzJyBieSBkZWZhdWx0IHdoZW4gYXZhaWxhYmxlLFxuICAvLyBmYWxscyBiYWNrIHRvICd3aW5kb3cnIG90aGVyd2lzZSAoZm9yIGJ1bmRsZXJzIGxpa2UgV2VicGFjaylcbiAgdmFyIGdsb2JhbFJlZiA9IHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB3aW5kb3c7IC8vIFRoZSBtYWluIHdyYXBwaW5nIGVsZW1lbnRcblxuICB2YXIgU1ZHID0gZ2xvYmFsUmVmLlNWRyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKFNWRy5zdXBwb3J0ZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkRvYyhlbGVtZW50KTtcblxuICAgICAgaWYgKCFTVkcucGFyc2VyLmRyYXcpIHtcbiAgICAgICAgU1ZHLnByZXBhcmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9OyAvLyBEZWZhdWx0IG5hbWVzcGFjZXNcblxuXG4gIFNWRy5ucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIFNWRy54bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG4gIFNWRy54bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbiAgU1ZHLnN2Z2pzID0gJ2h0dHA6Ly9zdmdqcy5jb20vc3ZnanMnOyAvLyBTdmcgc3VwcG9ydCB0ZXN0XG5cbiAgU1ZHLnN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcbiAgICAvLyAgICAgISEgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRy5ucywnc3ZnJykuY3JlYXRlU1ZHUmVjdFxuICB9KCk7IC8vIERvbid0IGJvdGhlciB0byBjb250aW51ZSBpZiBTVkcgaXMgbm90IHN1cHBvcnRlZFxuXG5cbiAgaWYgKCFTVkcuc3VwcG9ydGVkKSByZXR1cm4gZmFsc2U7IC8vIEVsZW1lbnQgaWQgc2VxdWVuY2VcblxuICBTVkcuZGlkID0gMTAwMDsgLy8gR2V0IG5leHQgbmFtZWQgZWxlbWVudCBpZFxuXG4gIFNWRy5laWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnU3ZnanMnICsgY2FwaXRhbGl6ZShuYW1lKSArIFNWRy5kaWQrKztcbiAgfTsgLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cblxuICBTVkcuY3JlYXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsIG5hbWUpOyAvLyBhcHBseSB1bmlxdWUgaWRcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZWlkKG5hbWUpKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTsgLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xuXG5cbiAgU1ZHLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kdWxlcywgbWV0aG9kcywga2V5LCBpOyAvLyBHZXQgbGlzdCBvZiBtb2R1bGVzXG5cbiAgICBtb2R1bGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyBHZXQgb2JqZWN0IHdpdGggZXh0ZW5zaW9uc1xuXG4gICAgbWV0aG9kcyA9IG1vZHVsZXMucG9wKCk7XG5cbiAgICBmb3IgKGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAobW9kdWxlc1tpXSkge1xuICAgICAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgbW9kdWxlc1tpXS5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gTWFrZSBzdXJlIFNWRy5TZXQgaW5oZXJpdHMgYW55IG5ld2x5IGFkZGVkIG1ldGhvZHNcblxuXG4gICAgaWYgKFNWRy5TZXQgJiYgU1ZHLlNldC5pbmhlcml0KSB7XG4gICAgICBTVkcuU2V0LmluaGVyaXQoKTtcbiAgICB9XG4gIH07IC8vIEludmVudCBuZXcgZWxlbWVudFxuXG5cbiAgU1ZHLmludmVudCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAvLyBDcmVhdGUgZWxlbWVudCBpbml0aWFsaXplclxuICAgIHZhciBpbml0aWFsaXplciA9IHR5cGVvZiBjb25maWcuY3JlYXRlID09PSAnZnVuY3Rpb24nID8gY29uZmlnLmNyZWF0ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKGNvbmZpZy5jcmVhdGUpKTtcbiAgICB9OyAvLyBJbmhlcml0IHByb3RvdHlwZVxuXG4gICAgaWYgKGNvbmZpZy5pbmhlcml0KSB7XG4gICAgICBpbml0aWFsaXplci5wcm90b3R5cGUgPSBuZXcgY29uZmlnLmluaGVyaXQoKTtcbiAgICB9IC8vIEV4dGVuZCB3aXRoIG1ldGhvZHNcblxuXG4gICAgaWYgKGNvbmZpZy5leHRlbmQpIHtcbiAgICAgIFNWRy5leHRlbmQoaW5pdGlhbGl6ZXIsIGNvbmZpZy5leHRlbmQpO1xuICAgIH0gLy8gQXR0YWNoIGNvbnN0cnVjdCBtZXRob2QgdG8gcGFyZW50XG5cblxuICAgIGlmIChjb25maWcuY29uc3RydWN0KSB7XG4gICAgICBTVkcuZXh0ZW5kKGNvbmZpZy5wYXJlbnQgfHwgU1ZHLkNvbnRhaW5lciwgY29uZmlnLmNvbnN0cnVjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXRpYWxpemVyO1xuICB9OyAvLyBBZG9wdCBleGlzdGluZyBzdmcgZWxlbWVudHNcblxuXG4gIFNWRy5hZG9wdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIG5vZGVcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsOyAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxuXG4gICAgaWYgKG5vZGUuaW5zdGFuY2UpIHJldHVybiBub2RlLmluc3RhbmNlOyAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXG4gICAgdmFyIGVsZW1lbnQ7IC8vIGFkb3B0IHdpdGggZWxlbWVudC1zcGVjaWZpYyBzZXR0aW5nc1xuXG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgIGVsZW1lbnQgPSBub2RlLnBhcmVudE5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCA/IG5ldyBTVkcuTmVzdGVkKCkgOiBuZXcgU1ZHLkRvYygpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAnbGluZWFyR3JhZGllbnQnKSB7XG4gICAgICBlbGVtZW50ID0gbmV3IFNWRy5HcmFkaWVudCgnbGluZWFyJyk7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09ICdyYWRpYWxHcmFkaWVudCcpIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdyYWRpYWwnKTtcbiAgICB9IGVsc2UgaWYgKFNWR1tjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUpXSkge1xuICAgICAgZWxlbWVudCA9IG5ldyBTVkdbY2FwaXRhbGl6ZShub2RlLm5vZGVOYW1lKV0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IG5ldyBTVkcuRWxlbWVudChub2RlKTtcbiAgICB9IC8vIGVuc3VyZSByZWZlcmVuY2VzXG5cblxuICAgIGVsZW1lbnQudHlwZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgZWxlbWVudC5ub2RlID0gbm9kZTtcbiAgICBub2RlLmluc3RhbmNlID0gZWxlbWVudDsgLy8gU1ZHLkNsYXNzIHNwZWNpZmljIHByZXBhcmF0aW9uc1xuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRG9jKSB7XG4gICAgICBlbGVtZW50Lm5hbWVzcGFjZSgpLmRlZnMoKTtcbiAgICB9IC8vIHB1bGwgc3ZnanMgZGF0YSBmcm9tIHRoZSBkb20gKGdldEF0dHJpYnV0ZU5TIGRvZXNuJ3Qgd29yayBpbiBodG1sNSlcblxuXG4gICAgZWxlbWVudC5zZXREYXRhKEpTT04ucGFyc2Uobm9kZS5nZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKSkgfHwge30pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9OyAvLyBJbml0aWFsaXplIHBhcnNpbmcgZWxlbWVudFxuXG5cbiAgU1ZHLnByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VsZWN0IGRvY3VtZW50IGJvZHkgYW5kIGNyZWF0ZSBpbnZpc2libGUgc3ZnIGVsZW1lbnRcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0sXG4gICAgICAgIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogU1ZHLmFkb3B0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkubmVzdGVkKCkpLnNpemUoMiwgMCk7IC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0XG5cbiAgICBTVkcucGFyc2VyID0ge1xuICAgICAgYm9keTogYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBkcmF3OiBkcmF3LnN0eWxlKCdvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwJTt0b3A6LTEwMCU7b3ZlcmZsb3c6aGlkZGVuJykubm9kZSxcbiAgICAgIHBvbHk6IGRyYXcucG9seWxpbmUoKS5ub2RlLFxuICAgICAgcGF0aDogZHJhdy5wYXRoKCkubm9kZSxcbiAgICAgIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcbiAgICB9O1xuICB9O1xuXG4gIFNWRy5wYXJzZXIgPSB7XG4gICAgbmF0aXZlOiBTVkcuY3JlYXRlKCdzdmcnKVxuICB9O1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICBTVkcucHJlcGFyZSgpO1xuICAgIH1cbiAgfSwgZmFsc2UpOyAvLyBTdG9yYWdlIGZvciByZWd1bGFyIGV4cHJlc3Npb25zXG5cbiAgU1ZHLnJlZ2V4ID0ge1xuICAgIC8vIFBhcnNlIHVuaXQgdmFsdWVcbiAgICBudW1iZXJBbmRVbml0OiAvXihbKy1dPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8pKFthLXolXSopJC9pLFxuICAgIC8vIFBhcnNlIGhleCB2YWx1ZVxuICAgIGhleDogL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaSxcbiAgICAvLyBQYXJzZSByZ2IgdmFsdWVcbiAgICByZ2I6IC9yZ2JcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcKS8sXG4gICAgLy8gUGFyc2UgcmVmZXJlbmNlIGlkXG4gICAgcmVmZXJlbmNlOiAvIyhbYS16MC05XFwtX10rKS9pLFxuICAgIC8vIHNwbGl0cyBhIHRyYW5zZm9ybWF0aW9uIGNoYWluXG4gICAgdHJhbnNmb3JtczogL1xcKVxccyosP1xccyovLFxuICAgIC8vIFdoaXRlc3BhY2VcbiAgICB3aGl0ZXNwYWNlOiAvXFxzL2csXG4gICAgLy8gVGVzdCBoZXggdmFsdWVcbiAgICBpc0hleDogL14jW2EtZjAtOV17Myw2fSQvaSxcbiAgICAvLyBUZXN0IHJnYiB2YWx1ZVxuICAgIGlzUmdiOiAvXnJnYlxcKC8sXG4gICAgLy8gVGVzdCBjc3MgZGVjbGFyYXRpb25cbiAgICBpc0NzczogL1teOl0rOlteO10rOz8vLFxuICAgIC8vIFRlc3QgZm9yIGJsYW5rIHN0cmluZ1xuICAgIGlzQmxhbms6IC9eKFxccyspPyQvLFxuICAgIC8vIFRlc3QgZm9yIG51bWVyaWMgc3RyaW5nXG4gICAgaXNOdW1iZXI6IC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxuICAgIC8vIFRlc3QgZm9yIHBlcmNlbnQgdmFsdWVcbiAgICBpc1BlcmNlbnQ6IC9eLT9bXFxkXFwuXSslJC8sXG4gICAgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXG4gICAgaXNJbWFnZTogL1xcLihqcGd8anBlZ3xwbmd8Z2lmfHN2ZykoXFw/W149XSsuKik/L2ksXG4gICAgLy8gc3BsaXQgYXQgd2hpdGVzcGFjZSBhbmQgY29tbWFcbiAgICBkZWxpbWl0ZXI6IC9bXFxzLF0rLyxcbiAgICAvLyBUaGUgZm9sbG93aW5nIHJlZ2V4IGFyZSB1c2VkIHRvIHBhcnNlIHRoZSBkIGF0dHJpYnV0ZSBvZiBhIHBhdGhcbiAgICAvLyBNYXRjaGVzIGFsbCBoeXBoZW5zIHdoaWNoIGFyZSBub3QgYWZ0ZXIgYW4gZXhwb25lbnRcbiAgICBoeXBoZW46IC8oW15lXSlcXC0vZ2ksXG4gICAgLy8gUmVwbGFjZXMgYW5kIHRlc3RzIGZvciBhbGwgcGF0aCBsZXR0ZXJzXG4gICAgcGF0aExldHRlcnM6IC9bTUxIVkNTUVRBWl0vZ2ksXG4gICAgLy8geWVzIHdlIG5lZWQgdGhpcyBvbmUsIHRvb1xuICAgIGlzUGF0aExldHRlcjogL1tNTEhWQ1NRVEFaXS9pLFxuICAgIC8vIG1hdGNoZXMgMC4xNTQuMjMuNDVcbiAgICBudW1iZXJzV2l0aERvdHM6IC8oKFxcZD9cXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSgoPzpcXC5cXGQrKD86ZVsrLV0/XFxkKyk/KSspKSsvZ2ksXG4gICAgLy8gbWF0Y2hlcyAuXG4gICAgZG90czogL1xcLi9nXG4gIH07XG4gIFNWRy51dGlscyA9IHtcbiAgICAvLyBNYXAgZnVuY3Rpb25cbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChhcnJheSwgYmxvY2spIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGlsID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChibG9jayhhcnJheVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLy8gRmlsdGVyIGZ1bmN0aW9uXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYXJyYXksIGJsb2NrKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBpbCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgaWYgKGJsb2NrKGFycmF5W2ldKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLy8gRGVncmVlcyB0byByYWRpYW5zXG4gICAgcmFkaWFuczogZnVuY3Rpb24gcmFkaWFucyhkKSB7XG4gICAgICByZXR1cm4gZCAlIDM2MCAqIE1hdGguUEkgLyAxODA7XG4gICAgfSxcbiAgICAvLyBSYWRpYW5zIHRvIGRlZ3JlZXNcbiAgICBkZWdyZWVzOiBmdW5jdGlvbiBkZWdyZWVzKHIpIHtcbiAgICAgIHJldHVybiByICogMTgwIC8gTWF0aC5QSSAlIDM2MDtcbiAgICB9LFxuICAgIGZpbHRlclNWR0VsZW1lbnRzOiBmdW5jdGlvbiBmaWx0ZXJTVkdFbGVtZW50cyhub2Rlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vZGVzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIFNWRy5kZWZhdWx0cyA9IHtcbiAgICAvLyBEZWZhdWx0IGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICBhdHRyczoge1xuICAgICAgLy8gZmlsbCBhbmQgc3Ryb2tlXG4gICAgICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgICAgICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcbiAgICAgICdzdHJva2UtbGluZWpvaW4nOiAnbWl0ZXInLFxuICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxuICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgLy8gcG9zaXRpb25cbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgY3g6IDAsXG4gICAgICBjeTogMCxcbiAgICAgIC8vIHNpemVcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgLy8gcmFkaXVzXG4gICAgICByOiAwLFxuICAgICAgcng6IDAsXG4gICAgICByeTogMCxcbiAgICAgIC8vIGdyYWRpZW50XG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgICAgICdzdG9wLWNvbG9yJzogJyMwMDAwMDAnLFxuICAgICAgLy8gdGV4dFxuICAgICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnLFxuICAgICAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J1xuICAgIH0gLy8gTW9kdWxlIGZvciBjb2xvciBjb252ZXJ0aW9uc1xuXG4gIH07XG5cbiAgU1ZHLkNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoOyAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG5cbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuZyA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICBpZiAoIWNvbG9yKSByZXR1cm47IC8vIHBhcnNlIGNvbG9yXG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFNWRy5yZWdleC5pc1JnYi50ZXN0KGNvbG9yKSkge1xuICAgICAgICAvLyBnZXQgcmdiIHZhbHVlc1xuICAgICAgICBtYXRjaCA9IFNWRy5yZWdleC5yZ2IuZXhlYyhjb2xvci5yZXBsYWNlKFNWRy5yZWdleC53aGl0ZXNwYWNlLCAnJykpOyAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xuXG4gICAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICB0aGlzLmIgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICB9IGVsc2UgaWYgKFNWRy5yZWdleC5pc0hleC50ZXN0KGNvbG9yKSkge1xuICAgICAgICAvLyBnZXQgaGV4IHZhbHVlc1xuICAgICAgICBtYXRjaCA9IFNWRy5yZWdleC5oZXguZXhlYyhmdWxsSGV4KGNvbG9yKSk7IC8vIHBhcnNlIG51bWVyaWMgdmFsdWVzXG5cbiAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcbiAgICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoY29sb3IpID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5yID0gY29sb3IucjtcbiAgICAgIHRoaXMuZyA9IGNvbG9yLmc7XG4gICAgICB0aGlzLmIgPSBjb2xvci5iO1xuICAgIH1cbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5Db2xvciwge1xuICAgIC8vIERlZmF1bHQgdG8gaGV4IGNvbnZlcnNpb25cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH0sXG4gICAgLy8gQnVpbGQgaGV4IHZhbHVlXG4gICAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgcmV0dXJuICcjJyArIGNvbXBUb0hleCh0aGlzLnIpICsgY29tcFRvSGV4KHRoaXMuZykgKyBjb21wVG9IZXgodGhpcy5iKTtcbiAgICB9LFxuICAgIC8vIEJ1aWxkIHJnYiB2YWx1ZVxuICAgIHRvUmdiOiBmdW5jdGlvbiB0b1JnYigpIHtcbiAgICAgIHJldHVybiAncmdiKCcgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYl0uam9pbigpICsgJyknO1xuICAgIH0sXG4gICAgLy8gQ2FsY3VsYXRlIHRydWUgYnJpZ2h0bmVzc1xuICAgIGJyaWdodG5lc3M6IGZ1bmN0aW9uIGJyaWdodG5lc3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yIC8gMjU1ICogMC4zMCArIHRoaXMuZyAvIDI1NSAqIDAuNTkgKyB0aGlzLmIgLyAyNTUgKiAwLjExO1xuICAgIH0sXG4gICAgLy8gTWFrZSBjb2xvciBtb3JwaGFibGVcbiAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgoY29sb3IpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLkNvbG9yKGNvbG9yKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gR2V0IG1vcnBoZWQgY29sb3IgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBub3JtYWxpc2UgcG9zXG5cbiAgICAgIHBvcyA9IHBvcyA8IDAgPyAwIDogcG9zID4gMSA/IDEgOiBwb3M7IC8vIGdlbmVyYXRlIG1vcnBoZWQgY29sb3JcblxuICAgICAgcmV0dXJuIG5ldyBTVkcuQ29sb3Ioe1xuICAgICAgICByOiB+fih0aGlzLnIgKyAodGhpcy5kZXN0aW5hdGlvbi5yIC0gdGhpcy5yKSAqIHBvcyksXG4gICAgICAgIGc6IH5+KHRoaXMuZyArICh0aGlzLmRlc3RpbmF0aW9uLmcgLSB0aGlzLmcpICogcG9zKSxcbiAgICAgICAgYjogfn4odGhpcy5iICsgKHRoaXMuZGVzdGluYXRpb24uYiAtIHRoaXMuYikgKiBwb3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBUZXN0ZXJzXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcblxuICBTVkcuQ29sb3IudGVzdCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGNvbG9yICs9ICcnO1xuICAgIHJldHVybiBTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikgfHwgU1ZHLnJlZ2V4LmlzUmdiLnRlc3QoY29sb3IpO1xuICB9OyAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgcmdiIG9iamVjdFxuXG5cbiAgU1ZHLkNvbG9yLmlzUmdiID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yICYmIHR5cGVvZiBjb2xvci5yID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmIgPT09ICdudW1iZXInO1xuICB9OyAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcblxuXG4gIFNWRy5Db2xvci5pc0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIFNWRy5Db2xvci5pc1JnYihjb2xvcikgfHwgU1ZHLkNvbG9yLnRlc3QoY29sb3IpO1xuICB9OyAvLyBNb2R1bGUgZm9yIGFycmF5IGNvbnZlcnNpb25cblxuXG4gIFNWRy5BcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgZmFsbGJhY2spIHtcbiAgICBhcnJheSA9IChhcnJheSB8fCBbXSkudmFsdWVPZigpOyAvLyBpZiBhcnJheSBpcyBlbXB0eSBhbmQgZmFsbGJhY2sgaXMgcHJvdmlkZWQsIHVzZSBmYWxsYmFja1xuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PSAwICYmIGZhbGxiYWNrKSB7XG4gICAgICBhcnJheSA9IGZhbGxiYWNrLnZhbHVlT2YoKTtcbiAgICB9IC8vIHBhcnNlIGFycmF5XG5cblxuICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlKGFycmF5KTtcbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5BcnJheSwge1xuICAgIC8vIE1ha2UgYXJyYXkgbW9ycGhhYmxlXG4gICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKGFycmF5KSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdGhpcy5wYXJzZShhcnJheSk7IC8vIG5vcm1hbGl6ZSBsZW5ndGggb2YgYXJyYXlzXG5cbiAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCAhPSB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLnZhbHVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgbGFzdERlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvblt0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnZhbHVlLmxlbmd0aCA+IHRoaXMuZGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5wdXNoKGxhc3REZXN0aW5hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodGhpcy52YWx1ZS5sZW5ndGggPCB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudmFsdWUucHVzaChsYXN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQ2xlYW4gdXAgYW55IGR1cGxpY2F0ZSBwb2ludHNcbiAgICBzZXR0bGU6IGZ1bmN0aW9uIHNldHRsZSgpIHtcbiAgICAgIC8vIGZpbmQgYWxsIHVuaXF1ZSB2YWx1ZXNcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBzZWVuID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YodGhpcy52YWx1ZVtpXSkgPT0gLTEpIHtcbiAgICAgICAgICBzZWVuLnB1c2godGhpcy52YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2V0IG5ldyB2YWx1ZVxuXG5cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gc2VlbjtcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gZ2VuZXJhdGUgbW9ycGhlZCBhcnJheVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldICsgKHRoaXMuZGVzdGluYXRpb25baV0gLSB0aGlzLnZhbHVlW2ldKSAqIHBvcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU1ZHLkFycmF5KGFycmF5KTtcbiAgICB9LFxuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuam9pbignICcpO1xuICAgIH0sXG4gICAgLy8gUmVhbCB2YWx1ZVxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIC8vIFBhcnNlIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIHN0cmluZ1xuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShhcnJheSkge1xuICAgICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7IC8vIGlmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSByZXR1cm4gYXJyYXk7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdChhcnJheSk7XG4gICAgfSxcbiAgICAvLyBTdHJpcCB1bm5lY2Vzc2FyeSB3aGl0ZXNwYWNlXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIHNwbGl0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpO1xuICAgIH0sXG4gICAgLy8gUmV2ZXJzZSBhcnJheVxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB0aGlzLnZhbHVlLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgIGNsb25lLnZhbHVlID0gYXJyYXlfY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICB9KTsgLy8gUG9seSBwb2ludHMgYXJyYXlcblxuICBTVkcuUG9pbnRBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgZmFsbGJhY2spIHtcbiAgICBTVkcuQXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgZmFsbGJhY2sgfHwgW1swLCAwXV0pO1xuICB9OyAvLyBJbmhlcml0IGZyb20gU1ZHLkFycmF5XG5cblxuICBTVkcuUG9pbnRBcnJheS5wcm90b3R5cGUgPSBuZXcgU1ZHLkFycmF5KCk7XG4gIFNWRy5Qb2ludEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5Qb2ludEFycmF5O1xuICBTVkcuZXh0ZW5kKFNWRy5Qb2ludEFycmF5LCB7XG4gICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAvLyBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBhcnJheSA9IFtdOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXMudmFsdWVbaV0uam9pbignLCcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcbiAgICB0b0xpbmU6IGZ1bmN0aW9uIHRvTGluZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB0aGlzLnZhbHVlWzBdWzBdLFxuICAgICAgICB5MTogdGhpcy52YWx1ZVswXVsxXSxcbiAgICAgICAgeDI6IHRoaXMudmFsdWVbMV1bMF0sXG4gICAgICAgIHkyOiB0aGlzLnZhbHVlWzFdWzFdXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gR2V0IG1vcnBoZWQgYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBnZW5lcmF0ZSBtb3JwaGVkIHBvaW50IHN0cmluZ1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaChbdGhpcy52YWx1ZVtpXVswXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldWzBdIC0gdGhpcy52YWx1ZVtpXVswXSkgKiBwb3MsIHRoaXMudmFsdWVbaV1bMV0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVsxXSAtIHRoaXMudmFsdWVbaV1bMV0pICogcG9zXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50QXJyYXkoYXJyYXkpO1xuICAgIH0sXG4gICAgLy8gUGFyc2UgcG9pbnQgc3RyaW5nIGFuZCBmbGF0IGFycmF5XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGFycmF5KSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBhcnJheSA9IGFycmF5LnZhbHVlT2YoKTsgLy8gaWYgaXQgaXMgYW4gYXJyYXlcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIC8vIGFuZCBpdCBpcyBub3QgZmxhdCwgdGhlcmUgaXMgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdXNlIGEgY2xvbmVcbiAgICAgICAgICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnNsaWNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXlbMF0ueCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gYWxsb3cgcG9pbnQgb2JqZWN0cyB0byBiZSBwYXNzZWRcbiAgICAgICAgICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtlbC54LCBlbC55XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRWxzZSwgaXQgaXMgY29uc2lkZXJlZCBhcyBhIHN0cmluZ1xuICAgICAgICAvLyBwYXJzZSBwb2ludHNcbiAgICAgICAgYXJyYXkgPSBhcnJheS50cmltKCkuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgfSAvLyB2YWxpZGF0ZSBwb2ludHMgLSBodHRwczovL3N2Z3dnLm9yZy9zdmcyLWRyYWZ0L3NoYXBlcy5odG1sI0RhdGFUeXBlUG9pbnRzXG4gICAgICAvLyBPZGQgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIGlzIGFuIGVycm9yLiBJbiBzdWNoIGNhc2VzLCBkcm9wIHRoZSBsYXN0IG9kZCBjb29yZGluYXRlLlxuXG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKTsgLy8gd3JhcCBwb2ludHMgaW4gdHdvLXR1cGxlcyBhbmQgcGFyc2UgcG9pbnRzIGFzIGZsb2F0c1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpID0gaSArIDIpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goW2FycmF5W2ldLCBhcnJheVtpICsgMV1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuICAgIC8vIE1vdmUgcG9pbnQgc3RyaW5nXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICB2YXIgYm94ID0gdGhpcy5iYm94KCk7IC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcblxuICAgICAgeCAtPSBib3gueDtcbiAgICAgIHkgLT0gYm94Lnk7IC8vIG1vdmUgZXZlcnkgcG9pbnRcblxuICAgICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldID0gW3RoaXMudmFsdWVbaV1bMF0gKyB4LCB0aGlzLnZhbHVlW2ldWzFdICsgeV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBSZXNpemUgcG9seSBzdHJpbmdcbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGJveCA9IHRoaXMuYmJveCgpOyAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxuXG4gICAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChib3gud2lkdGgpIHRoaXMudmFsdWVbaV1bMF0gPSAodGhpcy52YWx1ZVtpXVswXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgIGlmIChib3guaGVpZ2h0KSB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwb2ludHNcbiAgICBiYm94OiBmdW5jdGlvbiBiYm94KCkge1xuICAgICAgaWYgKCFTVkcucGFyc2VyLmRyYXcpIHtcbiAgICAgICAgU1ZHLnByZXBhcmUoKTtcbiAgICAgIH1cblxuICAgICAgU1ZHLnBhcnNlci5wb2x5LnNldEF0dHJpYnV0ZSgncG9pbnRzJywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBTVkcucGFyc2VyLnBvbHkuZ2V0QkJveCgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBwYXRoSGFuZGxlcnMgPSB7XG4gICAgTTogZnVuY3Rpb24gTShjLCBwLCBwMCkge1xuICAgICAgcC54ID0gcDAueCA9IGNbMF07XG4gICAgICBwLnkgPSBwMC55ID0gY1sxXTtcbiAgICAgIHJldHVybiBbJ00nLCBwLngsIHAueV07XG4gICAgfSxcbiAgICBMOiBmdW5jdGlvbiBMKGMsIHApIHtcbiAgICAgIHAueCA9IGNbMF07XG4gICAgICBwLnkgPSBjWzFdO1xuICAgICAgcmV0dXJuIFsnTCcsIGNbMF0sIGNbMV1dO1xuICAgIH0sXG4gICAgSDogZnVuY3Rpb24gSChjLCBwKSB7XG4gICAgICBwLnggPSBjWzBdO1xuICAgICAgcmV0dXJuIFsnSCcsIGNbMF1dO1xuICAgIH0sXG4gICAgVjogZnVuY3Rpb24gVihjLCBwKSB7XG4gICAgICBwLnkgPSBjWzBdO1xuICAgICAgcmV0dXJuIFsnVicsIGNbMF1dO1xuICAgIH0sXG4gICAgQzogZnVuY3Rpb24gQyhjLCBwKSB7XG4gICAgICBwLnggPSBjWzRdO1xuICAgICAgcC55ID0gY1s1XTtcbiAgICAgIHJldHVybiBbJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdXTtcbiAgICB9LFxuICAgIFM6IGZ1bmN0aW9uIFMoYywgcCkge1xuICAgICAgcC54ID0gY1syXTtcbiAgICAgIHAueSA9IGNbM107XG4gICAgICByZXR1cm4gWydTJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV07XG4gICAgfSxcbiAgICBROiBmdW5jdGlvbiBRKGMsIHApIHtcbiAgICAgIHAueCA9IGNbMl07XG4gICAgICBwLnkgPSBjWzNdO1xuICAgICAgcmV0dXJuIFsnUScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dO1xuICAgIH0sXG4gICAgVDogZnVuY3Rpb24gVChjLCBwKSB7XG4gICAgICBwLnggPSBjWzBdO1xuICAgICAgcC55ID0gY1sxXTtcbiAgICAgIHJldHVybiBbJ1QnLCBjWzBdLCBjWzFdXTtcbiAgICB9LFxuICAgIFo6IGZ1bmN0aW9uIFooYywgcCwgcDApIHtcbiAgICAgIHAueCA9IHAwLng7XG4gICAgICBwLnkgPSBwMC55O1xuICAgICAgcmV0dXJuIFsnWiddO1xuICAgIH0sXG4gICAgQTogZnVuY3Rpb24gQShjLCBwKSB7XG4gICAgICBwLnggPSBjWzVdO1xuICAgICAgcC55ID0gY1s2XTtcbiAgICAgIHJldHVybiBbJ0EnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdXTtcbiAgICB9XG4gIH07XG4gIHZhciBtbGh2cXRjc2EgPSAnbWxodnF0Y3Nheicuc3BsaXQoJycpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpbCA9IG1saHZxdGNzYS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgcGF0aEhhbmRsZXJzW21saHZxdGNzYVtpXV0gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBwLCBwMCkge1xuICAgICAgICBpZiAoaSA9PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54O2Vsc2UgaWYgKGkgPT0gJ1YnKSBjWzBdID0gY1swXSArIHAueTtlbHNlIGlmIChpID09ICdBJykge1xuICAgICAgICAgIGNbNV0gPSBjWzVdICsgcC54LCBjWzZdID0gY1s2XSArIHAueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBjLmxlbmd0aDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgIGNbal0gPSBjW2pdICsgKGogJSAyID8gcC55IDogcC54KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMCk7XG4gICAgICB9O1xuICAgIH0obWxodnF0Y3NhW2ldLnRvVXBwZXJDYXNlKCkpO1xuICB9IC8vIFBhdGggcG9pbnRzIGFycmF5XG5cblxuICBTVkcuUGF0aEFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBmYWxsYmFjaykge1xuICAgIFNWRy5BcnJheS5jYWxsKHRoaXMsIGFycmF5LCBmYWxsYmFjayB8fCBbWydNJywgMCwgMF1dKTtcbiAgfTsgLy8gSW5oZXJpdCBmcm9tIFNWRy5BcnJheVxuXG5cbiAgU1ZHLlBhdGhBcnJheS5wcm90b3R5cGUgPSBuZXcgU1ZHLkFycmF5KCk7XG4gIFNWRy5QYXRoQXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHLlBhdGhBcnJheTtcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aEFycmF5LCB7XG4gICAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb1N0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIC8vIE1vdmUgcGF0aCBzdHJpbmdcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICAgIHZhciBib3ggPSB0aGlzLmJib3goKTsgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuXG4gICAgICB4IC09IGJveC54O1xuICAgICAgeSAtPSBib3gueTtcblxuICAgICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcbiAgICAgICAgLy8gbW92ZSBldmVyeSBwb2ludFxuICAgICAgICBmb3IgKHZhciBsLCBpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGwgPSB0aGlzLnZhbHVlW2ldWzBdO1xuXG4gICAgICAgICAgaWYgKGwgPT0gJ00nIHx8IGwgPT0gJ0wnIHx8IGwgPT0gJ1QnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdICs9IHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4O1xuICAgICAgICAgIH0gZWxzZSBpZiAobCA9PSAnVicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ0MnIHx8IGwgPT0gJ1MnIHx8IGwgPT0gJ1EnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdICs9IHk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzNdICs9IHg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzRdICs9IHk7XG5cbiAgICAgICAgICAgIGlmIChsID09ICdDJykge1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdICs9IHg7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzddICs9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVzaXplIHBhdGggc3RyaW5nXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGJveCA9IHRoaXMuYmJveCgpOyAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxuXG4gICAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGwgPSB0aGlzLnZhbHVlW2ldWzBdO1xuXG4gICAgICAgIGlmIChsID09ICdNJyB8fCBsID09ICdMJyB8fCBsID09ICdUJykge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSA9ICh0aGlzLnZhbHVlW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ0gnKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSA9ICh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdWJykge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSA9ICh0aGlzLnZhbHVlW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bM10gPSAodGhpcy52YWx1ZVtpXVszXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs0XSA9ICh0aGlzLnZhbHVlW2ldWzRdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuXG4gICAgICAgICAgaWYgKGwgPT0gJ0MnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdID0gKHRoaXMudmFsdWVbaV1bNV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICh0aGlzLnZhbHVlW2ldWzZdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykge1xuICAgICAgICAgIC8vIHJlc2l6ZSByYWRpaVxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSB0aGlzLnZhbHVlW2ldWzFdICogd2lkdGggLyBib3gud2lkdGg7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSA9IHRoaXMudmFsdWVbaV1bMl0gKiBoZWlnaHQgLyBib3guaGVpZ2h0OyAvLyBtb3ZlIHBvc2l0aW9uIHZhbHVlc1xuXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICh0aGlzLnZhbHVlW2ldWzZdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzddID0gKHRoaXMudmFsdWVbaV1bN10gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBUZXN0IGlmIHRoZSBwYXNzZWQgcGF0aCBhcnJheSB1c2UgdGhlIHNhbWUgcGF0aCBkYXRhIGNvbW1hbmRzIGFzIHRoaXMgcGF0aCBhcnJheVxuICAgIGVxdWFsQ29tbWFuZHM6IGZ1bmN0aW9uIGVxdWFsQ29tbWFuZHMocGF0aEFycmF5KSB7XG4gICAgICB2YXIgaSwgaWwsIGVxdWFsQ29tbWFuZHM7XG4gICAgICBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheShwYXRoQXJyYXkpO1xuICAgICAgZXF1YWxDb21tYW5kcyA9IHRoaXMudmFsdWUubGVuZ3RoID09PSBwYXRoQXJyYXkudmFsdWUubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoOyBlcXVhbENvbW1hbmRzICYmIGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlW2ldWzBdID09PSBwYXRoQXJyYXkudmFsdWVbaV1bMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcXVhbENvbW1hbmRzO1xuICAgIH0sXG4gICAgLy8gTWFrZSBwYXRoIGFycmF5IG1vcnBoYWJsZVxuICAgIG1vcnBoOiBmdW5jdGlvbiBtb3JwaChwYXRoQXJyYXkpIHtcbiAgICAgIHBhdGhBcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHBhdGhBcnJheSk7XG5cbiAgICAgIGlmICh0aGlzLmVxdWFsQ29tbWFuZHMocGF0aEFycmF5KSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gcGF0aEFycmF5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gR2V0IG1vcnBoZWQgcGF0aCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgc291cmNlQXJyYXkgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXkgPSB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlLFxuICAgICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkoKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGlsLFxuICAgICAgICAgIGosXG4gICAgICAgICAgamw7IC8vIEFuaW1hdGUgaGFzIHNwZWNpZmllZCBpbiB0aGUgU1ZHIHNwZWNcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhdGhzLmh0bWwjUGF0aEVsZW1lbnRcblxuICAgICAgZm9yIChpID0gMCwgaWwgPSBzb3VyY2VBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gW3NvdXJjZUFycmF5W2ldWzBdXTtcblxuICAgICAgICBmb3IgKGogPSAxLCBqbCA9IHNvdXJjZUFycmF5W2ldLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICBhcnJheVtpXVtqXSA9IHNvdXJjZUFycmF5W2ldW2pdICsgKGRlc3RpbmF0aW9uQXJyYXlbaV1bal0gLSBzb3VyY2VBcnJheVtpXVtqXSkgKiBwb3M7XG4gICAgICAgIH0gLy8gRm9yIHRoZSB0d28gZmxhZ3Mgb2YgdGhlIGVsbGlwdGljYWwgYXJjIGNvbW1hbmQsIHRoZSBTVkcgc3BlYyBzYXk6XG4gICAgICAgIC8vIEZsYWdzIGFuZCBib29sZWFucyBhcmUgaW50ZXJwb2xhdGVkIGFzIGZyYWN0aW9ucyBiZXR3ZWVuIHplcm8gYW5kIG9uZSwgd2l0aCBhbnkgbm9uLXplcm8gdmFsdWUgY29uc2lkZXJlZCB0byBiZSBhIHZhbHVlIG9mIG9uZS90cnVlXG4gICAgICAgIC8vIEVsbGlwdGljYWwgYXJjIGNvbW1hbmQgYXMgYW4gYXJyYXkgZm9sbG93ZWQgYnkgY29ycmVzcG9uZGluZyBpbmRleGVzOlxuICAgICAgICAvLyBbJ0EnLCByeCwgcnksIHgtYXhpcy1yb3RhdGlvbiwgbGFyZ2UtYXJjLWZsYWcsIHN3ZWVwLWZsYWcsIHgsIHldXG4gICAgICAgIC8vICAgMCAgICAxICAgMiAgICAgICAgMyAgICAgICAgICAgICAgICAgNCAgICAgICAgICAgICA1ICAgICAgNiAgN1xuXG5cbiAgICAgICAgaWYgKGFycmF5W2ldWzBdID09PSAnQScpIHtcbiAgICAgICAgICBhcnJheVtpXVs0XSA9ICsoYXJyYXlbaV1bNF0gIT0gMCk7XG4gICAgICAgICAgYXJyYXlbaV1bNV0gPSArKGFycmF5W2ldWzVdICE9IDApO1xuICAgICAgICB9XG4gICAgICB9IC8vIERpcmVjdGx5IG1vZGlmeSB0aGUgdmFsdWUgb2YgYSBwYXRoIGFycmF5LCB0aGlzIGlzIGRvbmUgdGhpcyB3YXkgZm9yIHBlcmZvcm1hbmNlXG5cblxuICAgICAgcGF0aEFycmF5LnZhbHVlID0gYXJyYXk7XG4gICAgICByZXR1cm4gcGF0aEFycmF5O1xuICAgIH0sXG4gICAgLy8gQWJzb2x1dGl6ZSBhbmQgcGFyc2UgcGF0aCB0byBhcnJheVxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShhcnJheSkge1xuICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgcGF0aGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0XG4gICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBTVkcuUGF0aEFycmF5KSByZXR1cm4gYXJyYXkudmFsdWVPZigpOyAvLyBwcmVwYXJlIGZvciBwYXJzaW5nXG5cbiAgICAgIHZhciBzLFxuICAgICAgICAgIGFycixcbiAgICAgICAgICBwYXJhbUNudCA9IHtcbiAgICAgICAgJ00nOiAyLFxuICAgICAgICAnTCc6IDIsXG4gICAgICAgICdIJzogMSxcbiAgICAgICAgJ1YnOiAxLFxuICAgICAgICAnQyc6IDYsXG4gICAgICAgICdTJzogNCxcbiAgICAgICAgJ1EnOiA0LFxuICAgICAgICAnVCc6IDIsXG4gICAgICAgICdBJzogNyxcbiAgICAgICAgJ1onOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIGFycmF5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhcnJheSA9IGFycmF5LnJlcGxhY2UoU1ZHLnJlZ2V4Lm51bWJlcnNXaXRoRG90cywgcGF0aFJlZ1JlcGxhY2UpIC8vIGNvbnZlcnQgNDUuMTIzLjEyMyB0byA0NS4xMjMgLjEyM1xuICAgICAgICAucmVwbGFjZShTVkcucmVnZXgucGF0aExldHRlcnMsICcgJCYgJykgLy8gcHV0IHNvbWUgcm9vbSBiZXR3ZWVuIGxldHRlcnMgYW5kIG51bWJlcnNcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4Lmh5cGhlbiwgJyQxIC0nKSAvLyBhZGQgc3BhY2UgYmVmb3JlIGh5cGhlblxuICAgICAgICAudHJpbSgpIC8vIHRyaW1cbiAgICAgICAgLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpOyAvLyBzcGxpdCBpbnRvIGFycmF5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheSA9IGFycmF5LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuY2FsbChwcmV2LCBjdXJyKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgfSAvLyBhcnJheSBub3cgaXMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgcGFydHMgb2YgYSBwYXRoIGUuZy4gWydNJywgJzAnLCAnMCcsICdMJywgJzMwJywgJzMwJyAuLi5dXG5cblxuICAgICAgdmFyIGFyciA9IFtdLFxuICAgICAgICAgIHAgPSBuZXcgU1ZHLlBvaW50KCksXG4gICAgICAgICAgcDAgPSBuZXcgU1ZHLlBvaW50KCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgZG8ge1xuICAgICAgICAvLyBUZXN0IGlmIHdlIGhhdmUgYSBwYXRoIGxldHRlclxuICAgICAgICBpZiAoU1ZHLnJlZ2V4LmlzUGF0aExldHRlci50ZXN0KGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgICBzID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICsraW5kZXg7IC8vIElmIGxhc3QgbGV0dGVyIHdhcyBhIG1vdmUgY29tbWFuZCBhbmQgd2UgZ290IG5vIG5ldywgaXQgZGVmYXVsdHMgdG8gW0xdaW5lXG4gICAgICAgIH0gZWxzZSBpZiAocyA9PSAnTScpIHtcbiAgICAgICAgICBzID0gJ0wnO1xuICAgICAgICB9IGVsc2UgaWYgKHMgPT0gJ20nKSB7XG4gICAgICAgICAgcyA9ICdsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGFyci5wdXNoKHBhdGhIYW5kbGVyc1tzXS5jYWxsKG51bGwsIGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCA9IGluZGV4ICsgcGFyYW1DbnRbcy50b1VwcGVyQ2FzZSgpXSkubWFwKHBhcnNlRmxvYXQpLCBwLCBwMCkpO1xuICAgICAgfSB3aGlsZSAobGVuID4gaW5kZXgpO1xuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwYXRoXG4gICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICB9XG5cbiAgICAgIFNWRy5wYXJzZXIucGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgcmV0dXJuIFNWRy5wYXJzZXIucGF0aC5nZXRCQm94KCk7XG4gICAgfVxuICB9KTsgLy8gTW9kdWxlIGZvciB1bml0IGNvbnZlcnRpb25zXG5cbiAgU1ZHLk51bWJlciA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgdW5pdCkge1xuICAgICAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICcnOyAvLyBwYXJzZSB2YWx1ZVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXG4gICAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSkgPyAwIDogIWlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDwgMCA/IC0zLjRlKzM4IDogKzMuNGUrMzggOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB1bml0ID0gdmFsdWUubWF0Y2goU1ZHLnJlZ2V4Lm51bWJlckFuZFVuaXQpO1xuXG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgLy8gbWFrZSB2YWx1ZSBudW1lcmljXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodW5pdFsxXSk7IC8vIG5vcm1hbGl6ZVxuXG4gICAgICAgICAgaWYgKHVuaXRbNV0gPT0gJyUnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlIC89IDEwMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRbNV0gPT0gJ3MnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlICo9IDEwMDA7XG4gICAgICAgICAgfSAvLyBzdG9yZSB1bml0XG5cblxuICAgICAgICAgIHRoaXMudW5pdCA9IHVuaXRbNV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICAgIHRoaXMudW5pdCA9IHZhbHVlLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBTdHJpbmdhbGl6ZVxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudW5pdCA9PSAnJScgPyB+fih0aGlzLnZhbHVlICogMWU4KSAvIDFlNiA6IHRoaXMudW5pdCA9PSAncycgPyB0aGlzLnZhbHVlIC8gMWUzIDogdGhpcy52YWx1ZSkgKyB0aGlzLnVuaXQ7XG4gICAgICB9LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgLy8gQ29udmVydCB0byBwcmltaXRpdmVcbiAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBudW1iZXJcbiAgICAgIHBsdXM6IGZ1bmN0aW9uIHBsdXMobnVtYmVyKSB7XG4gICAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzICsgbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICAgICAgfSxcbiAgICAgIC8vIFN1YnRyYWN0IG51bWJlclxuICAgICAgbWludXM6IGZ1bmN0aW9uIG1pbnVzKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyAtIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgIH0sXG4gICAgICAvLyBNdWx0aXBseSBudW1iZXJcbiAgICAgIHRpbWVzOiBmdW5jdGlvbiB0aW1lcyhudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgKiBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gICAgICB9LFxuICAgICAgLy8gRGl2aWRlIG51bWJlclxuICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobnVtYmVyKSB7XG4gICAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICAgICAgfSxcbiAgICAgIC8vIENvbnZlcnQgdG8gZGlmZmVyZW50IHVuaXRcbiAgICAgIHRvOiBmdW5jdGlvbiB0byh1bml0KSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcih0aGlzKTtcblxuICAgICAgICBpZiAodHlwZW9mIHVuaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbnVtYmVyLnVuaXQgPSB1bml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH0sXG4gICAgICAvLyBNYWtlIG51bWJlciBtb3JwaGFibGVcbiAgICAgIG1vcnBoOiBmdW5jdGlvbiBtb3JwaChudW1iZXIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG5cbiAgICAgICAgaWYgKG51bWJlci5yZWxhdGl2ZSkge1xuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24udmFsdWUgKz0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtb3JwaGVkIG51bWJlciBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7IC8vIEdlbmVyYXRlIG5ldyBtb3JwaGVkIG51bWJlclxuXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzLmRlc3RpbmF0aW9uKS5taW51cyh0aGlzKS50aW1lcyhwb3MpLnBsdXModGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLkVsZW1lbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShub2RlKSB7XG4gICAgICAvLyBtYWtlIHN0cm9rZSB2YWx1ZSBhY2Nlc3NpYmxlIGR5bmFtaWNhbGx5XG4gICAgICB0aGlzLl9zdHJva2UgPSBTVkcuZGVmYXVsdHMuYXR0cnMuc3Ryb2tlO1xuICAgICAgdGhpcy5fZXZlbnQgPSBudWxsOyAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XG5cbiAgICAgIHRoaXMuZG9tID0ge307IC8vIGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcblxuICAgICAgaWYgKHRoaXMubm9kZSA9IG5vZGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgdGhpcy5ub2RlLmluc3RhbmNlID0gdGhpczsgLy8gc3RvcmUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWVcblxuICAgICAgICB0aGlzLl9zdHJva2UgPSBub2RlLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgdGhpcy5fc3Ryb2tlO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICAgIHg6IGZ1bmN0aW9uIHgoX3gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIF94KTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCBfeSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgIGN4OiBmdW5jdGlvbiBjeCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLngoKSArIHRoaXMud2lkdGgoKSAvIDIgOiB0aGlzLngoeCAtIHRoaXMud2lkdGgoKSAvIDIpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMiA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgZWxlbWVudCB0byBnaXZlbiB4IGFuZCB5IHZhbHVlc1xuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLngoeCkueSh5KTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxuICAgICAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jeCh4KS5jeSh5KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKF93aWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIF93aWR0aCk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hlaWdodCcsIF9oZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGgobmV3IFNWRy5OdW1iZXIocC53aWR0aCkpLmhlaWdodChuZXcgU1ZHLk51bWJlcihwLmhlaWdodCkpO1xuICAgICAgfSxcbiAgICAgIC8vIENsb25lIGVsZW1lbnRcbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShwYXJlbnQpIHtcbiAgICAgICAgLy8gd3JpdGUgZG9tIGRhdGEgdG8gdGhlIGRvbSBzbyB0aGUgY2xvbmUgY2FuIHBpY2t1cCB0aGUgZGF0YVxuICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKCk7IC8vIGNsb25lIGVsZW1lbnQgYW5kIGFzc2lnbiBuZXcgaWRcblxuICAgICAgICB2YXIgY2xvbmUgPSBhc3NpZ25OZXdJZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gaW5zZXJ0IHRoZSBjbG9uZSBpbiB0aGUgZ2l2ZW4gcGFyZW50IG9yIGFmdGVyIG15c2VsZlxuXG4gICAgICAgIGlmIChwYXJlbnQpIHBhcmVudC5hZGQoY2xvbmUpO2Vsc2UgdGhpcy5hZnRlcihjbG9uZSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgZWxlbWVudFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCgpKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gUmVwbGFjZSBlbGVtZW50XG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hZnRlcihlbGVtZW50KS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gc2VsZlxuICAgICAgYWRkVG86IGZ1bmN0aW9uIGFkZFRvKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LnB1dCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBjb250YWluZXJcbiAgICAgIHB1dEluOiBmdW5jdGlvbiBwdXRJbihwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5hZGQodGhpcyk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IC8gc2V0IGlkXG4gICAgICBpZDogZnVuY3Rpb24gaWQoX2lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgX2lkKTtcbiAgICAgIH0sXG4gICAgICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaW5zaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRcbiAgICAgIGluc2lkZTogZnVuY3Rpb24gaW5zaWRlKHgsIHkpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpO1xuICAgICAgICByZXR1cm4geCA+IGJveC54ICYmIHkgPiBib3gueSAmJiB4IDwgYm94LnggKyBib3gud2lkdGggJiYgeSA8IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgIH0sXG4gICAgICAvLyBTaG93IGVsZW1lbnRcbiAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJycpO1xuICAgICAgfSxcbiAgICAgIC8vIEhpZGUgZWxlbWVudFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgfSxcbiAgICAgIC8vIElzIGVsZW1lbnQgdmlzaWJsZT9cbiAgICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JykgIT0gJ25vbmUnO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiBpZCBvbiBzdHJpbmcgY29udmVyc2lvblxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiBhcnJheSBvZiBjbGFzc2VzIG9uIHRoZSBub2RlXG4gICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cignY2xhc3MnKTtcbiAgICAgICAgcmV0dXJuIGF0dHIgPT0gbnVsbCA/IFtdIDogYXR0ci50cmltKCkuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcik7XG4gICAgICB9LFxuICAgICAgLy8gUmV0dXJuIHRydWUgaWYgY2xhc3MgZXhpc3RzIG9uIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXMoKS5pbmRleE9mKG5hbWUpICE9IC0xO1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBjbGFzcyB0byB0aGUgbm9kZVxuICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5jbGFzc2VzKCk7XG4gICAgICAgICAgYXJyYXkucHVzaChuYW1lKTtcbiAgICAgICAgICB0aGlzLmF0dHIoJ2NsYXNzJywgYXJyYXkuam9pbignICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZSBjbGFzcyBmcm9tIHRoZSBub2RlXG4gICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgIHRoaXMuYXR0cignY2xhc3MnLCB0aGlzLmNsYXNzZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjICE9IG5hbWU7XG4gICAgICAgICAgfSkuam9pbignICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFRvZ2dsZSB0aGUgcHJlc2VuY2Ugb2YgYSBjbGFzcyBvbiB0aGUgbm9kZVxuICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MobmFtZSkgPyB0aGlzLnJlbW92ZUNsYXNzKG5hbWUpIDogdGhpcy5hZGRDbGFzcyhuYW1lKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgcmVmZXJlbmNlZCBlbGVtZW50IGZvcm0gYXR0cmlidXRlIHZhbHVlXG4gICAgICByZWZlcmVuY2U6IGZ1bmN0aW9uIHJlZmVyZW5jZShhdHRyKSB7XG4gICAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMuYXR0cihhdHRyKSk7XG4gICAgICB9LFxuICAgICAgLy8gUmV0dXJucyB0aGUgcGFyZW50IGVsZW1lbnQgaW5zdGFuY2VcbiAgICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHR5cGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7IC8vIGNoZWNrIGZvciBwYXJlbnRcblxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUpIHJldHVybiBudWxsOyAvLyBnZXQgcGFyZW50IGVsZW1lbnRcblxuICAgICAgICBwYXJlbnQgPSBTVkcuYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHBhcmVudDsgLy8gbG9vcCB0cm91Z2ggYW5jZXN0b3JzIGlmIHR5cGUgaXMgZ2l2ZW5cblxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5ub2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50Lm1hdGNoZXModHlwZSkgOiBwYXJlbnQgaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4gcGFyZW50O1xuICAgICAgICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSB8fCBwYXJlbnQubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnKSByZXR1cm4gbnVsbDsgLy8gIzc1OSwgIzcyMFxuXG4gICAgICAgICAgcGFyZW50ID0gU1ZHLmFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHBhcmVudCBkb2N1bWVudFxuICAgICAgZG9jOiBmdW5jdGlvbiBkb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgU1ZHLkRvYyA/IHRoaXMgOiB0aGlzLnBhcmVudChTVkcuRG9jKTtcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xuICAgICAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyh0eXBlKSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gW10sXG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KHR5cGUpO1xuICAgICAgICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQubm9kZSkgYnJlYWs7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH0gd2hpbGUgKHBhcmVudC5wYXJlbnQpO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgICAgfSxcbiAgICAgIC8vIG1hdGNoZXMgdGhlIGVsZW1lbnQgdnMgYSBjc3Mgc2VsZWN0b3JcbiAgICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIF9tYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybnMgdGhlIHN2ZyBub2RlIHRvIGNhbGwgbmF0aXZlIHN2ZyBtZXRob2RzIG9uIGl0XG4gICAgICBuYXRpdmU6IGZ1bmN0aW9uIG5hdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH0sXG4gICAgICAvLyBJbXBvcnQgcmF3IHN2Z1xuICAgICAgc3ZnOiBmdW5jdGlvbiBzdmcoX3N2Zykge1xuICAgICAgICAvLyBjcmVhdGUgdGVtcG9yYXJ5IGhvbGRlclxuICAgICAgICB2YXIgd2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N2ZycpOyAvLyBhY3QgYXMgYSBzZXR0ZXIgaWYgc3ZnIGlzIGdpdmVuXG5cbiAgICAgICAgaWYgKF9zdmcgJiYgdGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnQpIHtcbiAgICAgICAgICAvLyBkdW1wIHJhdyBzdmdcbiAgICAgICAgICB3ZWxsLmlubmVySFRNTCA9ICc8c3ZnPicgKyBfc3ZnLnJlcGxhY2UoL1xcbi8sICcnKS5yZXBsYWNlKC88KFtcXHc6LV0rKShbXjxdKz8pXFwvPi9nLCAnPCQxJDI+PC8kMT4nKSArICc8L3N2Zz4nOyAvLyB0cmFuc3BsYW50IG5vZGVzXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB3ZWxsLmZpcnN0Q2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQod2VsbC5maXJzdENoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIGdldHRlclxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgd3JhcHBpbmcgc3ZnIGVsZW1lbnQgaW4gY2FzZSBvZiBwYXJ0aWFsIGNvbnRlbnRcbiAgICAgICAgICB3ZWxsLmFwcGVuZENoaWxkKF9zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKSk7IC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuXG4gICAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpOyAvLyBpbnNlcnQgYSBjb3B5IG9mIHRoaXMgbm9kZVxuXG4gICAgICAgICAgX3N2Zy5hcHBlbmRDaGlsZCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gcmV0dXJuIHRhcmdldCBlbGVtZW50XG5cblxuICAgICAgICAgIHJldHVybiB3ZWxsLmlubmVySFRNTC5yZXBsYWNlKC9ePHN2Zz4vLCAnJykucmVwbGFjZSgvPFxcL3N2Zz4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXG4gICAgICB3cml0ZURhdGFUb0RvbTogZnVuY3Rpb24gd3JpdGVEYXRhVG9Eb20oKSB7XG4gICAgICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmICh0aGlzLmVhY2ggfHwgdGhpcy5saW5lcykge1xuICAgICAgICAgIHZhciBmbiA9IHRoaXMuZWFjaCA/IHRoaXMgOiB0aGlzLmxpbmVzKCk7XG4gICAgICAgICAgZm4uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gcmVtb3ZlIHByZXZpb3VzbHkgc2V0IGRhdGFcblxuXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kb20pLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRvbSkpO1xuICAgICAgICB9IC8vIHNlZSAjNDI4XG5cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBzZXQgZ2l2ZW4gZGF0YSB0byB0aGUgZWxlbWVudHMgZGF0YSBwcm9wZXJ0eVxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShvKSB7XG4gICAgICAgIHRoaXMuZG9tID0gbztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgaXM6IGZ1bmN0aW9uIGlzKG9iaikge1xuICAgICAgICByZXR1cm4gX2lzKHRoaXMsIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmVhc2luZyA9IHtcbiAgICAnLSc6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH0sXG4gICAgJzw+JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgIHJldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSkgLyAyICsgMC41O1xuICAgIH0sXG4gICAgJz4nOiBmdW5jdGlvbiBfKHBvcykge1xuICAgICAgcmV0dXJuIE1hdGguc2luKHBvcyAqIE1hdGguUEkgLyAyKTtcbiAgICB9LFxuICAgICc8JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgIHJldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSAvIDIpICsgMTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHLm1vcnBoID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1vcnBoT2JqKGZyb20sIHRvKS5hdChwb3MpO1xuICAgIH07XG4gIH07XG5cbiAgU1ZHLlNpdHVhdGlvbiA9IFNWRy5pbnZlbnQoe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKG8pIHtcbiAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXZlcnNpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXcgU1ZHLk51bWJlcihvLmR1cmF0aW9uKS52YWx1ZU9mKCk7XG4gICAgICB0aGlzLmRlbGF5ID0gbmV3IFNWRy5OdW1iZXIoby5kZWxheSkudmFsdWVPZigpO1xuICAgICAgdGhpcy5zdGFydCA9ICtuZXcgRGF0ZSgpICsgdGhpcy5kZWxheTtcbiAgICAgIHRoaXMuZmluaXNoID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgICB0aGlzLmVhc2UgPSBvLmVhc2U7IC8vIHRoaXMubG9vcCBpcyBpbmNyZW1lbnRlZCBmcm9tIDAgdG8gdGhpcy5sb29wc1xuICAgICAgLy8gaXQgaXMgYWxzbyBpbmNyZW1lbnRlZCB3aGVuIGluIGFuIGluZmluaXRlIGxvb3AgKHdoZW4gdGhpcy5sb29wcyBpcyB0cnVlKVxuXG4gICAgICB0aGlzLmxvb3AgPSAwO1xuICAgICAgdGhpcy5sb29wcyA9IGZhbHNlO1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gey8vIGZ1bmN0aW9uVG9DYWxsOiBbbGlzdCBvZiBtb3JwaGFibGUgb2JqZWN0c11cbiAgICAgICAgLy8gZS5nLiBtb3ZlOiBbU1ZHLk51bWJlciwgU1ZHLk51bWJlcl1cbiAgICAgIH07XG4gICAgICB0aGlzLmF0dHJzID0gey8vIGhvbGRzIGFsbCBhdHRyaWJ1dGVzIHdoaWNoIGFyZSBub3QgcmVwcmVzZW50ZWQgZnJvbSBhIGZ1bmN0aW9uIHN2Zy5qcyBwcm92aWRlc1xuICAgICAgICAvLyBlLmcuIHNvbWVBdHRyOiBTVkcuTnVtYmVyXG4gICAgICB9O1xuICAgICAgdGhpcy5zdHlsZXMgPSB7Ly8gaG9sZHMgYWxsIHN0eWxlcyB3aGljaCBzaG91bGQgYmUgYW5pbWF0ZWRcbiAgICAgICAgLy8gZS5nLiBmaWxsLWNvbG9yOiBTVkcuQ29sb3JcbiAgICAgIH07XG4gICAgICB0aGlzLnRyYW5zZm9ybXMgPSBbLy8gaG9sZHMgYWxsIHRyYW5zZm9ybWF0aW9ucyBhcyB0cmFuc2Zvcm1hdGlvbiBvYmplY3RzXG4gICAgICAgIC8vIGUuZy4gW1NWRy5Sb3RhdGUsIFNWRy5UcmFuc2xhdGUsIFNWRy5NYXRyaXhdXG4gICAgICBdO1xuICAgICAgdGhpcy5vbmNlID0gey8vIGZ1bmN0aW9ucyB0byBmaXJlIGF0IGEgc3BlY2lmaWMgcG9zaXRpb25cbiAgICAgICAgLy8gZS5nLiBcIjAuNVwiOiBmdW5jdGlvbiBmb28oKXt9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIFNWRy5GWCA9IFNWRy5pbnZlbnQoe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLnNpdHVhdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnNpdHVhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXN0UG9zID0gMDtcbiAgICAgIHRoaXMucG9zID0gMDsgLy8gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGFuaW1hdGlvbiBpcyBpdHMgcG9zaXRpb24gaW4gdGhlIGNvbnRleHQgb2YgaXRzIGNvbXBsZXRlIGR1cmF0aW9uIChpbmNsdWRpbmcgZGVsYXkgYW5kIGxvb3BzKVxuICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgZGVsYXksIGFic1BvcyBpcyBiZWxvdyAwIGFuZCB3aGVuIHBlcmZvcm1pbmcgYSBsb29wLCBpdHMgdmFsdWUgaXMgYWJvdmUgMVxuXG4gICAgICB0aGlzLmFic1BvcyA9IDA7XG4gICAgICB0aGlzLl9zcGVlZCA9IDE7XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cbiAgICAgICAqIEBwYXJhbSBvIG9iamVjdCB8fCBudW1iZXIgSW4gY2FzZSBvZiBPYmplY3QgaXQgaG9sZHMgYWxsIHBhcmFtZXRlcnMuIEluIGNhc2Ugb2YgbnVtYmVyIGl0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICogQHBhcmFtIGVhc2UgZnVuY3Rpb24gfHwgc3RyaW5nIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1c2VkIGZvciBlYXNpbmcgb3IgZWFzaW5nIGtleXdvcmRcbiAgICAgICAqIEBwYXJhbSBkZWxheSBOdW1iZXIgaW5kaWNhdGluZyB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzXG4gICAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUobywgZWFzZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKF90eXBlb2YobykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZWFzZSA9IG8uZWFzZTtcbiAgICAgICAgICBkZWxheSA9IG8uZGVsYXk7XG4gICAgICAgICAgbyA9IG8uZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l0dWF0aW9uID0gbmV3IFNWRy5TaXR1YXRpb24oe1xuICAgICAgICAgIGR1cmF0aW9uOiBvIHx8IDEwMDAsXG4gICAgICAgICAgZGVsYXk6IGRlbGF5IHx8IDAsXG4gICAgICAgICAgZWFzZTogU1ZHLmVhc2luZ1tlYXNlIHx8ICctJ10gfHwgZWFzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWV1ZShzaXR1YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBzZXRzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHF1ZXVlIGlzIGNhbGxlZFxuICAgICAgKiBAcGFyYW0gZGVsYXkgRHVyYXRpb24gb2YgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAqIEByZXR1cm4gdGhpcy50YXJnZXQoKVxuICAgICAgKi9cbiAgICAgIGRlbGF5OiBmdW5jdGlvbiBkZWxheShfZGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIGRlbGF5IGlzIHBlcmZvcm1lZCBieSBhbiBlbXB0eSBzaXR1YXRpb24gd2l0aCBpdHMgZHVyYXRpb25cbiAgICAgICAgLy8gYXR0cmlidXRlIHNldCB0byB0aGUgZHVyYXRpb24gb2YgdGhlIGRlbGF5XG4gICAgICAgIHZhciBzaXR1YXRpb24gPSBuZXcgU1ZHLlNpdHVhdGlvbih7XG4gICAgICAgICAgZHVyYXRpb246IF9kZWxheSxcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBlYXNlOiBTVkcuZWFzaW5nWyctJ11cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHNpdHVhdGlvbik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cbiAgICAgICogQHBhcmFtIG51bGwgfHwgdGFyZ2V0IFNWRy5FbGVtZW50IHdoaWNoIHNob3VsZCBiZSBzZXQgYXMgbmV3IHRhcmdldFxuICAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXG4gICAgICAqL1xuICAgICAgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoX3RhcmdldCkge1xuICAgICAgICBpZiAoX3RhcmdldCAmJiBfdGFyZ2V0IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl90YXJnZXQgPSBfdGFyZ2V0O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm5zIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBhdCBhIGdpdmVuIHRpbWVcbiAgICAgIHRpbWVUb0Fic1BvczogZnVuY3Rpb24gdGltZVRvQWJzUG9zKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gKHRpbWVzdGFtcCAtIHRoaXMuc2l0dWF0aW9uLnN0YXJ0KSAvICh0aGlzLnNpdHVhdGlvbi5kdXJhdGlvbiAvIHRoaXMuX3NwZWVkKTtcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm5zIHRoZSB0aW1lc3RhbXAgZnJvbSBhIGdpdmVuIGFic29sdXRlIHBvc2l0b25cbiAgICAgIGFic1Bvc1RvVGltZTogZnVuY3Rpb24gYWJzUG9zVG9UaW1lKGFic1Bvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZCAqIGFic1BvcyArIHRoaXMuc2l0dWF0aW9uLnN0YXJ0O1xuICAgICAgfSxcbiAgICAgIC8vIHN0YXJ0cyB0aGUgYW5pbWF0aW9ubG9vcFxuICAgICAgc3RhcnRBbmltRnJhbWU6IGZ1bmN0aW9uIHN0YXJ0QW5pbUZyYW1lKCkge1xuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuc3RlcCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSxcbiAgICAgIC8vIGNhbmNlbHMgdGhlIGFuaW1hdGlvbmZyYW1lXG4gICAgICBzdG9wQW5pbUZyYW1lOiBmdW5jdGlvbiBzdG9wQW5pbUZyYW1lKCkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8ga2lja3Mgb2ZmIHRoZSBhbmltYXRpb24gLSBvbmx5IGRvZXMgc29tZXRoaW5nIHdoZW4gdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBub3QgYWN0aXZlIGFuZCBhdCBsZWFzdCBvbmUgc2l0dWF0aW9uIGlzIHNldFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICAvLyBkb250IHN0YXJ0IGlmIGFscmVhZHkgc3RhcnRlZFxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlICYmIHRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhcnRDdXJyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBzdGFydCB0aGUgY3VycmVudCBzaXR1YXRpb25cbiAgICAgIHN0YXJ0Q3VycmVudDogZnVuY3Rpb24gc3RhcnRDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCA9ICtuZXcgRGF0ZSgpICsgdGhpcy5zaXR1YXRpb24uZGVsYXkgLyB0aGlzLl9zcGVlZDtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24uZmluaXNoID0gdGhpcy5zaXR1YXRpb24uc3RhcnQgKyB0aGlzLnNpdHVhdGlvbi5kdXJhdGlvbiAvIHRoaXMuX3NwZWVkO1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0QW5pbWF0aW9ucygpLnN0ZXAoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBhZGRzIGEgZnVuY3Rpb24gLyBTaXR1YXRpb24gdG8gdGhlIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gLyBzaXR1YXRpb24gdG8gYWRkXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nIHx8IGZuIGluc3RhbmNlb2YgU1ZHLlNpdHVhdGlvbikge1xuICAgICAgICAgIHRoaXMuc2l0dWF0aW9ucy5wdXNoKGZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zaXR1YXRpb24pIHRoaXMuc2l0dWF0aW9uID0gdGhpcy5zaXR1YXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHB1bGxzIG5leHQgZWxlbWVudCBmcm9tIHRoZSBxdWV1ZSBhbmQgZXhlY3V0ZSBpdFxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgICAvLyBzdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMuc3RvcCgpOyAvLyBnZXQgbmV4dCBhbmltYXRpb24gZnJvbSBxdWV1ZVxuXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uID0gdGhpcy5zaXR1YXRpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uIGluc3RhbmNlb2YgU1ZHLlNpdHVhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgYSBTVkcuU2l0dWF0aW9uLCB0aGVuIGl0IGlzIGEgZnVuY3Rpb24sIHdlIGV4ZWN1dGUgaXRcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gdXBkYXRlcyBhbGwgYW5pbWF0aW9ucyB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgd2hlbiBvbmUgcHJvcGVydHkgY291bGQgYmUgY2hhbmdlZCBmcm9tIGFub3RoZXIgcHJvcGVydHlcbiAgICAgIGluaXRBbmltYXRpb25zOiBmdW5jdGlvbiBpbml0QW5pbWF0aW9ucygpIHtcbiAgICAgICAgdmFyIGksIGosIHNvdXJjZTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNpdHVhdGlvbjtcbiAgICAgICAgaWYgKHMuaW5pdCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgZm9yIChpIGluIHMuYW5pbWF0aW9ucykge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMudGFyZ2V0KClbaV0oKTtcblxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocy5hbmltYXRpb25zW2ldKSkge1xuICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldID0gW3MuYW5pbWF0aW9uc1tpXV07XG4gICAgICAgICAgfSAvLyBpZihzLmFuaW1hdGlvbnNbaV0ubGVuZ3RoID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgIC8vICBzb3VyY2UuY29uY2F0ID0gc291cmNlLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0uc2xpY2Uoc291cmNlLmxlbmd0aCwgcy5hbmltYXRpb25zW2ldLmxlbmd0aCkpXG4gICAgICAgICAgLy8gfVxuXG5cbiAgICAgICAgICBmb3IgKGogPSBzb3VyY2UubGVuZ3RoOyBqLS07KSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZGl0aW9uIGlzIGJlY2F1c2Ugc29tZSBtZXRob2RzIHJldHVybiBhIG5vcm1hbCBudW1iZXIgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgYSBTVkcuTnVtYmVyXG4gICAgICAgICAgICBpZiAocy5hbmltYXRpb25zW2ldW2pdIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgICAgICBzb3VyY2Vbal0gPSBuZXcgU1ZHLk51bWJlcihzb3VyY2Vbal0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzLmFuaW1hdGlvbnNbaV1bal0gPSBzb3VyY2Vbal0ubW9ycGgocy5hbmltYXRpb25zW2ldW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgaW4gcy5hdHRycykge1xuICAgICAgICAgIHMuYXR0cnNbaV0gPSBuZXcgU1ZHLk1vcnBoT2JqKHRoaXMudGFyZ2V0KCkuYXR0cihpKSwgcy5hdHRyc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgaW4gcy5zdHlsZXMpIHtcbiAgICAgICAgICBzLnN0eWxlc1tpXSA9IG5ldyBTVkcuTW9ycGhPYmoodGhpcy50YXJnZXQoKS5zdHlsZShpKSwgcy5zdHlsZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5pbml0aWFsVHJhbnNmb3JtYXRpb24gPSB0aGlzLnRhcmdldCgpLm1hdHJpeGlmeSgpO1xuICAgICAgICBzLmluaXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgICAgICB0aGlzLnNpdHVhdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xlYXJDdXJyZW50OiBmdW5jdGlvbiBjbGVhckN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMuc2l0dWF0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKiogc3RvcHMgdGhlIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgKiBAcGFyYW0ganVtcFRvRW5kIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAgKiBAcGFyYW0gY2xlYXJRdWV1ZSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJlbW92ZSBxdWV1ZWQgYW5pbWF0aW9uIGFzIHdlbGwuXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKSB7XG4gICAgICAgIHZhciBhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGp1bXBUb0VuZCAmJiB0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNpdHVhdGlvbiBpZiBpdCB3YXMgbm90XG4gICAgICAgICAgIWFjdGl2ZSAmJiB0aGlzLnN0YXJ0Q3VycmVudCgpO1xuICAgICAgICAgIHRoaXMuYXRFbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhckN1cnJlbnQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKiByZXNldHMgdGhlIGVsZW1lbnQgdG8gdGhlIHN0YXRlIHdoZXJlIHRoZSBjdXJyZW50IGVsZW1lbnQgaGFzIHN0YXJ0ZWRcbiAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAqL1xuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24pIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuc2l0dWF0aW9uO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uID0gdGVtcDtcbiAgICAgICAgICB0aGlzLmF0U3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFN0b3AgdGhlIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbiwgcmVtb3ZlIGFsbCBxdWV1ZWQgYW5pbWF0aW9ucywgYW5kIGNvbXBsZXRlIGFsbCBhbmltYXRpb25zIGZvciB0aGUgZWxlbWVudC5cbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICB0aGlzLnN0b3AodHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmRlcXVldWUoKS5zaXR1YXRpb24gJiYgdGhpcy5zdG9wKHRydWUsIGZhbHNlKSkge1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhclF1ZXVlKCkuY2xlYXJDdXJyZW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHNldCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIHBvaW50ZXIgYXQgdGhlIHN0YXJ0IHBvc2l0aW9uLCBiZWZvcmUgYW55IGxvb3BzLCBhbmQgdXBkYXRlcyB0aGUgdmlzdWFsaXNhdGlvblxuICAgICAgYXRTdGFydDogZnVuY3Rpb24gYXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoMCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciBhdCB0aGUgZW5kIHBvc2l0aW9uLCBhZnRlciBhbGwgdGhlIGxvb3BzLCBhbmQgdXBkYXRlcyB0aGUgdmlzdWFsaXNhdGlvblxuICAgICAgYXRFbmQ6IGZ1bmN0aW9uIGF0RW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ubG9vcHMgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBJZiBpbiBhIGluZmluaXRlIGxvb3AsIHdlIGVuZCB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5sb29wcyA9IHRoaXMuc2l0dWF0aW9uLmxvb3AgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBJZiBwZXJmb3JtaW5nIGEgZmluaXRlIG51bWJlciBvZiBsb29wcywgd2UgZ28gYWZ0ZXIgYWxsIHRoZSBsb29wc1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuc2l0dWF0aW9uLmxvb3BzLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBubyBsb29wcywgd2UganVzdCBnbyBhdCB0aGUgZW5kXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgICAgIC8vIGlmIGlzQWJzUG9zIGlzIHRydWUsIHBvcyBpcyB0cmVhdGVkIGFzIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zLCBpc0Fic1Bvcykge1xuICAgICAgICB2YXIgZHVyRGl2U3BkID0gdGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZDtcbiAgICAgICAgdGhpcy5hYnNQb3MgPSBwb3M7IC8vIElmIHBvcyBpcyBub3QgYW4gYWJzb2x1dGUgcG9zaXRpb24sIHdlIGNvbnZlcnQgaXQgaW50byBvbmVcblxuICAgICAgICBpZiAoIWlzQWJzUG9zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkKSB0aGlzLmFic1BvcyA9IDEgLSB0aGlzLmFic1BvcztcbiAgICAgICAgICB0aGlzLmFic1BvcyArPSB0aGlzLnNpdHVhdGlvbi5sb29wO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXR1YXRpb24uc3RhcnQgPSArbmV3IERhdGUoKSAtIHRoaXMuYWJzUG9zICogZHVyRGl2U3BkO1xuICAgICAgICB0aGlzLnNpdHVhdGlvbi5maW5pc2ggPSB0aGlzLnNpdHVhdGlvbi5zdGFydCArIGR1ckRpdlNwZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcCh0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb25zXG4gICAgICAqIEBwYXJhbSBzcGVlZCBudWxsIHx8IE51bWJlciBUaGUgbmV3IHNwZWVkIG9mIHRoZSBhbmltYXRpb25zXG4gICAgICAqIEByZXR1cm4gTnVtYmVyIHx8IHRoaXNcbiAgICAgICovXG4gICAgICBzcGVlZDogZnVuY3Rpb24gc3BlZWQoX3NwZWVkKSB7XG4gICAgICAgIGlmIChfc3BlZWQgPT09IDApIHJldHVybiB0aGlzLnBhdXNlKCk7XG5cbiAgICAgICAgaWYgKF9zcGVlZCkge1xuICAgICAgICAgIHRoaXMuX3NwZWVkID0gX3NwZWVkOyAvLyBXZSB1c2UgYW4gYWJzb2x1dGUgcG9zaXRpb24gaGVyZSBzbyB0aGF0IHNwZWVkIGNhbiBhZmZlY3QgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLmFic1BvcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gdGhpcy5fc3BlZWQ7XG4gICAgICB9LFxuICAgICAgLy8gTWFrZSBsb29wYWJsZVxuICAgICAgbG9vcDogZnVuY3Rpb24gbG9vcCh0aW1lcywgcmV2ZXJzZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpOyAvLyBzdG9yZSB0b3RhbCBsb29wc1xuXG4gICAgICAgIGMubG9vcHMgPSB0aW1lcyAhPSBudWxsID8gdGltZXMgOiB0cnVlO1xuICAgICAgICBjLmxvb3AgPSAwO1xuICAgICAgICBpZiAocmV2ZXJzZSkgYy5yZXZlcnNpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBwYXVzZXMgdGhlIGFuaW1hdGlvblxuICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyB1bnBhdXNlIHRoZSBhbmltYXRpb25cbiAgICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlOyAvLyBXZSB1c2UgYW4gYWJzb2x1dGUgcG9zaXRpb24gaGVyZSBzbyB0aGF0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvbiBjYW4gYmUgcGF1c2VkXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHRvZ2dsZSBvciBzZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAqIHRydWUgc2V0cyBkaXJlY3Rpb24gdG8gYmFja3dhcmRzIHdoaWxlIGZhbHNlIHNldHMgaXQgdG8gZm9yd2FyZHNcbiAgICAgICogQHBhcmFtIHJldmVyc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJldmVyc2UgdGhlIGFuaW1hdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRvZ2dsZSB0aGUgcmV2ZXJzZSBzdGF0dXMpXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UocmV2ZXJzZWQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXZlcnNlZCA9PT0gJ3VuZGVmaW5lZCcpIGMucmV2ZXJzZWQgPSAhYy5yZXZlcnNlZDtlbHNlIGMucmV2ZXJzZWQgPSByZXZlcnNlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogcmV0dXJucyBhIGZsb2F0IGZyb20gMC0xIGluZGljYXRpbmcgdGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgKiBAcGFyYW0gZWFzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJldHVybmVkIHBvc2l0aW9uIHNob3VsZCBiZSBlYXNlZCBvciBub3RcbiAgICAgICogQHJldHVybiBudW1iZXJcbiAgICAgICovXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoZWFzZUl0KSB7XG4gICAgICAgIHJldHVybiBlYXNlSXQgPyB0aGlzLnNpdHVhdGlvbi5lYXNlKHRoaXMucG9zKSA6IHRoaXMucG9zO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIGFkZHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgY3VycmVudCBhbmltYXRpb24gaXMgZmluaXNoZWRcbiAgICAgICogQHBhcmFtIGZuIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBleGVjdXRlZCBhcyBjYWxsYmFja1xuICAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAgKi9cbiAgICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihmbikge1xuICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpLFxuICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRldGFpbC5zaXR1YXRpb24gPT0gYykge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBjKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpOyAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGFyZ2V0KCkub24oJ2ZpbmlzaGVkLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBhZGRzIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIG9uZSBhbmltYXRpb24gc3RlcCBpcyBwZXJmb3JtZWRcbiAgICAgIGR1cmluZzogZnVuY3Rpb24gZHVyaW5nKGZuKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYXN0KCksXG4gICAgICAgICAgICB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcihlKSB7XG4gICAgICAgICAgaWYgKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGUuZGV0YWlsLnBvcywgU1ZHLm1vcnBoKGUuZGV0YWlsLnBvcyksIGUuZGV0YWlsLmVhc2VkLCBjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIHNlZSBhYm92ZVxuXG5cbiAgICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKTtcbiAgICAgICAgdGhpcy5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgICAgfSxcbiAgICAgIC8vIGNhbGxzIGFmdGVyIEFMTCBhbmltYXRpb25zIGluIHRoZSBxdWV1ZSBhcmUgZmluaXNoZWRcbiAgICAgIGFmdGVyQWxsOiBmdW5jdGlvbiBhZnRlckFsbChmbikge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5vZmYoJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIH07IC8vIHNlZSBhYm92ZVxuXG5cbiAgICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcikub24oJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBjYWxscyBvbiBldmVyeSBhbmltYXRpb24gc3RlcCBmb3IgYWxsIGFuaW1hdGlvbnNcbiAgICAgIGR1cmluZ0FsbDogZnVuY3Rpb24gZHVyaW5nQWxsKGZuKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcihlKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzLCBlLmRldGFpbC5wb3MsIFNWRy5tb3JwaChlLmRldGFpbC5wb3MpLCBlLmRldGFpbC5lYXNlZCwgZS5kZXRhaWwuc2l0dWF0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRhcmdldCgpLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcikub24oJ2R1cmluZy5meCcsIHdyYXBwZXIpO1xuICAgICAgICB0aGlzLmFmdGVyQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l0dWF0aW9ucy5sZW5ndGggPyB0aGlzLnNpdHVhdGlvbnNbdGhpcy5zaXR1YXRpb25zLmxlbmd0aCAtIDFdIDogdGhpcy5zaXR1YXRpb247XG4gICAgICB9LFxuICAgICAgLy8gYWRkcyBvbmUgcHJvcGVydHkgdG8gdGhlIGFuaW1hdGlvbnNcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKG1ldGhvZCwgYXJncywgdHlwZSkge1xuICAgICAgICB0aGlzLmxhc3QoKVt0eXBlIHx8ICdhbmltYXRpb25zJ11bbWV0aG9kXSA9IGFyZ3M7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBwZXJmb3JtIG9uZSBzdGVwIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICogIEBwYXJhbSBpZ25vcmVUaW1lIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGlnbm9yZSB0aW1lIGFuZCB1c2UgcG9zaXRpb24gZGlyZWN0bHkgb3IgcmVjYWxjdWxhdGUgcG9zaXRpb24gYmFzZWQgb24gdGltZVxuICAgICAgKiAgQHJldHVybiB0aGlzXG4gICAgICAqL1xuICAgICAgc3RlcDogZnVuY3Rpb24gc3RlcChpZ25vcmVUaW1lKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgY3VycmVudCB0aW1lIHRvIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gICAgICAgIGlmICghaWdub3JlVGltZSkgdGhpcy5hYnNQb3MgPSB0aGlzLnRpbWVUb0Fic1BvcygrbmV3IERhdGUoKSk7IC8vIFRoaXMgcGFydCBjb252ZXJ0IGFuIGFic29sdXRlIHBvc2l0aW9uIHRvIGEgcG9zaXRpb25cblxuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ubG9vcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGFic1BvcywgYWJzUG9zSW50LCBsYXN0TG9vcDsgLy8gSWYgdGhlIGFic29sdXRlIHBvc2l0aW9uIGlzIGJlbG93IDAsIHdlIGp1c3QgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIDBcblxuICAgICAgICAgIGFic1BvcyA9IE1hdGgubWF4KHRoaXMuYWJzUG9zLCAwKTtcbiAgICAgICAgICBhYnNQb3NJbnQgPSBNYXRoLmZsb29yKGFic1Bvcyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ubG9vcHMgPT09IHRydWUgfHwgYWJzUG9zSW50IDwgdGhpcy5zaXR1YXRpb24ubG9vcHMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gYWJzUG9zIC0gYWJzUG9zSW50O1xuICAgICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wO1xuICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IGFic1Bvc0ludDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hYnNQb3MgPSB0aGlzLnNpdHVhdGlvbi5sb29wcztcbiAgICAgICAgICAgIHRoaXMucG9zID0gMTsgLy8gVGhlIC0xIGhlcmUgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHRvZ2dsZSByZXZlcnNlZCB3aGVuIGFsbCB0aGUgbG9vcHMgaGF2ZSBiZWVuIGNvbXBsZXRlZFxuXG4gICAgICAgICAgICBsYXN0TG9vcCA9IHRoaXMuc2l0dWF0aW9uLmxvb3AgLSAxO1xuICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IHRoaXMuc2l0dWF0aW9uLmxvb3BzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5yZXZlcnNpbmcpIHtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSByZXZlcnNlZCBpZiBhbiBvZGQgbnVtYmVyIG9mIGxvb3BzIGFzIG9jY3VyZWQgc2luY2UgdGhlIGxhc3QgY2FsbCBvZiBzdGVwXG4gICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCA9IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICE9IEJvb2xlYW4oKHRoaXMuc2l0dWF0aW9uLmxvb3AgLSBsYXN0TG9vcCkgJSAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxvb3AsIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBtdXN0IG5vdCBiZSBhYm92ZSAxXG4gICAgICAgICAgdGhpcy5hYnNQb3MgPSBNYXRoLm1pbih0aGlzLmFic1BvcywgMSk7XG4gICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmFic1BvcztcbiAgICAgICAgfSAvLyB3aGlsZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gY2FuIGJlIGJlbG93IDAsIHRoZSBwb3NpdGlvbiBtdXN0IG5vdCBiZSBiZWxvdyAwXG5cblxuICAgICAgICBpZiAodGhpcy5wb3MgPCAwKSB0aGlzLnBvcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgdGhpcy5wb3MgPSAxIC0gdGhpcy5wb3M7IC8vIGFwcGx5IGVhc2luZ1xuXG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuc2l0dWF0aW9uLmVhc2UodGhpcy5wb3MpOyAvLyBjYWxsIG9uY2UtY2FsbGJhY2tzXG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNpdHVhdGlvbi5vbmNlKSB7XG4gICAgICAgICAgaWYgKGkgPiB0aGlzLmxhc3RQb3MgJiYgaSA8PSBlYXNlZCkge1xuICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ub25jZVtpXS5jYWxsKHRoaXMudGFyZ2V0KCksIHRoaXMucG9zLCBlYXNlZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zaXR1YXRpb24ub25jZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZmlyZSBkdXJpbmcgY2FsbGJhY2sgd2l0aCBwb3NpdGlvbiwgZWFzZWQgcG9zaXRpb24gYW5kIGN1cnJlbnQgc2l0dWF0aW9uIGFzIHBhcmFtZXRlclxuXG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB0aGlzLnRhcmdldCgpLmZpcmUoJ2R1cmluZycsIHtcbiAgICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICAgIGVhc2VkOiBlYXNlZCxcbiAgICAgICAgICBmeDogdGhpcyxcbiAgICAgICAgICBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9uXG4gICAgICAgIH0pOyAvLyB0aGUgdXNlciBtYXkgY2FsbCBzdG9wIG9yIGZpbmlzaCBpbiB0aGUgZHVyaW5nIGNhbGxiYWNrXG4gICAgICAgIC8vIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIHN0aWxsIGhhdmUgYSB2YWxpZCBzaXR1YXRpb25cblxuICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gLy8gYXBwbHkgdGhlIGFjdHVhbCBhbmltYXRpb24gdG8gZXZlcnkgcHJvcGVydHlcblxuXG4gICAgICAgIHRoaXMuZWFjaEF0KCk7IC8vIGRvIGZpbmFsIGNvZGUgd2hlbiBzaXR1YXRpb24gaXMgZmluaXNoZWRcblxuICAgICAgICBpZiAodGhpcy5wb3MgPT0gMSAmJiAhdGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQgfHwgdGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQgJiYgdGhpcy5wb3MgPT0gMCkge1xuICAgICAgICAgIC8vIHN0b3AgYW5pbWF0aW9uIGNhbGxiYWNrXG4gICAgICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKCk7IC8vIGZpcmUgZmluaXNoZWQgY2FsbGJhY2sgd2l0aCBjdXJyZW50IHNpdHVhdGlvbiBhcyBwYXJhbWV0ZXJcblxuICAgICAgICAgIHRoaXMudGFyZ2V0KCkuZmlyZSgnZmluaXNoZWQnLCB7XG4gICAgICAgICAgICBmeDogdGhpcyxcbiAgICAgICAgICAgIHNpdHVhdGlvbjogdGhpcy5zaXR1YXRpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdGhpcy5zaXR1YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdhbGxmaW5pc2hlZCcpOyAvLyBSZWNoZWNrIHRoZSBsZW5ndGggc2luY2UgdGhlIHVzZXIgbWF5IGNhbGwgYW5pbWF0ZSBpbiB0aGUgYWZ0ZXJBbGwgY2FsbGJhY2tcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNpdHVhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCcuZngnKTsgLy8gdGhlcmUgc2hvdWxkbnQgYmUgYW55IGJpbmRpbmcgbGVmdCwgYnV0IHRvIG1ha2Ugc3VyZS4uLlxuXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBzdGFydCBuZXh0IGFuaW1hdGlvblxuXG5cbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHRoaXMuZGVxdWV1ZSgpO2Vsc2UgdGhpcy5jbGVhckN1cnJlbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQgJiYgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAvLyB3ZSBjb250aW51ZSBhbmltYXRpbmcgd2hlbiB3ZSBhcmUgbm90IGF0IHRoZSBlbmRcbiAgICAgICAgICB0aGlzLnN0YXJ0QW5pbUZyYW1lKCk7XG4gICAgICAgIH0gLy8gc2F2ZSBsYXN0IGVhc2VkIHBvc2l0aW9uIGZvciBvbmNlIGNhbGxiYWNrIHRyaWdnZXJpbmdcblxuXG4gICAgICAgIHRoaXMubGFzdFBvcyA9IGVhc2VkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBjYWxjdWxhdGVzIHRoZSBzdGVwIGZvciBldmVyeSBwcm9wZXJ0eSBhbmQgY2FsbHMgYmxvY2sgd2l0aCBpdFxuICAgICAgZWFjaEF0OiBmdW5jdGlvbiBlYWNoQXQoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgYXQsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0KCksXG4gICAgICAgICAgICBzID0gdGhpcy5zaXR1YXRpb247IC8vIGFwcGx5IGFuaW1hdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB0cm91Z2ggYSBtZXRob2RcblxuICAgICAgICBmb3IgKGkgaW4gcy5hbmltYXRpb25zKSB7XG4gICAgICAgICAgYXQgPSBbXS5jb25jYXQocy5hbmltYXRpb25zW2ldKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldFtpXS5hcHBseSh0YXJnZXQsIGF0KTtcbiAgICAgICAgfSAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBhdHRyKClcblxuXG4gICAgICAgIGZvciAoaSBpbiBzLmF0dHJzKSB7XG4gICAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuYXR0cnNbaV0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZWwgIT09ICdzdHJpbmcnICYmIGVsLmF0ID8gZWwuYXQocy5lYXNlKHNlbGYucG9zKSwgc2VsZi5wb3MpIDogZWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGFyZ2V0LmF0dHIuYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgIH0gLy8gYXBwbHkgYW5pbWF0aW9uIHdoaWNoIGhhcyB0byBiZSBhcHBsaWVkIHdpdGggc3R5bGUoKVxuXG5cbiAgICAgICAgZm9yIChpIGluIHMuc3R5bGVzKSB7XG4gICAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuc3R5bGVzW2ldKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5hcHBseSh0YXJnZXQsIGF0KTtcbiAgICAgICAgfSAvLyBhbmltYXRlIGluaXRpYWxUcmFuc2Zvcm1hdGlvbiB3aGljaCBoYXMgdG8gYmUgY2hhaW5lZFxuXG5cbiAgICAgICAgaWYgKHMudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBnZXQgaW5pdGlhbCBpbml0aWFsVHJhbnNmb3JtYXRpb25cbiAgICAgICAgICBhdCA9IHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBnZXQgbmV4dCB0cmFuc2Zvcm1hdGlvbiBpbiBjaGFpblxuICAgICAgICAgICAgdmFyIGEgPSBzLnRyYW5zZm9ybXNbaV07IC8vIG11bHRpcGx5IG1hdHJpeCBkaXJlY3RseVxuXG4gICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFNWRy5NYXRyaXgpIHtcbiAgICAgICAgICAgICAgaWYgKGEucmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBhdCA9IGF0Lm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KCkubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0ID0gYXQubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gd2hlbiB0cmFuc2Zvcm1hdGlvbiBpcyBhYnNvbHV0ZSB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBuZWVkZWQgdHJhbnNmb3JtYXRpb24gZmlyc3RcblxuXG4gICAgICAgICAgICBpZiAoIWEucmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgYS51bmRvKGF0LmV4dHJhY3QoKSk7XG4gICAgICAgICAgICB9IC8vIGFuZCByZWFwcGx5IGl0IGFmdGVyXG5cblxuICAgICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShhLmF0KHMuZWFzZSh0aGlzLnBvcykpKTtcbiAgICAgICAgICB9IC8vIHNldCBuZXcgbWF0cml4IG9uIGVsZW1lbnRcblxuXG4gICAgICAgICAgdGFyZ2V0Lm1hdHJpeChhdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBhZGRzIGFuIG9uY2UtY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24gYW5kIG5ldmVyIGFnYWluXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKHBvcywgZm4sIGlzRWFzZWQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKTtcbiAgICAgICAgaWYgKCFpc0Vhc2VkKSBwb3MgPSBjLmVhc2UocG9zKTtcbiAgICAgICAgYy5vbmNlW3Bvc10gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgX2NhbGxTdGFydDogZnVuY3Rpb24gX2NhbGxTdGFydCgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcmVudDogU1ZHLkVsZW1lbnQsXG4gICAgLy8gQWRkIG1ldGhvZCB0byBwYXJlbnQgZWxlbWVudHNcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIEdldCBmeCBtb2R1bGUgb3IgY3JlYXRlIGEgbmV3IG9uZSwgdGhlbiBhbmltYXRlIHdpdGggZ2l2ZW4gZHVyYXRpb24gYW5kIGVhc2VcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUobywgZWFzZSwgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmFuaW1hdGUobywgZWFzZSwgZGVsYXkpO1xuICAgICAgfSxcbiAgICAgIGRlbGF5OiBmdW5jdGlvbiBkZWxheShfZGVsYXkyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5kZWxheShfZGVsYXkyKTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGp1bXBUb0VuZCwgY2xlYXJRdWV1ZSkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZnguc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZ4KSB7XG4gICAgICAgICAgdGhpcy5meC5maW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmZ4KSB7XG4gICAgICAgICAgdGhpcy5meC5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gUGxheSBwYXVzZWQgY3VycmVudCBhbmltYXRpb25cbiAgICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmZ4KSB7XG4gICAgICAgICAgdGhpcy5meC5wbGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBTZXQvR2V0IHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xuICAgICAgc3BlZWQ6IGZ1bmN0aW9uIHNwZWVkKF9zcGVlZDIpIHtcbiAgICAgICAgaWYgKHRoaXMuZngpIHtcbiAgICAgICAgICBpZiAoX3NwZWVkMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5meC5zcGVlZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZ4LnNwZWVkKF9zcGVlZDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIE1vcnBoT2JqIGlzIHVzZWQgd2hlbmV2ZXIgbm8gbW9ycGhhYmxlIG9iamVjdCBpcyBnaXZlblxuXG4gIFNWRy5Nb3JwaE9iaiA9IFNWRy5pbnZlbnQoe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGZyb20sIHRvKSB7XG4gICAgICAvLyBwcmVwYXJlIGNvbG9yIGZvciBtb3JwaGluZ1xuICAgICAgaWYgKFNWRy5Db2xvci5pc0NvbG9yKHRvKSkgcmV0dXJuIG5ldyBTVkcuQ29sb3IoZnJvbSkubW9ycGgodG8pOyAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgbGlzdCBvZiB2YWx1ZXNcblxuICAgICAgaWYgKFNWRy5yZWdleC5kZWxpbWl0ZXIudGVzdChmcm9tKSkge1xuICAgICAgICAvLyBwcmVwYXJlIHBhdGggZm9yIG1vcnBoaW5nXG4gICAgICAgIGlmIChTVkcucmVnZXgucGF0aExldHRlcnMudGVzdChmcm9tKSkgcmV0dXJuIG5ldyBTVkcuUGF0aEFycmF5KGZyb20pLm1vcnBoKHRvKTsgLy8gcHJlcGFyZSB2YWx1ZSBsaXN0IGZvciBtb3JwaGluZ1xuICAgICAgICBlbHNlIHJldHVybiBuZXcgU1ZHLkFycmF5KGZyb20pLm1vcnBoKHRvKTtcbiAgICAgIH0gLy8gcHJlcGFyZSBudW1iZXIgZm9yIG1vcnBoaW5nXG5cblxuICAgICAgaWYgKFNWRy5yZWdleC5udW1iZXJBbmRVbml0LnRlc3QodG8pKSByZXR1cm4gbmV3IFNWRy5OdW1iZXIoZnJvbSkubW9ycGgodG8pOyAvLyBwcmVwYXJlIGZvciBwbGFpbiBtb3JwaGluZ1xuXG4gICAgICB0aGlzLnZhbHVlID0gZnJvbTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSB0bztcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcywgcmVhbCkge1xuICAgICAgICByZXR1cm4gcmVhbCA8IDEgPyB0aGlzLnZhbHVlIDogdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgIH0sXG4gICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5GWCwge1xuICAgIC8vIEFkZCBhbmltYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIHYsIHJlbGF0aXZlKSB7XG4gICAgICAvLyBhcHBseSBhdHRyaWJ1dGVzIGluZGl2aWR1YWxseVxuICAgICAgaWYgKF90eXBlb2YoYSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKGtleSwgYVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGQoYSwgdiwgJ2F0dHJzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgc3R5bGVzXG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKHMsIHYpIHtcbiAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcykge1xuICAgICAgICAgIHRoaXMuc3R5bGUoa2V5LCBzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZChzLCB2LCAnc3R5bGVzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbiB4KF94MiwgcmVsYXRpdmUpIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICAgIHg6IF94MlxuICAgICAgICB9LCByZWxhdGl2ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtID0gbmV3IFNWRy5OdW1iZXIoX3gyKTtcbiAgICAgIG51bS5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKCd4JywgbnVtKTtcbiAgICB9LFxuICAgIC8vIEFuaW1hdGFibGUgeS1heGlzXG4gICAgeTogZnVuY3Rpb24geShfeTIsIHJlbGF0aXZlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5HKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgICB5OiBfeTJcbiAgICAgICAgfSwgcmVsYXRpdmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKF95Mik7XG4gICAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgneScsIG51bSk7XG4gICAgfSxcbiAgICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcbiAgICBjeDogZnVuY3Rpb24gY3goeCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKCdjeCcsIG5ldyBTVkcuTnVtYmVyKHgpKTtcbiAgICB9LFxuICAgIC8vIEFuaW1hdGFibGUgY2VudGVyIHktYXhpc1xuICAgIGN5OiBmdW5jdGlvbiBjeSh5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ2N5JywgbmV3IFNWRy5OdW1iZXIoeSkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMueCh4KS55KHkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgY2VudGVyXG4gICAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSBzaXplXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5UZXh0KSB7XG4gICAgICAgIC8vIGFuaW1hdGUgZm9udCBzaXplIGZvciBUZXh0IGVsZW1lbnRzXG4gICAgICAgIHRoaXMuYXR0cignZm9udC1zaXplJywgd2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5pbWF0ZSBiYm94IGJhc2VkIHNpemUgZm9yIGFsbCBvdGhlciBlbGVtZW50c1xuICAgICAgICB2YXIgYm94O1xuXG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICAgIGJveCA9IHRoaXMudGFyZ2V0KCkuYmJveCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAqIGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAqIHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGQoJ3dpZHRoJywgbmV3IFNWRy5OdW1iZXIod2lkdGgpKS5hZGQoJ2hlaWdodCcsIG5ldyBTVkcuTnVtYmVyKGhlaWdodCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHdpZHRoXG4gICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKF93aWR0aDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgnd2lkdGgnLCBuZXcgU1ZHLk51bWJlcihfd2lkdGgyKSk7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSBoZWlnaHRcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0Mikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKCdoZWlnaHQnLCBuZXcgU1ZHLk51bWJlcihfaGVpZ2h0MikpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgcGxvdFxuICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QoYSwgYiwgYywgZCkge1xuICAgICAgLy8gTGluZXMgY2FuIGJlIHBsb3R0ZWQgd2l0aCA0IGFyZ3VtZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gNCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90KFthLCBiLCBjLCBkXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFkZCgncGxvdCcsIG5ldyAodGhpcy50YXJnZXQoKS5tb3JwaEFycmF5KShhKSk7XG4gICAgfSxcbiAgICAvLyBBZGQgbGVhZGluZyBtZXRob2RcbiAgICBsZWFkaW5nOiBmdW5jdGlvbiBsZWFkaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQoKS5sZWFkaW5nID8gdGhpcy5hZGQoJ2xlYWRpbmcnLCBuZXcgU1ZHLk51bWJlcih2YWx1ZSkpIDogdGhpcztcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHZpZXdib3hcbiAgICB2aWV3Ym94OiBmdW5jdGlvbiB2aWV3Ym94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmFkZCgndmlld2JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobykge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuU3RvcCkge1xuICAgICAgICBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgY29sb3I6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSk7XG4gICAgICAgIGlmIChvLmNvbG9yICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpO1xuICAgICAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBvLm9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5Cb3ggPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgJiYgISh4IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpKSB7XG4gICAgICAgIC8vIGNocm9tZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGhhcyBubyB4IGFuZCB5IHByb3BlcnR5XG4gICAgICAgIHJldHVybiBTVkcuQm94LmNhbGwodGhpcywgeC5sZWZ0ICE9IG51bGwgPyB4LmxlZnQgOiB4LngsIHgudG9wICE9IG51bGwgPyB4LnRvcCA6IHgueSwgeC53aWR0aCwgeC5oZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH0gLy8gYWRkIGNlbnRlciwgcmlnaHQsIGJvdHRvbS4uLlxuXG5cbiAgICAgIGZ1bGxCb3godGhpcyk7XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIE1lcmdlIHJlY3QgYm94IHdpdGggYW5vdGhlciwgcmV0dXJuIGEgbmV3IGluc3RhbmNlXG4gICAgICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoYm94KSB7XG4gICAgICAgIHZhciBiID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTsgLy8gbWVyZ2UgYm94ZXNcblxuICAgICAgICBiLnggPSBNYXRoLm1pbih0aGlzLngsIGJveC54KTtcbiAgICAgICAgYi55ID0gTWF0aC5taW4odGhpcy55LCBib3gueSk7XG4gICAgICAgIGIud2lkdGggPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBib3gueCArIGJveC53aWR0aCkgLSBiLng7XG4gICAgICAgIGIuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSBiLnk7XG4gICAgICAgIHJldHVybiBmdWxsQm94KGIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG0pIHtcbiAgICAgICAgdmFyIHhNaW4gPSBJbmZpbml0eSxcbiAgICAgICAgICAgIHhNYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgICB5TWluID0gSW5maW5pdHksXG4gICAgICAgICAgICB5TWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgICAgYmJveDtcbiAgICAgICAgdmFyIHB0cyA9IFtuZXcgU1ZHLlBvaW50KHRoaXMueCwgdGhpcy55KSwgbmV3IFNWRy5Qb2ludCh0aGlzLngyLCB0aGlzLnkpLCBuZXcgU1ZHLlBvaW50KHRoaXMueCwgdGhpcy55MiksIG5ldyBTVkcuUG9pbnQodGhpcy54MiwgdGhpcy55MildO1xuICAgICAgICBwdHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHAgPSBwLnRyYW5zZm9ybShtKTtcbiAgICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgcC54KTtcbiAgICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgcC54KTtcbiAgICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgcC55KTtcbiAgICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgcC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJib3ggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBiYm94LnggPSB4TWluO1xuICAgICAgICBiYm94LndpZHRoID0geE1heCAtIHhNaW47XG4gICAgICAgIGJib3gueSA9IHlNaW47XG4gICAgICAgIGJib3guaGVpZ2h0ID0geU1heCAtIHlNaW47XG4gICAgICAgIGZ1bGxCb3goYmJveCk7XG4gICAgICAgIHJldHVybiBiYm94O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5CQm94ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIFNWRy5Cb3guYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTsgLy8gZ2V0IHZhbHVlcyBpZiBlbGVtZW50IGlzIGdpdmVuXG5cbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJveDsgLy8geWVzIHRoaXMgaXMgdWdseSwgYnV0IEZpcmVmb3ggY2FuIGJlIGEgcGFpbiB3aGVuIGl0IGNvbWVzIHRvIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCB5ZXQgcmVuZGVyZWRcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIElFIC0gaXQgZG9lcyBub3Qgc3VwcG9ydCBjb250YWlucygpIGZvciB0b3AtbGV2ZWwgU1ZHc1xuICAgICAgICAgICAgdmFyIHRvcFBhcmVudCA9IGVsZW1lbnQubm9kZTtcblxuICAgICAgICAgICAgd2hpbGUgKHRvcFBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHRvcFBhcmVudCA9IHRvcFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9wUGFyZW50ICE9IGRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKTtcbiAgICAgICAgICB9IC8vIHRoZSBlbGVtZW50IGlzIE5PVCBpbiB0aGUgZG9tLCB0aHJvdyBlcnJvclxuICAgICAgICAgIC8vIGRpc2FibGluZyB0aGUgY2hlY2sgYmVsb3cgd2hpY2ggZml4ZXMgaXNzdWUgIzc2XG4gICAgICAgICAgLy8gaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudC5ub2RlKSkgdGhyb3cgbmV3IEV4Y2VwdGlvbignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpXG4gICAgICAgICAgLy8gZmluZCBuYXRpdmUgYmJveFxuXG5cbiAgICAgICAgICBib3ggPSBlbGVtZW50Lm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuU2hhcGUpIHtcbiAgICAgICAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgICAgICAgIC8vIGZpeGVzIGFwZXhjaGFydHMvdnVlLWFwZXhjaGFydHMgIzE0XG4gICAgICAgICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGVsZW1lbnQuY2xvbmUoU1ZHLnBhcnNlci5kcmF3Lmluc3RhbmNlKS5zaG93KCk7XG4gICAgICAgICAgICBib3ggPSBjbG9uZS5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgICAgIGNsb25lLnJlbW92ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICAgIHg6IGVsZW1lbnQubm9kZS5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgICB5OiBlbGVtZW50Lm5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgICB3aWR0aDogZWxlbWVudC5ub2RlLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQubm9kZS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU1ZHLkJveC5jYWxsKHRoaXMsIGJveCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWZpbmUgYW5jZXN0b3JcbiAgICBpbmhlcml0OiBTVkcuQm94LFxuICAgIC8vIERlZmluZSBQYXJlbnRcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIENvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBHZXQgYm91bmRpbmcgYm94XG4gICAgICBiYm94OiBmdW5jdGlvbiBiYm94KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5CQm94KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5CQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5CQm94O1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgdGJveDogZnVuY3Rpb24gdGJveCgpIHtcbiAgICAgIGNvbnNvbGUud2FybignVXNlIG9mIFRCb3ggaXMgZGVwcmVjYXRlZCBhbmQgbWFwcGVkIHRvIFJCb3guIFVzZSAucmJveCgpIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gdGhpcy5yYm94KHRoaXMuZG9jKCkpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5SQm94ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIFNWRy5Cb3guYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblxuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCkge1xuICAgICAgICBTVkcuQm94LmNhbGwodGhpcywgZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaGVyaXQ6IFNWRy5Cb3gsXG4gICAgLy8gZGVmaW5lIFBhcmVudFxuICAgIHBhcmVudDogU1ZHLkVsZW1lbnQsXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhZGRPZmZzZXQ6IGZ1bmN0aW9uIGFkZE9mZnNldCgpIHtcbiAgICAgICAgLy8gb2Zmc2V0IGJ5IHdpbmRvdyBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNoYW5nZXMgd2hlbiB3aW5kb3cgaXMgc2Nyb2xsZWRcbiAgICAgICAgdGhpcy54ICs9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgdGhpcy55ICs9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gR2V0IHJlY3QgYm94XG4gICAgICByYm94OiBmdW5jdGlvbiByYm94KGVsKSB7XG4gICAgICAgIGlmIChlbCkgcmV0dXJuIG5ldyBTVkcuUkJveCh0aGlzKS50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuUkJveCh0aGlzKS5hZGRPZmZzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuUkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUkJveDtcbiAgU1ZHLk1hdHJpeCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGJhc2UgPSBhcnJheVRvTWF0cml4KFsxLCAwLCAwLCAxLCAwLCAwXSk7IC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICAgIHNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50ID8gc291cmNlLm1hdHJpeGlmeSgpIDogdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBhcnJheVRvTWF0cml4KHNvdXJjZS5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdCkpIDogYXJndW1lbnRzLmxlbmd0aCA9PSA2ID8gYXJyYXlUb01hdHJpeChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpIDogQXJyYXkuaXNBcnJheShzb3VyY2UpID8gYXJyYXlUb01hdHJpeChzb3VyY2UpIDogX3R5cGVvZihzb3VyY2UpID09PSAnb2JqZWN0JyA/IHNvdXJjZSA6IGJhc2U7IC8vIG1lcmdlIHNvdXJjZVxuXG4gICAgICBmb3IgKGkgPSBhYmNkZWYubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdGhpc1thYmNkZWZbaV1dID0gc291cmNlW2FiY2RlZltpXV0gIT0gbnVsbCA/IHNvdXJjZVthYmNkZWZbaV1dIDogYmFzZVthYmNkZWZbaV1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEV4dHJhY3QgaW5kaXZpZHVhbCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIGV4dHJhY3Q6IGZ1bmN0aW9uIGV4dHJhY3QoKSB7XG4gICAgICAgIC8vIGZpbmQgZGVsdGEgdHJhbnNmb3JtIHBvaW50c1xuICAgICAgICB2YXIgcHggPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDAsIDEpLFxuICAgICAgICAgICAgcHkgPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDEsIDApLFxuICAgICAgICAgICAgc2tld1ggPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweC55LCBweC54KSAtIDkwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIHRyYW5zbGF0aW9uXG4gICAgICAgICAgeDogdGhpcy5lLFxuICAgICAgICAgIHk6IHRoaXMuZixcbiAgICAgICAgICB0cmFuc2Zvcm1lZFg6ICh0aGlzLmUgKiBNYXRoLmNvcyhza2V3WCAqIE1hdGguUEkgLyAxODApICsgdGhpcy5mICogTWF0aC5zaW4oc2tld1ggKiBNYXRoLlBJIC8gMTgwKSkgLyBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKSxcbiAgICAgICAgICB0cmFuc2Zvcm1lZFk6ICh0aGlzLmYgKiBNYXRoLmNvcyhza2V3WCAqIE1hdGguUEkgLyAxODApICsgdGhpcy5lICogTWF0aC5zaW4oLXNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZCksXG4gICAgICAgICAgLy8gc2tld1xuICAgICAgICAgIHNrZXdYOiAtc2tld1gsXG4gICAgICAgICAgc2tld1k6IDE4MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4yKHB5LnksIHB5LngpLFxuICAgICAgICAgIC8vIHNjYWxlXG4gICAgICAgICAgc2NhbGVYOiBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKSxcbiAgICAgICAgICBzY2FsZVk6IE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpLFxuICAgICAgICAgIC8vIHJvdGF0aW9uXG4gICAgICAgICAgcm90YXRpb246IHNrZXdYLFxuICAgICAgICAgIGE6IHRoaXMuYSxcbiAgICAgICAgICBiOiB0aGlzLmIsXG4gICAgICAgICAgYzogdGhpcy5jLFxuICAgICAgICAgIGQ6IHRoaXMuZCxcbiAgICAgICAgICBlOiB0aGlzLmUsXG4gICAgICAgICAgZjogdGhpcy5mLFxuICAgICAgICAgIG1hdHJpeDogbmV3IFNWRy5NYXRyaXgodGhpcylcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBDbG9uZSBtYXRyaXhcbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vcnBoIG9uZSBtYXRyaXggaW50byBhbm90aGVyXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgobWF0cml4KSB7XG4gICAgICAgIC8vIHN0b3JlIG5ldyBkZXN0aW5hdGlvblxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5NYXRyaXgobWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IG1vcnBoZWQgbWF0cml4IGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBjYWxjdWxhdGUgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxuXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh7XG4gICAgICAgICAgYTogdGhpcy5hICsgKHRoaXMuZGVzdGluYXRpb24uYSAtIHRoaXMuYSkgKiBwb3MsXG4gICAgICAgICAgYjogdGhpcy5iICsgKHRoaXMuZGVzdGluYXRpb24uYiAtIHRoaXMuYikgKiBwb3MsXG4gICAgICAgICAgYzogdGhpcy5jICsgKHRoaXMuZGVzdGluYXRpb24uYyAtIHRoaXMuYykgKiBwb3MsXG4gICAgICAgICAgZDogdGhpcy5kICsgKHRoaXMuZGVzdGluYXRpb24uZCAtIHRoaXMuZCkgKiBwb3MsXG4gICAgICAgICAgZTogdGhpcy5lICsgKHRoaXMuZGVzdGluYXRpb24uZSAtIHRoaXMuZSkgKiBwb3MsXG4gICAgICAgICAgZjogdGhpcy5mICsgKHRoaXMuZGVzdGluYXRpb24uZiAtIHRoaXMuZikgKiBwb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9LFxuICAgICAgLy8gTXVsdGlwbGllcyBieSBnaXZlbiBtYXRyaXhcbiAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMubmF0aXZlKCkubXVsdGlwbHkocGFyc2VNYXRyaXgobWF0cml4KS5uYXRpdmUoKSkpO1xuICAgICAgfSxcbiAgICAgIC8vIEludmVyc2VzIG1hdHJpeFxuICAgICAgaW52ZXJzZTogZnVuY3Rpb24gaW52ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMubmF0aXZlKCkuaW52ZXJzZSgpKTtcbiAgICAgIH0sXG4gICAgICAvLyBUcmFuc2xhdGUgbWF0cml4XG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLnRyYW5zbGF0ZSh4IHx8IDAsIHkgfHwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFNjYWxlIG1hdHJpeFxuICAgICAgc2NhbGU6IGZ1bmN0aW9uIHNjYWxlKHgsIHksIGN4LCBjeSkge1xuICAgICAgICAvLyBzdXBwb3J0IHVuaWZvcm1hbCBzY2FsZVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgeSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgY3kgPSBjeDtcbiAgICAgICAgICBjeCA9IHk7XG4gICAgICAgICAgeSA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeCh4LCAwLCAwLCB5LCAwLCAwKSk7XG4gICAgICB9LFxuICAgICAgLy8gUm90YXRlIG1hdHJpeFxuICAgICAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUociwgY3gsIGN5KSB7XG4gICAgICAgIC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgICAgIHIgPSBTVkcudXRpbHMucmFkaWFucyhyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoTWF0aC5jb3MociksIE1hdGguc2luKHIpLCAtTWF0aC5zaW4ociksIE1hdGguY29zKHIpLCAwLCAwKSk7XG4gICAgICB9LFxuICAgICAgLy8gRmxpcCBtYXRyaXggb24geCBvciB5LCBhdCBhIGdpdmVuIG9mZnNldFxuICAgICAgZmxpcDogZnVuY3Rpb24gZmxpcChhLCBvKSB7XG4gICAgICAgIHJldHVybiBhID09ICd4JyA/IHRoaXMuc2NhbGUoLTEsIDEsIG8sIDApIDogYSA9PSAneScgPyB0aGlzLnNjYWxlKDEsIC0xLCAwLCBvKSA6IHRoaXMuc2NhbGUoLTEsIC0xLCBhLCBvICE9IG51bGwgPyBvIDogYSk7XG4gICAgICB9LFxuICAgICAgLy8gU2tld1xuICAgICAgc2tldzogZnVuY3Rpb24gc2tldyh4LCB5LCBjeCwgY3kpIHtcbiAgICAgICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2tld1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgeSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgY3kgPSBjeDtcbiAgICAgICAgICBjeCA9IHk7XG4gICAgICAgICAgeSA9IHg7XG4gICAgICAgIH0gLy8gY29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcblxuXG4gICAgICAgIHggPSBTVkcudXRpbHMucmFkaWFucyh4KTtcbiAgICAgICAgeSA9IFNWRy51dGlscy5yYWRpYW5zKHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeCgxLCBNYXRoLnRhbih5KSwgTWF0aC50YW4oeCksIDEsIDAsIDApKTtcbiAgICAgIH0sXG4gICAgICAvLyBTa2V3WFxuICAgICAgc2tld1g6IGZ1bmN0aW9uIHNrZXdYKHgsIGN4LCBjeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5za2V3KHgsIDAsIGN4LCBjeSk7XG4gICAgICB9LFxuICAgICAgLy8gU2tld1lcbiAgICAgIHNrZXdZOiBmdW5jdGlvbiBza2V3WSh5LCBjeCwgY3kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tldygwLCB5LCBjeCwgY3kpO1xuICAgICAgfSxcbiAgICAgIC8vIFRyYW5zZm9ybSBhcm91bmQgYSBjZW50ZXIgcG9pbnRcbiAgICAgIGFyb3VuZDogZnVuY3Rpb24gYXJvdW5kKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KDEsIDAsIDAsIDEsIGN4IHx8IDAsIGN5IHx8IDApKS5tdWx0aXBseShtYXRyaXgpLm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KDEsIDAsIDAsIDEsIC1jeCB8fCAwLCAtY3kgfHwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIENvbnZlcnQgdG8gbmF0aXZlIFNWR01hdHJpeFxuICAgICAgbmF0aXZlOiBmdW5jdGlvbiBuYXRpdmUoKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbWF0cml4XG4gICAgICAgIHZhciBtYXRyaXggPSBTVkcucGFyc2VyLm5hdGl2ZS5jcmVhdGVTVkdNYXRyaXgoKTsgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcblxuICAgICAgICBmb3IgKHZhciBpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgbWF0cml4W2FiY2RlZltpXV0gPSB0aGlzW2FiY2RlZltpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfSxcbiAgICAgIC8vIENvbnZlcnQgbWF0cml4IHRvIHN0cmluZ1xuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIG1hdHJpeCBkaXJlY3RseSwgYXZvaWQgdmFsdWVzIHRoYXQgYXJlIHRvbyBzbWFsbFxuICAgICAgICByZXR1cm4gJ21hdHJpeCgnICsgZmxvYXQzMlN0cmluZyh0aGlzLmEpICsgJywnICsgZmxvYXQzMlN0cmluZyh0aGlzLmIpICsgJywnICsgZmxvYXQzMlN0cmluZyh0aGlzLmMpICsgJywnICsgZmxvYXQzMlN0cmluZyh0aGlzLmQpICsgJywnICsgZmxvYXQzMlN0cmluZyh0aGlzLmUpICsgJywnICsgZmxvYXQzMlN0cmluZyh0aGlzLmYpICsgJyknO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVmaW5lIHBhcmVudFxuICAgIHBhcmVudDogU1ZHLkVsZW1lbnQsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgY3RtOiBmdW5jdGlvbiBjdG0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5vZGUuZ2V0Q1RNKCkpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBjdXJyZW50IHNjcmVlbiBtYXRyaXhcbiAgICAgIHNjcmVlbkNUTTogZnVuY3Rpb24gc2NyZWVuQ1RNKCkge1xuICAgICAgICAvKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzQ0NTM3XG4gICAgICAgICAgIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgRkYgZG9lcyBub3QgcmV0dXJuIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgICAgICAgZm9yIHRoZSBpbm5lciBjb29yZGluYXRlIHN5c3RlbSB3aGVuIGdldFNjcmVlbkNUTSgpIGlzIGNhbGxlZCBvbiBuZXN0ZWQgc3Zncy5cbiAgICAgICAgICAgSG93ZXZlciBhbGwgb3RoZXIgQnJvd3NlcnMgZG8gdGhhdCAqL1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVjdCgxLCAxKTtcbiAgICAgICAgICB2YXIgbSA9IHJlY3Qubm9kZS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICByZWN0LnJlbW92ZSgpO1xuICAgICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeChtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Qb2ludCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG4gICAgICB2YXIgc291cmNlLFxuICAgICAgICAgIGJhc2UgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcblxuICAgICAgfTtcbiAgICAgIHNvdXJjZSA9IEFycmF5LmlzQXJyYXkoeCkgPyB7XG4gICAgICAgIHg6IHhbMF0sXG4gICAgICAgIHk6IHhbMV1cbiAgICAgIH0gOiBfdHlwZW9mKHgpID09PSAnb2JqZWN0JyA/IHtcbiAgICAgICAgeDogeC54LFxuICAgICAgICB5OiB4LnlcbiAgICAgIH0gOiB4ICE9IG51bGwgPyB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHkgIT0gbnVsbCA/IHkgOiB4XG4gICAgICB9IDogYmFzZTsgLy8gSWYgeSBoYXMgbm8gdmFsdWUsIHRoZW4geCBpcyB1c2VkIGhhcyBpdHMgdmFsdWVcbiAgICAgIC8vIG1lcmdlIHNvdXJjZVxuXG4gICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgIHRoaXMueSA9IHNvdXJjZS55O1xuICAgIH0sXG4gICAgLy8gQWRkIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIENsb25lIHBvaW50XG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vcnBoIG9uZSBwb2ludCBpbnRvIGFub3RoZXJcbiAgICAgIG1vcnBoOiBmdW5jdGlvbiBtb3JwaCh4LCB5KSB7XG4gICAgICAgIC8vIHN0b3JlIG5ldyBkZXN0aW5hdGlvblxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Qb2ludCh4LCB5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IG1vcnBoZWQgcG9pbnQgYXQgYSBnaXZlbiBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7IC8vIGNhbGN1bGF0ZSBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFNWRy5Qb2ludCh7XG4gICAgICAgICAgeDogdGhpcy54ICsgKHRoaXMuZGVzdGluYXRpb24ueCAtIHRoaXMueCkgKiBwb3MsXG4gICAgICAgICAgeTogdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IHRvIG5hdGl2ZSBTVkdQb2ludFxuICAgICAgbmF0aXZlOiBmdW5jdGlvbiBuYXRpdmUoKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgcG9pbnRcbiAgICAgICAgdmFyIHBvaW50ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHUG9pbnQoKTsgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcblxuICAgICAgICBwb2ludC54ID0gdGhpcy54O1xuICAgICAgICBwb2ludC55ID0gdGhpcy55O1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgLy8gdHJhbnNmb3JtIHBvaW50IHdpdGggbWF0cml4XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQodGhpcy5uYXRpdmUoKS5tYXRyaXhUcmFuc2Zvcm0obWF0cml4Lm5hdGl2ZSgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIEdldCBwb2ludFxuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh4LCB5KS50cmFuc2Zvcm0odGhpcy5zY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXG4gICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCB2LCBuKSB7XG4gICAgICAvLyBhY3QgYXMgZnVsbCBnZXR0ZXJcbiAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgLy8gZ2V0IGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgICAgIGEgPSB7fTtcbiAgICAgICAgdiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAobiA9IHYubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgICBhW3Zbbl0ubm9kZU5hbWVdID0gU1ZHLnJlZ2V4LmlzTnVtYmVyLnRlc3QodltuXS5ub2RlVmFsdWUpID8gcGFyc2VGbG9hdCh2W25dLm5vZGVWYWx1ZSkgOiB2W25dLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBhcHBseSBldmVyeSBhdHRyaWJ1dGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcbiAgICAgICAgZm9yICh2IGluIGEpIHtcbiAgICAgICAgICB0aGlzLmF0dHIodiwgYVt2XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICAvLyByZW1vdmUgdmFsdWVcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhKTtcbiAgICAgIH0gZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICB2ID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhKTtcbiAgICAgICAgcmV0dXJuIHYgPT0gbnVsbCA/IFNWRy5kZWZhdWx0cy5hdHRyc1thXSA6IFNWRy5yZWdleC5pc051bWJlci50ZXN0KHYpID8gcGFyc2VGbG9hdCh2KSA6IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCVUcgRklYOiBzb21lIGJyb3dzZXJzIHdpbGwgcmVuZGVyIGEgc3Ryb2tlIGlmIGEgY29sb3IgaXMgZ2l2ZW4gZXZlbiB0aG91Z2ggc3Ryb2tlIHdpZHRoIGlzIDBcbiAgICAgICAgaWYgKGEgPT0gJ3N0cm9rZS13aWR0aCcpIHtcbiAgICAgICAgICB0aGlzLmF0dHIoJ3N0cm9rZScsIHBhcnNlRmxvYXQodikgPiAwID8gdGhpcy5fc3Ryb2tlIDogbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PSAnc3Ryb2tlJykge1xuICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IHY7XG4gICAgICAgIH0gLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcblxuXG4gICAgICAgIGlmIChhID09ICdmaWxsJyB8fCBhID09ICdzdHJva2UnKSB7XG4gICAgICAgICAgaWYgKFNWRy5yZWdleC5pc0ltYWdlLnRlc3QodikpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5pbWFnZSh2LCAwLCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFNWRy5JbWFnZSkge1xuICAgICAgICAgICAgdiA9IHRoaXMuZG9jKCkuZGVmcygpLnBhdHRlcm4oMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGlzLmFkZCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbnN1cmUgY29ycmVjdCBudW1lcmljIHZhbHVlcyAoYWxzbyBhY2NlcHRzIE5hTiBhbmQgSW5maW5pdHkpXG5cblxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdiA9IG5ldyBTVkcuTnVtYmVyKHYpO1xuICAgICAgICB9IC8vIGVuc3VyZSBmdWxsIGhleCBjb2xvclxuICAgICAgICBlbHNlIGlmIChTVkcuQ29sb3IuaXNDb2xvcih2KSkge1xuICAgICAgICAgICAgdiA9IG5ldyBTVkcuQ29sb3Iodik7XG4gICAgICAgICAgfSAvLyBwYXJzZSBhcnJheSB2YWx1ZXNcbiAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkFycmF5KHYpO1xuICAgICAgICAgICAgfSAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXG5cblxuICAgICAgICBpZiAoYSA9PSAnbGVhZGluZycpIHtcbiAgICAgICAgICAvLyAuLi4gY2FsbCB0aGUgbGVhZGluZyBtZXRob2QgaW5zdGVhZFxuICAgICAgICAgIGlmICh0aGlzLmxlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubGVhZGluZyh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXG4gICAgICAgICAgdHlwZW9mIG4gPT09ICdzdHJpbmcnID8gdGhpcy5ub2RlLnNldEF0dHJpYnV0ZU5TKG4sIGEsIHYudG9TdHJpbmcoKSkgOiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEsIHYudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gLy8gcmVidWlsZCBpZiByZXF1aXJlZFxuXG5cbiAgICAgICAgaWYgKHRoaXMucmVidWlsZCAmJiAoYSA9PSAnZm9udC1zaXplJyB8fCBhID09ICd4JykpIHtcbiAgICAgICAgICB0aGlzLnJlYnVpbGQoYSwgdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShvLCByZWxhdGl2ZSkge1xuICAgICAgLy8gZ2V0IHRhcmdldCBpbiBjYXNlIG9mIHRoZSBmeCBtb2R1bGUsIG90aGVyd2lzZSByZWZlcmVuY2UgdGhpc1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgbWF0cml4LFxuICAgICAgICAgIGJib3g7IC8vIGFjdCBhcyBhIGdldHRlclxuXG4gICAgICBpZiAoX3R5cGVvZihvKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgbWF0cml4XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldCkuZXh0cmFjdCgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbWF0cml4W29dIDogbWF0cml4O1xuICAgICAgfSAvLyBnZXQgY3VycmVudCBtYXRyaXhcblxuXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpOyAvLyBlbnN1cmUgcmVsYXRpdmUgZmxhZ1xuXG4gICAgICByZWxhdGl2ZSA9ICEhcmVsYXRpdmUgfHwgISFvLnJlbGF0aXZlOyAvLyBhY3Qgb24gbWF0cml4XG5cbiAgICAgIGlmIChvLmEgIT0gbnVsbCkge1xuICAgICAgICBtYXRyaXggPSByZWxhdGl2ZSAvLyByZWxhdGl2ZVxuICAgICAgICA/IG1hdHJpeC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeChvKSkgLy8gYWJzb2x1dGVcbiAgICAgICAgOiBuZXcgU1ZHLk1hdHJpeChvKTsgLy8gYWN0IG9uIHJvdGF0aW9uXG4gICAgICB9IGVsc2UgaWYgKG8ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxuXG4gICAgICAgIG1hdHJpeCA9IHJlbGF0aXZlIC8vIHJlbGF0aXZlXG4gICAgICAgID8gbWF0cml4LnJvdGF0ZShvLnJvdGF0aW9uLCBvLmN4LCBvLmN5KSAvLyBhYnNvbHV0ZVxuICAgICAgICA6IG1hdHJpeC5yb3RhdGUoby5yb3RhdGlvbiAtIG1hdHJpeC5leHRyYWN0KCkucm90YXRpb24sIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2NhbGVcbiAgICAgIH0gZWxzZSBpZiAoby5zY2FsZSAhPSBudWxsIHx8IG8uc2NhbGVYICE9IG51bGwgfHwgby5zY2FsZVkgIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBlbnN1cmUgc2NhbGUgdmFsdWVzIG9uIGJvdGggYXhlc1xuXG4gICAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDE7XG4gICAgICAgIG8uc2NhbGVZID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVZICE9IG51bGwgPyBvLnNjYWxlWSA6IDE7XG5cbiAgICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAgIC8vIGFic29sdXRlOyBtdWx0aXBseSBpbnZlcnNlZCB2YWx1ZXNcbiAgICAgICAgICB2YXIgZSA9IG1hdHJpeC5leHRyYWN0KCk7XG4gICAgICAgICAgby5zY2FsZVggPSBvLnNjYWxlWCAqIDEgLyBlLnNjYWxlWDtcbiAgICAgICAgICBvLnNjYWxlWSA9IG8uc2NhbGVZICogMSAvIGUuc2NhbGVZO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0cml4ID0gbWF0cml4LnNjYWxlKG8uc2NhbGVYLCBvLnNjYWxlWSwgby5jeCwgby5jeSk7IC8vIGFjdCBvbiBza2V3XG4gICAgICB9IGVsc2UgaWYgKG8uc2tldyAhPSBudWxsIHx8IG8uc2tld1ggIT0gbnVsbCB8fCBvLnNrZXdZICE9IG51bGwpIHtcbiAgICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KTsgLy8gZW5zdXJlIHNrZXcgdmFsdWVzIG9uIGJvdGggYXhlc1xuXG4gICAgICAgIG8uc2tld1ggPSBvLnNrZXcgIT0gbnVsbCA/IG8uc2tldyA6IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwO1xuICAgICAgICBvLnNrZXdZID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdZICE9IG51bGwgPyBvLnNrZXdZIDogMDtcblxuICAgICAgICBpZiAoIXJlbGF0aXZlKSB7XG4gICAgICAgICAgLy8gYWJzb2x1dGU7IHJlc2V0IHNrZXcgdmFsdWVzXG4gICAgICAgICAgdmFyIGUgPSBtYXRyaXguZXh0cmFjdCgpO1xuICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLnNrZXcoZS5za2V3WCwgZS5za2V3WSwgby5jeCwgby5jeSkuaW52ZXJzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC5za2V3KG8uc2tld1gsIG8uc2tld1ksIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gZmxpcFxuICAgICAgfSBlbHNlIGlmIChvLmZsaXApIHtcbiAgICAgICAgaWYgKG8uZmxpcCA9PSAneCcgfHwgby5mbGlwID09ICd5Jykge1xuICAgICAgICAgIG8ub2Zmc2V0ID0gby5vZmZzZXQgPT0gbnVsbCA/IHRhcmdldC5iYm94KClbJ2MnICsgby5mbGlwXSA6IG8ub2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvLm9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBiYm94ID0gdGFyZ2V0LmJib3goKTtcbiAgICAgICAgICAgIG8uZmxpcCA9IGJib3guY3g7XG4gICAgICAgICAgICBvLm9mZnNldCA9IGJib3guY3k7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG8uZmxpcCA9IG8ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KCkuZmxpcChvLmZsaXAsIG8ub2Zmc2V0KTsgLy8gYWN0IG9uIHRyYW5zbGF0ZVxuICAgICAgfSBlbHNlIGlmIChvLnggIT0gbnVsbCB8fCBvLnkgIT0gbnVsbCkge1xuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAvLyByZWxhdGl2ZVxuICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC50cmFuc2xhdGUoby54LCBvLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFic29sdXRlXG4gICAgICAgICAgaWYgKG8ueCAhPSBudWxsKSBtYXRyaXguZSA9IG8ueDtcbiAgICAgICAgICBpZiAoby55ICE9IG51bGwpIG1hdHJpeC5mID0gby55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRlgsIHtcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShvLCByZWxhdGl2ZSkge1xuICAgICAgLy8gZ2V0IHRhcmdldCBpbiBjYXNlIG9mIHRoZSBmeCBtb2R1bGUsIG90aGVyd2lzZSByZWZlcmVuY2UgdGhpc1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0KCksXG4gICAgICAgICAgbWF0cml4LFxuICAgICAgICAgIGJib3g7IC8vIGFjdCBhcyBhIGdldHRlclxuXG4gICAgICBpZiAoX3R5cGVvZihvKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgbWF0cml4XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldCkuZXh0cmFjdCgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbWF0cml4W29dIDogbWF0cml4O1xuICAgICAgfSAvLyBlbnN1cmUgcmVsYXRpdmUgZmxhZ1xuXG5cbiAgICAgIHJlbGF0aXZlID0gISFyZWxhdGl2ZSB8fCAhIW8ucmVsYXRpdmU7IC8vIGFjdCBvbiBtYXRyaXhcblxuICAgICAgaWYgKG8uYSAhPSBudWxsKSB7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KG8pOyAvLyBhY3Qgb24gcm90YXRpb25cbiAgICAgIH0gZWxzZSBpZiAoby5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcbiAgICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldCk7IC8vIGFwcGx5IHRyYW5zZm9ybWF0aW9uXG5cbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5Sb3RhdGUoby5yb3RhdGlvbiwgby5jeCwgby5jeSk7IC8vIGFjdCBvbiBzY2FsZVxuICAgICAgfSBlbHNlIGlmIChvLnNjYWxlICE9IG51bGwgfHwgby5zY2FsZVggIT0gbnVsbCB8fCBvLnNjYWxlWSAhPSBudWxsKSB7XG4gICAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcbiAgICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldCk7IC8vIGVuc3VyZSBzY2FsZSB2YWx1ZXMgb24gYm90aCBheGVzXG5cbiAgICAgICAgby5zY2FsZVggPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVggIT0gbnVsbCA/IG8uc2NhbGVYIDogMTtcbiAgICAgICAgby5zY2FsZVkgPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVkgIT0gbnVsbCA/IG8uc2NhbGVZIDogMTtcbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5TY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2tld1xuICAgICAgfSBlbHNlIGlmIChvLnNrZXdYICE9IG51bGwgfHwgby5za2V3WSAhPSBudWxsKSB7XG4gICAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcbiAgICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldCk7IC8vIGVuc3VyZSBza2V3IHZhbHVlcyBvbiBib3RoIGF4ZXNcblxuICAgICAgICBvLnNrZXdYID0gby5za2V3WCAhPSBudWxsID8gby5za2V3WCA6IDA7XG4gICAgICAgIG8uc2tld1kgPSBvLnNrZXdZICE9IG51bGwgPyBvLnNrZXdZIDogMDtcbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5Ta2V3KG8uc2tld1gsIG8uc2tld1ksIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gZmxpcFxuICAgICAgfSBlbHNlIGlmIChvLmZsaXApIHtcbiAgICAgICAgaWYgKG8uZmxpcCA9PSAneCcgfHwgby5mbGlwID09ICd5Jykge1xuICAgICAgICAgIG8ub2Zmc2V0ID0gby5vZmZzZXQgPT0gbnVsbCA/IHRhcmdldC5iYm94KClbJ2MnICsgby5mbGlwXSA6IG8ub2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvLm9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBiYm94ID0gdGFyZ2V0LmJib3goKTtcbiAgICAgICAgICAgIG8uZmxpcCA9IGJib3guY3g7XG4gICAgICAgICAgICBvLm9mZnNldCA9IGJib3guY3k7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG8uZmxpcCA9IG8ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KCkuZmxpcChvLmZsaXAsIG8ub2Zmc2V0KTsgLy8gYWN0IG9uIHRyYW5zbGF0ZVxuICAgICAgfSBlbHNlIGlmIChvLnggIT0gbnVsbCB8fCBvLnkgIT0gbnVsbCkge1xuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLlRyYW5zbGF0ZShvLngsIG8ueSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0cml4KSByZXR1cm4gdGhpcztcbiAgICAgIG1hdHJpeC5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuICAgICAgdGhpcy5sYXN0KCkudHJhbnNmb3Jtcy5wdXNoKG1hdHJpeCk7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIFJlc2V0IGFsbCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB1bnRyYW5zZm9ybTogZnVuY3Rpb24gdW50cmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKTtcbiAgICB9LFxuICAgIC8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcbiAgICBtYXRyaXhpZnk6IGZ1bmN0aW9uIG1hdHJpeGlmeSgpIHtcbiAgICAgIHZhciBtYXRyaXggPSAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJykuIC8vIHNwbGl0IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgc3BsaXQoU1ZHLnJlZ2V4LnRyYW5zZm9ybXMpLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcbiAgICAgICAgdmFyIGt2ID0gc3RyLnRyaW0oKS5zcGxpdCgnKCcpO1xuICAgICAgICByZXR1cm4gW2t2WzBdLCBrdlsxXS5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVswXSA9PSAnbWF0cml4JykgcmV0dXJuIG1hdHJpeC5tdWx0aXBseShhcnJheVRvTWF0cml4KHRyYW5zZm9ybVsxXSkpO1xuICAgICAgICByZXR1cm4gbWF0cml4W3RyYW5zZm9ybVswXV0uYXBwbHkobWF0cml4LCB0cmFuc2Zvcm1bMV0pO1xuICAgICAgfSwgbmV3IFNWRy5NYXRyaXgoKSk7XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG4gICAgLy8gYWRkIGFuIGVsZW1lbnQgdG8gYW5vdGhlciBwYXJlbnQgd2l0aG91dCBjaGFuZ2luZyB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzY3JlZW5cbiAgICB0b1BhcmVudDogZnVuY3Rpb24gdG9QYXJlbnQocGFyZW50KSB7XG4gICAgICBpZiAodGhpcyA9PSBwYXJlbnQpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGN0bSA9IHRoaXMuc2NyZWVuQ1RNKCk7XG4gICAgICB2YXIgcEN0bSA9IHBhcmVudC5zY3JlZW5DVE0oKS5pbnZlcnNlKCk7XG4gICAgICB0aGlzLmFkZFRvKHBhcmVudCkudW50cmFuc2Zvcm0oKS50cmFuc2Zvcm0ocEN0bS5tdWx0aXBseShjdG0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gc2FtZSBhcyBhYm92ZSB3aXRoIHBhcmVudCBlcXVhbHMgcm9vdC1zdmdcbiAgICB0b0RvYzogZnVuY3Rpb24gdG9Eb2MoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1BhcmVudCh0aGlzLmRvYygpKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuVHJhbnNmb3JtYXRpb24gPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGludmVyc2VkKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGludmVyc2VkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgdGhpc1t0aGlzLmFyZ3VtZW50c1tpXV0gPSBzb3VyY2VbdGhpcy5hcmd1bWVudHNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW52ZXJzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGludmVyc2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaW52ZXJzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgbWV0aG9kOiAnJyxcbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gdGhpcy5fdW5kbyB8fCBuZXcgU1ZHLk1hdHJpeCgpO1xuICAgICAgICBtID0gbmV3IFNWRy5NYXRyaXgoKS5tb3JwaChTVkcuTWF0cml4LnByb3RvdHlwZVt0aGlzLm1ldGhvZF0uYXBwbHkobSwgcGFyYW1zKSkuYXQocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJzZWQgPyBtLmludmVyc2UoKSA6IG07XG4gICAgICB9LFxuICAgICAgdW5kbzogZnVuY3Rpb24gdW5kbyhvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIG9bdGhpcy5hcmd1bWVudHNbaV1dID0gdHlwZW9mIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID09PSAndW5kZWZpbmVkJyA/IDAgOiBvW3RoaXMuYXJndW1lbnRzW2ldXTtcbiAgICAgICAgfSAvLyBUaGUgbWV0aG9kIFNWRy5NYXRyaXguZXh0cmFjdCB3aGljaCB3YXMgdXNlZCBiZWZvcmUgY2FsbGluZyB0aGlzXG4gICAgICAgIC8vIG1ldGhvZCB0byBvYnRhaW4gYSB2YWx1ZSBmb3IgdGhlIHBhcmFtZXRlciBvIGRvZXNuJ3QgcmV0dXJuIGEgY3ggYW5kXG4gICAgICAgIC8vIGEgY3kgc28gd2UgdXNlIHRoZSBvbmVzIHRoYXQgd2VyZSBwcm92aWRlZCB0byB0aGlzIG9iamVjdCBhdCBpdHMgY3JlYXRpb25cblxuXG4gICAgICAgIG8uY3ggPSB0aGlzLmN4O1xuICAgICAgICBvLmN5ID0gdGhpcy5jeTtcbiAgICAgICAgdGhpcy5fdW5kbyA9IG5ldyBTVkdbY2FwaXRhbGl6ZSh0aGlzLm1ldGhvZCldKG8sIHRydWUpLmF0KDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuVHJhbnNsYXRlID0gU1ZHLmludmVudCh7XG4gICAgcGFyZW50OiBTVkcuTWF0cml4LFxuICAgIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvbixcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGludmVyc2VkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGFyZ3VtZW50czogWyd0cmFuc2Zvcm1lZFgnLCAndHJhbnNmb3JtZWRZJ10sXG4gICAgICBtZXRob2Q6ICd0cmFuc2xhdGUnXG4gICAgfVxuICB9KTtcbiAgU1ZHLlJvdGF0ZSA9IFNWRy5pbnZlbnQoe1xuICAgIHBhcmVudDogU1ZHLk1hdHJpeCxcbiAgICBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb24sXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhcmd1bWVudHM6IFsncm90YXRpb24nLCAnY3gnLCAnY3knXSxcbiAgICAgIG1ldGhvZDogJ3JvdGF0ZScsXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIHZhciBtID0gbmV3IFNWRy5NYXRyaXgoKS5yb3RhdGUobmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh0aGlzLnJvdGF0aW9uIC0gKHRoaXMuX3VuZG8gPyB0aGlzLl91bmRvLnJvdGF0aW9uIDogMCkpLmF0KHBvcyksIHRoaXMuY3gsIHRoaXMuY3kpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZlcnNlZCA/IG0uaW52ZXJzZSgpIDogbTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiBmdW5jdGlvbiB1bmRvKG8pIHtcbiAgICAgICAgdGhpcy5fdW5kbyA9IG87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5TY2FsZSA9IFNWRy5pbnZlbnQoe1xuICAgIHBhcmVudDogU1ZHLk1hdHJpeCxcbiAgICBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb24sXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhcmd1bWVudHM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdjeCcsICdjeSddLFxuICAgICAgbWV0aG9kOiAnc2NhbGUnXG4gICAgfVxuICB9KTtcbiAgU1ZHLlNrZXcgPSBTVkcuaW52ZW50KHtcbiAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgaW52ZXJzZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbJ3NrZXdYJywgJ3NrZXdZJywgJ2N4JywgJ2N5J10sXG4gICAgICBtZXRob2Q6ICdza2V3J1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBEeW5hbWljIHN0eWxlIGdlbmVyYXRvclxuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShzLCB2KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIC8vIGdldCBmdWxsIHN0eWxlXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dCB8fCAnJztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgLy8gYXBwbHkgZXZlcnkgc3R5bGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKF90eXBlb2YocykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2IGluIHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUodiwgc1t2XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFNWRy5yZWdleC5pc0Nzcy50ZXN0KHMpKSB7XG4gICAgICAgICAgLy8gcGFyc2UgY3NzIHN0cmluZ1xuICAgICAgICAgIHMgPSBzLnNwbGl0KC9cXHMqO1xccyovKSAvLyBmaWx0ZXIgb3V0IHN1ZmZpeCA7IGFuZCBzdHVmZiBsaWtlIDs7XG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZTtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnNwbGl0KC9cXHMqOlxccyovKTtcbiAgICAgICAgICB9KTsgLy8gYXBwbHkgZXZlcnkgZGVmaW5pdGlvbiBpbmRpdmlkdWFsbHlcblxuICAgICAgICAgIHdoaWxlICh2ID0gcy5wb3AoKSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSh2WzBdLCB2WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UocyldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHMpXSA9IHYgPT09IG51bGwgfHwgU1ZHLnJlZ2V4LmlzQmxhbmsudGVzdCh2KSA/ICcnIDogdjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBhcmVudCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZCBlbGVtZW50c1xuICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gU1ZHLnV0aWxzLm1hcChTVkcudXRpbHMuZmlsdGVyU1ZHRWxlbWVudHModGhpcy5ub2RlLmNoaWxkTm9kZXMpLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBTVkcuYWRvcHQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBnaXZlbiBlbGVtZW50IGF0IGEgcG9zaXRpb25cbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubm9kZSAhPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSBhcyBgYWRkKClgIGJ1dCByZXR1cm5zIHRoZSBhZGRlZCBlbGVtZW50IGluc3RlYWRcbiAgICAgIHB1dDogZnVuY3Rpb24gcHV0KGVsZW1lbnQsIGkpIHtcbiAgICAgICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIC8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhIGNoaWxkXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDA7XG4gICAgICB9LFxuICAgICAgLy8gR2V0cyBpbmRleCBvZiBnaXZlbiBlbGVtZW50XG4gICAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLm5vZGUuY2hpbGROb2RlcykuaW5kZXhPZihlbGVtZW50Lm5vZGUpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBhIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChpKSB7XG4gICAgICAgIHJldHVybiBTVkcuYWRvcHQodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBmaXJzdCBjaGlsZFxuICAgICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoMCk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkXG4gICAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuICAgICAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRyZW4gYW5kIGludm9rZXMgYSBnaXZlbiBibG9ja1xuICAgICAgZWFjaDogZnVuY3Rpb24gZWFjaChibG9jaywgZGVlcCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlsLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbaSwgY2hpbGRyZW5dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVlcCAmJiBjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZSBhIGdpdmVuIGNoaWxkXG4gICAgICByZW1vdmVFbGVtZW50OiBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZSBhbGwgZWxlbWVudHMgaW4gdGhpcyBjb250YWluZXJcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO1xuICAgICAgICB9IC8vIHJlbW92ZSBkZWZzIHJlZmVyZW5jZVxuXG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2RlZnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBkZWZzXG4gICAgICBkZWZzOiBmdW5jdGlvbiBkZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MoKS5kZWZzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XG4gICAgdW5ncm91cDogZnVuY3Rpb24gdW5ncm91cChwYXJlbnQsIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPT09IDAgfHwgdGhpcyBpbnN0YW5jZW9mIFNWRy5EZWZzIHx8IHRoaXMubm9kZSA9PSBTVkcucGFyc2VyLmRyYXcpIHJldHVybiB0aGlzO1xuICAgICAgcGFyZW50ID0gcGFyZW50IHx8ICh0aGlzIGluc3RhbmNlb2YgU1ZHLkRvYyA/IHRoaXMgOiB0aGlzLnBhcmVudChTVkcuUGFyZW50KSk7XG4gICAgICBkZXB0aCA9IGRlcHRoIHx8IEluZmluaXR5O1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTVkcuRGVmcykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU1ZHLlBhcmVudCkgcmV0dXJuIHRoaXMudW5ncm91cChwYXJlbnQsIGRlcHRoIC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHBhcmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubm9kZS5maXJzdENoaWxkIHx8IHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4ocGFyZW50LCBkZXB0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5ncm91cChwYXJlbnQsIGRlcHRoKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuQ29udGFpbmVyID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlBhcmVudFxuICB9KTtcbiAgU1ZHLlZpZXdCb3ggPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UpIHtcbiAgICAgIHZhciBiYXNlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgd2UsXG4gICAgICAgICAgaGUsXG4gICAgICAgICAgd20gPSAxLFxuICAgICAgICAgIC8vIHdpZHRoIG11bHRpcGxpZXJcbiAgICAgIGhtID0gMSxcbiAgICAgICAgICAvLyBoZWlnaHQgbXVsdGlwbGllclxuICAgICAgcmVnID0gL1srLV0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9naTtcblxuICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgIHdlID0gc291cmNlO1xuICAgICAgICBoZSA9IHNvdXJjZTtcbiAgICAgICAgdmlldyA9IChzb3VyY2UuYXR0cigndmlld0JveCcpIHx8ICcnKS5tYXRjaChyZWcpO1xuICAgICAgICBib3ggPSBzb3VyY2UuYmJveDsgLy8gZ2V0IGRpbWVuc2lvbnMgb2YgY3VycmVudCBub2RlXG5cbiAgICAgICAgd2lkdGggPSBuZXcgU1ZHLk51bWJlcihzb3VyY2Uud2lkdGgoKSk7XG4gICAgICAgIGhlaWdodCA9IG5ldyBTVkcuTnVtYmVyKHNvdXJjZS5oZWlnaHQoKSk7IC8vIGZpbmQgbmVhcmVzdCBub24tcGVyY2VudHVhbCBkaW1lbnNpb25zXG5cbiAgICAgICAgd2hpbGUgKHdpZHRoLnVuaXQgPT0gJyUnKSB7XG4gICAgICAgICAgd20gKj0gd2lkdGgudmFsdWU7XG4gICAgICAgICAgd2lkdGggPSBuZXcgU1ZHLk51bWJlcih3ZSBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB3ZS5wYXJlbnQoKS5vZmZzZXRXaWR0aCA6IHdlLnBhcmVudCgpLndpZHRoKCkpO1xuICAgICAgICAgIHdlID0gd2UucGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaGVpZ2h0LnVuaXQgPT0gJyUnKSB7XG4gICAgICAgICAgaG0gKj0gaGVpZ2h0LnZhbHVlO1xuICAgICAgICAgIGhlaWdodCA9IG5ldyBTVkcuTnVtYmVyKGhlIGluc3RhbmNlb2YgU1ZHLkRvYyA/IGhlLnBhcmVudCgpLm9mZnNldEhlaWdodCA6IGhlLnBhcmVudCgpLmhlaWdodCgpKTtcbiAgICAgICAgICBoZSA9IGhlLnBhcmVudCgpO1xuICAgICAgICB9IC8vIGVuc3VyZSBkZWZhdWx0c1xuXG5cbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogd207XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogaG07XG4gICAgICAgIHRoaXMuem9vbSA9IDE7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAvLyBnZXQgd2lkdGggYW5kIGhlaWdodCBmcm9tIHZpZXdib3hcbiAgICAgICAgICB4ID0gcGFyc2VGbG9hdCh2aWV3WzBdKTtcbiAgICAgICAgICB5ID0gcGFyc2VGbG9hdCh2aWV3WzFdKTtcbiAgICAgICAgICB3aWR0aCA9IHBhcnNlRmxvYXQodmlld1syXSk7XG4gICAgICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdCh2aWV3WzNdKTsgLy8gY2FsY3VsYXRlIHpvb20gYWNjb3JpbmcgdG8gdmlld2JveFxuXG4gICAgICAgICAgdGhpcy56b29tID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0ID4gd2lkdGggLyBoZWlnaHQgPyB0aGlzLmhlaWdodCAvIGhlaWdodCA6IHRoaXMud2lkdGggLyB3aWR0aDsgLy8gY2FsY3VsYXRlIHJlYWwgcGl4ZWwgZGltZW5zaW9ucyBvbiBwYXJlbnQgU1ZHLkRvYyBlbGVtZW50XG5cbiAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuICAgICAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZS5tYXRjaChyZWcpLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbCk7XG4gICAgICAgIH0pIDogQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogX3R5cGVvZihzb3VyY2UpID09PSAnb2JqZWN0JyA/IFtzb3VyY2UueCwgc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodF0gOiBhcmd1bWVudHMubGVuZ3RoID09IDQgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBiYXNlO1xuICAgICAgICB0aGlzLnggPSBzb3VyY2VbMF07XG4gICAgICAgIHRoaXMueSA9IHNvdXJjZVsxXTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZVsyXTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzb3VyY2VbM107XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArICcgJyArIHRoaXMueSArICcgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodDtcbiAgICAgIH0sXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5WaWV3Qm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlZpZXdCb3goW3RoaXMueCArICh0aGlzLmRlc3RpbmF0aW9uLnggLSB0aGlzLngpICogcG9zLCB0aGlzLnkgKyAodGhpcy5kZXN0aW5hdGlvbi55IC0gdGhpcy55KSAqIHBvcywgdGhpcy53aWR0aCArICh0aGlzLmRlc3RpbmF0aW9uLndpZHRoIC0gdGhpcy53aWR0aCkgKiBwb3MsIHRoaXMuaGVpZ2h0ICsgKHRoaXMuZGVzdGluYXRpb24uaGVpZ2h0IC0gdGhpcy5oZWlnaHQpICogcG9zXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWZpbmUgcGFyZW50XG4gICAgcGFyZW50OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBnZXQvc2V0IHZpZXdib3hcbiAgICAgIHZpZXdib3g6IGZ1bmN0aW9uIHZpZXdib3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50c1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU1ZHLlZpZXdCb3godGhpcyk7XG4gICAgICAgICAgfSAvLyBvdGhlcndpc2UgYWN0IGFzIGEgc2V0dGVyXG5cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd2aWV3Qm94JywgbmV3IFNWRy5WaWV3Qm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pIC8vIEFkZCBldmVudHMgdG8gZWxlbWVudHNcbiAgO1xuICBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAvLyAsICdtb3VzZWVudGVyJyAtPiBub3Qgc3VwcG9ydGVkIGJ5IElFXG4gIC8vICwgJ21vdXNlbGVhdmUnIC0+IG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNobGVhdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGFkZCBldmVudCB0byBTVkcuRWxlbWVudFxuICAgIFNWRy5FbGVtZW50LnByb3RvdHlwZVtldmVudF0gPSBmdW5jdGlvbiAoZikge1xuICAgICAgLy8gYmluZCBldmVudCB0byBlbGVtZW50IHJhdGhlciB0aGFuIGVsZW1lbnQgbm9kZVxuICAgICAgU1ZHLm9uKHRoaXMubm9kZSwgZXZlbnQsIGYpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7IC8vIEluaXRpYWxpemUgbGlzdGVuZXJzIHN0YWNrXG5cbiAgU1ZHLmxpc3RlbmVycyA9IFtdO1xuICBTVkcuaGFuZGxlck1hcCA9IFtdO1xuICBTVkcubGlzdGVuZXJJZCA9IDA7IC8vIEFkZCBldmVudCBiaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcblxuICBTVkcub24gPSBmdW5jdGlvbiAobm9kZSwgZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgLy8gY3JlYXRlIGxpc3RlbmVyLCBnZXQgb2JqZWN0LWluZGV4XG4gICAgdmFyIGwgPSBsaXN0ZW5lci5iaW5kKGJpbmRpbmcgfHwgbm9kZS5pbnN0YW5jZSB8fCBub2RlKSxcbiAgICAgICAgaW5kZXggPSAoU1ZHLmhhbmRsZXJNYXAuaW5kZXhPZihub2RlKSArIDEgfHwgU1ZHLmhhbmRsZXJNYXAucHVzaChub2RlKSkgLSAxLFxuICAgICAgICBldiA9IGV2ZW50LnNwbGl0KCcuJylbMF0sXG4gICAgICAgIG5zID0gZXZlbnQuc3BsaXQoJy4nKVsxXSB8fCAnKic7IC8vIGVuc3VyZSB2YWxpZCBvYmplY3RcblxuICAgIFNWRy5saXN0ZW5lcnNbaW5kZXhdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF0gfHwge307XG4gICAgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdIHx8IHt9O1xuICAgIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10gPSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdIHx8IHt9O1xuXG4gICAgaWYgKCFsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkKSB7XG4gICAgICBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkID0gKytTVkcubGlzdGVuZXJJZDtcbiAgICB9IC8vIHJlZmVyZW5jZSBsaXN0ZW5lclxuXG5cbiAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbDsgLy8gYWRkIGxpc3RlbmVyXG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGwsIG9wdGlvbnMgfHwgZmFsc2UpO1xuICB9OyAvLyBBZGQgZXZlbnQgdW5iaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcblxuXG4gIFNWRy5vZmYgPSBmdW5jdGlvbiAobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGluZGV4ID0gU1ZHLmhhbmRsZXJNYXAuaW5kZXhPZihub2RlKSxcbiAgICAgICAgZXYgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzBdLFxuICAgICAgICBucyA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMV0sXG4gICAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIGlmIChpbmRleCA9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSBsaXN0ZW5lciA9IGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQ7XG4gICAgICBpZiAoIWxpc3RlbmVyKSByZXR1cm47IC8vIHJlbW92ZSBsaXN0ZW5lciByZWZlcmVuY2VcblxuICAgICAgaWYgKFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAmJiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXSkge1xuICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl0sIGZhbHNlKTtcbiAgICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5zICYmIGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBuYW1lc3BhY2VkIGV2ZW50XG4gICAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdICYmIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10pIHtcbiAgICAgICAgZm9yIChsaXN0ZW5lciBpbiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdKSB7XG4gICAgICAgICAgU1ZHLm9mZihub2RlLCBbZXYsIG5zXS5qb2luKCcuJyksIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgICAgZm9yIChldmVudCBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSkge1xuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBTVkcubGlzdGVuZXJzW2luZGV4XVtldmVudF0pIHtcbiAgICAgICAgICBpZiAobnMgPT09IG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgU1ZHLm9mZihub2RlLCBbZXZlbnQsIG5zXS5qb2luKCcuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXYpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnRcbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0pIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKSB7XG4gICAgICAgICAgU1ZHLm9mZihub2RlLCBbZXYsIG5hbWVzcGFjZV0uam9pbignLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxuICAgICAgZm9yIChldmVudCBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSkge1xuICAgICAgICBTVkcub2ZmKG5vZGUsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdO1xuICAgICAgZGVsZXRlIFNWRy5oYW5kbGVyTWFwW2luZGV4XTtcbiAgICB9XG4gIH07IC8vXG5cblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxuICAgIG9uOiBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcbiAgICAgIFNWRy5vbih0aGlzLm5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFVuYmluZCBldmVudCBmcm9tIGxpc3RlbmVyXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBTVkcub2ZmKHRoaXMubm9kZSwgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gRmlyZSBnaXZlbiBldmVudFxuICAgIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQgPSBuZXcgU1ZHLkN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgZGV0YWlsOiBkYXRhLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ldmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBldmVudDogZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkRlZnMgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdkZWZzJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyXG4gIH0pO1xuICBTVkcuRyA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2cnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcbiAgICAgIHg6IGZ1bmN0aW9uIHgoX3gzKSB7XG4gICAgICAgIHJldHVybiBfeDMgPT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtKCd4JykgOiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgICAgeDogX3gzIC0gdGhpcy54KClcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICAgeTogZnVuY3Rpb24geShfeTMpIHtcbiAgICAgICAgcmV0dXJuIF95MyA9PSBudWxsID8gdGhpcy50cmFuc2Zvcm0oJ3knKSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgICB5OiBfeTMgLSB0aGlzLnkoKVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuZ2JveCgpLmN4IDogdGhpcy54KHggLSB0aGlzLmdib3goKS53aWR0aCAvIDIpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5nYm94KCkuY3kgOiB0aGlzLnkoeSAtIHRoaXMuZ2JveCgpLmhlaWdodCAvIDIpO1xuICAgICAgfSxcbiAgICAgIGdib3g6IGZ1bmN0aW9uIGdib3goKSB7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5iYm94KCksXG4gICAgICAgICAgICB0cmFucyA9IHRoaXMudHJhbnNmb3JtKCk7XG4gICAgICAgIGJib3gueCArPSB0cmFucy54O1xuICAgICAgICBiYm94LngyICs9IHRyYW5zLng7XG4gICAgICAgIGJib3guY3ggKz0gdHJhbnMueDtcbiAgICAgICAgYmJveC55ICs9IHRyYW5zLnk7XG4gICAgICAgIGJib3gueTIgKz0gdHJhbnMueTtcbiAgICAgICAgYmJveC5jeSArPSB0cmFucy55O1xuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XG4gICAgICBncm91cDogZnVuY3Rpb24gZ3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLkRvYyA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYSBkb20gZWxlbWVudFxuICAgICAgICBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCkgOiBlbGVtZW50OyAvLyBJZiB0aGUgdGFyZ2V0IGlzIGFuIHN2ZyBlbGVtZW50LCB1c2UgdGhhdCBlbGVtZW50IGFzIHRoZSBtYWluIHdyYXBwZXIuXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHN2Zy5qcyB0byB3b3JrIHdpdGggc3ZnIGRvY3VtZW50cyBhcyB3ZWxsLlxuXG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSk7XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICAgIHRoaXMuc2l6ZSgnMTAwJScsICcxMDAlJyk7XG4gICAgICAgIH0gLy8gc2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZXMgYW5kIGVuc3VyZSBkZWZzIG5vZGVcblxuXG4gICAgICAgIHRoaXMubmFtZXNwYWNlKCkuZGVmcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gQWRkIG5hbWVzcGFjZXNcbiAgICAgIG5hbWVzcGFjZTogZnVuY3Rpb24gbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgICAgICB4bWxuczogU1ZHLm5zLFxuICAgICAgICAgIHZlcnNpb246ICcxLjEnXG4gICAgICAgIH0pLmF0dHIoJ3htbG5zOnhsaW5rJywgU1ZHLnhsaW5rLCBTVkcueG1sbnMpLmF0dHIoJ3htbG5zOnN2Z2pzJywgU1ZHLnN2Z2pzLCBTVkcueG1sbnMpO1xuICAgICAgfSxcbiAgICAgIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgZGVmcyBlbGVtZW50XG4gICAgICBkZWZzOiBmdW5jdGlvbiBkZWZzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlZnMpIHtcbiAgICAgICAgICB2YXIgZGVmczsgLy8gRmluZCBvciBjcmVhdGUgYSBkZWZzIGVsZW1lbnQgaW4gdGhpcyBpbnN0YW5jZVxuXG4gICAgICAgICAgaWYgKGRlZnMgPSB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKVswXSkge1xuICAgICAgICAgICAgdGhpcy5fZGVmcyA9IFNWRy5hZG9wdChkZWZzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVmcyA9IG5ldyBTVkcuRGVmcygpO1xuICAgICAgICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBkZWZzIG5vZGUgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RhY2tcblxuXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuX2RlZnMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmcztcbiAgICAgIH0sXG4gICAgICAvLyBjdXN0b20gcGFyZW50IG1ldGhvZFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2RlLnBhcmVudE5vZGUgfHwgdGhpcy5ub2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT0gJyNkb2N1bWVudCcpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICB9LFxuICAgICAgLy8gRml4IGZvciBwb3NzaWJsZSBzdWItcGl4ZWwgb2Zmc2V0LiBTZWU6XG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MDg4MTJcbiAgICAgIHNwb2Y6IGZ1bmN0aW9uIHNwb2YoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG5cbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgIHRoaXMuc3R5bGUoJ2xlZnQnLCAtcG9zLmUgJSAxICsgJ3B4Jykuc3R5bGUoJ3RvcCcsIC1wb3MuZiAlIDEgKyAncHgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZXMgdGhlIGRvYyBmcm9tIHRoZSBET01cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQoKSkge1xuICAgICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO1xuICAgICAgICB9IC8vIHJlbW92ZSBkZWZzIHJlZmVyZW5jZVxuXG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2RlZnM7IC8vIGFkZCBiYWNrIHBhcnNlclxuXG4gICAgICAgIGlmIChTVkcucGFyc2VyLmRyYXcgJiYgIVNWRy5wYXJzZXIuZHJhdy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKFNWRy5wYXJzZXIuZHJhdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUocGFyZW50KSB7XG4gICAgICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpOyAvLyBnZXQgcmVmZXJlbmNlIHRvIG5vZGVcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTsgLy8gY2xvbmUgZWxlbWVudCBhbmQgYXNzaWduIG5ldyBpZFxuXG4gICAgICAgIHZhciBjbG9uZSA9IGFzc2lnbk5ld0lkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTsgLy8gaW5zZXJ0IHRoZSBjbG9uZSBpbiB0aGUgZ2l2ZW4gcGFyZW50IG9yIGFmdGVyIG15c2VsZlxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAocGFyZW50Lm5vZGUgfHwgcGFyZW50KS5hcHBlbmRDaGlsZChjbG9uZS5ub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLm5vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vICMjIyBUaGlzIG1vZHVsZSBhZGRzIGJhY2t3YXJkIC8gZm9yd2FyZCBmdW5jdGlvbmFsaXR5IHRvIGVsZW1lbnRzLlxuICAvL1xuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBHZXQgYWxsIHNpYmxpbmdzLCBpbmNsdWRpbmcgbXlzZWxmXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKTtcbiAgICB9LFxuICAgIC8vIEdldCB0aGUgY3VyZW50IHBvc2l0aW9uIHNpYmxpbmdzXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuaW5kZXgodGhpcyk7XG4gICAgfSxcbiAgICAvLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSArIDFdO1xuICAgIH0sXG4gICAgLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbiAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSAtIDFdO1xuICAgIH0sXG4gICAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCkgKyAxLFxuICAgICAgICAgIHAgPSB0aGlzLnBhcmVudCgpOyAvLyBtb3ZlIG5vZGUgb25lIHN0ZXAgZm9yd2FyZFxuXG4gICAgICBwLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkpOyAvLyBtYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXG5cbiAgICAgIGlmIChwIGluc3RhbmNlb2YgU1ZHLkRvYykge1xuICAgICAgICBwLm5vZGUuYXBwZW5kQ2hpbGQocC5kZWZzKCkubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXG4gICAgYmFja3dhcmQ6IGZ1bmN0aW9uIGJhY2t3YXJkKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCk7XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkgLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGZyb250XG4gICAgZnJvbnQ6IGZ1bmN0aW9uIGZyb250KCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnBhcmVudCgpOyAvLyBNb3ZlIG5vZGUgZm9yd2FyZFxuXG4gICAgICBwLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTsgLy8gTWFrZSBzdXJlIGRlZnMgbm9kZSBpcyBhbHdheXMgYXQgdGhlIHRvcFxuXG4gICAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpIHtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHAuZGVmcygpLm5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBpZiAodGhpcy5wb3NpdGlvbigpID4gMCkge1xuICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHRoaXMucGFyZW50KCkuYWRkKGVsZW1lbnQsIGkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBJbnN0ZXJzIGEgZ2l2ZW4gZWxlbWVudCBhZnRlciB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpICsgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBTVkcuTWFzayA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ21hc2snKSk7IC8vIGtlZXAgcmVmZXJlbmNlcyB0byBtYXNrZWQgZWxlbWVudHNcblxuICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBVbm1hc2sgYWxsIG1hc2tlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIC8vIHVubWFzayBhbGwgdGFyZ2V0c1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0c1tpXSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzW2ldLnVubWFzaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdOyAvLyByZW1vdmUgbWFzayBmcm9tIHBhcmVudFxuXG4gICAgICAgIFNWRy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIG1hc2tpbmcgZWxlbWVudFxuICAgICAgbWFzazogZnVuY3Rpb24gbWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLk1hc2soKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIERpc3RyaWJ1dGUgbWFzayB0byBzdmcgZWxlbWVudFxuICAgIG1hc2tXaXRoOiBmdW5jdGlvbiBtYXNrV2l0aChlbGVtZW50KSB7XG4gICAgICAvLyB1c2UgZ2l2ZW4gbWFzayBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICB0aGlzLm1hc2tlciA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuTWFzayA/IGVsZW1lbnQgOiB0aGlzLnBhcmVudCgpLm1hc2soKS5hZGQoZWxlbWVudCk7IC8vIHN0b3JlIHJldmVyZW5jZSBvbiBzZWxmIGluIG1hc2tcblxuICAgICAgdGhpcy5tYXNrZXIudGFyZ2V0cy5wdXNoKHRoaXMpOyAvLyBhcHBseSBtYXNrXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCAndXJsKFwiIycgKyB0aGlzLm1hc2tlci5hdHRyKCdpZCcpICsgJ1wiKScpO1xuICAgIH0sXG4gICAgLy8gVW5tYXNrIGVsZW1lbnRcbiAgICB1bm1hc2s6IGZ1bmN0aW9uIHVubWFzaygpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hc2tlcjtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuQ2xpcFBhdGggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdjbGlwUGF0aCcpKTsgLy8ga2VlcCByZWZlcmVuY2VzIHRvIGNsaXBwZWQgZWxlbWVudHNcblxuICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBVbmNsaXAgYWxsIGNsaXBwZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAvLyB1bmNsaXAgYWxsIHRhcmdldHNcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudGFyZ2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICh0aGlzLnRhcmdldHNbaV0pIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bmNsaXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTsgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XG5cbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgY2xpcHBpbmcgZWxlbWVudFxuICAgICAgY2xpcDogZnVuY3Rpb24gY2xpcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLkNsaXBQYXRoKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vXG5cbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIERpc3RyaWJ1dGUgY2xpcFBhdGggdG8gc3ZnIGVsZW1lbnRcbiAgICBjbGlwV2l0aDogZnVuY3Rpb24gY2xpcFdpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIGNsaXAgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgdGhpcy5jbGlwcGVyID0gZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5DbGlwUGF0aCA/IGVsZW1lbnQgOiB0aGlzLnBhcmVudCgpLmNsaXAoKS5hZGQoZWxlbWVudCk7IC8vIHN0b3JlIHJldmVyZW5jZSBvbiBzZWxmIGluIG1hc2tcblxuICAgICAgdGhpcy5jbGlwcGVyLnRhcmdldHMucHVzaCh0aGlzKTsgLy8gYXBwbHkgbWFza1xuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKFwiIycgKyB0aGlzLmNsaXBwZXIuYXR0cignaWQnKSArICdcIiknKTtcbiAgICB9LFxuICAgIC8vIFVuY2xpcCBlbGVtZW50XG4gICAgdW5jbGlwOiBmdW5jdGlvbiB1bmNsaXAoKSB7XG4gICAgICBkZWxldGUgdGhpcy5jbGlwcGVyO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgbnVsbCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkdyYWRpZW50ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodHlwZSkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUodHlwZSArICdHcmFkaWVudCcpKTsgLy8gc3RvcmUgdHlwZVxuXG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gQWRkIGEgY29sb3Igc3RvcFxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KG9mZnNldCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3RvcCgpKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSk7XG4gICAgICB9LFxuICAgICAgLy8gVXBkYXRlIGdyYWRpZW50XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShibG9jaykge1xuICAgICAgICAvLyByZW1vdmUgYWxsIHN0b3BzXG4gICAgICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKCkge1xuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJztcbiAgICAgIH0sXG4gICAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGwoKTtcbiAgICAgIH0sXG4gICAgICAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG4gICAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgPT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nO1xuICAgICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBncmFkaWVudCBlbGVtZW50IGluIGRlZnNcbiAgICAgIGdyYWRpZW50OiBmdW5jdGlvbiBncmFkaWVudCh0eXBlLCBibG9jaykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZzKCkuZ3JhZGllbnQodHlwZSwgYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIEFkZCBhbmltYXRhYmxlIG1ldGhvZHMgdG8gYm90aCBncmFkaWVudCBhbmQgZnggbW9kdWxlXG5cbiAgU1ZHLmV4dGVuZChTVkcuR3JhZGllbnQsIFNWRy5GWCwge1xuICAgIC8vIEZyb20gcG9zaXRpb25cbiAgICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgsIHkpIHtcbiAgICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgPyB0aGlzLmF0dHIoe1xuICAgICAgICBmeDogbmV3IFNWRy5OdW1iZXIoeCksXG4gICAgICAgIGZ5OiBuZXcgU1ZHLk51bWJlcih5KVxuICAgICAgfSkgOiB0aGlzLmF0dHIoe1xuICAgICAgICB4MTogbmV3IFNWRy5OdW1iZXIoeCksXG4gICAgICAgIHkxOiBuZXcgU1ZHLk51bWJlcih5KVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBUbyBwb3NpdGlvblxuICAgIHRvOiBmdW5jdGlvbiB0byh4LCB5KSB7XG4gICAgICByZXR1cm4gKHRoaXMuX3RhcmdldCB8fCB0aGlzKS50eXBlID09ICdyYWRpYWwnID8gdGhpcy5hdHRyKHtcbiAgICAgICAgY3g6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICBjeTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pIDogdGhpcy5hdHRyKHtcbiAgICAgICAgeDI6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICB5MjogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7IC8vIEJhc2UgZ3JhZGllbnQgZ2VuZXJhdGlvblxuXG4gIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAvLyBkZWZpbmUgZ3JhZGllbnRcbiAgICBncmFkaWVudDogZnVuY3Rpb24gZ3JhZGllbnQodHlwZSwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5TdG9wID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnc3RvcCcsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIGFkZCBjb2xvciBzdG9wc1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobykge1xuICAgICAgICBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgICAgbyA9IHtcbiAgICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgY29sb3I6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gc2V0IGF0dHJpYnV0ZXNcblxuXG4gICAgICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpO1xuICAgICAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKTtcbiAgICAgICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0JywgbmV3IFNWRy5OdW1iZXIoby5vZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBhdHRlcm4gPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwYXR0ZXJuJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwoKSB7XG4gICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICAgICAgfSxcbiAgICAgIC8vIFVwZGF0ZSBwYXR0ZXJuIGJ5IHJlYnVpbGRpbmdcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGJsb2NrKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjb250ZW50XG4gICAgICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsKCk7XG4gICAgICB9LFxuICAgICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICAgICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhID09ICd0cmFuc2Zvcm0nKSBhID0gJ3BhdHRlcm5UcmFuc2Zvcm0nO1xuICAgICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBwYXR0ZXJuIGVsZW1lbnQgaW4gZGVmc1xuICAgICAgcGF0dGVybjogZnVuY3Rpb24gcGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAgIC8vIERlZmluZSBncmFkaWVudFxuICAgIHBhdHRlcm46IGZ1bmN0aW9uIHBhdHRlcm4od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdHRlcm4oKSkudXBkYXRlKGJsb2NrKS5hdHRyKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuU2hhcGUgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudFxuICB9KTtcbiAgU1ZHLkJhcmUgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCwgaW5oZXJpdCkge1xuICAgICAgLy8gY29uc3RydWN0IGVsZW1lbnRcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKGVsZW1lbnQpKTsgLy8gaW5oZXJpdCBjdXN0b20gbWV0aG9kc1xuXG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gaW5oZXJpdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluaGVyaXQucHJvdG90eXBlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IGluaGVyaXQucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcbiAgICAvLyBBZGQgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gSW5zZXJ0IHNvbWUgcGxhaW4gdGV4dFxuICAgICAgd29yZHM6IGZ1bmN0aW9uIHdvcmRzKHRleHQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGNvbnRlbnRzXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO1xuICAgICAgICB9IC8vIGNyZWF0ZSB0ZXh0IG5vZGVcblxuXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xuICAgIC8vIENyZWF0ZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IGRlc2NyaWJlZCBieSBTVkcuanNcbiAgICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KF9lbGVtZW50LCBpbmhlcml0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5CYXJlKF9lbGVtZW50LCBpbmhlcml0KSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlN5bWJvbCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3N5bWJvbCcsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIGNyZWF0ZSBzeW1ib2xcbiAgICAgIHN5bWJvbDogZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TeW1ib2woKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlVzZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3VzZScsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBVc2UgZWxlbWVudCBhcyBhIHJlZmVyZW5jZVxuICAgICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudChfZWxlbWVudDIsIGZpbGUpIHtcbiAgICAgICAgLy8gU2V0IGxpbmVkIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChmaWxlIHx8ICcnKSArICcjJyArIF9lbGVtZW50MiwgU1ZHLnhsaW5rKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxuICAgICAgdXNlOiBmdW5jdGlvbiB1c2UoZWxlbWVudCwgZmlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Vc2UoKSkuZWxlbWVudChlbGVtZW50LCBmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuUmVjdCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3JlY3QnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XG4gICAgICByZWN0OiBmdW5jdGlvbiByZWN0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5DaXJjbGUgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdjaXJjbGUnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGNpcmNsZSBlbGVtZW50LCBiYXNlZCBvbiBlbGxpcHNlXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNpcmNsZSgpKS5yeChuZXcgU1ZHLk51bWJlcihzaXplKS5kaXZpZGUoMikpLm1vdmUoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuQ2lyY2xlLCBTVkcuRlgsIHtcbiAgICAvLyBSYWRpdXMgeCB2YWx1ZVxuICAgIHJ4OiBmdW5jdGlvbiByeChfcngpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCBfcngpO1xuICAgIH0sXG4gICAgLy8gQWxpYXMgcmFkaXVzIHggdmFsdWVcbiAgICByeTogZnVuY3Rpb24gcnkoX3J5KSB7XG4gICAgICByZXR1cm4gdGhpcy5yeChfcnkpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5FbGxpcHNlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnZWxsaXBzZScsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYW4gZWxsaXBzZVxuICAgICAgZWxsaXBzZTogZnVuY3Rpb24gZWxsaXBzZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsbGlwc2UsIFNWRy5SZWN0LCBTVkcuRlgsIHtcbiAgICAvLyBSYWRpdXMgeCB2YWx1ZVxuICAgIHJ4OiBmdW5jdGlvbiByeChfcngyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdyeCcsIF9yeDIpO1xuICAgIH0sXG4gICAgLy8gUmFkaXVzIHkgdmFsdWVcbiAgICByeTogZnVuY3Rpb24gcnkoX3J5Mikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncnknLCBfcnkyKTtcbiAgICB9XG4gIH0pOyAvLyBBZGQgY29tbW9uIG1ldGhvZFxuXG4gIFNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkVsbGlwc2UsIHtcbiAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgeDogZnVuY3Rpb24geChfeDQpIHtcbiAgICAgIHJldHVybiBfeDQgPT0gbnVsbCA/IHRoaXMuY3goKSAtIHRoaXMucngoKSA6IHRoaXMuY3goX3g0ICsgdGhpcy5yeCgpKTtcbiAgICB9LFxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgICB5OiBmdW5jdGlvbiB5KF95NCkge1xuICAgICAgcmV0dXJuIF95NCA9PSBudWxsID8gdGhpcy5jeSgpIC0gdGhpcy5yeSgpIDogdGhpcy5jeShfeTQgKyB0aGlzLnJ5KCkpO1xuICAgIH0sXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICBjeDogZnVuY3Rpb24gY3goeCkge1xuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYXR0cignY3gnKSA6IHRoaXMuYXR0cignY3gnLCB4KTtcbiAgICB9LFxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmF0dHIoJ2N5JykgOiB0aGlzLmF0dHIoJ2N5JywgeSk7XG4gICAgfSxcbiAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgzKSB7XG4gICAgICByZXR1cm4gX3dpZHRoMyA9PSBudWxsID8gdGhpcy5yeCgpICogMiA6IHRoaXMucngobmV3IFNWRy5OdW1iZXIoX3dpZHRoMykuZGl2aWRlKDIpKTtcbiAgICB9LFxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQzKSB7XG4gICAgICByZXR1cm4gX2hlaWdodDMgPT0gbnVsbCA/IHRoaXMucnkoKSAqIDIgOiB0aGlzLnJ5KG5ldyBTVkcuTnVtYmVyKF9oZWlnaHQzKS5kaXZpZGUoMikpO1xuICAgIH0sXG4gICAgLy8gQ3VzdG9tIHNpemUgZnVuY3Rpb25cbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSkucnkobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpLmRpdmlkZSgyKSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkxpbmUgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdsaW5lJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEdldCBhcnJheVxuICAgICAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KFtbdGhpcy5hdHRyKCd4MScpLCB0aGlzLmF0dHIoJ3kxJyldLCBbdGhpcy5hdHRyKCd4MicpLCB0aGlzLmF0dHIoJ3kyJyldXSk7XG4gICAgICB9LFxuICAgICAgLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXG4gICAgICBwbG90OiBmdW5jdGlvbiBwbG90KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGlmICh4MSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgeDEgPSB7XG4gICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgxID0gbmV3IFNWRy5Qb2ludEFycmF5KHgxKS50b0xpbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoeDEpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KS50b0xpbmUoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgbGluZSBlbGVtZW50XG4gICAgICBsaW5lOiBmdW5jdGlvbiBsaW5lKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgICAvLyB4MSBpcyBub3QgbmVjZXNzYXJpbHkgYSBudW1iZXIsIGl0IGNhbiBhbHNvIGJlIGFuIGFycmF5LCBhIHN0cmluZyBhbmQgYSBTVkcuUG9pbnRBcnJheVxuICAgICAgICByZXR1cm4gU1ZHLkxpbmUucHJvdG90eXBlLnBsb3QuYXBwbHkodGhpcy5wdXQobmV3IFNWRy5MaW5lKCkpLCB4MSAhPSBudWxsID8gW3gxLCB5MSwgeDIsIHkyXSA6IFswLCAwLCAwLCAwXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBvbHlsaW5lID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAncG9seWxpbmUnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5bGluZSBlbGVtZW50XG4gICAgICBwb2x5bGluZTogZnVuY3Rpb24gcG9seWxpbmUocCkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUG9seWxpbmUoKSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuUG9seWdvbiA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3BvbHlnb24nLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcbiAgICAgIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24ocCkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUG9seWdvbigpKS5wbG90KHAgfHwgbmV3IFNWRy5Qb2ludEFycmF5KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIEFkZCBwb2x5Z29uLXNwZWNpZmljIGZ1bmN0aW9uc1xuXG4gIFNWRy5leHRlbmQoU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xuICAgIC8vIEdldCBhcnJheVxuICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkodGhpcy5hdHRyKCdwb2ludHMnKSkpO1xuICAgIH0sXG4gICAgLy8gUGxvdCBuZXcgcGF0aFxuICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QocCkge1xuICAgICAgcmV0dXJuIHAgPT0gbnVsbCA/IHRoaXMuYXJyYXkoKSA6IHRoaXMuY2xlYXIoKS5hdHRyKCdwb2ludHMnLCB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwIDogdGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkocCkpO1xuICAgIH0sXG4gICAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSk7XG4gICAgfSxcbiAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSk7XG4gICAgfVxuICB9KTsgLy8gdW5pZnkgYWxsIHBvaW50IHRvIHBvaW50IGVsZW1lbnRzXG5cbiAgU1ZHLmV4dGVuZChTVkcuTGluZSwgU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xuICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgICBtb3JwaEFycmF5OiBTVkcuUG9pbnRBcnJheSxcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAgIHg6IGZ1bmN0aW9uIHgoX3g1KSB7XG4gICAgICByZXR1cm4gX3g1ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKF94NSwgdGhpcy5iYm94KCkueSk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xuICAgIHk6IGZ1bmN0aW9uIHkoX3k1KSB7XG4gICAgICByZXR1cm4gX3k1ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIF95NSk7XG4gICAgfSxcbiAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGg0KSB7XG4gICAgICB2YXIgYiA9IHRoaXMuYmJveCgpO1xuICAgICAgcmV0dXJuIF93aWR0aDQgPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUoX3dpZHRoNCwgYi5oZWlnaHQpO1xuICAgIH0sXG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoX2hlaWdodDQpIHtcbiAgICAgIHZhciBiID0gdGhpcy5iYm94KCk7XG4gICAgICByZXR1cm4gX2hlaWdodDQgPT0gbnVsbCA/IGIuaGVpZ2h0IDogdGhpcy5zaXplKGIud2lkdGgsIF9oZWlnaHQ0KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuUGF0aCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3BhdGgnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gRGVmaW5lIG1vcnBoYWJsZSBhcnJheVxuICAgICAgbW9ycGhBcnJheTogU1ZHLlBhdGhBcnJheSxcbiAgICAgIC8vIEdldCBhcnJheVxuICAgICAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkgfHwgKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkodGhpcy5hdHRyKCdkJykpKTtcbiAgICAgIH0sXG4gICAgICAvLyBQbG90IG5ldyBwYXRoXG4gICAgICBwbG90OiBmdW5jdGlvbiBwbG90KGQpIHtcbiAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCA/IHRoaXMuYXJyYXkoKSA6IHRoaXMuY2xlYXIoKS5hdHRyKCdkJywgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IHRoaXMuX2FycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkoZCkpO1xuICAgICAgfSxcbiAgICAgIC8vIENsZWFyIGFycmF5IGNhY2hlXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hcnJheTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcbiAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94Nikge1xuICAgICAgICByZXR1cm4gX3g2ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKF94NiwgdGhpcy5iYm94KCkueSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgICAgIHk6IGZ1bmN0aW9uIHkoX3k2KSB7XG4gICAgICAgIHJldHVybiBfeTYgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgX3k2KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gICAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoNSkge1xuICAgICAgICByZXR1cm4gX3dpZHRoNSA9PSBudWxsID8gdGhpcy5iYm94KCkud2lkdGggOiB0aGlzLnNpemUoX3dpZHRoNSwgdGhpcy5iYm94KCkuaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQ1KSB7XG4gICAgICAgIHJldHVybiBfaGVpZ2h0NSA9PSBudWxsID8gdGhpcy5iYm94KCkuaGVpZ2h0IDogdGhpcy5zaXplKHRoaXMuYmJveCgpLndpZHRoLCBfaGVpZ2h0NSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwYXRoIGVsZW1lbnRcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZCkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUGF0aCgpKS5wbG90KGQgfHwgbmV3IFNWRy5QYXRoQXJyYXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLkltYWdlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnaW1hZ2UnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gKHJlKWxvYWQgaW1hZ2VcbiAgICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsKSB7XG4gICAgICAgIGlmICghdXJsKSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaW1nID0gbmV3IHdpbmRvdy5JbWFnZSgpOyAvLyBwcmVsb2FkIGltYWdlXG5cbiAgICAgICAgU1ZHLm9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgU1ZHLm9mZihpbWcpO1xuICAgICAgICAgIHZhciBwID0gc2VsZi5wYXJlbnQoU1ZHLlBhdHRlcm4pO1xuICAgICAgICAgIGlmIChwID09PSBudWxsKSByZXR1cm47IC8vIGVuc3VyZSBpbWFnZSBzaXplXG5cbiAgICAgICAgICBpZiAoc2VsZi53aWR0aCgpID09IDAgJiYgc2VsZi5oZWlnaHQoKSA9PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNpemUoaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgICAgICB9IC8vIGVuc3VyZSBwYXR0ZXJuIHNpemUgaWYgbm90IHNldFxuXG5cbiAgICAgICAgICBpZiAocCAmJiBwLndpZHRoKCkgPT0gMCAmJiBwLmhlaWdodCgpID09IDApIHtcbiAgICAgICAgICAgIHAuc2l6ZShzZWxmLndpZHRoKCksIHNlbGYuaGVpZ2h0KCkpO1xuICAgICAgICAgIH0gLy8gY2FsbGJhY2tcblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9sb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGYuX2xvYWRlZC5jYWxsKHNlbGYsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0LFxuICAgICAgICAgICAgICByYXRpbzogaW1nLndpZHRoIC8gaW1nLmhlaWdodCxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFNWRy5vbihpbWcsICdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgU1ZHLm9mZihpbWcpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2VsZi5fZXJyb3IuY2FsbChzZWxmLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgaW1nLnNyYyA9IHRoaXMuc3JjID0gdXJsLCBTVkcueGxpbmspO1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBsb2FkZWQgY2FsbGJhY2tcbiAgICAgIGxvYWRlZDogZnVuY3Rpb24gbG9hZGVkKF9sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gX2xvYWRlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgICAgICB0aGlzLl9lcnJvciA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gY3JlYXRlIGltYWdlIGVsZW1lbnQsIGxvYWQgaW1hZ2UgYW5kIHNldCBpdHMgc2l6ZVxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uIGltYWdlKHNvdXJjZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5JbWFnZSgpKS5sb2FkKHNvdXJjZSkuc2l6ZSh3aWR0aCB8fCAwLCBoZWlnaHQgfHwgd2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRleHQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCd0ZXh0JykpO1xuICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKDEuMyk7IC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcblxuICAgICAgdGhpcy5fcmVidWlsZCA9IHRydWU7IC8vIGVuYWJsZSBhdXRvbWF0aWMgdXBkYXRpbmcgb2YgZHkgdmFsdWVzXG5cbiAgICAgIHRoaXMuX2J1aWxkID0gZmFsc2U7IC8vIGRpc2FibGUgYnVpbGQgbW9kZSBmb3IgYWRkaW5nIG11bHRpcGxlIGxpbmVzXG4gICAgICAvLyBzZXQgZGVmYXVsdCBmb250XG5cbiAgICAgIHRoaXMuYXR0cignZm9udC1mYW1pbHknLCBTVkcuZGVmYXVsdHMuYXR0cnNbJ2ZvbnQtZmFtaWx5J10pO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94Nykge1xuICAgICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICAgIGlmIChfeDcgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCBfeDcpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgICAgIHk6IGZ1bmN0aW9uIHkoX3k3KSB7XG4gICAgICAgIHZhciBveSA9IHRoaXMuYXR0cigneScpLFxuICAgICAgICAgICAgbyA9IHR5cGVvZiBveSA9PT0gJ251bWJlcicgPyBveSAtIHRoaXMuYmJveCgpLnkgOiAwOyAvLyBhY3QgYXMgZ2V0dGVyXG5cbiAgICAgICAgaWYgKF95NyA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBveSA9PT0gJ251bWJlcicgPyBveSAtIG8gOiBveTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0eXBlb2YgX3k3LnZhbHVlT2YoKSA9PT0gJ251bWJlcicgPyBfeTcgKyBvIDogX3k3KTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHgtYXhpc1xuICAgICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN4IDogdGhpcy54KHggLSB0aGlzLmJib3goKS53aWR0aCAvIDIpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXG4gICAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkuY3kgOiB0aGlzLnkoeSAtIHRoaXMuYmJveCgpLmhlaWdodCAvIDIpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCB0aGUgdGV4dCBjb250ZW50XG4gICAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBfdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgX3RleHQgPSAnJztcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgLy8gYWRkIG5ld2xpbmUgaWYgaXRzIG5vdCB0aGUgZmlyc3QgY2hpbGQgYW5kIG5ld0xpbmVkIGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICBpZiAoaSAhPSAwICYmIGNoaWxkcmVuW2ldLm5vZGVUeXBlICE9IDMgJiYgU1ZHLmFkb3B0KGNoaWxkcmVuW2ldKS5kb20ubmV3TGluZWQgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfdGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH0gLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXG5cblxuICAgICAgICAgICAgX3RleHQgKz0gY2hpbGRyZW5baV0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgICB9IC8vIHJlbW92ZSBleGlzdGluZyBjb250ZW50XG5cblxuICAgICAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIGNhbGwgYmxvY2tcbiAgICAgICAgICBfdGV4dC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xuICAgICAgICAgIF90ZXh0ID0gX3RleHQuc3BsaXQoJ1xcbicpOyAvLyBidWlsZCBuZXcgbGluZXNcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IF90ZXh0Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudHNwYW4oX3RleHRbaV0pLm5ld0xpbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZGlzYWJsZSBidWlsZCBtb2RlIGFuZCByZWJ1aWxkIGxpbmVzXG5cblxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkucmVidWlsZCgpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBmb250IHNpemVcbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZm9udC1zaXplJywgX3NpemUpLnJlYnVpbGQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgLyBnZXQgbGVhZGluZ1xuICAgICAgbGVhZGluZzogZnVuY3Rpb24gbGVhZGluZyh2YWx1ZSkge1xuICAgICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmxlYWRpbmc7XG4gICAgICAgIH0gLy8gYWN0IGFzIHNldHRlclxuXG5cbiAgICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVidWlsZCgpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBhbGwgdGhlIGZpcnN0IGxldmVsIGxpbmVzXG4gICAgICBsaW5lczogZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICAgIHZhciBub2RlID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGU7IC8vIGZpbHRlciB0c3BhbnMgYW5kIG1hcCB0aGVtIHRvIFNWRy5qcyBpbnN0YW5jZXNcblxuICAgICAgICB2YXIgbGluZXMgPSBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyhub2RlLmNoaWxkTm9kZXMpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KGVsKTtcbiAgICAgICAgfSk7IC8vIHJldHVybiBhbiBpbnN0YW5jZSBvZiBTVkcuc2V0XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KGxpbmVzKTtcbiAgICAgIH0sXG4gICAgICAvLyBSZWJ1aWxkIGFwcGVhcmFuY2UgdHlwZVxuICAgICAgcmVidWlsZDogZnVuY3Rpb24gcmVidWlsZChfcmVidWlsZCkge1xuICAgICAgICAvLyBzdG9yZSBuZXcgcmVidWlsZCBmbGFnIGlmIGdpdmVuXG4gICAgICAgIGlmICh0eXBlb2YgX3JlYnVpbGQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMuX3JlYnVpbGQgPSBfcmVidWlsZDtcbiAgICAgICAgfSAvLyBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzXG5cblxuICAgICAgICBpZiAodGhpcy5fcmVidWlsZCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgICAgZHkgPSB0aGlzLmRvbS5sZWFkaW5nICogbmV3IFNWRy5OdW1iZXIodGhpcy5hdHRyKCdmb250LXNpemUnKSk7XG4gICAgICAgICAgdGhpcy5saW5lcygpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB7XG4gICAgICAgICAgICAgIGlmICghc2VsZi50ZXh0UGF0aCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyKCd4Jywgc2VsZi5hdHRyKCd4JykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMudGV4dCgpID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ICs9IGR5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cignZHknLCBkeSArIGJsYW5rTGluZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZmlyZSgncmVidWlsZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXG4gICAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoX2J1aWxkKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkID0gISFfYnVpbGQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIG92ZXJ3cml0ZSBtZXRob2QgZnJvbSBwYXJlbnQgdG8gc2V0IGRhdGEgcHJvcGVybHlcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEobykge1xuICAgICAgICB0aGlzLmRvbSA9IG87XG4gICAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcihvLmxlYWRpbmcgfHwgMS4zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIHRleHQgZWxlbWVudFxuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCgpKS50ZXh0KF90ZXh0Mik7XG4gICAgICB9LFxuICAgICAgLy8gQ3JlYXRlIHBsYWluIHRleHQgZWxlbWVudFxuICAgICAgcGxhaW46IGZ1bmN0aW9uIHBsYWluKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCgpKS5wbGFpbih0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuVHNwYW4gPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICd0c3BhbicsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBTZXQgdGV4dCBjb250ZW50XG4gICAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KF90ZXh0Mykge1xuICAgICAgICBpZiAoX3RleHQzID09IG51bGwpIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKTtcbiAgICAgICAgdHlwZW9mIF90ZXh0MyA9PT0gJ2Z1bmN0aW9uJyA/IF90ZXh0My5jYWxsKHRoaXMsIHRoaXMpIDogdGhpcy5wbGFpbihfdGV4dDMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBTaG9ydGN1dCBkeFxuICAgICAgZHg6IGZ1bmN0aW9uIGR4KF9keCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIF9keCk7XG4gICAgICB9LFxuICAgICAgLy8gU2hvcnRjdXQgZHlcbiAgICAgIGR5OiBmdW5jdGlvbiBkeShfZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHknLCBfZHkpO1xuICAgICAgfSxcbiAgICAgIC8vIENyZWF0ZSBuZXcgbGluZVxuICAgICAgbmV3TGluZTogZnVuY3Rpb24gbmV3TGluZSgpIHtcbiAgICAgICAgLy8gZmV0Y2ggdGV4dCBwYXJlbnRcbiAgICAgICAgdmFyIHQgPSB0aGlzLnBhcmVudChTVkcuVGV4dCk7IC8vIG1hcmsgbmV3IGxpbmVcblxuICAgICAgICB0aGlzLmRvbS5uZXdMaW5lZCA9IHRydWU7IC8vIGFwcGx5IG5ldyBoecKhblxuXG4gICAgICAgIHJldHVybiB0aGlzLmR5KHQuZG9tLmxlYWRpbmcgKiB0LmF0dHIoJ2ZvbnQtc2l6ZScpKS5hdHRyKCd4JywgdC54KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLlRleHQsIFNWRy5Uc3Bhbiwge1xuICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcbiAgICBwbGFpbjogZnVuY3Rpb24gcGxhaW4odGV4dCkge1xuICAgICAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxuICAgICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9IC8vIGNyZWF0ZSB0ZXh0IG5vZGVcblxuXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSB0c3BhblxuICAgIHRzcGFuOiBmdW5jdGlvbiB0c3Bhbih0ZXh0KSB7XG4gICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlLFxuICAgICAgICAgIHRzcGFuID0gbmV3IFNWRy5Uc3BhbigpOyAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG5cbiAgICAgIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSAvLyBhZGQgbmV3IHRzcGFuXG5cblxuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0c3Bhbi5ub2RlKTtcbiAgICAgIHJldHVybiB0c3Bhbi50ZXh0KHRleHQpO1xuICAgIH0sXG4gICAgLy8gQ2xlYXIgYWxsIGxpbmVzXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZTsgLy8gcmVtb3ZlIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG5cbiAgICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxuICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuVGV4dFBhdGggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICd0ZXh0UGF0aCcsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlBhcmVudCxcbiAgICAvLyBEZWZpbmUgcGFyZW50IGNsYXNzXG4gICAgcGFyZW50OiBTVkcuVGV4dCxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgbW9ycGhBcnJheTogU1ZHLlBhdGhBcnJheSxcbiAgICAgIC8vIENyZWF0ZSBwYXRoIGZvciB0ZXh0IHRvIHJ1biBvblxuICAgICAgcGF0aDogZnVuY3Rpb24gcGF0aChkKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB0ZXh0UGF0aCBlbGVtZW50XG4gICAgICAgIHZhciBwYXRoID0gbmV3IFNWRy5UZXh0UGF0aCgpLFxuICAgICAgICAgICAgdHJhY2sgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXRoKGQpOyAvLyBtb3ZlIGxpbmVzIHRvIHRleHRwYXRoXG5cbiAgICAgICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBwYXRoLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IC8vIGFkZCB0ZXh0UGF0aCBlbGVtZW50IGFzIGNoaWxkIG5vZGVcblxuXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChwYXRoLm5vZGUpOyAvLyBsaW5rIHRleHRQYXRoIHRvIHBhdGggYW5kIGFkZCBjb250ZW50XG5cbiAgICAgICAgcGF0aC5hdHRyKCdocmVmJywgJyMnICsgdHJhY2ssIFNWRy54bGluayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHJldHVybiB0aGUgYXJyYXkgb2YgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxuICAgICAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KCkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIC8vIFBsb3QgcGF0aCBpZiBhbnlcbiAgICAgIHBsb3Q6IGZ1bmN0aW9uIHBsb3QoZCkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKCksXG4gICAgICAgICAgICBwYXRoQXJyYXkgPSBudWxsO1xuXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHBhdGhBcnJheSA9IHRyYWNrLnBsb3QoZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZCA9PSBudWxsID8gcGF0aEFycmF5IDogdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxuICAgICAgdHJhY2s6IGZ1bmN0aW9uIHRyYWNrKCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMudGV4dFBhdGgoKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHJldHVybiBwYXRoLnJlZmVyZW5jZSgnaHJlZicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZFxuICAgICAgdGV4dFBhdGg6IGZ1bmN0aW9uIHRleHRQYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmZpcnN0Q2hpbGQgJiYgdGhpcy5ub2RlLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT0gJ3RleHRQYXRoJykge1xuICAgICAgICAgIHJldHVybiBTVkcuYWRvcHQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLk5lc3RlZCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ3N2ZycpKTtcbiAgICAgIHRoaXMuc3R5bGUoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBuZXN0ZWQgc3ZnIGRvY3VtZW50XG4gICAgICBuZXN0ZWQ6IGZ1bmN0aW9uIG5lc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTmVzdGVkKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5BID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnYScsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gTGluayB1cmxcbiAgICAgIHRvOiBmdW5jdGlvbiB0byh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIHVybCwgU1ZHLnhsaW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBMaW5rIHNob3cgYXR0cmlidXRlXG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdzaG93JywgdGFyZ2V0LCBTVkcueGxpbmspO1xuICAgICAgfSxcbiAgICAgIC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxuICAgICAgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoX3RhcmdldDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndGFyZ2V0JywgX3RhcmdldDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XG4gICAgICBsaW5rOiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5BKCkpLnRvKHVybCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XG4gICAgbGlua1RvOiBmdW5jdGlvbiBsaW5rVG8odXJsKSB7XG4gICAgICB2YXIgbGluayA9IG5ldyBTVkcuQSgpO1xuXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsudG8odXJsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkucHV0KGxpbmspLnB1dCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuTWFya2VyID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnbWFya2VyJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKF93aWR0aDYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VyV2lkdGgnLCBfd2lkdGg2KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQ2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlckhlaWdodCcsIF9oZWlnaHQ2KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgbWFya2VyIHJlZlggYW5kIHJlZllcbiAgICAgIHJlZjogZnVuY3Rpb24gcmVmKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigncmVmWCcsIHgpLmF0dHIoJ3JlZlknLCB5KTtcbiAgICAgIH0sXG4gICAgICAvLyBVcGRhdGUgbWFya2VyXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShibG9jaykge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGNvbnRlbnRcbiAgICAgICAgdGhpcy5jbGVhcigpOyAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG5cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSc7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgbWFya2VyOiBmdW5jdGlvbiBtYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtlciBlbGVtZW50IGluIGRlZnNcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xuICAgIC8vIENyZWF0ZSBtYXJrZXJcbiAgICBtYXJrZXI6IGZ1bmN0aW9uIG1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgdmlld2JveCB0byBtYXRjaCB0aGUgd2lkdGggYW5kIGhlaWdodCwgc2V0IHJlZiB0byBjeCBhbmQgY3kgYW5kIHNldCBvcmllbnQgdG8gYXV0b1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTWFya2VyKCkpLnNpemUod2lkdGgsIGhlaWdodCkucmVmKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMikudmlld2JveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5hdHRyKCdvcmllbnQnLCAnYXV0bycpLnVwZGF0ZShibG9jayk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuTGluZSwgU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwgU1ZHLlBhdGgsIHtcbiAgICAvLyBDcmVhdGUgYW5kIGF0dGFjaCBtYXJrZXJzXG4gICAgbWFya2VyOiBmdW5jdGlvbiBtYXJrZXIoX21hcmtlciwgd2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIHZhciBhdHRyID0gWydtYXJrZXInXTsgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcblxuICAgICAgaWYgKF9tYXJrZXIgIT0gJ2FsbCcpIGF0dHIucHVzaChfbWFya2VyKTtcbiAgICAgIGF0dHIgPSBhdHRyLmpvaW4oJy0nKTsgLy8gU2V0IG1hcmtlciBhdHRyaWJ1dGVcblxuICAgICAgX21hcmtlciA9IGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFNWRy5NYXJrZXIgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmRvYygpLm1hcmtlcih3aWR0aCwgaGVpZ2h0LCBibG9jayk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKGF0dHIsIF9tYXJrZXIpO1xuICAgIH1cbiAgfSk7IC8vIERlZmluZSBsaXN0IG9mIGF2YWlsYWJsZSBhdHRyaWJ1dGVzIGZvciBzdHJva2UgYW5kIGZpbGxcblxuICB2YXIgc3VnYXIgPSB7XG4gICAgc3Ryb2tlOiBbJ2NvbG9yJywgJ3dpZHRoJywgJ29wYWNpdHknLCAnbGluZWNhcCcsICdsaW5lam9pbicsICdtaXRlcmxpbWl0JywgJ2Rhc2hhcnJheScsICdkYXNob2Zmc2V0J10sXG4gICAgZmlsbDogWydjb2xvcicsICdvcGFjaXR5JywgJ3J1bGUnXSxcbiAgICBwcmVmaXg6IGZ1bmN0aW9uIHByZWZpeCh0LCBhKSB7XG4gICAgICByZXR1cm4gYSA9PSAnY29sb3InID8gdCA6IHQgKyAnLScgKyBhO1xuICAgIH0gLy8gQWRkIHN1Z2FyIGZvciBmaWxsIGFuZCBzdHJva2VcblxuICB9O1xuICBbJ2ZpbGwnLCAnc3Ryb2tlJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHZhciBpLFxuICAgICAgICBleHRlbnNpb24gPSB7fTtcblxuICAgIGV4dGVuc2lvblttXSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8IFNWRy5Db2xvci5pc1JnYihvKSB8fCBvICYmIHR5cGVvZiBvLmZpbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hdHRyKG0sIG8pO1xuICAgICAgfSBlbHNlIC8vIHNldCBhbGwgYXR0cmlidXRlcyBmcm9tIHN1Z2FyLmZpbGwgYW5kIHN1Z2FyLnN0cm9rZSBsaXN0XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKGkgPSBzdWdhclttXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKG9bc3VnYXJbbV1baV1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5hdHRyKHN1Z2FyLnByZWZpeChtLCBzdWdhclttXVtpXSksIG9bc3VnYXJbbV1baV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIFNWRy5GWCwgZXh0ZW5zaW9uKTtcbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIFNWRy5GWCwge1xuICAgIC8vIE1hcCByb3RhdGlvbiB0byB0cmFuc2Zvcm1cbiAgICByb3RhdGU6IGZ1bmN0aW9uIHJvdGF0ZShkLCBjeCwgY3kpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIHJvdGF0aW9uOiBkLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgc2tldyB0byB0cmFuc2Zvcm1cbiAgICBza2V3OiBmdW5jdGlvbiBza2V3KHgsIHksIGN4LCBjeSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09IDMgPyB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIHNrZXc6IHgsXG4gICAgICAgIGN4OiB5LFxuICAgICAgICBjeTogY3hcbiAgICAgIH0pIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICBza2V3WDogeCxcbiAgICAgICAgc2tld1k6IHksXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE1hcCBzY2FsZSB0byB0cmFuc2Zvcm1cbiAgICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoeCwgeSwgY3gsIGN5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PSAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2NhbGU6IHgsXG4gICAgICAgIGN4OiB5LFxuICAgICAgICBjeTogY3hcbiAgICAgIH0pIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICBzY2FsZVg6IHgsXG4gICAgICAgIHNjYWxlWTogeSxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gTWFwIHRyYW5zbGF0ZSB0byB0cmFuc2Zvcm1cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxuICAgIGZsaXA6IGZ1bmN0aW9uIGZsaXAoYSwgbykge1xuICAgICAgbyA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGEgOiBvO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgZmxpcDogYSB8fCAnYm90aCcsXG4gICAgICAgIG9mZnNldDogb1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgbWF0cml4IHRvIHRyYW5zZm9ybVxuICAgIG1hdHJpeDogZnVuY3Rpb24gbWF0cml4KG0pIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG5ldyBTVkcuTWF0cml4KGFyZ3VtZW50cy5sZW5ndGggPT0gNiA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSA6IG0pKTtcbiAgICB9LFxuICAgIC8vIE9wYWNpdHlcbiAgICBvcGFjaXR5OiBmdW5jdGlvbiBvcGFjaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdvcGFjaXR5JywgdmFsdWUpO1xuICAgIH0sXG4gICAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHggYXhpc1xuICAgIGR4OiBmdW5jdGlvbiBkeCh4KSB7XG4gICAgICByZXR1cm4gdGhpcy54KG5ldyBTVkcuTnVtYmVyKHgpLnBsdXModGhpcyBpbnN0YW5jZW9mIFNWRy5GWCA/IDAgOiB0aGlzLngoKSksIHRydWUpO1xuICAgIH0sXG4gICAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xuICAgIGR5OiBmdW5jdGlvbiBkeSh5KSB7XG4gICAgICByZXR1cm4gdGhpcy55KG5ldyBTVkcuTnVtYmVyKHkpLnBsdXModGhpcyBpbnN0YW5jZW9mIFNWRy5GWCA/IDAgOiB0aGlzLnkoKSksIHRydWUpO1xuICAgIH0sXG4gICAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHggYW5kIHkgYXhlc1xuICAgIGRtb3ZlOiBmdW5jdGlvbiBkbW92ZSh4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy5keCh4KS5keSh5KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5SZWN0LCBTVkcuRWxsaXBzZSwgU1ZHLkNpcmNsZSwgU1ZHLkdyYWRpZW50LCBTVkcuRlgsIHtcbiAgICAvLyBBZGQgeCBhbmQgeSByYWRpdXNcbiAgICByYWRpdXM6IGZ1bmN0aW9uIHJhZGl1cyh4LCB5KSB7XG4gICAgICB2YXIgdHlwZSA9ICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZTtcbiAgICAgIHJldHVybiB0eXBlID09ICdyYWRpYWwnIHx8IHR5cGUgPT0gJ2NpcmNsZScgPyB0aGlzLmF0dHIoJ3InLCBuZXcgU1ZHLk51bWJlcih4KSkgOiB0aGlzLnJ4KHgpLnJ5KHkgPT0gbnVsbCA/IHggOiB5KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5QYXRoLCB7XG4gICAgLy8gR2V0IHBhdGggbGVuZ3RoXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgfSxcbiAgICAvLyBHZXQgcG9pbnQgYXQgbGVuZ3RoXG4gICAgcG9pbnRBdDogZnVuY3Rpb24gcG9pbnRBdChsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudCwgU1ZHLlRleHQsIFNWRy5Uc3BhbiwgU1ZHLkZYLCB7XG4gICAgLy8gU2V0IGZvbnRcbiAgICBmb250OiBmdW5jdGlvbiBmb250KGEsIHYpIHtcbiAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHYgaW4gYSkge1xuICAgICAgICAgIHRoaXMuZm9udCh2LCBhW3ZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYSA9PSAnbGVhZGluZycgPyB0aGlzLmxlYWRpbmcodikgOiBhID09ICdhbmNob3InID8gdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHYpIDogYSA9PSAnc2l6ZScgfHwgYSA9PSAnZmFtaWx5JyB8fCBhID09ICd3ZWlnaHQnIHx8IGEgPT0gJ3N0cmV0Y2gnIHx8IGEgPT0gJ3ZhcmlhbnQnIHx8IGEgPT0gJ3N0eWxlJyA/IHRoaXMuYXR0cignZm9udC0nICsgYSwgdikgOiB0aGlzLmF0dHIoYSwgdik7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlNldCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShtZW1iZXJzKSB7XG4gICAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICAgICAgQXJyYXkuaXNBcnJheShtZW1iZXJzKSA/IHRoaXMubWVtYmVycyA9IG1lbWJlcnMgOiB0aGlzLmNsZWFyKCk7XG4gICAgfSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gc2V0XG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpbCxcbiAgICAgICAgICAgIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIHRoaXMubWVtYmVycy5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gc2V0XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleChlbGVtZW50KTsgLy8gcmVtb3ZlIGdpdmVuIGNoaWxkXG5cbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgIHRoaXMubWVtYmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG1lbWJlcnNcbiAgICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goYmxvY2spIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBibG9jay5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIFtpLCB0aGlzLm1lbWJlcnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlc3RvcmUgdG8gZGVmYXVsdHNcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzdG9yZVxuICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgYSBzZXRcbiAgICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHByZXNlbnQgaW4gc2V0XG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDA7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dW5zIGluZGV4IG9mIGdpdmVuIGVsZW1lbnQgaW4gc2V0XG4gICAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IG1lbWJlciBhdCBnaXZlbiBpbmRleFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzW2ldO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBmaXJzdCBtZW1iZXJcbiAgICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBsYXN0IG1lbWJlclxuICAgICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubWVtYmVycy5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG4gICAgICAvLyBEZWZhdWx0IHZhbHVlXG4gICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIGFsbCBtZW1iZXJzIGluY2x1ZGVkIG9yIGVtcHR5IGJveCBpZiBzZXQgaGFzIG5vIGl0ZW1zXG4gICAgICBiYm94OiBmdW5jdGlvbiBiYm94KCkge1xuICAgICAgICAvLyByZXR1cm4gYW4gZW1wdHkgYm94IG9mIHRoZXJlIGFyZSBubyBtZW1iZXJzXG4gICAgICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5SQm94KCk7XG4gICAgICAgIH0gLy8gZ2V0IHRoZSBmaXJzdCByYm94IGFuZCB1cGRhdGUgdGhlIHRhcmdldCBiYm94XG5cblxuICAgICAgICB2YXIgcmJveCA9IHRoaXMubWVtYmVyc1swXS5yYm94KHRoaXMubWVtYmVyc1swXS5kb2MoKSk7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdXNlciByYm94IGZvciBjb3JyZWN0IHBvc2l0aW9uIGFuZCB2aXN1YWwgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICByYm94ID0gcmJveC5tZXJnZSh0aGlzLnJib3godGhpcy5kb2MoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJib3g7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobWVtYmVycykge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5TZXQobWVtYmVycyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLkZYLlNldCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNldCkge1xuICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIHNldFxuICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICB9KTsgLy8gQWxpYXMgbWV0aG9kc1xuXG4gIFNWRy5TZXQuaW5oZXJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSxcbiAgICAgICAgbWV0aG9kcyA9IFtdOyAvLyBnYXRoZXIgc2hhcGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgbSBpbiBTVkcuU2hhcGUucHJvdG90eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIFNWRy5TaGFwZS5wcm90b3R5cGVbbV0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5TZXQucHJvdG90eXBlW21dICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9IC8vIGFwcGx5IHNoYXBlIGFsaWFzc2VzXG5cblxuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBTVkcuU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1lbWJlcnNbaV0gJiYgdHlwZW9mIHRoaXMubWVtYmVyc1tpXVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXS5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZCA9PSAnYW5pbWF0ZScgPyB0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWC5TZXQodGhpcykpIDogdGhpcztcbiAgICAgIH07XG4gICAgfSk7IC8vIGNsZWFyIG1ldGhvZHMgZm9yIHRoZSBuZXh0IHJvdW5kXG5cbiAgICBtZXRob2RzID0gW107IC8vIGdhdGhlciBmeCBtZXRob2RzXG5cbiAgICBmb3IgKHZhciBtIGluIFNWRy5GWC5wcm90b3R5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgU1ZHLkZYLnByb3RvdHlwZVttXSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU1ZHLkZYLlNldC5wcm90b3R5cGVbbV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWV0aG9kcy5wdXNoKG0pO1xuICAgICAgfVxuICAgIH0gLy8gYXBwbHkgZnggYWxpYXNzZXNcblxuXG4gICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIFNWRy5GWC5TZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMuc2V0Lm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2V0Lm1lbWJlcnNbaV0uZnhbbWV0aG9kXS5hcHBseSh0aGlzLnNldC5tZW1iZXJzW2ldLmZ4LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBTdG9yZSBkYXRhIHZhbHVlcyBvbiBzdmcgbm9kZXNcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKGEsIHYsIHIpIHtcbiAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHYgaW4gYSkge1xuICAgICAgICAgIHRoaXMuZGF0YSh2LCBhW3ZdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYXR0cignZGF0YS0nICsgYSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZGF0YS0nICsgYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cignZGF0YS0nICsgYSwgdiA9PT0gbnVsbCA/IG51bGwgOiByID09PSB0cnVlIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicgPyB2IDogSlNPTi5zdHJpbmdpZnkodikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gUmVtZW1iZXIgYXJiaXRyYXJ5IGRhdGFcbiAgICByZW1lbWJlcjogZnVuY3Rpb24gcmVtZW1iZXIoaywgdikge1xuICAgICAgLy8gcmVtZW1iZXIgZXZlcnkgaXRlbSBpbiBhbiBvYmplY3QgaW5kaXZpZHVhbGx5XG4gICAgICBpZiAoX3R5cGVvZihhcmd1bWVudHNbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciB2IGluIGspIHtcbiAgICAgICAgICB0aGlzLnJlbWVtYmVyKHYsIGtbdl0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIHJldHJpZXZlIG1lbW9yeVxuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWVtb3J5KClba107XG4gICAgICAgIH0gLy8gc3RvcmUgbWVtb3J5XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnkoKVtrXSA9IHY7XG4gICAgICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEVyYXNlIGEgZ2l2ZW4gbWVtb3J5XG4gICAgZm9yZ2V0OiBmdW5jdGlvbiBmb3JnZXQoKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRoaXMuX21lbW9yeSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBJbml0aWFsaXplIG9yIHJldHVybiBsb2NhbCBtZW1vcnkgb2JqZWN0XG4gICAgbWVtb3J5OiBmdW5jdGlvbiBtZW1vcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVtb3J5IHx8ICh0aGlzLl9tZW1vcnkgPSB7fSk7XG4gICAgfVxuICB9KTsgLy8gTWV0aG9kIGZvciBnZXR0aW5nIGFuIGVsZW1lbnQgYnkgaWRcblxuICBTVkcuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZEZyb21SZWZlcmVuY2UoaWQpIHx8IGlkKTtcbiAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICB9OyAvLyBTZWxlY3QgZWxlbWVudHMgYnkgcXVlcnkgc3RyaW5nXG5cblxuICBTVkcuc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IFNWRy5TZXQoU1ZHLnV0aWxzLm1hcCgocGFyZW50IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBTVkcuYWRvcHQobm9kZSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xuICAgIC8vIFNjb3BlZCBzZWxlY3QgbWV0aG9kXG4gICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QocXVlcnkpIHtcbiAgICAgIHJldHVybiBTVkcuc2VsZWN0KHF1ZXJ5LCB0aGlzLm5vZGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gcGF0aFJlZ1JlcGxhY2UoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICsgZC5yZXBsYWNlKFNWRy5yZWdleC5kb3RzLCAnIC4nKTtcbiAgfSAvLyBjcmVhdGVzIGRlZXAgY2xvbmUgb2YgYXJyYXlcblxuXG4gIGZ1bmN0aW9uIGFycmF5X2Nsb25lKGFycikge1xuICAgIHZhciBjbG9uZSA9IGFyci5zbGljZSgwKTtcblxuICAgIGZvciAodmFyIGkgPSBjbG9uZS5sZW5ndGg7IGktLTspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNsb25lW2ldKSkge1xuICAgICAgICBjbG9uZVtpXSA9IGFycmF5X2Nsb25lKGNsb25lW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH0gLy8gdGVzdHMgaWYgYSBnaXZlbiBlbGVtZW50IGlzIGluc3RhbmNlIG9mIGFuIG9iamVjdFxuXG5cbiAgZnVuY3Rpb24gX2lzKGVsLCBvYmopIHtcbiAgICByZXR1cm4gZWwgaW5zdGFuY2VvZiBvYmo7XG4gIH0gLy8gdGVzdHMgaWYgYSBnaXZlbiBzZWxlY3RvciBtYXRjaGVzIGFuIGVsZW1lbnRcblxuXG4gIGZ1bmN0aW9uIF9tYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIH0gLy8gQ29udmVydCBkYXNoLXNlcGFyYXRlZC1zdHJpbmcgdG8gY2FtZWxDYXNlXG5cblxuICBmdW5jdGlvbiBjYW1lbENhc2Uocykge1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobSwgZykge1xuICAgICAgcmV0dXJuIGcudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfSAvLyBDYXBpdGFsaXplIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuXG5cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xuICB9IC8vIEVuc3VyZSB0byBzaXgtYmFzZWQgaGV4XG5cblxuICBmdW5jdGlvbiBmdWxsSGV4KGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoID09IDQgPyBbJyMnLCBoZXguc3Vic3RyaW5nKDEsIDIpLCBoZXguc3Vic3RyaW5nKDEsIDIpLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDMsIDQpLCBoZXguc3Vic3RyaW5nKDMsIDQpXS5qb2luKCcnKSA6IGhleDtcbiAgfSAvLyBDb21wb25lbnQgdG8gaGV4IHZhbHVlXG5cblxuICBmdW5jdGlvbiBjb21wVG9IZXgoY29tcCkge1xuICAgIHZhciBoZXggPSBjb21wLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICB9IC8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcblxuXG4gIGZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB2YXIgYm94ID0gZWxlbWVudC5iYm94KCk7XG5cbiAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAqIGhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAqIHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH0gLy8gRGVsdGEgdHJhbnNmb3JtIHBvaW50XG5cblxuICBmdW5jdGlvbiBkZWx0YVRyYW5zZm9ybVBvaW50KG1hdHJpeCwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICogbWF0cml4LmEgKyB5ICogbWF0cml4LmMgKyAwLFxuICAgICAgeTogeCAqIG1hdHJpeC5iICsgeSAqIG1hdHJpeC5kICsgMFxuICAgIH07XG4gIH0gLy8gTWFwIG1hdHJpeCBhcnJheSB0byBvYmplY3RcblxuXG4gIGZ1bmN0aW9uIGFycmF5VG9NYXRyaXgoYSkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBhWzBdLFxuICAgICAgYjogYVsxXSxcbiAgICAgIGM6IGFbMl0sXG4gICAgICBkOiBhWzNdLFxuICAgICAgZTogYVs0XSxcbiAgICAgIGY6IGFbNV1cbiAgICB9O1xuICB9IC8vIFBhcnNlIG1hdHJpeCBpZiByZXF1aXJlZFxuXG5cbiAgZnVuY3Rpb24gcGFyc2VNYXRyaXgobWF0cml4KSB7XG4gICAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgU1ZHLk1hdHJpeCkpIHtcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfSAvLyBBZGQgY2VudHJlIHBvaW50IHRvIHRyYW5zZm9ybSBvYmplY3RcblxuXG4gIGZ1bmN0aW9uIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpIHtcbiAgICBvLmN4ID0gby5jeCA9PSBudWxsID8gdGFyZ2V0LmJib3goKS5jeCA6IG8uY3g7XG4gICAgby5jeSA9IG8uY3kgPT0gbnVsbCA/IHRhcmdldC5iYm94KCkuY3kgOiBvLmN5O1xuICB9IC8vIFBhdGhBcnJheSBIZWxwZXJzXG5cblxuICBmdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aCwgcyA9ICcnOyBpIDwgaWw7IGkrKykge1xuICAgICAgcyArPSBhW2ldWzBdO1xuXG4gICAgICBpZiAoYVtpXVsxXSAhPSBudWxsKSB7XG4gICAgICAgIHMgKz0gYVtpXVsxXTtcblxuICAgICAgICBpZiAoYVtpXVsyXSAhPSBudWxsKSB7XG4gICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgcyArPSBhW2ldWzJdO1xuXG4gICAgICAgICAgaWYgKGFbaV1bM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICBzICs9IGFbaV1bM107XG4gICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIHMgKz0gYVtpXVs0XTtcblxuICAgICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzVdO1xuICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzZdO1xuXG4gICAgICAgICAgICAgIGlmIChhW2ldWzddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgICAgICBzICs9IGFbaV1bN107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcyArICcgJztcbiAgfSAvLyBEZWVwIG5ldyBpZCBhc3NpZ25tZW50XG5cblxuICBmdW5jdGlvbiBhc3NpZ25OZXdJZChub2RlKSB7XG4gICAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXG4gICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICAgIGFzc2lnbk5ld0lkKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKS5pZChTVkcuZWlkKG5vZGUubm9kZU5hbWUpKTtcbiAgfSAvLyBBZGQgbW9yZSBib3VuZGluZyBib3ggcHJvcGVydGllc1xuXG5cbiAgZnVuY3Rpb24gZnVsbEJveChiKSB7XG4gICAgaWYgKGIueCA9PSBudWxsKSB7XG4gICAgICBiLnggPSAwO1xuICAgICAgYi55ID0gMDtcbiAgICAgIGIud2lkdGggPSAwO1xuICAgICAgYi5oZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIGIudyA9IGIud2lkdGg7XG4gICAgYi5oID0gYi5oZWlnaHQ7XG4gICAgYi54MiA9IGIueCArIGIud2lkdGg7XG4gICAgYi55MiA9IGIueSArIGIuaGVpZ2h0O1xuICAgIGIuY3ggPSBiLnggKyBiLndpZHRoIC8gMjtcbiAgICBiLmN5ID0gYi55ICsgYi5oZWlnaHQgLyAyO1xuICAgIHJldHVybiBiO1xuICB9IC8vIEdldCBpZCBmcm9tIHJlZmVyZW5jZSBzdHJpbmdcblxuXG4gIGZ1bmN0aW9uIGlkRnJvbVJlZmVyZW5jZSh1cmwpIHtcbiAgICB2YXIgbSA9ICh1cmwgfHwgJycpLnRvU3RyaW5nKCkubWF0Y2goU1ZHLnJlZ2V4LnJlZmVyZW5jZSk7XG4gICAgaWYgKG0pIHJldHVybiBtWzFdO1xuICB9IC8vIElmIHZhbHVlcyBsaWtlIDFlLTg4IGFyZSBwYXNzZWQsIHRoaXMgaXMgbm90IGEgdmFsaWQgMzIgYml0IGZsb2F0LFxuICAvLyBidXQgaW4gdGhvc2UgY2FzZXMsIHdlIGFyZSBzbyBjbG9zZSB0byAwIHRoYXQgMCB3b3JrcyB3ZWxsIVxuXG5cbiAgZnVuY3Rpb24gZmxvYXQzMlN0cmluZyh2KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHYpID4gMWUtMzcgPyB2IDogMDtcbiAgfSAvLyBDcmVhdGUgbWF0cml4IGFycmF5IGZvciBsb29waW5nXG5cblxuICB2YXIgYWJjZGVmID0gJ2FiY2RlZicuc3BsaXQoJycpOyAvLyBBZGQgQ3VzdG9tRXZlbnQgdG8gSUU5IGFuZCBJRTEwXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDb2RlIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudFxuICAgIHZhciBDdXN0b21FdmVudFBvbHkgPSBmdW5jdGlvbiBDdXN0b21FdmVudFBvbHkoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBlLmluaXRDdXN0b21FdmVudChldmVudCwgb3B0aW9ucy5idWJibGVzLCBvcHRpb25zLmNhbmNlbGFibGUsIG9wdGlvbnMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICBDdXN0b21FdmVudFBvbHkucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICBTVkcuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudFBvbHk7XG4gIH0gZWxzZSB7XG4gICAgU1ZHLkN1c3RvbUV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuICB9IC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSAvIGNhbmNlbEFuaW1hdGlvbkZyYW1lIFBvbHlmaWxsIHdpdGggZmFsbGJhY2sgYmFzZWQgb24gUGF1bCBJcmlzaFxuXG5cbiAgKGZ1bmN0aW9uICh3KSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddO1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgIHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgfVxuXG4gICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICB2YXIgaWQgPSB3LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgdy5jbGVhclRpbWVvdXQ7XG4gIH0pKHdpbmRvdyk7XG5cbiAgcmV0dXJuIFNWRztcbn0pO1xuXG4vKiEgc3ZnLmZpbHRlci5qcyAtIHYyLjAuMiAtIDIwMTYtMDItMjRcclxuKiBodHRwczovL2dpdGh1Yi5jb20vd291dC9zdmcuZmlsdGVyLmpzXHJcbiogQ29weXJpZ2h0IChjKSAyMDE2IFdvdXQgRmllcmVuczsgTGljZW5zZWQgTUlUICovXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgLy8gTWFpbiBmaWx0ZXIgY2xhc3NcclxuICBTVkcuRmlsdGVyID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6ICdmaWx0ZXInLFxyXG4gICAgaW5oZXJpdDogU1ZHLlBhcmVudCxcclxuICAgIGV4dGVuZDoge1xyXG4gICAgICAvLyBTdGF0aWMgc3RyaW5nc1xyXG4gICAgICBzb3VyY2U6ICAgICAgICAgICAnU291cmNlR3JhcGhpYycsXHJcbiAgICAgIHNvdXJjZUFscGhhOiAgICAgICdTb3VyY2VBbHBoYScsXHJcbiAgICAgIGJhY2tncm91bmQ6ICAgICAgICdCYWNrZ3JvdW5kSW1hZ2UnLFxyXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6ICAnQmFja2dyb3VuZEFscGhhJyxcclxuICAgICAgZmlsbDogICAgICAgICAgICAgJ0ZpbGxQYWludCcsXHJcbiAgICAgIHN0cm9rZTogICAgICAgICAgICdTdHJva2VQYWludCcsXHJcblxyXG4gICAgICBhdXRvU2V0SW46IHRydWUsXHJcbiAgICAgIC8vIEN1c3RvbSBwdXQgbWV0aG9kIGZvciBsZWFuZXIgY29kZVxyXG4gICAgICBwdXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcclxuICAgICAgICB0aGlzLmFkZChlbGVtZW50LCBpKTtcclxuXHJcbiAgICAgICAgaWYoIWVsZW1lbnQuYXR0cignaW4nKSAmJiB0aGlzLmF1dG9TZXRJbil7XHJcbiAgICAgICAgICBlbGVtZW50LmF0dHIoJ2luJyx0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFlbGVtZW50LmF0dHIoJ3Jlc3VsdCcpKXtcclxuICAgICAgICAgIGVsZW1lbnQuYXR0cigncmVzdWx0JyxlbGVtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtZW50XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIEJsZW5kIGVmZmVjdFxyXG4gICAgICBibGVuZDogZnVuY3Rpb24oaW4xLCBpbjIsIG1vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5CbGVuZEVmZmVjdChpbjEsIGluMiwgbW9kZSkpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIENvbG9yTWF0cml4IGVmZmVjdFxyXG4gICAgICBjb2xvck1hdHJpeDogZnVuY3Rpb24odHlwZSwgdmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ29sb3JNYXRyaXhFZmZlY3QodHlwZSwgdmFsdWVzKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29udm9sdmVNYXRyaXggZWZmZWN0XHJcbiAgICAgIGNvbnZvbHZlTWF0cml4OiBmdW5jdGlvbihtYXRyaXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db252b2x2ZU1hdHJpeEVmZmVjdChtYXRyaXgpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBDb21wb25lbnRUcmFuc2ZlciBlZmZlY3RcclxuICAgICAgY29tcG9uZW50VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbXBvbmVudHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db21wb25lbnRUcmFuc2ZlckVmZmVjdChjb21wb25lbnRzKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29tcG9zaXRlIGVmZmVjdFxyXG4gICAgICBjb21wb3NpdGU6IGZ1bmN0aW9uKGluMSwgaW4yLCBvcGVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNvbXBvc2l0ZUVmZmVjdChpbjEsIGluMiwgb3BlcmF0b3IpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBGbG9vZCBlZmZlY3RcclxuICAgICAgZmxvb2Q6IGZ1bmN0aW9uKGNvbG9yLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRmxvb2RFZmZlY3QoY29sb3IsIG9wYWNpdHkpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBPZmZzZXQgZWZmZWN0XHJcbiAgICAgIG9mZnNldDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk9mZnNldEVmZmVjdCh4LHkpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBJbWFnZSBlZmZlY3RcclxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkltYWdlRWZmZWN0KHNyYykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIE1lcmdlIGVmZmVjdFxyXG4gICAgICBtZXJnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9wYXNzIHRoZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2Ugd2UgZG9udCBrbm93IGlmIHRoZSB1c2VyIGdhdmUgdXMgYW4gYXJyYXkgYXMgdGhlIGZpcnN0IGFyZ3VlbW50IG9yIHdldGhlciB0aGV5IGxpc3RlZCB0aGUgZWZmZWN0cyBpbiB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbdW5kZWZpbmVkXTtcclxuICAgICAgICBmb3IodmFyIGkgaW4gYXJndW1lbnRzKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IChTVkcuTWVyZ2VFZmZlY3QuYmluZC5hcHBseShTVkcuTWVyZ2VFZmZlY3QsYXJncykpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBHYXVzc2lhbiBCbHVyIGVmZmVjdFxyXG4gICAgICBnYXVzc2lhbkJsdXI6IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkdhdXNzaWFuQmx1ckVmZmVjdCh4LHkpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBNb3JwaG9sb2d5IGVmZmVjdFxyXG4gICAgICBtb3JwaG9sb2d5OiBmdW5jdGlvbihvcGVyYXRvcixyYWRpdXMpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk1vcnBob2xvZ3lFZmZlY3Qob3BlcmF0b3IscmFkaXVzKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gRGlmZnVzZUxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgICBkaWZmdXNlTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRGlmZnVzZUxpZ2h0aW5nRWZmZWN0KHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCkpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIERpc3BsYWNlbWVudE1hcCBlZmZlY3RcclxuICAgICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3Rvcil7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRGlzcGxhY2VtZW50TWFwRWZmZWN0KGluMSxpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gU3BlY3VsYXJMaWdodGluZyBlZmZlY3RcclxuICAgICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlNwZWN1bGFyTGlnaHRpbmdFZmZlY3Qoc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBUaWxlIGVmZmVjdFxyXG4gICAgICB0aWxlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRpbGVFZmZlY3QoKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIFR1cmJ1bGVuY2UgZWZmZWN0XHJcbiAgICAgIHR1cmJ1bGVuY2U6IGZ1bmN0aW9uKGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlR1cmJ1bGVuY2VFZmZlY3QoYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSkpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIERlZmF1bHQgc3RyaW5nIHZhbHVlXHJcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuYXR0cignaWQnKSArICcpJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vYWRkIC5maWx0ZXIgZnVuY3Rpb25cclxuICBTVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XHJcbiAgICAvLyBEZWZpbmUgZmlsdGVyXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnB1dChuZXcgU1ZHLkZpbHRlcik7XHJcblxyXG4gICAgICAvKiBpbnZva2UgcGFzc2VkIGJsb2NrICovXHJcbiAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgYmxvY2suY2FsbChmaWx0ZXIsIGZpbHRlcik7XHJcblxyXG4gICAgICByZXR1cm4gZmlsdGVyXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgU1ZHLmV4dGVuZChTVkcuQ29udGFpbmVyLCB7XHJcbiAgICAvLyBEZWZpbmUgZmlsdGVyIG9uIGRlZnNcclxuICAgIGZpbHRlcjogZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmZpbHRlcihibG9jaylcclxuICAgIH1cclxuICB9KTtcclxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRywgU1ZHLk5lc3RlZCwge1xyXG4gICAgLy8gQ3JlYXRlIGZpbHRlciBlbGVtZW50IGluIGRlZnMgYW5kIHN0b3JlIHJlZmVyZW5jZVxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICB0aGlzLmZpbHRlcmVyID0gYmxvY2sgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCA/XHJcbiAgICAgICAgYmxvY2sgOiB0aGlzLmRvYygpLmZpbHRlcihibG9jayk7XHJcblxyXG4gICAgICBpZih0aGlzLmRvYygpICYmIHRoaXMuZmlsdGVyZXIuZG9jKCkgIT09IHRoaXMuZG9jKCkpe1xyXG4gICAgICAgIHRoaXMuZG9jKCkuZGVmcygpLmFkZCh0aGlzLmZpbHRlcmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5hdHRyKCdmaWx0ZXInLCB0aGlzLmZpbHRlcmVyKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVyXHJcbiAgICB9LFxyXG4gICAgLy8gUmVtb3ZlIGZpbHRlclxyXG4gICAgdW5maWx0ZXI6IGZ1bmN0aW9uKHJlbW92ZSkge1xyXG4gICAgICAvKiBhbHNvIHJlbW92ZSB0aGUgZmlsdGVyIG5vZGUgKi9cclxuICAgICAgaWYgKHRoaXMuZmlsdGVyZXIgJiYgcmVtb3ZlID09PSB0cnVlKVxyXG4gICAgICAgIHRoaXMuZmlsdGVyZXIucmVtb3ZlKCk7XHJcblxyXG4gICAgICAvKiBkZWxldGUgcmVmZXJlbmNlIHRvIGZpbHRlcmVyICovXHJcbiAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcmVyO1xyXG5cclxuICAgICAgLyogcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgKi9cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZmlsdGVyJywgbnVsbClcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gQ3JlYXRlIFNWRy5FZmZlY3QgY2xhc3NcclxuICBTVkcuRWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcclxuICAgIGV4dGVuZDoge1xyXG4gICAgICAvLyBTZXQgaW4gYXR0cmlidXRlXHJcbiAgICAgIGluOiBmdW5jdGlvbihlZmZlY3QpIHtcclxuICAgICAgICByZXR1cm4gZWZmZWN0ID09IG51bGw/IHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5zZWxlY3QoJ1tyZXN1bHQ9XCInK3RoaXMuYXR0cignaW4nKSsnXCJdJykuZ2V0KDApIHx8IHRoaXMuYXR0cignaW4nKSA6IHRoaXMuYXR0cignaW4nLCBlZmZlY3QpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIE5hbWVkIHJlc3VsdFxyXG4gICAgICByZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbD8gdGhpcy5hdHRyKCdyZXN1bHQnKSA6IHRoaXMuYXR0cigncmVzdWx0JyxyZXN1bHQpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIFN0cmluZ2lmaWNhdGlvblxyXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBjcmVhdGUgY2xhc3MgZm9yIHBhcmVudCBlZmZlY3RzIGxpa2UgbWVyZ2VcclxuICAvLyBJbmhlcml0IGZyb20gU1ZHLlBhcmVudFxyXG4gIFNWRy5QYXJlbnRFZmZlY3QgPSBTVkcuaW52ZW50KHtcclxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXHJcbiAgICBleHRlbmQ6IHtcclxuICAgICAgLy8gU2V0IGluIGF0dHJpYnV0ZVxyXG4gICAgICBpbjogZnVuY3Rpb24oZWZmZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVmZmVjdCA9PSBudWxsPyB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc2VsZWN0KCdbcmVzdWx0PVwiJyt0aGlzLmF0dHIoJ2luJykrJ1wiXScpLmdldCgwKSB8fCB0aGlzLmF0dHIoJ2luJykgOiB0aGlzLmF0dHIoJ2luJywgZWZmZWN0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBOYW1lZCByZXN1bHRcclxuICAgICAgcmVzdWx0OiBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ID09IG51bGw/IHRoaXMuYXR0cigncmVzdWx0JykgOiB0aGlzLmF0dHIoJ3Jlc3VsdCcscmVzdWx0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBTdHJpbmdpZmljYXRpb25cclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy9jaGFpbmluZ1xyXG4gIHZhciBjaGFpbmluZ0VmZmVjdHMgPSB7XHJcbiAgICAvLyBCbGVuZCBlZmZlY3RcclxuICAgIGJsZW5kOiBmdW5jdGlvbihpbjIsIG1vZGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5ibGVuZCh0aGlzLCBpbjIsIG1vZGUpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBpbnB1dFxyXG4gICAgfSxcclxuICAgIC8vIENvbG9yTWF0cml4IGVmZmVjdFxyXG4gICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlcykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbG9yTWF0cml4KHR5cGUsIHZhbHVlcykuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBDb252b2x2ZU1hdHJpeCBlZmZlY3RcclxuICAgIGNvbnZvbHZlTWF0cml4OiBmdW5jdGlvbihtYXRyaXgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb252b2x2ZU1hdHJpeChtYXRyaXgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gQ29tcG9uZW50VHJhbnNmZXIgZWZmZWN0XHJcbiAgICBjb21wb25lbnRUcmFuc2ZlcjogZnVuY3Rpb24oY29tcG9uZW50cykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbXBvbmVudFRyYW5zZmVyKGNvbXBvbmVudHMpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gQ29tcG9zaXRlIGVmZmVjdFxyXG4gICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjIsIG9wZXJhdG9yKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY29tcG9zaXRlKHRoaXMsIGluMiwgb3BlcmF0b3IpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBpbnB1dFxyXG4gICAgfSxcclxuICAgIC8vIEZsb29kIGVmZmVjdFxyXG4gICAgZmxvb2Q6IGZ1bmN0aW9uKGNvbG9yLCBvcGFjaXR5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuZmxvb2QoY29sb3IsIG9wYWNpdHkpIC8vdGhpcyBlZmZlY3QgZG9udCBoYXZlIGlucHV0c1xyXG4gICAgfSxcclxuICAgIC8vIE9mZnNldCBlZmZlY3RcclxuICAgIG9mZnNldDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLm9mZnNldCh4LHkpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gSW1hZ2UgZWZmZWN0XHJcbiAgICBpbWFnZTogZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuaW1hZ2Uoc3JjKSAvL3RoaXMgZWZmZWN0IGRvbnQgaGF2ZSBpbnB1dHNcclxuICAgIH0sXHJcbiAgICAvLyBNZXJnZSBlZmZlY3RcclxuICAgIG1lcmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5tZXJnZS5hcHBseSh0aGlzLnBhcmVudCgpLFt0aGlzXS5jb25jYXQoYXJndW1lbnRzKSkgLy9wYXNzIHRoaXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XHJcbiAgICB9LFxyXG4gICAgLy8gR2F1c3NpYW4gQmx1ciBlZmZlY3RcclxuICAgIGdhdXNzaWFuQmx1cjogZnVuY3Rpb24oeCx5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuZ2F1c3NpYW5CbHVyKHgseSkuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBNb3JwaG9sb2d5IGVmZmVjdFxyXG4gICAgbW9ycGhvbG9neTogZnVuY3Rpb24ob3BlcmF0b3IscmFkaXVzKXtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5tb3JwaG9sb2d5KG9wZXJhdG9yLHJhZGl1cykuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBEaWZmdXNlTGlnaHRpbmcgZWZmZWN0XHJcbiAgICBkaWZmdXNlTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuZGlmZnVzZUxpZ2h0aW5nKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCkuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBEaXNwbGFjZW1lbnRNYXAgZWZmZWN0XHJcbiAgICBkaXNwbGFjZW1lbnRNYXA6IGZ1bmN0aW9uKGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3Ipe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmRpc3BsYWNlbWVudE1hcCh0aGlzLGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3IpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBpbnB1dFxyXG4gICAgfSxcclxuICAgIC8vIFNwZWN1bGFyTGlnaHRpbmcgZWZmZWN0XHJcbiAgICBzcGVjdWxhckxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc3BlY3VsYXJMaWdodGluZyhzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCkuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBUaWxlIGVmZmVjdFxyXG4gICAgdGlsZTogZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS50aWxlKCkuaW4odGhpcylcclxuICAgIH0sXHJcbiAgICAvLyBUdXJidWxlbmNlIGVmZmVjdFxyXG4gICAgdHVyYnVsZW5jZTogZnVuY3Rpb24oYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkudHVyYnVsZW5jZShiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKS5pbih0aGlzKVxyXG4gICAgfVxyXG4gIH07XHJcbiAgU1ZHLmV4dGVuZChTVkcuRWZmZWN0LGNoYWluaW5nRWZmZWN0cyk7XHJcbiAgU1ZHLmV4dGVuZChTVkcuUGFyZW50RWZmZWN0LGNoYWluaW5nRWZmZWN0cyk7XHJcblxyXG4gIC8vY3JlYSBjbGFzcyBmb3IgY2hpbGQgZWZmZWN0cywgbGlrZSBNZXJnZU5vZGUsIEZ1bmNSIGFuZCBsaWdodHNcclxuICBTVkcuQ2hpbGRFZmZlY3QgPSBTVkcuaW52ZW50KHtcclxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxyXG4gICAgZXh0ZW5kOiB7XHJcbiAgICBpbjogZnVuY3Rpb24oZWZmZWN0KXtcclxuICAgICAgdGhpcy5hdHRyKCdpbicsZWZmZWN0KTtcclxuICAgIH1cclxuICAgIC8vZG9udCBpbmNsdWRlIGFueSBcInJlc3VsdFwiIGZ1bmN0aW9ucyBiZWNhdXNlIHRoZXNlIHR5cGVzIG9mIG5vZGVzIGRvbnQgaGF2ZSB0aGVtXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIENyZWF0ZSBhbGwgZGlmZmVyZW50IGVmZmVjdHNcclxuICB2YXIgZWZmZWN0cyA9IHtcclxuICAgIGJsZW5kOiBmdW5jdGlvbihpbjEsaW4yLG1vZGUpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGluOiBpbjEsXHJcbiAgICAgICAgaW4yOiBpbjIsXHJcbiAgICAgICAgbW9kZTogbW9kZSB8fCAnbm9ybWFsJ1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb2xvck1hdHJpeDogZnVuY3Rpb24odHlwZSx2YWx1ZXMpe1xyXG4gICAgICBpZiAodHlwZSA9PSAnbWF0cml4JylcclxuICAgICAgICB2YWx1ZXMgPSBub3JtYWxpc2VNYXRyaXgodmFsdWVzKTtcclxuXHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgdHlwZTogICB0eXBlXHJcbiAgICAgICwgdmFsdWVzOiB0eXBlb2YgdmFsdWVzID09ICd1bmRlZmluZWQnID8gbnVsbCA6IHZhbHVlc1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KXtcclxuICAgICAgbWF0cml4ID0gbm9ybWFsaXNlTWF0cml4KG1hdHJpeCk7XHJcblxyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIG9yZGVyOiAgICAgICAgTWF0aC5zcXJ0KG1hdHJpeC5zcGxpdCgnICcpLmxlbmd0aClcclxuICAgICAgLCBrZXJuZWxNYXRyaXg6IG1hdHJpeFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb21wb3NpdGU6IGZ1bmN0aW9uKGluMSwgaW4yLCBvcGVyYXRvcil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgaW46IGluMSxcclxuICAgICAgICBpbjI6IGluMixcclxuICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3JcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZmxvb2Q6IGZ1bmN0aW9uKGNvbG9yLG9wYWNpdHkpe1xyXG4gICAgICB0aGlzLmF0dHIoJ2Zsb29kLWNvbG9yJyxjb2xvcik7XHJcbiAgICAgIGlmKG9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdmbG9vZC1vcGFjaXR5JyxvcGFjaXR5KTtcclxuICAgIH0sXHJcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgZHg6IHgsXHJcbiAgICAgICAgZHk6IHlcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgaW1hZ2U6IGZ1bmN0aW9uKHNyYyl7XHJcbiAgICAgIHRoaXMuYXR0cignaHJlZicsIHNyYywgU1ZHLnhsaW5rKTtcclxuICAgIH0sXHJcbiAgICBkaXNwbGFjZW1lbnRNYXA6IGZ1bmN0aW9uKGluMSxpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBpbjogaW4xLFxyXG4gICAgICAgIGluMjogaW4yLFxyXG4gICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICB4Q2hhbm5lbFNlbGVjdG9yOiB4Q2hhbm5lbFNlbGVjdG9yLFxyXG4gICAgICAgIHlDaGFubmVsU2VsZWN0b3I6IHlDaGFubmVsU2VsZWN0b3JcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZ2F1c3NpYW5CbHVyOiBmdW5jdGlvbih4LHkpe1xyXG4gICAgICBpZih4ICE9IG51bGwgfHwgeSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuYXR0cignc3RkRGV2aWF0aW9uJywgbGlzdFN0cmluZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmF0dHIoJ3N0ZERldmlhdGlvbicsICcwIDAnKTtcclxuICAgIH0sXHJcbiAgICBtb3JwaG9sb2d5OiBmdW5jdGlvbihvcGVyYXRvcixyYWRpdXMpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcclxuICAgICAgICByYWRpdXM6IHJhZGl1c1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB0aWxlOiBmdW5jdGlvbigpe1xyXG5cclxuICAgIH0sXHJcbiAgICB0dXJidWxlbmNlOiBmdW5jdGlvbihiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBudW1PY3RhdmVzOiBudW1PY3RhdmVzLFxyXG4gICAgICAgIHNlZWQ6IHNlZWQsXHJcbiAgICAgICAgc3RpdGNoVGlsZXM6IHN0aXRjaFRpbGVzLFxyXG4gICAgICAgIGJhc2VGcmVxdWVuY3k6IGJhc2VGcmVxdWVuY3ksXHJcbiAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYWxsIHBhcmVudCBlZmZlY3RzXHJcbiAgdmFyIHBhcmVudEVmZmVjdHMgPSB7XHJcbiAgICBtZXJnZTogZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGNoaWxkcmVuO1xyXG5cclxuICAgICAgLy90ZXN0IHRvIHNlZSBpZiB3ZSBoYXZlIGEgc2V0XHJcbiAgICAgIGlmKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNWRy5TZXQpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBhcmd1bWVudHNbMF0uZWFjaChmdW5jdGlvbihpKXtcclxuICAgICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuTWVyZ2VOb2RlKVxyXG4gICAgICAgICAgICB0aGF0LnB1dCh0aGlzKTtcclxuICAgICAgICAgIGVsc2UgaWYodGhpcyBpbnN0YW5jZW9mIFNWRy5FZmZlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnRFZmZlY3QpXHJcbiAgICAgICAgICAgIHRoYXQucHV0KG5ldyBTVkcuTWVyZ2VOb2RlKHRoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIC8vaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5IHVzZSBpdFxyXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSlcclxuICAgICAgICAgIGNoaWxkcmVuID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGNoaWxkcmVuID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgaWYoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuTWVyZ2VOb2RlKXtcclxuICAgICAgICAgICAgdGhpcy5wdXQoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB0aGlzLnB1dChuZXcgU1ZHLk1lcmdlTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFRyYW5zZmVyOiBmdW5jdGlvbihjb21wb250ZW50cyl7XHJcbiAgICAgIC8qIGNyZWF0ZSByZ2Igc2V0ICovXHJcbiAgICAgIHRoaXMucmdiID0gbmV3IFNWRy5TZXRcclxuXHJcbiAgICAgIC8qIGNyZWF0ZSBjb21wb25lbnRzICovXHJcbiAgICAgIDsoWydyJywgJ2cnLCAnYicsICdhJ10pLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgICAgIC8qIGNyZWF0ZSBjb21wb25lbnQgKi9cclxuICAgICAgICB0aGlzW2NdID0gbmV3IFNWR1snRnVuYycgKyBjLnRvVXBwZXJDYXNlKCldKCdpZGVudGl0eScpO1xyXG5cclxuICAgICAgICAvKiBzdG9yZSBjb21wb25lbnQgaW4gc2V0ICovXHJcbiAgICAgICAgdGhpcy5yZ2IuYWRkKHRoaXNbY10pO1xyXG5cclxuICAgICAgICAvKiBhZGQgY29tcG9uZW50IG5vZGUgKi9cclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpc1tjXS5ub2RlKTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTsgLy9sb3N0IGNvbnRleHQgaW4gZm9yZWFjaFxyXG5cclxuICAgICAgLyogc2V0IGNvbXBvbmVudHMgKi9cclxuICAgICAgaWYgKGNvbXBvbnRlbnRzKSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbnRlbnRzLnJnYikge1xyXG4oWydyJywgJ2cnLCAnYiddKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgdGhpc1tjXS5hdHRyKGNvbXBvbnRlbnRzLnJnYik7XHJcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgIGRlbGV0ZSBjb21wb250ZW50cy5yZ2I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBzZXQgaW5kaXZpZHVhbCBjb21wb25lbnRzICovXHJcbiAgICAgICAgZm9yICh2YXIgYyBpbiBjb21wb250ZW50cylcclxuICAgICAgICAgIHRoaXNbY10uYXR0cihjb21wb250ZW50c1tjXSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkaWZmdXNlTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgc3VyZmFjZVNjYWxlOiBzdXJmYWNlU2NhbGUsXHJcbiAgICAgICAgZGlmZnVzZUNvbnN0YW50OiBkaWZmdXNlQ29uc3RhbnQsXHJcbiAgICAgICAga2VybmVsVW5pdExlbmd0aDoga2VybmVsVW5pdExlbmd0aFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBzcGVjdWxhckxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsa2VybmVsVW5pdExlbmd0aCl7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgc3VyZmFjZVNjYWxlOiBzdXJmYWNlU2NhbGUsXHJcbiAgICAgICAgZGlmZnVzZUNvbnN0YW50OiBkaWZmdXNlQ29uc3RhbnQsXHJcbiAgICAgICAgc3BlY3VsYXJFeHBvbmVudDogc3BlY3VsYXJFeHBvbmVudCxcclxuICAgICAgICBrZXJuZWxVbml0TGVuZ3RoOiBrZXJuZWxVbml0TGVuZ3RoXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgY2hpbGQgZWZmZWN0cyBsaWtlIFBvaW50TGlnaHQgYW5kIE1lcmdlTm9kZVxyXG4gIHZhciBjaGlsZEVmZmVjdHMgPSB7XHJcbiAgICBkaXN0YW50TGlnaHQ6IGZ1bmN0aW9uKGF6aW11dGgsIGVsZXZhdGlvbil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgYXppbXV0aDogYXppbXV0aCxcclxuICAgICAgICBlbGV2YXRpb246IGVsZXZhdGlvblxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb2ludExpZ2h0OiBmdW5jdGlvbih4LHkseil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHo6IHpcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgc3BvdExpZ2h0OiBmdW5jdGlvbih4LHkseixwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0Wil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICB5OiB5LFxyXG4gICAgICAgIHo6IHosXHJcbiAgICAgICAgcG9pbnRzQXRYOiBwb2ludHNBdFgsXHJcbiAgICAgICAgcG9pbnRzQXRZOiBwb2ludHNBdFksXHJcbiAgICAgICAgcG9pbnRzQXRaOiBwb2ludHNBdFpcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWVyZ2VOb2RlOiBmdW5jdGlvbihpbjEpe1xyXG4gICAgICB0aGlzLmF0dHIoJ2luJyxpbjEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGNvbXBvbnRlbnQgZnVuY3Rpb25zXHJcbiAgOyhbJ3InLCAnZycsICdiJywgJ2EnXSkuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICAvKiBjcmVhdGUgY2xhc3MgKi9cclxuICAgIGNoaWxkRWZmZWN0c1snRnVuYycgKyBjLnRvVXBwZXJDYXNlKCldID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICB0aGlzLmF0dHIoJ3R5cGUnLHR5cGUpO1xyXG5cclxuICAgICAgLy8gdGFrZSBkaWZmZW50IGFyZ3VtZW50cyBiYXNlZCBvbiB0aGUgdHlwZVxyXG4gICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgY2FzZSAndGFibGUnOlxyXG4gICAgICAgICAgdGhpcy5hdHRyKCd0YWJsZVZhbHVlcycsYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnbGluZWFyJzpcclxuICAgICAgICAgIHRoaXMuYXR0cignc2xvcGUnLGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICB0aGlzLmF0dHIoJ2ludGVyY2VwdCcsYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnZ2FtbWEnOlxyXG4gICAgICAgICAgdGhpcy5hdHRyKCdhbXBsaXR1ZGUnLGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICB0aGlzLmF0dHIoJ2V4cG9uZW50Jyxhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyKCdvZmZzZXQnLGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICAvL2NyZWF0ZSBlZmZlY3RzXHJcbiAgZm9yZWFjaChlZmZlY3RzLGZ1bmN0aW9uKGVmZmVjdCxpKXtcclxuXHJcbiAgICAvKiBjYXBpdGFsaXplIG5hbWUgKi9cclxuICAgIHZhciBuYW1lID0gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XHJcbiAgICB2YXIgcHJvdG8gPSB7fTtcclxuXHJcbiAgICAvKiBjcmVhdGUgY2xhc3MgKi9cclxuICAgIFNWR1tuYW1lICsgJ0VmZmVjdCddID0gU1ZHLmludmVudCh7XHJcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9jYWxsIHN1cGVyXHJcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ2ZlJyArIG5hbWUpKTtcclxuXHJcbiAgICAgICAgLy9jYWxsIGNvbnN0cnVjdG9yIGZvciB0aGlzIGVmZmVjdFxyXG4gICAgICAgIGVmZmVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIC8vc2V0IHRoZSByZXN1bHRcclxuICAgICAgICB0aGlzLnJlc3VsdCh0aGlzLmF0dHIoJ2lkJykgKyAnT3V0Jyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGluaGVyaXQ6IFNWRy5FZmZlY3QsXHJcbiAgICAgIGV4dGVuZDogcHJvdG9cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAvL2NyZWF0ZSBwYXJlbnQgZWZmZWN0c1xyXG4gIGZvcmVhY2gocGFyZW50RWZmZWN0cyxmdW5jdGlvbihlZmZlY3QsaSl7XHJcblxyXG4gICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgdmFyIHByb3RvID0ge307XHJcblxyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBTVkdbbmFtZSArICdFZmZlY3QnXSA9IFNWRy5pbnZlbnQoe1xyXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdmZScgKyBuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vY2FsbCBjb25zdHJ1Y3RvciBmb3IgdGhpcyBlZmZlY3RcclxuICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAvL3NldCB0aGUgcmVzdWx0XHJcbiAgICAgICAgdGhpcy5yZXN1bHQodGhpcy5hdHRyKCdpZCcpICsgJ091dCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmhlcml0OiBTVkcuUGFyZW50RWZmZWN0LFxyXG4gICAgICBleHRlbmQ6IHByb3RvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy9jcmVhdGUgY2hpbGQgZWZmZWN0c1xyXG4gIGZvcmVhY2goY2hpbGRFZmZlY3RzLGZ1bmN0aW9uKGVmZmVjdCxpKXtcclxuXHJcbiAgICAvKiBjYXBpdGFsaXplIG5hbWUgKi9cclxuICAgIHZhciBuYW1lID0gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XHJcbiAgICB2YXIgcHJvdG8gPSB7fTtcclxuXHJcbiAgICAvKiBjcmVhdGUgY2xhc3MgKi9cclxuICAgIFNWR1tuYW1lXSA9IFNWRy5pbnZlbnQoe1xyXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdmZScgKyBuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vY2FsbCBjb25zdHJ1Y3RvciBmb3IgdGhpcyBlZmZlY3RcclxuICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmhlcml0OiBTVkcuQ2hpbGRFZmZlY3QsXHJcbiAgICAgIGV4dGVuZDogcHJvdG9cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAvLyBFZmZlY3Qtc3BlY2lmaWMgZXh0ZW5zaW9uc1xyXG4gIFNWRy5leHRlbmQoU1ZHLk1lcmdlRWZmZWN0LHtcclxuICAgIGluOiBmdW5jdGlvbihlZmZlY3Qpe1xyXG4gICAgICBpZihlZmZlY3QgaW5zdGFuY2VvZiBTVkcuTWVyZ2VOb2RlKVxyXG4gICAgICAgIHRoaXMuYWRkKGVmZmVjdCwwKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuYWRkKG5ldyBTVkcuTWVyZ2VOb2RlKGVmZmVjdCksMCk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFNWRy5leHRlbmQoU1ZHLkNvbXBvc2l0ZUVmZmVjdCxTVkcuQmxlbmRFZmZlY3QsU1ZHLkRpc3BsYWNlbWVudE1hcEVmZmVjdCx7XHJcbiAgICBpbjI6IGZ1bmN0aW9uKGVmZmVjdCl7XHJcbiAgICAgICAgcmV0dXJuIGVmZmVjdCA9PSBudWxsPyB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc2VsZWN0KCdbcmVzdWx0PVwiJyt0aGlzLmF0dHIoJ2luMicpKydcIl0nKS5nZXQoMCkgfHwgdGhpcy5hdHRyKCdpbjInKSA6IHRoaXMuYXR0cignaW4yJywgZWZmZWN0KVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBQcmVzZXRzXHJcbiAgU1ZHLmZpbHRlciA9IHtcclxuICAgIHNlcGlhdG9uZTogIFsgLjM0MywgLjY2OSwgLjExOSwgMCwgMFxyXG4gICAgICAgICAgICAgICAgLCAuMjQ5LCAuNjI2LCAuMTMwLCAwLCAwXHJcbiAgICAgICAgICAgICAgICAsIC4xNzIsIC4zMzQsIC4xMTEsIDAsIDBcclxuICAgICAgICAgICAgICAgICwgLjAwMCwgLjAwMCwgLjAwMCwgMSwgMCBdXHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVyc1xyXG4gIGZ1bmN0aW9uIG5vcm1hbGlzZU1hdHJpeChtYXRyaXgpIHtcclxuICAgIC8qIGNvbnZlcnQgcG9zc2libGUgYXJyYXkgdmFsdWUgdG8gc3RyaW5nICovXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRyaXgpKVxyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLkFycmF5KG1hdHJpeCk7XHJcblxyXG4gICAgLyogZW5zdXJlIHRoZXJlIGFyZSBubyBsZWFkaW5nLCB0YWlsaW5nIG9yIGRvdWJsZSBzcGFjZXMgKi9cclxuICAgIHJldHVybiBtYXRyaXgudG9TdHJpbmcoKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxpc3RTdHJpbmcobGlzdCkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKVxyXG4gICAgICByZXR1cm4gbGlzdFxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGgsIHMgPSBbXTsgaSA8IGw7IGkrKylcclxuICAgICAgcy5wdXNoKGxpc3RbaV0pO1xyXG5cclxuICAgIHJldHVybiBzLmpvaW4oJyAnKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9yZWFjaCgpeyAvL2xvb3BzIHRocm91Z2ggbXV0aXBsZSBvYmplY3RzXHJcbiAgICB2YXIgZm4gPSBmdW5jdGlvbigpe307XHJcbiAgICBpZih0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0gPT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV07XHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsYXJndW1lbnRzLmxlbmd0aC0xLDEpO1xyXG4gICAgfVxyXG4gICAgZm9yKHZhciBrIGluIGFyZ3VtZW50cyl7XHJcbiAgICAgIGZvcih2YXIgaSBpbiBhcmd1bWVudHNba10pe1xyXG4gICAgICAgIGZuKGFyZ3VtZW50c1trXVtpXSxpLGFyZ3VtZW50c1trXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59KS5jYWxsKHVuZGVmaW5lZCk7XG5cbihmdW5jdGlvbigpIHtcclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xyXG4gIG1vcnBoOiBmdW5jdGlvbihhcnJheSkge1xyXG5cclxuICAgIHZhciBzdGFydEFyciA9IHRoaXMudmFsdWVcclxuICAgICAgLCAgZGVzdEFyciA9IHRoaXMucGFyc2UoYXJyYXkpO1xyXG5cclxuICAgIHZhciBzdGFydE9mZnNldE0gPSAwXHJcbiAgICAgICwgIGRlc3RPZmZzZXRNID0gMDtcclxuXHJcbiAgICB2YXIgc3RhcnRPZmZzZXROZXh0TSA9IGZhbHNlXHJcbiAgICAgICwgIGRlc3RPZmZzZXROZXh0TSA9IGZhbHNlO1xyXG5cclxuICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAvLyBzdG9wIGlmIHRoZXJlIGlzIG5vIE0gYW55bW9yZVxyXG4gICAgICBpZihzdGFydE9mZnNldE0gPT09IGZhbHNlICYmIGRlc3RPZmZzZXRNID09PSBmYWxzZSkgYnJlYWtcclxuXHJcbiAgICAgIC8vIGZpbmQgdGhlIG5leHQgTSBpbiBwYXRoIGFycmF5XHJcbiAgICAgIHN0YXJ0T2Zmc2V0TmV4dE0gPSBmaW5kTmV4dE0oc3RhcnRBcnIsIHN0YXJ0T2Zmc2V0TSA9PT0gZmFsc2UgPyBmYWxzZSA6IHN0YXJ0T2Zmc2V0TSsxKTtcclxuICAgICAgIGRlc3RPZmZzZXROZXh0TSA9IGZpbmROZXh0TSggZGVzdEFyciwgIGRlc3RPZmZzZXRNID09PSBmYWxzZSA/IGZhbHNlIDogIGRlc3RPZmZzZXRNKzEpO1xyXG5cclxuICAgICAgLy8gV2UgaGF2ZSB0byBhZGQgb25lIE0gdG8gdGhlIHN0YXJ0QXJyYXlcclxuICAgICAgaWYoc3RhcnRPZmZzZXRNID09PSBmYWxzZSl7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgU1ZHLlBhdGhBcnJheShyZXN1bHQuc3RhcnQpLmJib3goKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB0aGUgbGFzdCBibG9jayBoYWQgbm8gYm91bmRpbmcgYm94IHdlIHNpbXBseSB0YWtlIHRoZSBmaXJzdCBNIHdlIGdvdFxyXG4gICAgICAgIGlmKGJib3guaGVpZ2h0ID09IDAgfHwgYmJveC53aWR0aCA9PSAwKXtcclxuICAgICAgICAgIHN0YXJ0T2Zmc2V0TSA9ICBzdGFydEFyci5wdXNoKHN0YXJ0QXJyWzBdKSAtIDE7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAvLyB3ZSB0YWtlIHRoZSBtaWRkbGUgb2YgdGhlIGJib3ggaW5zdGVhZCB3aGVuIHdlIGdvdCBvbmVcclxuICAgICAgICAgIHN0YXJ0T2Zmc2V0TSA9IHN0YXJ0QXJyLnB1c2goIFsnTScsIGJib3gueCArIGJib3gud2lkdGgvMiwgYmJveC55ICsgYmJveC5oZWlnaHQvMiBdICkgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2UgaGF2ZSB0byBhZGQgb25lIE0gdG8gdGhlIGRlc3RBcnJheVxyXG4gICAgICBpZiggZGVzdE9mZnNldE0gPT09IGZhbHNlKXtcclxuICAgICAgICB2YXIgYmJveCA9IG5ldyBTVkcuUGF0aEFycmF5KHJlc3VsdC5kZXN0KS5iYm94KCk7XHJcblxyXG4gICAgICAgIGlmKGJib3guaGVpZ2h0ID09IDAgfHwgYmJveC53aWR0aCA9PSAwKXtcclxuICAgICAgICAgIGRlc3RPZmZzZXRNID0gIGRlc3RBcnIucHVzaChkZXN0QXJyWzBdKSAtIDE7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0QXJyLnB1c2goIFsnTScsIGJib3gueCArIGJib3gud2lkdGgvMiwgYmJveC55ICsgYmJveC5oZWlnaHQvMiBdICkgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaGFuZGxlIGJsb2NrIGZyb20gTSB0byBuZXh0IE1cclxuICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZUJsb2NrKHN0YXJ0QXJyLCBzdGFydE9mZnNldE0sIHN0YXJ0T2Zmc2V0TmV4dE0sIGRlc3RBcnIsIGRlc3RPZmZzZXRNLCBkZXN0T2Zmc2V0TmV4dE0pO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIHRoZSBhcnJheXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xyXG4gICAgICBzdGFydEFyciA9IHN0YXJ0QXJyLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0TSkuY29uY2F0KHJlc3VsdC5zdGFydCwgc3RhcnRPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBbXSA6IHN0YXJ0QXJyLnNsaWNlKHN0YXJ0T2Zmc2V0TmV4dE0pKTtcclxuICAgICAgIGRlc3RBcnIgPSAgZGVzdEFyci5zbGljZSgwLCAgZGVzdE9mZnNldE0pLmNvbmNhdChyZXN1bHQuZGVzdCAsICBkZXN0T2Zmc2V0TmV4dE0gPT09IGZhbHNlID8gW10gOiAgZGVzdEFyci5zbGljZSggZGVzdE9mZnNldE5leHRNKSk7XHJcblxyXG4gICAgICAvLyB1cGRhdGUgb2Zmc2V0c1xyXG4gICAgICBzdGFydE9mZnNldE0gPSBzdGFydE9mZnNldE5leHRNID09PSBmYWxzZSA/IGZhbHNlIDogc3RhcnRPZmZzZXRNICsgcmVzdWx0LnN0YXJ0Lmxlbmd0aDtcclxuICAgICAgIGRlc3RPZmZzZXRNID0gIGRlc3RPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBmYWxzZSA6ICBkZXN0T2Zmc2V0TSArIHJlc3VsdC5kZXN0Lmxlbmd0aDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29weSBiYWNrIGFycmF5c1xyXG4gICAgdGhpcy52YWx1ZSA9IHN0YXJ0QXJyO1xyXG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuUGF0aEFycmF5KCk7XHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlID0gZGVzdEFycjtcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSk7XHJcblxyXG5cclxuXHJcbi8vIHNvcnJ5IGZvciB0aGUgbG9uZyBkZWNsYXJhdGlvblxyXG4vLyBzbGljZXMgb3V0IG9uZSBibG9jayAoZnJvbSBNIHRvIE0pIGFuZCBzeW5jcm9uaXplIGl0IHNvIHRoZSB0eXBlcyBhbmQgbGVuZ3RoIG1hdGNoXHJcbmZ1bmN0aW9uIGhhbmRsZUJsb2NrKHN0YXJ0QXJyLCBzdGFydE9mZnNldE0sIHN0YXJ0T2Zmc2V0TmV4dE0sIGRlc3RBcnIsIGRlc3RPZmZzZXRNLCBkZXN0T2Zmc2V0TmV4dE0sIHVuZGVmaW5lZCl7XHJcblxyXG4gIC8vIHNsaWNlIG91dCB0aGUgYmxvY2sgd2UgbmVlZFxyXG4gIHZhciBzdGFydEFyclRlbXAgPSBzdGFydEFyci5zbGljZShzdGFydE9mZnNldE0sIHN0YXJ0T2Zmc2V0TmV4dE0gfHwgdW5kZWZpbmVkKVxyXG4gICAgLCAgZGVzdEFyclRlbXAgPSAgZGVzdEFyci5zbGljZSggZGVzdE9mZnNldE0sICBkZXN0T2Zmc2V0TmV4dE0gfHwgdW5kZWZpbmVkKTtcclxuXHJcbiAgdmFyIGkgPSAwXHJcbiAgICAsIHBvc1N0YXJ0ID0ge3BvczpbMCwwXSwgc3RhcnQ6WzAsMF19XHJcbiAgICAsIHBvc0Rlc3QgID0ge3BvczpbMCwwXSwgc3RhcnQ6WzAsMF19O1xyXG5cclxuICBkb3tcclxuXHJcbiAgICAvLyBjb252ZXJ0IHNob3J0aGFuZCB0eXBlcyB0byBsb25nIGZvcm1cclxuICAgIHN0YXJ0QXJyVGVtcFtpXSA9IHNpbXBseWZ5LmNhbGwocG9zU3RhcnQsIHN0YXJ0QXJyVGVtcFtpXSk7XHJcbiAgICAgZGVzdEFyclRlbXBbaV0gPSBzaW1wbHlmeS5jYWxsKHBvc0Rlc3QgLCAgZGVzdEFyclRlbXBbaV0pO1xyXG5cclxuICAgIC8vIGNoZWNrIGlmIGJvdGggc2hhcGUgdHlwZXMgbWF0Y2hcclxuICAgIC8vIDIgZWxsaXB0aWNhbCBhcmMgY3VydmUgY29tbWFuZHMgKCdBJyksIGFyZSBjb25zaWRlcmVkIGRpZmZlcmVudCBpZiB0aGVcclxuICAgIC8vIGZsYWdzIChsYXJnZS1hcmMtZmxhZywgc3dlZXAtZmxhZykgZG9uJ3QgbWF0Y2hcclxuICAgIGlmKHN0YXJ0QXJyVGVtcFtpXVswXSAhPSBkZXN0QXJyVGVtcFtpXVswXSB8fCBzdGFydEFyclRlbXBbaV1bMF0gPT0gJ00nIHx8XHJcbiAgICAgICAgKHN0YXJ0QXJyVGVtcFtpXVswXSA9PSAnQScgJiZcclxuICAgICAgICAgIChzdGFydEFyclRlbXBbaV1bNF0gIT0gZGVzdEFyclRlbXBbaV1bNF0gfHwgc3RhcnRBcnJUZW1wW2ldWzVdICE9IGRlc3RBcnJUZW1wW2ldWzVdKVxyXG4gICAgICAgIClcclxuICAgICAgKSB7XHJcblxyXG4gICAgICAvLyBpZiBub3QsIGNvbnZlcnQgc2hhcGVzIHRvIGJlemllcmVcclxuICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdGFydEFyclRlbXAsIFtpLCAxXS5jb25jYXQodG9CZXppZXJlLmNhbGwocG9zU3RhcnQsIHN0YXJ0QXJyVGVtcFtpXSkpKTtcclxuICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoZGVzdEFyclRlbXAsIFtpLCAxXS5jb25jYXQodG9CZXppZXJlLmNhbGwocG9zRGVzdCwgZGVzdEFyclRlbXBbaV0pKSk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIG9ubHkgdXBkYXRlIHBvc2l0aW9ucyBvdGhlcndpc2VcclxuICAgICAgc3RhcnRBcnJUZW1wW2ldID0gc2V0UG9zQW5kUmVmbGVjdGlvbi5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pO1xyXG4gICAgICAgZGVzdEFyclRlbXBbaV0gPSBzZXRQb3NBbmRSZWZsZWN0aW9uLmNhbGwocG9zRGVzdCAsICBkZXN0QXJyVGVtcFtpXSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIGFyZSBhdCB0aGUgZW5kIGF0IGJvdGggYXJyYXlzLiBzdG9wIGhlcmVcclxuICAgIGlmKCsraSA9PSBzdGFydEFyclRlbXAubGVuZ3RoICYmIGkgPT0gZGVzdEFyclRlbXAubGVuZ3RoKSBicmVha1xyXG5cclxuICAgIC8vIGRlc3RBcnJheSBpcyBsb25nZXIuIEFkZCBvbmUgZWxlbWVudFxyXG4gICAgaWYoaSA9PSBzdGFydEFyclRlbXAubGVuZ3RoKXtcclxuICAgICAgc3RhcnRBcnJUZW1wLnB1c2goW1xyXG4gICAgICAgICdDJyxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzFdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1swXSxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzBdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1sxXSxcclxuICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RhcnRBcnIgaXMgbG9uZ2VyLiBBZGQgb25lIGVsZW1lbnRcclxuICAgIGlmKGkgPT0gZGVzdEFyclRlbXAubGVuZ3RoKXtcclxuICAgICAgZGVzdEFyclRlbXAucHVzaChbXHJcbiAgICAgICAgJ0MnLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzBdLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzFdLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzBdLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzFdLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzBdLFxyXG4gICAgICAgIHBvc0Rlc3QucG9zWzFdXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgfXdoaWxlKHRydWUpXHJcblxyXG4gIC8vIHJldHVybiB0aGUgdXBkYXRlZCBibG9ja1xyXG4gIHJldHVybiB7c3RhcnQ6c3RhcnRBcnJUZW1wLCBkZXN0OmRlc3RBcnJUZW1wfVxyXG59XHJcblxyXG4vLyBjb252ZXJ0cyBzaG9ydGhhbmQgdHlwZXMgdG8gbG9uZyBmb3JtXHJcbmZ1bmN0aW9uIHNpbXBseWZ5KHZhbCl7XHJcblxyXG4gIHN3aXRjaCh2YWxbMF0pe1xyXG4gICAgY2FzZSAneic6IC8vIHNob3J0aGFuZCBsaW5lIHRvIHN0YXJ0XHJcbiAgICBjYXNlICdaJzpcclxuICAgICAgdmFsWzBdID0gJ0wnO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnN0YXJ0WzBdO1xyXG4gICAgICB2YWxbMl0gPSB0aGlzLnN0YXJ0WzFdO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnSCc6IC8vIHNob3J0aGFuZCBob3Jpem9udGFsIGxpbmVcclxuICAgICAgdmFsWzBdID0gJ0wnO1xyXG4gICAgICB2YWxbMl0gPSB0aGlzLnBvc1sxXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ1YnOiAvLyBzaG9ydGhhbmQgdmVydGljYWwgbGluZVxyXG4gICAgICB2YWxbMF0gPSAnTCc7XHJcbiAgICAgIHZhbFsyXSA9IHZhbFsxXTtcclxuICAgICAgdmFsWzFdID0gdGhpcy5wb3NbMF07XHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdUJzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpYyBiZXppZXJlXHJcbiAgICAgIHZhbFswXSA9ICdRJztcclxuICAgICAgdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucmVmbGVjdGlvblsxXTtcclxuICAgICAgdmFsWzJdID0gdGhpcy5yZWZsZWN0aW9uWzBdO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJlXHJcbiAgICAgIHZhbFswXSA9ICdDJztcclxuICAgICAgdmFsWzZdID0gdmFsWzRdO1xyXG4gICAgICB2YWxbNV0gPSB2YWxbM107XHJcbiAgICAgIHZhbFs0XSA9IHZhbFsyXTtcclxuICAgICAgdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICB2YWxbMl0gPSB0aGlzLnJlZmxlY3Rpb25bMV07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucmVmbGVjdGlvblswXTtcclxuICAgICAgYnJlYWtcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWxcclxuXHJcbn1cclxuXHJcbi8vIHVwZGF0ZXMgcmVmbGVjdGlvbiBwb2ludCBhbmQgY3VycmVudCBwb3NpdGlvblxyXG5mdW5jdGlvbiBzZXRQb3NBbmRSZWZsZWN0aW9uKHZhbCl7XHJcblxyXG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xyXG5cclxuICB0aGlzLnBvcyA9IFsgdmFsW2xlbi0yXSwgdmFsW2xlbi0xXSBdO1xyXG5cclxuICBpZignU0NRVCcuaW5kZXhPZih2YWxbMF0pICE9IC0xKVxyXG4gICAgdGhpcy5yZWZsZWN0aW9uID0gWyAyICogdGhpcy5wb3NbMF0gLSB2YWxbbGVuLTRdLCAyICogdGhpcy5wb3NbMV0gLSB2YWxbbGVuLTNdIF07XHJcblxyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuLy8gY29udmVydHMgYWxsIHR5cGVzIHRvIGN1YmljIGJlemllcmVcclxuZnVuY3Rpb24gdG9CZXppZXJlKHZhbCl7XHJcbiAgdmFyIHJldFZhbCA9IFt2YWxdO1xyXG5cclxuICBzd2l0Y2godmFsWzBdKXtcclxuICAgIGNhc2UgJ00nOiAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBNXHJcbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydCA9IFt2YWxbMV0sIHZhbFsyXV07XHJcbiAgICAgIHJldHVybiByZXRWYWxcclxuICAgIGNhc2UgJ0wnOlxyXG4gICAgICB2YWxbNV0gPSB2YWxbM10gPSB2YWxbMV07XHJcbiAgICAgIHZhbFs2XSA9IHZhbFs0XSA9IHZhbFsyXTtcclxuICAgICAgdmFsWzFdID0gdGhpcy5wb3NbMF07XHJcbiAgICAgIHZhbFsyXSA9IHRoaXMucG9zWzFdO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnUSc6XHJcbiAgICAgIHZhbFs2XSA9IHZhbFs0XTtcclxuICAgICAgdmFsWzVdID0gdmFsWzNdO1xyXG4gICAgICB2YWxbNF0gPSB2YWxbNF0gKiAxLzMgKyB2YWxbMl0gKiAyLzM7XHJcbiAgICAgIHZhbFszXSA9IHZhbFszXSAqIDEvMyArIHZhbFsxXSAqIDIvMztcclxuICAgICAgdmFsWzJdID0gdGhpcy5wb3NbMV0gKiAxLzMgKyB2YWxbMl0gKiAyLzM7XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucG9zWzBdICogMS8zICsgdmFsWzFdICogMi8zO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnQSc6XHJcbiAgICAgIHJldFZhbCA9IGFyY1RvQmV6aWVyZSh0aGlzLnBvcywgdmFsKTtcclxuICAgICAgdmFsID0gcmV0VmFsWzBdO1xyXG4gICAgICBicmVha1xyXG4gIH1cclxuXHJcbiAgdmFsWzBdID0gJ0MnO1xyXG4gIHRoaXMucG9zID0gW3ZhbFs1XSwgdmFsWzZdXTtcclxuICB0aGlzLnJlZmxlY3Rpb24gPSBbMiAqIHZhbFs1XSAtIHZhbFszXSwgMiAqIHZhbFs2XSAtIHZhbFs0XV07XHJcblxyXG4gIHJldHVybiByZXRWYWxcclxuXHJcbn1cclxuXHJcbi8vIGZpbmRzIHRoZSBuZXh0IHBvc2l0aW9uIG9mIHR5cGUgTVxyXG5mdW5jdGlvbiBmaW5kTmV4dE0oYXJyLCBvZmZzZXQpe1xyXG5cclxuICBpZihvZmZzZXQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgZm9yKHZhciBpID0gb2Zmc2V0LCBsZW4gPSBhcnIubGVuZ3RoO2kgPCBsZW47KytpKXtcclxuXHJcbiAgICBpZihhcnJbaV1bMF0gPT0gJ00nKSByZXR1cm4gaVxyXG5cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5cclxuXHJcbi8vIENvbnZlcnQgYW4gYXJjIHNlZ21lbnQgaW50byBlcXVpdmFsZW50IGN1YmljIEJlemllciBjdXJ2ZXNcclxuLy8gRGVwZW5kaW5nIG9uIHRoZSBhcmMsIHVwIHRvIDQgY3VydmVzIG1pZ2h0IGJlIHVzZWQgdG8gcmVwcmVzZW50IGl0IHNpbmNlIGFcclxuLy8gY3VydmUgZ2l2ZXMgYSBnb29kIGFwcHJveGltYXRpb24gZm9yIG9ubHkgYSBxdWFydGVyIG9mIGFuIGVsbGlwc2VcclxuLy8gVGhlIGN1cnZlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkgb2YgU1ZHIGN1cnZlIGNvbW1hbmRzOlxyXG4vLyBbIFsnQycsIHgxLCB5MSwgeDIsIHkyLCB4LCB5XSAuLi4gXVxyXG5mdW5jdGlvbiBhcmNUb0JlemllcmUocG9zLCB2YWwpIHtcclxuICAgIC8vIFBhcmFtZXRlcnMgZXh0cmFjdGlvbiwgaGFuZGxlIG91dC1vZi1yYW5nZSBwYXJhbWV0ZXJzIGFzIHNwZWNpZmllZCBpbiB0aGUgU1ZHIHNwZWNcclxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjT3V0T2ZSYW5nZVBhcmFtZXRlcnNcclxuICAgIHZhciByeCA9IE1hdGguYWJzKHZhbFsxXSksIHJ5ID0gTWF0aC5hYnModmFsWzJdKSwgeEF4aXNSb3RhdGlvbiA9IHZhbFszXSAlIDM2MFxyXG4gICAgICAsIGxhcmdlQXJjRmxhZyA9IHZhbFs0XSwgc3dlZXBGbGFnID0gdmFsWzVdLCB4ID0gdmFsWzZdLCB5ID0gdmFsWzddXHJcbiAgICAgICwgQSA9IG5ldyBTVkcuUG9pbnQocG9zKSwgQiA9IG5ldyBTVkcuUG9pbnQoeCwgeSlcclxuICAgICAgLCBwcmltZWRDb29yZCwgbGFtYmRhLCBtYXQsIGssIGMsIGNTcXVhcmUsIHQsIE8sIE9BLCBPQiwgdGV0YVN0YXJ0LCB0ZXRhRW5kXHJcbiAgICAgICwgZGVsdGFUZXRhLCBuYlNlY3RvcnMsIGYsIGFyY1NlZ1BvaW50cywgYW5nbGUsIHNpbkFuZ2xlLCBjb3NBbmdsZSwgcHQsIGksIGlsXHJcbiAgICAgICwgcmV0VmFsID0gW10sIHgxLCB5MSwgeDIsIHkyO1xyXG5cclxuICAgIC8vIEVuc3VyZSByYWRpaSBhcmUgbm9uLXplcm9cclxuICAgIGlmKHJ4ID09PSAwIHx8IHJ5ID09PSAwIHx8IChBLnggPT09IEIueCAmJiBBLnkgPT09IEIueSkpIHtcclxuICAgICAgLy8gdHJlYXQgdGhpcyBhcmMgYXMgYSBzdHJhaWdodCBsaW5lIHNlZ21lbnRcclxuICAgICAgcmV0dXJuIFtbJ0MnLCBBLngsIEEueSwgQi54LCBCLnksIEIueCwgQi55XV1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaCB1c2luZyB0aGUgYWxnb3JpdGhtIHByb3ZpZGVkIGluIHRoZSBTVkcgc3BlY1xyXG4gICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNDb3JyZWN0aW9uT3V0T2ZSYW5nZVJhZGlpXHJcbiAgICBwcmltZWRDb29yZCA9IG5ldyBTVkcuUG9pbnQoKEEueC1CLngpLzIsIChBLnktQi55KS8yKS50cmFuc2Zvcm0obmV3IFNWRy5NYXRyaXgoKS5yb3RhdGUoeEF4aXNSb3RhdGlvbikpO1xyXG4gICAgbGFtYmRhID0gKHByaW1lZENvb3JkLnggKiBwcmltZWRDb29yZC54KSAvIChyeCAqIHJ4KSArIChwcmltZWRDb29yZC55ICogcHJpbWVkQ29vcmQueSkgLyAocnkgKiByeSk7XHJcbiAgICBpZihsYW1iZGEgPiAxKSB7XHJcbiAgICAgIGxhbWJkYSA9IE1hdGguc3FydChsYW1iZGEpO1xyXG4gICAgICByeCA9IGxhbWJkYSpyeDtcclxuICAgICAgcnkgPSBsYW1iZGEqcnk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG8gc2ltcGxpZnkgY2FsY3VsYXRpb25zLCB3ZSBtYWtlIHRoZSBhcmMgcGFydCBvZiBhIHVuaXQgY2lyY2xlIChyYXlvbiBpcyAxKSBpbnN0ZWFkIG9mIGFuIGVsbGlwc2VcclxuICAgIG1hdCA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pLnNjYWxlKDEvcngsIDEvcnkpLnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XHJcbiAgICBBID0gQS50cmFuc2Zvcm0obWF0KTtcclxuICAgIEIgPSBCLnRyYW5zZm9ybShtYXQpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgaW5pdGlhbCBhbmQgZmluYWwgcG9pbnQgb2YgdGhlIGFyY1xyXG4gICAgayA9IFtCLngtQS54LCBCLnktQS55XTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGggb2YgdGhlIGNob3JkIGZvcm1lZCBieSBBIGFuZCBCXHJcbiAgICBjU3F1YXJlID0ga1swXSprWzBdICsga1sxXSprWzFdO1xyXG4gICAgYyA9IE1hdGguc3FydChjU3F1YXJlKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHJhdGlvcyBvZiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGlzdGFuY2Ugb24gdGhlIGxlbmd0aCBvZiB0aGUgY2hvcmRcclxuICAgIGtbMF0gLz0gYztcclxuICAgIGtbMV0gLz0gYztcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNpcmNsZSBjZW50ZXIgYW5kIHRoZSBjaG9yZCBtaWRwb2ludFxyXG4gICAgLy8gdXNpbmcgdGhpcyBmb3JtdWxhOiB0ID0gc3FydChyXjIgLSBjXjIgLyA0KVxyXG4gICAgLy8gd2hlcmUgdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY2lybGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnQsXHJcbiAgICAvLyAgICAgICByIGlzIHRoZSByYXlvbiBvZiB0aGUgY2lyY2xlIGFuZCBjIGlzIHRoZSBjaG9yZCBsZW5ndGhcclxuICAgIC8vIEZyb206IGh0dHA6Ly93d3cuYWpkZXNpZ25lci5jb20vcGhwY2lyY2xlL2NpcmNsZV9zZWdtZW50X2Nob3JkX3QucGhwXHJcbiAgICAvLyBCZWNhdXNlIG9mIHRoZSBpbXByZWNpc2lvbiBvZiBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBjU3F1YXJlIG1pZ2h0IGVuZFxyXG4gICAgLy8gdXAgYmVpbmcgc2xpZ2h0bHkgYWJvdmUgNCB3aGljaCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSByYWRpY2FuZFxyXG4gICAgLy8gVG8gcHJldmVudCB0aGF0LCBhIHRlc3QgaXMgbWFkZSBiZWZvcmUgY29tcHV0aW5nIHRoZSBzcXVhcmUgcm9vdFxyXG4gICAgdCA9IChjU3F1YXJlIDwgNCkgPyBNYXRoLnNxcnQoMSAtIGNTcXVhcmUvNCkgOiAwO1xyXG5cclxuICAgIC8vIEZvciBtb3N0IHNpdHVhdGlvbnMsIHRoZXJlIGFyZSBhY3R1YWxseSB0d28gZGlmZmVyZW50IGVsbGlwc2VzIHRoYXRcclxuICAgIC8vIHNhdGlzZnkgdGhlIGNvbnN0cmFpbnRzIGltcG9zZWQgYnkgdGhlIHBvaW50cyBBIGFuZCBCLCB0aGUgcmFkaWkgcnggYW5kIHJ5LFxyXG4gICAgLy8gYW5kIHRoZSB4QXhpc1JvdGF0aW9uXHJcbiAgICAvLyBXaGVuIHRoZSBmbGFncyBsYXJnZUFyY0ZsYWcgYW5kIHN3ZWVwRmxhZyBhcmUgZXF1YWwsIGl0IG1lYW5zIHRoYXQgdGhlXHJcbiAgICAvLyBzZWNvbmQgZWxsaXBzZSBpcyB1c2VkIGFzIGEgc29sdXRpb25cclxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhRWxsaXB0aWNhbEFyY0NvbW1hbmRzXHJcbiAgICBpZihsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZykge1xyXG4gICAgICAgIHQgKj0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgZnJvbSB0aGUgbWlkcG9pbnQgb2YgdGhlIGNob3JkXHJcbiAgICAvLyBUaGlzIGlzIGRvbmUgYnkgbXVsdGlwbHlpbmcgdGhlIHJhdGlvcyBjYWxjdWxhdGVkIHByZXZpb3VzbHkgYnkgdGhlIGRpc3RhbmNlIGJldHdlZW5cclxuICAgIC8vIHRoZSBjaXJjbGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnQgYW5kIHVzaW5nIHRoZXNlIHZhbHVlcyB0byBnbyBmcm9tIHRoZSBtaWRwb2ludFxyXG4gICAgLy8gdG8gdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAvLyBUaGUgbmVnYXRpdmUgb2YgdGhlIHZlcnRpY2FsIGRpc3RhbmNlIHJhdGlvIGlzIHVzZWQgdG8gbW9kaWZ5IHRoZSB4IGNvb3JkaW5hdGUgd2hpbGVcclxuICAgIC8vIHRoZSBob3Jpem9udGFsIGRpc3RhbmNlIHJhdGlvIGlzIHVzZWQgdG8gbW9kaWZ5IHRoZSB5IGNvb3JkaW5hdGVcclxuICAgIC8vIFRoYXQgaXMgYmVjYXVzZSB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgaXMgcGVycGVuZGljdWxhciB0byB0aGUgY2hvcmQgYW5kIHBlcnBlbmRpY3VsYXJcclxuICAgIC8vIGxpbmVzIGFyZSBuZWdhdGl2ZSByZWNpcHJvY2Fsc1xyXG4gICAgTyA9IG5ldyBTVkcuUG9pbnQoKEIueCtBLngpLzIgKyB0Ki1rWzFdLCAoQi55K0EueSkvMiArIHQqa1swXSk7XHJcbiAgICAvLyBNb3ZlIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhdCB0aGUgb3JpZ2luXHJcbiAgICBPQSA9IG5ldyBTVkcuUG9pbnQoQS54LU8ueCwgQS55LU8ueSk7XHJcbiAgICBPQiA9IG5ldyBTVkcuUG9pbnQoQi54LU8ueCwgQi55LU8ueSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlXHJcbiAgICB0ZXRhU3RhcnQgPSBNYXRoLmFjb3MoT0EueC9NYXRoLnNxcnQoT0EueCpPQS54ICsgT0EueSpPQS55KSk7XHJcbiAgICBpZiAoT0EueSA8IDApIHtcclxuICAgICAgdGV0YVN0YXJ0ICo9IC0xO1xyXG4gICAgfVxyXG4gICAgdGV0YUVuZCA9IE1hdGguYWNvcyhPQi54L01hdGguc3FydChPQi54Kk9CLnggKyBPQi55Kk9CLnkpKTtcclxuICAgIGlmIChPQi55IDwgMCkge1xyXG4gICAgICB0ZXRhRW5kICo9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHN3ZWVwLWZsYWcgaXMgJzEnLCB0aGVuIHRoZSBhcmMgd2lsbCBiZSBkcmF3biBpbiBhIFwicG9zaXRpdmUtYW5nbGVcIiBkaXJlY3Rpb24sXHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZW5kIGFuZ2xlIGlzIGFib3ZlIHRoZSBzdGFydCBhbmdsZVxyXG4gICAgaWYgKHN3ZWVwRmxhZyAmJiB0ZXRhU3RhcnQgPiB0ZXRhRW5kKSB7XHJcbiAgICAgIHRldGFFbmQgKz0gMipNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgc3dlZXAtZmxhZyBpcyAnMCcsIHRoZW4gdGhlIGFyYyB3aWxsIGJlIGRyYXduIGluIGEgXCJuZWdhdGl2ZS1hbmdsZVwiIGRpcmVjdGlvbixcclxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBlbmQgYW5nbGUgaXMgYmVsb3cgdGhlIHN0YXJ0IGFuZ2xlXHJcbiAgICBpZiAoIXN3ZWVwRmxhZyAmJiB0ZXRhU3RhcnQgPCB0ZXRhRW5kKSB7XHJcbiAgICAgIHRldGFFbmQgLT0gMipNYXRoLlBJO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmQgdGhlIG51bWJlciBvZiBCZXppZXIgY3VydmVzIHRoYXQgYXJlIHJlcXVpcmVkIHRvIHJlcHJlc2VudCB0aGUgYXJjXHJcbiAgICAvLyBBIGN1YmljIEJlemllciBjdXJ2ZSBnaXZlcyBhIGdvb2QgZW5vdWdoIGFwcHJveGltYXRpb24gd2hlbiByZXByZXNlbnRpbmcgYXQgbW9zdCBhIHF1YXJ0ZXIgb2YgYSBjaXJjbGVcclxuICAgIG5iU2VjdG9ycyA9IE1hdGguY2VpbChNYXRoLmFicyh0ZXRhU3RhcnQtdGV0YUVuZCkgKiAyL01hdGguUEkpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50cyBvZiBhbGwgdGhlIEJlemllciBjdXJ2ZXMgcmVxdWlyZWQgdG8gcmVwcmVzZW50IHRoZSBhcmNcclxuICAgIC8vIEZvciBhbiBpbi1kZXB0aCBleHBsYW5hdGlvbiBvZiB0aGlzIHBhcnQgc2VlOiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2NpcmNsZXNfY3ViaWNcclxuICAgIGFyY1NlZ1BvaW50cyA9IFtdO1xyXG4gICAgYW5nbGUgPSB0ZXRhU3RhcnQ7XHJcbiAgICBkZWx0YVRldGEgPSAodGV0YUVuZC10ZXRhU3RhcnQpL25iU2VjdG9ycztcclxuICAgIGYgPSA0Kk1hdGgudGFuKGRlbHRhVGV0YS80KS8zO1xyXG4gICAgZm9yIChpID0gMDsgaSA8PSBuYlNlY3RvcnM7IGkrKykgeyAvLyBUaGUgPD0gaXMgYmVjYXVzZSBhIEJlemllciBjdXJ2ZSBoYXZlIGEgc3RhcnQgYW5kIGEgZW5kcG9pbnRcclxuICAgICAgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgcHQgPSBuZXcgU1ZHLlBvaW50KE8ueCtjb3NBbmdsZSwgTy55K3NpbkFuZ2xlKTtcclxuICAgICAgYXJjU2VnUG9pbnRzW2ldID0gW25ldyBTVkcuUG9pbnQocHQueCtmKnNpbkFuZ2xlLCBwdC55LWYqY29zQW5nbGUpLCBwdCwgbmV3IFNWRy5Qb2ludChwdC54LWYqc2luQW5nbGUsIHB0LnkrZipjb3NBbmdsZSldO1xyXG5cclxuICAgICAgYW5nbGUgKz0gZGVsdGFUZXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgZmlyc3Qgc2VnbWVudCBwb2ludCBhbmQgcmVtb3ZlIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgbGFzdCBzZWdtZW50IHBvaW50XHJcbiAgICAvLyBUaGVzZSB0d28gY29udHJvbCBwb2ludHMgYXJlIG5vdCB1c2VkIGluIHRoZSBhcHByb3hpbWF0aW9uIG9mIHRoZSBhcmMsIHRoYXQgaXMgd2h5IHRoZXkgYXJlIHJlbW92ZWRcclxuICAgIGFyY1NlZ1BvaW50c1swXVswXSA9IGFyY1NlZ1BvaW50c1swXVsxXS5jbG9uZSgpO1xyXG4gICAgYXJjU2VnUG9pbnRzW2FyY1NlZ1BvaW50cy5sZW5ndGgtMV1bMl0gPSBhcmNTZWdQb2ludHNbYXJjU2VnUG9pbnRzLmxlbmd0aC0xXVsxXS5jbG9uZSgpO1xyXG5cclxuICAgIC8vIFJldmVydCB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCB3YXMgYXBwbGllZCB0byBtYWtlIHRoZSBhcmMgcGFydCBvZiBhIHVuaXQgY2lyY2xlIGluc3RlYWQgb2YgYW4gZWxsaXBzZVxyXG4gICAgbWF0ID0gbmV3IFNWRy5NYXRyaXgoKS5yb3RhdGUoeEF4aXNSb3RhdGlvbikuc2NhbGUocngsIHJ5KS5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG4gICAgZm9yIChpID0gMCwgaWwgPSBhcmNTZWdQb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICBhcmNTZWdQb2ludHNbaV1bMF0gPSBhcmNTZWdQb2ludHNbaV1bMF0udHJhbnNmb3JtKG1hdCk7XHJcbiAgICAgIGFyY1NlZ1BvaW50c1tpXVsxXSA9IGFyY1NlZ1BvaW50c1tpXVsxXS50cmFuc2Zvcm0obWF0KTtcclxuICAgICAgYXJjU2VnUG9pbnRzW2ldWzJdID0gYXJjU2VnUG9pbnRzW2ldWzJdLnRyYW5zZm9ybShtYXQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDb252ZXJ0IHRoZSBzZWdtZW50cyBwb2ludHMgdG8gU1ZHIGN1cnZlIGNvbW1hbmRzXHJcbiAgICBmb3IgKGkgPSAxLCBpbCA9IGFyY1NlZ1BvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIHB0ID0gYXJjU2VnUG9pbnRzW2ktMV1bMl07XHJcbiAgICAgIHgxID0gcHQueDtcclxuICAgICAgeTEgPSBwdC55O1xyXG5cclxuICAgICAgcHQgPSBhcmNTZWdQb2ludHNbaV1bMF07XHJcbiAgICAgIHgyID0gcHQueDtcclxuICAgICAgeTIgPSBwdC55O1xyXG5cclxuICAgICAgcHQgPSBhcmNTZWdQb2ludHNbaV1bMV07XHJcbiAgICAgIHggPSBwdC54O1xyXG4gICAgICB5ID0gcHQueTtcclxuXHJcbiAgICAgIHJldFZhbC5wdXNoKFsnQycsIHgxLCB5MSwgeDIsIHkyLCB4LCB5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldFZhbFxyXG59XHJcbn0oKSk7XG5cbi8qISBzdmcuZHJhZ2dhYmxlLmpzIC0gdjIuMi4xIC0gMjAxNi0wOC0yNVxyXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS93b3V0L3N2Zy5kcmFnZ2FibGUuanNcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTYgV291dCBGaWVyZW5zOyBMaWNlbnNlZCBNSVQgKi9cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAvLyBjcmVhdGVzIGhhbmRsZXIsIHNhdmVzIGl0XHJcbiAgZnVuY3Rpb24gRHJhZ0hhbmRsZXIoZWwpe1xyXG4gICAgZWwucmVtZW1iZXIoJ19kcmFnZ2FibGUnLCB0aGlzKTtcclxuICAgIHRoaXMuZWwgPSBlbDtcclxuICB9XHJcblxyXG5cclxuICAvLyBTZXRzIG5ldyBwYXJhbWV0ZXIsIHN0YXJ0cyBkcmFnZ2luZ1xyXG4gIERyYWdIYW5kbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY29uc3RyYWludCwgdmFsKXtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcclxuICAgIHRoaXMuZWwub24oJ21vdXNlZG93bi5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLnN0YXJ0KGUpOyB9KTtcclxuICAgIHRoaXMuZWwub24oJ3RvdWNoc3RhcnQuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5zdGFydChlKTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gdHJhbnNmb3JtcyBvbmUgcG9pbnQgZnJvbSBzY3JlZW4gdG8gdXNlciBjb29yZHNcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbihldmVudCwgb2Zmc2V0KXtcclxuICAgICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gfHwgZXZlbnQ7XHJcbiAgICAgIHRoaXMucC54ID0gdG91Y2hlcy5wYWdlWCAtIChvZmZzZXQgfHwgMCk7XHJcbiAgICAgIHRoaXMucC55ID0gdG91Y2hlcy5wYWdlWTtcclxuICAgICAgcmV0dXJuIHRoaXMucC5tYXRyaXhUcmFuc2Zvcm0odGhpcy5tKVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gZ2V0cyBlbGVtZW50cyBib3VuZGluZyBib3ggd2l0aCBzcGVjaWFsIGhhbmRsaW5nIG9mIGdyb3VwcywgbmVzdGVkIGFuZCB1c2VcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuZ2V0QkJveCA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIGJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIGlmKHRoaXMuZWwgaW5zdGFuY2VvZiBTVkcuTmVzdGVkKSBib3ggPSB0aGlzLmVsLnJib3goKTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuZWwgaW5zdGFuY2VvZiBTVkcuRyB8fCB0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLlVzZSB8fCB0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLk5lc3RlZCkge1xyXG4gICAgICBib3gueCA9IHRoaXMuZWwueCgpO1xyXG4gICAgICBib3gueSA9IHRoaXMuZWwueSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBib3hcclxuICB9O1xyXG5cclxuICAvLyBzdGFydCBkcmFnZ2luZ1xyXG4gIERyYWdIYW5kbGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGUpe1xyXG5cclxuICAgIC8vIGNoZWNrIGZvciBsZWZ0IGJ1dHRvblxyXG4gICAgaWYoZS50eXBlID09ICdjbGljayd8fCBlLnR5cGUgPT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09ICdtb3VzZW1vdmUnKXtcclxuICAgICAgaWYoKGUud2hpY2ggfHwgZS5idXR0b25zKSAhPSAxKXtcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIC8vIGZpcmUgYmVmb3JlZHJhZyBldmVudFxyXG4gICAgdGhpcy5lbC5maXJlKCdiZWZvcmVkcmFnJywgeyBldmVudDogZSwgaGFuZGxlcjogdGhpcyB9KTtcclxuXHJcbiAgICAvLyBzZWFyY2ggZm9yIHBhcmVudCBvbiB0aGUgZmx5IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gY2FsbFxyXG4gICAgLy8gZHJhZ2dhYmxlKCkgZXZlbiB3aGVuIGVsZW1lbnQgaXMgbm90IGluIHRoZSBkb20gY3VycmVudGx5XHJcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuZWwucGFyZW50KFNWRy5OZXN0ZWQpIHx8IHRoaXMuZWwucGFyZW50KFNWRy5Eb2MpO1xyXG4gICAgdGhpcy5wID0gdGhpcy5wYXJlbnQubm9kZS5jcmVhdGVTVkdQb2ludCgpO1xyXG5cclxuICAgIC8vIHNhdmUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIHRoaXMubSA9IHRoaXMuZWwubm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCk7XHJcblxyXG4gICAgdmFyIGJveCA9IHRoaXMuZ2V0QkJveCgpO1xyXG4gICAgXHJcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xyXG4gICAgXHJcbiAgICAvLyBmaXggdGV4dC1hbmNob3IgaW4gdGV4dC1lbGVtZW50ICgjMzcpXHJcbiAgICBpZih0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLlRleHQpe1xyXG4gICAgICBhbmNob3JPZmZzZXQgPSB0aGlzLmVsLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XHJcbiAgICAgICAgXHJcbiAgICAgIHN3aXRjaCh0aGlzLmVsLmF0dHIoJ3RleHQtYW5jaG9yJykpe1xyXG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XHJcbiAgICAgICAgICBhbmNob3JPZmZzZXQgLz0gMjtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuc3RhcnRQb2ludHMgPSB7XHJcbiAgICAgIC8vIFdlIHRha2UgYWJzb2x1dGUgY29vcmRpbmF0ZXMgc2luY2Ugd2UgYXJlIGp1c3QgdXNpbmcgYSBkZWx0YSBoZXJlXHJcbiAgICAgIHBvaW50OiB0aGlzLnRyYW5zZm9ybVBvaW50KGUsIGFuY2hvck9mZnNldCksXHJcbiAgICAgIGJveDogICBib3gsXHJcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5lbC50cmFuc2Zvcm0oKVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gYWRkIGRyYWcgYW5kIGVuZCBldmVudHMgdG8gd2luZG93XHJcbiAgICBTVkcub24od2luZG93LCAnbW91c2Vtb3ZlLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZHJhZyhlKTsgfSk7XHJcbiAgICBTVkcub24od2luZG93LCAndG91Y2htb3ZlLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZHJhZyhlKTsgfSk7XHJcbiAgICBTVkcub24od2luZG93LCAnbW91c2V1cC5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmVuZChlKTsgfSk7XHJcbiAgICBTVkcub24od2luZG93LCAndG91Y2hlbmQuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSk7IH0pO1xyXG5cclxuICAgIC8vIGZpcmUgZHJhZ3N0YXJ0IGV2ZW50XHJcbiAgICB0aGlzLmVsLmZpcmUoJ2RyYWdzdGFydCcsIHtldmVudDogZSwgcDogdGhpcy5zdGFydFBvaW50cy5wb2ludCwgbTogdGhpcy5tLCBoYW5kbGVyOiB0aGlzfSk7XHJcblxyXG4gICAgLy8gcHJldmVudCBicm93c2VyIGRyYWcgYmVoYXZpb3JcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBwcmV2ZW50IHByb3BhZ2F0aW9uIHRvIGEgcGFyZW50IHRoYXQgbWlnaHQgYWxzbyBoYXZlIGRyYWdnaW5nIGVuYWJsZWRcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gd2hpbGUgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuZHJhZyA9IGZ1bmN0aW9uKGUpe1xyXG5cclxuICAgIHZhciBib3ggPSB0aGlzLmdldEJCb3goKVxyXG4gICAgICAsIHAgICA9IHRoaXMudHJhbnNmb3JtUG9pbnQoZSlcclxuICAgICAgLCB4ICAgPSB0aGlzLnN0YXJ0UG9pbnRzLmJveC54ICsgcC54IC0gdGhpcy5zdGFydFBvaW50cy5wb2ludC54XHJcbiAgICAgICwgeSAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueSArIHAueSAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueVxyXG4gICAgICAsIGMgICA9IHRoaXMuY29uc3RyYWludFxyXG4gICAgICAsIGd4ICA9IHAueCAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueFxyXG4gICAgICAsIGd5ICA9IHAueSAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueTtcclxuICAgICAgXHJcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2RyYWdtb3ZlJywge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgICBldmVudDogZVxyXG4gICAgICAgICAgLCBwOiBwXHJcbiAgICAgICAgICAsIG06IHRoaXMubVxyXG4gICAgICAgICAgLCBoYW5kbGVyOiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgICAsIGNhbmNlbGFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgICBcclxuICAgIHRoaXMuZWwuZmlyZShldmVudCk7XHJcbiAgICBcclxuICAgIGlmKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiBwXHJcblxyXG4gICAgLy8gbW92ZSB0aGUgZWxlbWVudCB0byBpdHMgbmV3IHBvc2l0aW9uLCBpZiBwb3NzaWJsZSBieSBjb25zdHJhaW50XHJcbiAgICBpZiAodHlwZW9mIGMgPT0gJ2Z1bmN0aW9uJykge1xyXG5cclxuICAgICAgdmFyIGNvb3JkID0gYy5jYWxsKHRoaXMuZWwsIHgsIHksIHRoaXMubSk7XHJcblxyXG4gICAgICAvLyBib29sLCBqdXN0IHNob3cgdXMgaWYgbW92ZW1lbnQgaXMgYWxsb3dlZCBvciBub3RcclxuICAgICAgaWYgKHR5cGVvZiBjb29yZCA9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBjb29yZCA9IHtcclxuICAgICAgICAgIHg6IGNvb3JkLFxyXG4gICAgICAgICAgeTogY29vcmRcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB0cnVlLCB3ZSBqdXN0IG1vdmUuIElmICFmYWxzZSBpdHMgYSBudW1iZXIgYW5kIHdlIG1vdmUgaXQgdGhlcmVcclxuICAgICAgaWYgKGNvb3JkLnggPT09IHRydWUpIHtcclxuICAgICAgICB0aGlzLmVsLngoeCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29vcmQueCAhPT0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmVsLngoY29vcmQueCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb29yZC55ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5lbC55KHkpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5lbC55KGNvb3JkLnkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgLy8ga2VlcCBlbGVtZW50IHdpdGhpbiBjb25zdHJhaW5lZCBib3hcclxuICAgICAgaWYgKGMubWluWCAhPSBudWxsICYmIHggPCBjLm1pblgpXHJcbiAgICAgICAgeCA9IGMubWluWDtcclxuICAgICAgZWxzZSBpZiAoYy5tYXhYICE9IG51bGwgJiYgeCA+IGMubWF4WCAtIGJveC53aWR0aCl7XHJcbiAgICAgICAgeCA9IGMubWF4WCAtIGJveC53aWR0aDtcclxuICAgICAgfWlmIChjLm1pblkgIT0gbnVsbCAmJiB5IDwgYy5taW5ZKVxyXG4gICAgICAgIHkgPSBjLm1pblk7XHJcbiAgICAgIGVsc2UgaWYgKGMubWF4WSAhPSBudWxsICYmIHkgPiBjLm1heFkgLSBib3guaGVpZ2h0KVxyXG4gICAgICAgIHkgPSBjLm1heFkgLSBib3guaGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICBpZih0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLkcpXHJcbiAgICAgICAgdGhpcy5lbC5tYXRyaXgodGhpcy5zdGFydFBvaW50cy50cmFuc2Zvcm0pLnRyYW5zZm9ybSh7eDpneCwgeTogZ3l9LCB0cnVlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZWwubW92ZSh4LCB5KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gc28gd2UgY2FuIHVzZSBpdCBpbiB0aGUgZW5kLW1ldGhvZCwgdG9vXHJcbiAgICByZXR1cm4gcFxyXG4gIH07XHJcblxyXG4gIERyYWdIYW5kbGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAvLyBmaW5hbCBkcmFnXHJcbiAgICB2YXIgcCA9IHRoaXMuZHJhZyhlKTtcclxuXHJcbiAgICAvLyBmaXJlIGRyYWdlbmQgZXZlbnRcclxuICAgIHRoaXMuZWwuZmlyZSgnZHJhZ2VuZCcsIHsgZXZlbnQ6IGUsIHA6IHAsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpcyB9KTtcclxuXHJcbiAgICAvLyB1bmJpbmQgZXZlbnRzXHJcbiAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNlbW92ZS5kcmFnJyk7XHJcbiAgICBTVkcub2ZmKHdpbmRvdywgJ3RvdWNobW92ZS5kcmFnJyk7XHJcbiAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNldXAuZHJhZycpO1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaGVuZC5kcmFnJyk7XHJcblxyXG4gIH07XHJcblxyXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgIC8vIE1ha2UgZWxlbWVudCBkcmFnZ2FibGVcclxuICAgIC8vIENvbnN0cmFpbnQgbWlnaHQgYmUgYW4gb2JqZWN0IChhcyBkZXNjcmliZWQgaW4gcmVhZG1lLm1kKSBvciBhIGZ1bmN0aW9uIGluIHRoZSBmb3JtIFwiZnVuY3Rpb24gKHgsIHkpXCIgdGhhdCBnZXRzIGNhbGxlZCBiZWZvcmUgZXZlcnkgbW92ZS5cclxuICAgIC8vIFRoZSBmdW5jdGlvbiBjYW4gcmV0dXJuIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0ge3gsIHl9LCB0byB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGJlIG1vdmVkLiBcIkZhbHNlXCIgc2tpcHMgbW92aW5nLCB0cnVlIG1vdmVzIHRvIHJhdyB4LCB5LlxyXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbih2YWx1ZSwgY29uc3RyYWludCkge1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdGhlIHBhcmFtZXRlcnMgYW5kIHJlYXNzaWduIGlmIG5lZWRlZFxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3RyYWludCA9IHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRyYWdIYW5kbGVyID0gdGhpcy5yZW1lbWJlcignX2RyYWdnYWJsZScpIHx8IG5ldyBEcmFnSGFuZGxlcih0aGlzKTtcclxuXHJcbiAgICAgIC8vIFdoZW4gbm8gcGFyYW1ldGVyIGlzIGdpdmVuLCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiB2YWx1ZTtcclxuXHJcbiAgICAgIGlmKHZhbHVlKSBkcmFnSGFuZGxlci5pbml0KGNvbnN0cmFpbnQgfHwge30sIHZhbHVlKTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93bi5kcmFnJyk7XHJcbiAgICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQuZHJhZycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbn0pLmNhbGwodW5kZWZpbmVkKTtcblxuKGZ1bmN0aW9uKCkge1xuXG5mdW5jdGlvbiBTZWxlY3RIYW5kbGVyKGVsKSB7XHJcblxyXG4gICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgZWwucmVtZW1iZXIoJ19zZWxlY3RIYW5kbGVyJywgdGhpcyk7XHJcbiAgICB0aGlzLnBvaW50U2VsZWN0aW9uID0ge2lzU2VsZWN0ZWQ6IGZhbHNlfTtcclxuICAgIHRoaXMucmVjdFNlbGVjdGlvbiA9IHtpc1NlbGVjdGVkOiBmYWxzZX07XHJcblxyXG59XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgdmFyIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIC8vIE1lcmdpbmcgdGhlIGRlZmF1bHRzIGFuZCB0aGUgb3B0aW9ucy1vYmplY3QgdG9nZXRoZXJcclxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5lbC5zZWxlY3RpemUuZGVmYXVsdHMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSB0aGlzLmVsLnNlbGVjdGl6ZS5kZWZhdWx0c1tpXTtcclxuICAgICAgICBpZiAob3B0aW9uc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFyZW50ID0gdGhpcy5lbC5wYXJlbnQoKTtcclxuICAgIHRoaXMubmVzdGVkID0gKHRoaXMubmVzdGVkIHx8IHRoaXMucGFyZW50Lmdyb3VwKCkpO1xyXG4gICAgdGhpcy5uZXN0ZWQubWF0cml4KG5ldyBTVkcuTWF0cml4KHRoaXMuZWwpLnRyYW5zbGF0ZShiYm94LngsIGJib3gueSkpO1xyXG5cclxuICAgIC8vIFdoZW4gZGVlcFNlbGVjdCBpcyBlbmFibGVkIGFuZCB0aGUgZWxlbWVudCBpcyBhIGxpbmUvcG9seWxpbmUvcG9seWdvbiwgZHJhdyBvbmx5IHBvaW50cyBmb3IgbW92aW5nXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBTZWxlY3QgJiYgWydsaW5lJywgJ3BvbHlsaW5lJywgJ3BvbHlnb24nXS5pbmRleE9mKHRoaXMuZWwudHlwZSkgIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RQb2ludHModmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNlbGVjdFJlY3QodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub2JzZXJ2ZSgpO1xyXG4gICAgdGhpcy5jbGVhbnVwKCk7XHJcblxyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuc2VsZWN0UG9pbnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgdGhpcy5wb2ludFNlbGVjdGlvbi5pc1NlbGVjdGVkID0gdmFsdWU7XHJcblxyXG4gICAgLy8gV2hlbiBzZXQgaXMgYWxyZWFkeSB0aGVyZSB3ZSBkb250IGhhdmUgdG8gY3JlYXRlIG9uZVxyXG4gICAgaWYgKHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIG91ciBzZXQgb2YgZWxlbWVudHNcclxuICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0ID0gdGhpcy5wYXJlbnQuc2V0KCk7XHJcbiAgICAvLyBkcmF3IHRoZSBjaXJjbGVzIGFuZCBtYXJrIHRoZSBlbGVtZW50IGFzIHNlbGVjdGVkXHJcbiAgICB0aGlzLmRyYXdDaXJjbGVzKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLy8gY3JlYXRlIHRoZSBwb2ludC1hcnJheSB3aGljaCBjb250YWlucyB0aGUgMiBwb2ludHMgb2YgYSBsaW5lIG9yIHNpbXBseSB0aGUgcG9pbnRzLWFycmF5IG9mIHBvbHlsaW5lL3BvbHlnb25cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuZ2V0UG9pbnRBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZWwuYXJyYXkoKS52YWx1ZU9mKCkubWFwKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHJldHVybiBbZWxbMF0gLSBiYm94LngsIGVsWzFdIC0gYmJveC55XTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLy8gVGhlIGZ1bmN0aW9uIHRvIGRyYXcgdGhlIGNpcmNsZXNcclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuZHJhd0NpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcywgYXJyYXkgPSB0aGlzLmdldFBvaW50QXJyYXkoKTtcclxuXHJcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBvZiBwb2ludHNcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cclxuICAgICAgICB2YXIgY3VycmllZEV2ZW50ID0gKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGV2ID0gZXYgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogZXYucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZXYucGFnZVggfHwgZXYudG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZXYucGFnZVkgfHwgZXYudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVsLmZpcmUoJ3BvaW50Jywge3g6IHgsIHk6IHksIGk6IGssIGV2ZW50OiBldn0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKGkpO1xyXG5cclxuICAgICAgICAvLyBhZGQgZXZlcnkgcG9pbnQgdG8gdGhlIHNldFxyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmFkZChcclxuICAgICAgICAgICAgLy8gYSBjaXJjbGUgd2l0aCBvdXIgY3NzLWNsYXNzZXMgYW5kIGEgdG91Y2hzdGFydC1ldmVudCB3aGljaCBmaXJlcyBvdXIgZXZlbnQgZm9yIG1vdmluZyBwb2ludHNcclxuICAgICAgICAgICAgdGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAuY2VudGVyKGFycmF5W2ldWzBdLCBhcnJheVtpXVsxXSlcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19wb2ludCcpXHJcbiAgICAgICAgICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBjdXJyaWVkRXZlbnQpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGN1cnJpZWRFdmVudClcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8vIGV2ZXJ5IHRpbWUgYSBjaXJjbGUgaXMgbW92ZWQsIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2Ygb3VyIGNpcmNsZVxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQb2ludFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0UG9pbnRBcnJheSgpO1xyXG5cclxuICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5jeCgpID09PSBhcnJheVtpXVswXSAmJiB0aGlzLmN5KCkgPT09IGFycmF5W2ldWzFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jZW50ZXIoYXJyYXlbaV1bMF0sIGFycmF5W2ldWzFdKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUmVjdFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcblxyXG4gICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMCkuYXR0cih7XHJcbiAgICAgICAgd2lkdGg6IGJib3gud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc2V0LmdldCgxKSBpcyBhbHdheXMgaW4gdGhlIHVwcGVyIGxlZnQgY29ybmVyLiBubyBuZWVkIHRvIG1vdmUgaXRcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMikuY2VudGVyKGJib3gud2lkdGgsIDApO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDMpLmNlbnRlcihiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNCkuY2VudGVyKDAsIGJib3guaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNSkuY2VudGVyKGJib3gud2lkdGggLyAyLCAwKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg2KS5jZW50ZXIoYmJveC53aWR0aCwgYmJveC5oZWlnaHQgLyAyKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg3KS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIGJib3guaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg4KS5jZW50ZXIoMCwgYmJveC5oZWlnaHQgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uUG9pbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBvaW50cykge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg5KS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIDIwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgxKS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIDIwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RSZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgdmFyIF90aGlzID0gdGhpcywgYmJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkID0gdmFsdWU7XHJcblxyXG4gICAgLy8gd2hlbiBzZXQgaXMgYWxyZWFkeSBwXHJcbiAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0ID0gdGhpcy5yZWN0U2VsZWN0aW9uLnNldCB8fCB0aGlzLnBhcmVudC5zZXQoKTtcclxuXHJcbiAgICAvLyBoZWxwZXJGdW5jdGlvbiB0byBjcmVhdGUgYSBtb3VzZS1kb3duIGZ1bmN0aW9uIHdoaWNoIHRyaWdnZXJzIHRoZSBldmVudCBzcGVjaWZpZWQgaW4gYGV2ZW50TmFtZWBcclxuICAgIGZ1bmN0aW9uIGdldE1vc2VEb3duRnVuYyhldmVudE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGV2ID0gZXYgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCA/IGV2LnByZXZlbnREZWZhdWx0KCkgOiBldi5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gZXYucGFnZVggfHwgZXYudG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgdmFyIHkgPSBldi5wYWdlWSB8fCBldi50b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICBfdGhpcy5lbC5maXJlKGV2ZW50TmFtZSwge3g6IHgsIHk6IHksIGV2ZW50OiBldn0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3JlYXRlIHRoZSBzZWxlY3Rpb24tcmVjdGFuZ2xlIGFuZCBhZGQgdGhlIGNzcy1jbGFzc1xyXG4gICAgaWYgKCF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgwKSkge1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLnJlY3QoYmJveC53aWR0aCwgYmJveC5oZWlnaHQpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbGFzc1JlY3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEcmF3IFBvaW50cyBhdCB0aGUgZWRnZXMsIGlmIGVuYWJsZWRcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgxKSkge1xyXG4gICAgICAgIHZhciBlbmFtZSA9XCJ0b3VjaHN0YXJ0XCIsIG1uYW1lID0gXCJtb3VzZWRvd25cIjtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKDAsIDApLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19sdCcpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2x0JykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2x0JykpKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKGJib3gud2lkdGgsIDApLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19ydCcpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3J0JykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3J0JykpKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKGJib3gud2lkdGgsIGJib3guaGVpZ2h0KS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcmInKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdyYicpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdyYicpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcigwLCBiYm94LmhlaWdodCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX2xiJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygnbGInKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygnbGInKSkpO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKGJib3gud2lkdGggLyAyLCAwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfdCcpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3QnKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygndCcpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoLCBiYm94LmhlaWdodCAvIDIpLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19yJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygncicpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdyJykpKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKGJib3gud2lkdGggLyAyLCBiYm94LmhlaWdodCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX2InKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdiJykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2InKSkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoMCwgYmJveC5oZWlnaHQgLyAyKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfbCcpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2wnKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygnbCcpKSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoX3RoaXMub3B0aW9ucy5jbGFzc1BvaW50cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZHJhdyByb3RhdGlvblBpbnQsIGlmIGVuYWJsZWRcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRpb25Qb2ludCAmJiAoKHRoaXMub3B0aW9ucy5wb2ludHMgJiYgIXRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDkpKSB8fCAoIXRoaXMub3B0aW9ucy5wb2ludHMgJiYgIXRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDEpKSkpIHtcclxuXHJcbiAgICAgICAgdmFyIGN1cnJpZWRFdmVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogZXYucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZXYucGFnZVkgfHwgZXYudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuZmlyZSgncm90Jywge3g6IHgsIHk6IHksIGV2ZW50OiBldn0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgMjApLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19yb3QnKVxyXG4gICAgICAgICAgICAub24oXCJ0b3VjaHN0YXJ0XCIsIGN1cnJpZWRFdmVudCkub24oXCJtb3VzZWRvd25cIiwgY3VycmllZEV2ZW50KSk7XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuICAgIHRoaXMubmVzdGVkLm1hdHJpeChuZXcgU1ZHLk1hdHJpeCh0aGlzLmVsKS50cmFuc2xhdGUoYmJveC54LCBiYm94LnkpKTtcclxuXHJcbiAgICBpZiAodGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVJlY3RTZWxlY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wb2ludFNlbGVjdGlvbi5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQb2ludFNlbGVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIGlmIChNdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkIHx8IHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdCA9IHRoaXMub2JzZXJ2ZXJJbnN0IHx8IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJJbnN0Lm9ic2VydmUodGhpcy5lbC5ub2RlLCB7YXR0cmlidXRlczogdHJ1ZX0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlckluc3Q7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ0RPTUF0dHJNb2RpZmllZC5zZWxlY3QnKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkIHx8IHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLm9uKCdET01BdHRyTW9kaWZpZWQuc2VsZWN0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBpZiAoIXRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkICYmIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQpIHtcclxuICAgICAgICAvLyBzdG9wIHdhdGNoaW5nIHRoZSBlbGVtZW50LCByZW1vdmUgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuY2xlYXIoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5yZWN0U2VsZWN0aW9uLnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiB0aGlzLnBvaW50U2VsZWN0aW9uLnNldCkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgcG9pbnRzLCBjbGVhciB0aGUgc2V0LCBzdG9wIHdhdGNoaW5nIHRoZSBlbGVtZW50XHJcbiAgICAgICAgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmNsZWFyKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5wb2ludFNlbGVjdGlvbi5pc1NlbGVjdGVkICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgIHRoaXMubmVzdGVkLnJlbW92ZSgpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm5lc3RlZDtcclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gICAgLy8gU2VsZWN0IGVsZW1lbnQgd2l0aCBtb3VzZVxyXG4gICAgc2VsZWN0aXplOiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHBhcmFtZXRlcnMgYW5kIHJlYXNzaWduIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGVjdEhhbmRsZXIgPSB0aGlzLnJlbWVtYmVyKCdfc2VsZWN0SGFuZGxlcicpIHx8IG5ldyBTZWxlY3RIYW5kbGVyKHRoaXMpO1xyXG5cclxuICAgICAgICBzZWxlY3RIYW5kbGVyLmluaXQodmFsdWUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2YWx1ZSwgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxufSk7XHJcblxyXG5TVkcuRWxlbWVudC5wcm90b3R5cGUuc2VsZWN0aXplLmRlZmF1bHRzID0ge1xyXG4gICAgcG9pbnRzOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cnVlLCBwb2ludHMgYXQgdGhlIGVkZ2VzIGFyZSBkcmF3bi4gTmVlZGVkIGZvciByZXNpemUhXHJcbiAgICBjbGFzc1JlY3Q6ICdzdmdfc2VsZWN0X2JvdW5kaW5nUmVjdCcsICAgIC8vIENzcy1jbGFzcyBhZGRlZCB0byB0aGUgcmVjdFxyXG4gICAgY2xhc3NQb2ludHM6ICdzdmdfc2VsZWN0X3BvaW50cycsICAgICAgICAvLyBDc3MtY2xhc3MgYWRkZWQgdG8gdGhlIHBvaW50c1xyXG4gICAgcmFkaXVzOiA3LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYWRpdXMgb2YgdGhlIHBvaW50c1xyXG4gICAgcm90YXRpb25Qb2ludDogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cnVlLCByb3RhdGlvbiBwb2ludCBpcyBkcmF3bi4gTmVlZGVkIGZvciByb3RhdGlvbiFcclxuICAgIGRlZXBTZWxlY3Q6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgbW92aW5nIG9mIHNpbmdsZSBwb2ludHMgaXMgcG9zc2libGUgKG9ubHkgbGluZSwgcG9seWxpbmUsIHBvbHlvbilcclxufTtcbn0oKSk7XG5cbihmdW5jdGlvbigpIHtcbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gUmVzaXplSGFuZGxlcihlbCkge1xyXG5cclxuICAgICAgICBlbC5yZW1lbWJlcignX3Jlc2l6ZUhhbmRsZXInLCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUNhbGwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucCA9IGVsLmRvYygpLm5vZGUuY3JlYXRlU1ZHUG9pbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKHgsIHksIG0pe1xyXG5cclxuICAgICAgICB0aGlzLnAueCA9IHggLSAodGhpcy5vZmZzZXQueCAtIHdpbmRvdy5wYWdlWE9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5wLnkgPSB5IC0gKHRoaXMub2Zmc2V0LnkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wLm1hdHJpeFRyYW5zZm9ybShtIHx8IHRoaXMubSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5fZXh0cmFjdFBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAvLyBFeHRyYWN0IGEgcG9zaXRpb24gZnJvbSBhIG1vdXNlL3RvdWNoIGV2ZW50LlxyXG4gICAgICAgIC8vIFJldHVybnMgeyB4OiAuLiwgeTogLi4gfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggIT0gbnVsbCA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFgsXHJcbiAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgIT0gbnVsbCA/IGV2ZW50LmNsaWVudFkgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdzdG9wJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gTWVyZ2Ugb3B0aW9ucyBhbmQgZGVmYXVsdHNcclxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZWwucmVzaXplLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IHRoaXMuZWwucmVzaXplLmRlZmF1bHRzW2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbaV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBsaXN0ZW4gdG8gYWxsIHRoZXNlIGV2ZW50cyB3aGljaCBhcmUgc3BlY2lmeWluZyBkaWZmZXJlbnQgZWRnZXNcclxuICAgICAgICB0aGlzLmVsLm9uKCdsdC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBMZWZ0LVRvcFxyXG4gICAgICAgIHRoaXMuZWwub24oJ3J0LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgIC8vIFJpZ2h0LVRvcFxyXG4gICAgICAgIHRoaXMuZWwub24oJ3JiLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgIC8vIFJpZ2h0LUJvdHRvbVxyXG4gICAgICAgIHRoaXMuZWwub24oJ2xiLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgIC8vIExlZnQtQm90dG9tXHJcblxyXG4gICAgICAgIHRoaXMuZWwub24oJ3QucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIFRvcFxyXG4gICAgICAgIHRoaXMuZWwub24oJ3IucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIFJpZ2h0XHJcbiAgICAgICAgdGhpcy5lbC5vbignYi5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAgLy8gQm90dG9tXHJcbiAgICAgICAgdGhpcy5lbC5vbignbC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAgLy8gTGVmdFxyXG5cclxuICAgICAgICB0aGlzLmVsLm9uKCdyb3QucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAvLyBSb3RhdGlvblxyXG5cclxuICAgICAgICB0aGlzLmVsLm9uKCdwb2ludC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7IC8vIFBvaW50LU1vdmluZ1xyXG5cclxuICAgICAgICAvLyBUaGlzIGNhbGwgZW5zdXJlcywgdGhhdCB0aGUgcGx1Z2luIHJlYWN0cyB0byBhIGNoYW5nZSBvZiBzbmFwVG9HcmlkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdsdC5yZXNpemUnKTtcclxuICAgICAgICB0aGlzLmVsLm9mZigncnQucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ3JiLnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdsYi5yZXNpemUnKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ3QucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ3IucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ2IucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ2wucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdyb3QucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdwb2ludC5yZXNpemUnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLm0gPSB0aGlzLmVsLm5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0geyB4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB9O1xyXG5cclxuICAgICAgICB2YXIgdHhQdCA9IHRoaXMuX2V4dHJhY3RQb3NpdGlvbihldmVudC5kZXRhaWwuZXZlbnQpO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgdHlwZTogdGhpcy5lbC50eXBlLCAvLyB0aGUgdHlwZSBvZiBlbGVtZW50XHJcbiAgICAgICAgICAgIHA6IHRoaXMudHJhbnNmb3JtUG9pbnQodHhQdC54LCB0eFB0LnkpLFxyXG4gICAgICAgICAgICB4OiBldmVudC5kZXRhaWwueCwgICAgICAvLyB4LXBvc2l0aW9uIG9mIHRoZSBtb3VzZSB3aGVuIHJlc2l6aW5nIHN0YXJ0ZWRcclxuICAgICAgICAgICAgeTogZXZlbnQuZGV0YWlsLnksICAgICAgLy8geS1wb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2hlbiByZXNpemluZyBzdGFydGVkXHJcbiAgICAgICAgICAgIGJveDogdGhpcy5lbC5iYm94KCksICAgIC8vIFRoZSBib3VuZGluZy1ib3ggb2YgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgcm90YXRpb246IHRoaXMuZWwudHJhbnNmb3JtKCkucm90YXRpb24gIC8vIFRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGZvbnQtc2l6ZSBwYXJhbWV0ZXIgaWYgdGhlIGVsZW1lbnQgdHlwZSBpcyB0ZXh0XHJcbiAgICAgICAgaWYgKHRoaXMuZWwudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvbnRTaXplID0gdGhpcy5lbC5hdHRyKClbXCJmb250LXNpemVcIl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGUgaS1wYXJhbSBpbiB0aGUgZXZlbnQgaG9sZHMgdGhlIGluZGV4IG9mIHRoZSBwb2ludCB3aGljaCBpcyBtb3ZlZCwgd2hlbiB1c2luZyBgZGVlcFNlbGVjdGBcclxuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmkgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwb2ludCBhcnJheVxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmVsLmFycmF5KCkudmFsdWVPZigpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgaW5kZXggYW5kIHRoZSBwb2ludCB3aGljaCBpcyBtb3ZlZFxyXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMuaSA9IGV2ZW50LmRldGFpbC5pO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMucG9pbnRDb29yZHMgPSBbYXJyYXlbZXZlbnQuZGV0YWlsLmldWzBdLCBhcnJheVtldmVudC5kZXRhaWwuaV1bMV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTGV0cyBjaGVjayB3aGljaCBlZGdlIG9mIHRoZSBib3VuZGluZy1ib3ggd2FzIGNsaWNrZWQgYW5kIHJlc2l6ZSB0aGUgdGhpcy5lbCBhY2NvcmRpbmcgdG8gdGhpc1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gTGVmdC1Ub3AtRWRnZVxyXG4gICAgICAgICAgICBjYXNlICdsdCc6XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBidWlsZCBhIGNhbGN1bGF0aW5nIGZ1bmN0aW9uIGZvciBldmVyeSBjYXNlIHdoaWNoIGdpdmVzIHVzIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIHRoaXMuZWxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJvY2VkdXJlIGlzIGFsd2F5cyB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHdlIHNuYXAgdGhlIGVkZ2UgdG8gdGhlIGdpdmVuIGdyaWQgKHNuYXBwaW5nIHRvIDFweCBncmlkIGlzIG5vcm1hbCByZXNpemluZylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgd2UgY2hlY2sgaWYgdGhlIG5ldyBoZWlnaHQgYW5kIHdpZHRoIHN0aWxsIHZhbGlkICg+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdID4gMCAmJiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmlmIHZhbGlkLCB3ZSByZXNpemUgdGhlIHRoaXMuZWwgKHdoaWNoIGNhbiBpbmNsdWRlIG1vdmluZyBiZWNhdXNlIHRoZSBjb29yZC1zeXN0ZW0gc3RhcnRzIGF0IHRoZSBsZWZ0LXRvcCBhbmQgdGhpcyBlZGdlIGlzIG1vdmluZyBzb21ldGltZXMgd2hlbiByZXNpemVkKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogYnV0IGZpcnN0IGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHRleHQgYm94LCBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBmb250IHNpemUgaW5zdGVhZCBvZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5hdHRyKFwiZm9udC1zaXplXCIsIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSAtIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwID0gdGhpcy5jaGVja0FzcGVjdFJhdGlvKHNuYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3gueSArIHNuYXBbMV0pLnNpemUodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gUmlnaHQtVG9wXHJcbiAgICAgICAgICAgIGNhc2UgJ3J0JzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDEgPDwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdID4gMCAmJiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5hdHRyKFwiZm9udC1zaXplXCIsIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwID0gdGhpcy5jaGVja0FzcGVjdFJhdGlvKHNuYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55ICsgc25hcFsxXSkuc2l6ZSh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBSaWdodC1Cb3R0b21cclxuICAgICAgICAgICAgY2FzZSAncmInOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdID4gMCAmJiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5hdHRyKFwiZm9udC1zaXplXCIsIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwID0gdGhpcy5jaGVja0FzcGVjdFJhdGlvKHNuYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIExlZnQtQm90dG9tXHJcbiAgICAgICAgICAgIGNhc2UgJ2xiJzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgLSBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLnNpemUodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0ICsgc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gVG9wXHJcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMSA8PCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBmb250LXJlc2l6aW5nIGlmIGl0IGlzIG5vdCBmcm9tIHRoZSBjb3JuZXIgb2YgYm91bmRpbmctYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55ICsgc25hcFsxXSkuaGVpZ2h0KHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gUmlnaHRcclxuICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS53aWR0aCh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gQm90dG9tXHJcbiAgICAgICAgICAgIGNhc2UgJ2InOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0ICsgc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54LCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLmhlaWdodCh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIExlZnRcclxuICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3gueSkud2lkdGgodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdGF0aW9uXHJcbiAgICAgICAgICAgIGNhc2UgJ3JvdCc6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHllcyB0aGlzIGlzIGtpbmRhIHN0dXBpZCBidXQgd2UgbmVlZCB0aGUgbW91c2UgY29vcmRzIGJhY2suLi5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHt4OiBkaWZmWCArIHRoaXMucGFyYW1ldGVycy5wLngsIHk6IGRpZmZZICsgdGhpcy5wYXJhbWV0ZXJzLnAueX07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG1pbnVzIG1pZGRsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzQW5nbGUgPSBNYXRoLmF0YW4yKCh0aGlzLnBhcmFtZXRlcnMucC55IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC55IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLyAyKSwgKHRoaXMucGFyYW1ldGVycy5wLnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC8gMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgbWludXMgbWlkZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBBbmdsZSA9IE1hdGguYXRhbjIoKGN1cnJlbnQueSAtIHRoaXMucGFyYW1ldGVycy5ib3gueSAtIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC8gMiksIChjdXJyZW50LnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LnggLSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC8gMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAocEFuZ2xlIC0gc0FuZ2xlKSAqIDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbW92ZSB0aGUgZWxlbWVudCB0byB0aGUgY2VudGVyIG9mIHRoZSBib3ggZmlyc3QgYW5kIGNoYW5nZSB0aGUgcm90YXRpb24gYWZ0ZXJ3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugcm90YXRpb24gYWx3YXlzIHdvcmtzIGFyb3VuZCBhIHJvdGF0aW9uLWNlbnRlciwgd2hpY2ggaXMgY2hhbmdlZCB3aGVuIG1vdmluZyB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gc2V0IHRoZSBuZXcgcm90YXRpb24gY2VudGVyIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGJveC5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmNlbnRlcih0aGlzLnBhcmFtZXRlcnMuYm94LmN4LCB0aGlzLnBhcmFtZXRlcnMuYm94LmN5KS5yb3RhdGUodGhpcy5wYXJhbWV0ZXJzLnJvdGF0aW9uICsgYW5nbGUgLSBhbmdsZSAlIHRoaXMub3B0aW9ucy5zbmFwVG9BbmdsZSwgdGhpcy5wYXJhbWV0ZXJzLmJveC5jeCwgdGhpcy5wYXJhbWV0ZXJzLmJveC5jeSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBNb3Zpbmcgb25lIHNpbmdsZSBQb2ludCAobmVlZGVkIHdoZW4gYW4gZWxlbWVudCBpcyBkZWVwU2VsZWN0ZWQgd2hpY2ggbWVhbnMgeW91IGNhbiBtb3ZlIGV2ZXJ5IHNpbmdsZSBwb2ludCBvZiB0aGUgb2JqZWN0KVxyXG4gICAgICAgICAgICBjYXNlICdwb2ludCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBwaW5nIHRoZSBwb2ludCB0byB0aGUgZ3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzWzBdLCB0aGlzLnBhcmFtZXRlcnMucG9pbnRDb29yZHNbMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvaW50IGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5lbC5hcnJheSgpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIG1vdmVkIHBvaW50IGluIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3RoaXMucGFyYW1ldGVycy5pXVswXSA9IHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1swXSArIHNuYXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbdGhpcy5wYXJhbWV0ZXJzLmldWzFdID0gdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzWzFdICsgc25hcFsxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHBsb3QgdGhlIG5ldyB0aGlzLmVsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5wbG90KGFycmF5KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmVsLmZpcmUoJ3Jlc2l6ZXN0YXJ0Jywge2R4OiB0aGlzLnBhcmFtZXRlcnMueCwgZHk6IHRoaXMucGFyYW1ldGVycy55LCBldmVudDogZXZlbnR9KTtcclxuICAgICAgICAvLyBXaGVuIHJlc2l6aW5nIHN0YXJ0ZWQsIHdlIGhhdmUgdG8gcmVnaXN0ZXIgZXZlbnRzIGZvci4uLlxyXG4gICAgICAgIC8vIFRvdWNoZXMuXHJcbiAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNobW92ZS5yZXNpemUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZShlIHx8IHdpbmRvdy5ldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNoZW5kLnJlc2l6ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5kb25lKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTW91c2UuXHJcbiAgICAgICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNlbW92ZS5yZXNpemUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGUoZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICdtb3VzZXVwLnJlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhlIHVwZGF0ZS1mdW5jdGlvbiByZWRyYXdzIHRoZSBlbGVtZW50IGV2ZXJ5IHRpbWUgdGhlIG1vdXNlIGlzIG1vdmluZ1xyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFVwZGF0ZUNhbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyh0aGlzLmxhc3RVcGRhdGVDYWxsWzBdLCB0aGlzLmxhc3RVcGRhdGVDYWxsWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbW91c2Vwb3NpdGlvbiBhdCBzdGFydCBhbmQgbm93XHJcbiAgICAgICAgdmFyIHR4UHQgPSB0aGlzLl9leHRyYWN0UG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICAgIHZhciBwID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh0eFB0LngsIHR4UHQueSk7XHJcblxyXG4gICAgICAgIHZhciBkaWZmWCA9IHAueCAtIHRoaXMucGFyYW1ldGVycy5wLngsXHJcbiAgICAgICAgICAgIGRpZmZZID0gcC55IC0gdGhpcy5wYXJhbWV0ZXJzLnAueTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlQ2FsbCA9IFtkaWZmWCwgZGlmZlldO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiBhbmQgaGVpZ2h0IC8gd2lkdGggb2YgdGhlIGVsZW1lbnRcclxuICAgICAgICB0aGlzLmNhbGMoZGlmZlgsIGRpZmZZKTtcclxuXHJcbiAgICAgICAvLyBFbWl0IGFuIGV2ZW50IHRvIHNheSB3ZSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemluZycsIHtkeDogZGlmZlgsIGR5OiBkaWZmWSwgZXZlbnQ6IGV2ZW50fSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIElzIGNhbGxlZCBvbiBtb3VzZXVwLlxyXG4gICAgLy8gUmVtb3ZlcyB0aGUgdXBkYXRlLWZ1bmN0aW9uIGZyb20gdGhlIG1vdXNlbW92ZSBldmVudFxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVDYWxsID0gbnVsbDtcclxuICAgICAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNlbW92ZS5yZXNpemUnKTtcclxuICAgICAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNldXAucmVzaXplJyk7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUucmVzaXplJyk7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaGVuZC5yZXNpemUnKTtcclxuICAgICAgICB0aGlzLmVsLmZpcmUoJ3Jlc2l6ZWRvbmUnKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhlIGZsYWcgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgcmVzaXppbmcgaXMgdXNlZCB3aXRoIGEgbGVmdC1Qb2ludCAoZmlyc3QgYml0KSBhbmQgdG9wLXBvaW50IChzZWNvbmQgYml0KVxyXG4gICAgLy8gSW4gdGhpcyBjYXNlcyB0aGUgdGVtcC12YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZGlmZmVyZW50bHlcclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnNuYXBUb0dyaWQgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZLCBmbGFnLCBwb2ludENvb3Jkc1kpIHtcclxuXHJcbiAgICAgICAgdmFyIHRlbXA7XHJcblxyXG4gICAgICAgIC8vIElmIGBwb2ludENvb3Jkc1lgIGlzIGdpdmVuLCBhIHNpbmdsZSBQb2ludCBoYXMgdG8gYmUgc25hcHBlZCAoZGVlcFNlbGVjdCkuIFRoYXQncyB3aHkgd2UgbmVlZCBhIGRpZmZlcmVudCB0ZW1wLXZhbHVlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBwb2ludENvb3Jkc1kgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmbGFnID0gcG9pbnRDb29yZHNYIGluIHRoaXMgY2FzZVxyXG4gICAgICAgICAgICB0ZW1wID0gWyhmbGFnICsgZGlmZlgpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQsIChwb2ludENvb3Jkc1kgKyBkaWZmWSkgJSB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2UgY2hlY2sgaWYgdGhlIGZsYWcgaXMgc2V0IGFuZCBpZiBub3Qgd2Ugc2V0IGEgZGVmYXVsdC12YWx1ZSAoYm90aCBiaXRzIHNldCAtIHdoaWNoIG1lYW5zIHVwcGVyLWxlZnQtZWRnZSlcclxuICAgICAgICAgICAgZmxhZyA9IGZsYWcgPT0gbnVsbCA/IDEgfCAxIDw8IDEgOiBmbGFnO1xyXG4gICAgICAgICAgICB0ZW1wID0gWyh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBkaWZmWCArIChmbGFnICYgMSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoKSkgJSB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCwgKHRoaXMucGFyYW1ldGVycy5ib3gueSArIGRpZmZZICsgKGZsYWcgJiAoMSA8PCAxKSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWRdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGRpZmZYIC09IChNYXRoLmFicyh0ZW1wWzBdKSA8IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkIC8gMiA/XHJcbiAgICAgICAgICAgICAgICAgIHRlbXBbMF0gOlxyXG4gICAgICAgICAgICAgICAgICB0ZW1wWzBdIC0gKGRpZmZYIDwgMCA/IC10aGlzLm9wdGlvbnMuc25hcFRvR3JpZCA6IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkKSk7XHJcbiAgICAgICAgZGlmZlkgLT0gKE1hdGguYWJzKHRlbXBbMV0pIDwgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQgLyAyID9cclxuICAgICAgICAgICAgICAgICAgdGVtcFsxXSA6XHJcbiAgICAgICAgICAgICAgICAgIHRlbXBbMV0gLSAoZGlmZlkgPCAwID8gLXRoaXMub3B0aW9ucy5zbmFwVG9HcmlkIDogdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludFRvQm94KGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJhaW50VG9Cb3ggPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZLCBmbGFnLCBwb2ludENvb3Jkc1kpIHtcclxuICAgICAgICAvL3JldHVybiBbZGlmZlgsIGRpZmZZXVxyXG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLmNvbnN0cmFpbnQgfHwge307XHJcbiAgICAgICAgdmFyIG9yZ1gsIG9yZ1k7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRDb29yZHNZICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgb3JnWCA9IGZsYWc7XHJcbiAgICAgICAgICBvcmdZID0gcG9pbnRDb29yZHNZO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvcmdYID0gdGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgKGZsYWcgJiAxID8gMCA6IHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGgpO1xyXG4gICAgICAgICAgb3JnWSA9IHRoaXMucGFyYW1ldGVycy5ib3gueSArIChmbGFnICYgKDE8PDEpID8gMCA6IHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYy5taW5YICE9PSAndW5kZWZpbmVkJyAmJiBvcmdYICsgZGlmZlggPCBjLm1pblgpIHtcclxuICAgICAgICAgIGRpZmZYID0gYy5taW5YIC0gb3JnWDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYy5tYXhYICE9PSAndW5kZWZpbmVkJyAmJiBvcmdYICsgZGlmZlggPiBjLm1heFgpIHtcclxuICAgICAgICAgIGRpZmZYID0gYy5tYXhYIC0gb3JnWDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYy5taW5ZICE9PSAndW5kZWZpbmVkJyAmJiBvcmdZICsgZGlmZlkgPCBjLm1pblkpIHtcclxuICAgICAgICAgIGRpZmZZID0gYy5taW5ZIC0gb3JnWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYy5tYXhZICE9PSAndW5kZWZpbmVkJyAmJiBvcmdZICsgZGlmZlkgPiBjLm1heFkpIHtcclxuICAgICAgICAgIGRpZmZZID0gYy5tYXhZIC0gb3JnWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbZGlmZlgsIGRpZmZZXTtcclxuICAgIH07XHJcblxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuY2hlY2tBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIChzbmFwKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZUFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVwZGF0ZWRTbmFwID0gc25hcC5zbGljZSgpO1xyXG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLyB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodDtcclxuICAgICAgICB2YXIgbmV3VyA9IHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdO1xyXG4gICAgICAgIHZhciBuZXdIID0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdO1xyXG4gICAgICAgIHZhciBuZXdBc3BlY3RSYXRpbyA9IG5ld1cgLyBuZXdIO1xyXG5cclxuICAgICAgICBpZiAobmV3QXNwZWN0UmF0aW8gPCBhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICAvLyBIZWlnaHQgaXMgdG9vIGJpZy4gQWRhcHQgaXRcclxuICAgICAgICAgICAgdXBkYXRlZFNuYXBbMV0gPSBuZXdXIC8gYXNwZWN0UmF0aW8gLSB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodDtcclxuICAgICAgICB9IGVsc2UgaWYgKG5ld0FzcGVjdFJhdGlvID4gYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgLy8gV2lkdGggaXMgdG9vIGJpZy4gQWRhcHQgaXRcclxuICAgICAgICAgICAgdXBkYXRlZFNuYXBbMF0gPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gbmV3SCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRTbmFwO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gICAgICAgIC8vIFJlc2l6ZSBlbGVtZW50IHdpdGggbW91c2VcclxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAodGhpcy5yZW1lbWJlcignX3Jlc2l6ZUhhbmRsZXInKSB8fCBuZXcgUmVzaXplSGFuZGxlcih0aGlzKSkuaW5pdChvcHRpb25zIHx8IHt9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgU1ZHLkVsZW1lbnQucHJvdG90eXBlLnJlc2l6ZS5kZWZhdWx0cyA9IHtcclxuICAgICAgICBzbmFwVG9BbmdsZTogMC4xLCAgICAgICAvLyBTcGVjaWZpZXMgdGhlIHNwZWVkIHRoZSByb3RhdGlvbiBpcyBoYXBwZW5pbmcgd2hlbiBtb3ZpbmcgdGhlIG1vdXNlXHJcbiAgICAgICAgc25hcFRvR3JpZDogMSwgICAgICAgICAgLy8gU25hcHMgdG8gYSBncmlkIG9mIGBzbmFwVG9HcmlkYCBQaXhlbHNcclxuICAgICAgICBjb25zdHJhaW50OiB7fSwgICAgICAgICAvLyBrZWVwIGVsZW1lbnQgd2l0aGluIGNvbnN0cmFpbmVkIGJveFxyXG4gICAgICAgIHNhdmVBc3BlY3RSYXRpbzogZmFsc2UgIC8vIFNhdmUgYXNwZWN0IHJhdGlvIHdoZW4gcmVzaXppbmcgdXNpbmcgbHQsIHJ0LCByYiBvciBsYiBwb2ludHNcclxuICAgIH07XHJcblxyXG59KS5jYWxsKHRoaXMpO1xufSgpKTtcblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzID0gXCIuYXBleGNoYXJ0cy1jYW52YXMge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAvKiBjYW5ub3QgZ2l2ZSBvdmVyZmxvdzogaGlkZGVuIGFzIGl0IHdpbGwgY3JvcCB0b29sdGlwcyB3aGljaCBvdmVyZmxvdyBvdXRzaWRlIGNoYXJ0IGFyZWEgKi9cXG59XFxuXFxuLyogc2Nyb2xsYmFyIGlzIG5vdCB2aXNpYmxlIGJ5IGRlZmF1bHQgZm9yIGxlZ2VuZCwgaGVuY2UgZm9yY2luZyB0aGUgdmlzaWJpbGl0eSAqL1xcbi5hcGV4Y2hhcnRzLWNhbnZhcyA6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIHdpZHRoOiA2cHg7XFxufVxcbi5hcGV4Y2hhcnRzLWNhbnZhcyA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsLjUpO1xcbiAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDI1NSwyNTUsMjU1LC41KTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDI1NSwyNTUsMjU1LC41KTtcXG59XFxuXFxuLmFwZXhjaGFydHMtaW5uZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4ubGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZSB7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG4gIG9wYWNpdHk6IDAuMjA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFwZXhjaGFydHMtZ3JpZGxpbmUsIC5hcGV4Y2hhcnRzLXRleHQge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAge1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm94LXNoYWRvdzogMnB4IDJweCA2cHggLTRweCAjOTk5O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgbGVmdDogNjJweDtcXG4gIG9wYWNpdHk6IDA7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMjBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgei1pbmRleDogMTI7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC5saWdodCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTNlM2UzO1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk2KTtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC5kYXJrIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgYmFja2dyb3VuZDogcmdiYSgzMCwzMCwzMCwgMC44KTtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcCAqIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwIC5hcGV4Y2hhcnRzLW1hcmtlcixcXG4uYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1hcmVhLFxcbi5hcGV4Y2hhcnRzLWxpbmUge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10aXRsZSB7XFxuICBwYWRkaW5nOiA2cHg7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBtYXJnaW4tYm90dG9tOiA0cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAubGlnaHQgLmFwZXhjaGFydHMtdG9vbHRpcC10aXRsZSB7XFxuICBiYWNrZ3JvdW5kOiAjRUNFRkYxO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuZGFyayAuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43KTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMjIyO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtdmFsdWUsXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotdmFsdWUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LWxhYmVsOmVtcHR5LFxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlOmVtcHR5IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC12YWx1ZSwgXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXotdmFsdWUge1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1tYXJrZXIge1xcbiAgd2lkdGg6IDEycHg7XFxuICBoZWlnaHQ6IDEycHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDBweDtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAge1xcbiAgcGFkZGluZzogMCAxMHB4O1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGxlZnQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cC5hY3RpdmUgLmFwZXhjaGFydHMtdG9vbHRpcC1tYXJrZXIge1xcbiAgb3BhY2l0eTogMTtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAuYWN0aXZlLCAuYXBleGNoYXJ0cy10b29sdGlwLXNlcmllcy1ncm91cDpsYXN0LWNoaWxkIHtcXG4gIHBhZGRpbmctYm90dG9tOiA0cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAteS1ncm91cCB7XFxuICBwYWRkaW5nOiA2cHggMCA1cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtY2FuZGxlc3RpY2sge1xcbiAgcGFkZGluZzogNHB4IDhweDtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC1jYW5kbGVzdGljayA+IGRpdiB7XFxuICBtYXJnaW46IDRweCAwO1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLWNhbmRsZXN0aWNrIHNwYW4udmFsdWUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgcGFkZGluZzogOXB4IDEwcHg7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGNvbG9yOiAjMzczZDNmO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTA7XFxuXFx0YmFja2dyb3VuZDogI0VDRUZGMTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5MEE0QUU7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmFmdGVyLCAuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHRsZWZ0OiA1MCU7XFxuXFx0Ym9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG5cXHRjb250ZW50OiBcXFwiIFxcXCI7XFxuXFx0aGVpZ2h0OiAwO1xcblxcdHdpZHRoOiAwO1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmFmdGVyIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMjM2LCAyMzksIDI0MSwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA2cHg7XFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcDpiZWZvcmUge1xcblxcdGJvcmRlci1jb2xvcjogcmdiYSgxNDQsIDE2NCwgMTc0LCAwKTtcXG5cXHRib3JkZXItd2lkdGg6IDdweDtcXG5cXHRtYXJnaW4tbGVmdDogLTdweDtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTphZnRlciwgLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcbiAgYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tOmFmdGVyIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNFQ0VGRjE7XFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICM5MEE0QUU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YWZ0ZXIsIC5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YmVmb3JlIHtcXG4gIHRvcDogMTAwJTtcXG59XFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcDphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjRUNFRkYxO1xcbn1cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmJlZm9yZSB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjOTBBNEFFO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwIHtcXG4gIG9wYWNpdHk6IDA7XFxuICBwYWRkaW5nOiA0cHggMTBweDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgY29sb3I6ICMzNzNkM2Y7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMDtcXG5cXHRiYWNrZ3JvdW5kOiAjRUNFRkYxO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzkwQTRBRTtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmFmdGVyLCAuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHR0b3A6IDUwJTtcXG5cXHRib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcblxcdGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG5cXHRoZWlnaHQ6IDA7XFxuXFx0d2lkdGg6IDA7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YWZ0ZXIge1xcblxcdGJvcmRlci1jb2xvcjogcmdiYSgyMzYsIDIzOSwgMjQxLCAwKTtcXG5cXHRib3JkZXItd2lkdGg6IDZweDtcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMTQ0LCAxNjQsIDE3NCwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA3cHg7XFxuXFx0bWFyZ2luLXRvcDogLTdweDtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YWZ0ZXIsIC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxuICBsZWZ0OiAxMDAlO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdDphZnRlciB7XFxuICBib3JkZXItbGVmdC1jb2xvcjogI0VDRUZGMTtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YmVmb3JlIHtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiAjOTBBNEFFO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YWZ0ZXIsIC5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcbiAgcmlnaHQ6IDEwMCU7XFxufVxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDphZnRlciB7XFxuICBib3JkZXItcmlnaHQtY29sb3I6ICNFQ0VGRjE7XFxufVxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjOTBBNEFFO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhjcm9zc2hhaXJzLCAuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuLmFwZXhjaGFydHMteGNyb3NzaGFpcnMuYWN0aXZlLCAuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy5hY3RpdmUge1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbS1yZWN0IHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24tcmVjdCB7XFxuICBjdXJzb3I6IG1vdmU7XFxufVxcblxcbi5zdmdfc2VsZWN0X3BvaW50cywgLnN2Z19zZWxlY3RfcG9pbnRzX3JvdCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG4uc3ZnX3NlbGVjdF9wb2ludHNfbCwgLnN2Z19zZWxlY3RfcG9pbnRzX3Ige1xcbiAgY3Vyc29yOiBldy1yZXNpemU7XFxuICBvcGFjaXR5OiAxO1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIGZpbGw6ICM4ODg7XFxufVxcbi5hcGV4Y2hhcnRzLWNhbnZhcy56b29tYWJsZSAuaG92ZXJpbmctem9vbSB7XFxuICBjdXJzb3I6IGNyb3NzaGFpclxcbn1cXG4uYXBleGNoYXJ0cy1jYW52YXMuem9vbWFibGUgLmhvdmVyaW5nLXBhbiB7XFxuICBjdXJzb3I6IG1vdmVcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXMsXFxuLmFwZXhjaGFydHMteWF4aXMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20taWNvbiwgXFxuLmFwZXhjaGFydHMtem9vbS1pbi1pY29uLFxcbi5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb24sXFxuLmFwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uLCBcXG4uYXBleGNoYXJ0cy1wYW4taWNvbiwgXFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24sXFxuLmFwZXhjaGFydHMtbWVudS1pY29uLCBcXG4uYXBleGNoYXJ0cy10b29sYmFyLWN1c3RvbS1pY29uIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDI0cHg7XFxuICBjb2xvcjogIzZFODE5MjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbS1pY29uIHN2ZywgXFxuLmFwZXhjaGFydHMtem9vbS1pbi1pY29uIHN2ZyxcXG4uYXBleGNoYXJ0cy16b29tLW91dC1pY29uIHN2ZyxcXG4uYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24gc3ZnLFxcbi5hcGV4Y2hhcnRzLW1lbnUtaWNvbiBzdmcge1xcbiAgZmlsbDogIzZFODE5MjtcXG59XFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24gc3ZnIHtcXG4gIGZpbGw6ICM0NDQ7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuNzYpXFxufVxcbi5hcGV4Y2hhcnRzLXpvb20taWNvbi5zZWxlY3RlZCBzdmcsIFxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uLnNlbGVjdGVkIHN2ZywgXFxuLmFwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uLnNlbGVjdGVkIHN2ZyB7XFxuICBmaWxsOiAjMDA4RkZCO1xcbn1cXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24taWNvbjpub3QoLnNlbGVjdGVkKTpob3ZlciBzdmcsXFxuLmFwZXhjaGFydHMtem9vbS1pY29uOm5vdCguc2VsZWN0ZWQpOmhvdmVyIHN2ZywgXFxuLmFwZXhjaGFydHMtem9vbS1pbi1pY29uOmhvdmVyIHN2ZywgXFxuLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbjpob3ZlciBzdmcsIFxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbjpob3ZlciBzdmcsIFxcbi5hcGV4Y2hhcnRzLW1lbnUtaWNvbjpob3ZlciBzdmcge1xcbiAgZmlsbDogIzMzMztcXG59XFxuXFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb24sIC5hcGV4Y2hhcnRzLW1lbnUtaWNvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiB7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbn1cXG4uYXBleGNoYXJ0cy16b29tLWljb24sIC5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiwgLmFwZXhjaGFydHMtbWVudS1pY29uIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC44NSk7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20taW4taWNvbiwgLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbiB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuNylcXG59XFxuXFxuLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbiB7XFxuICBtYXJnaW4tcmlnaHQ6IDNweDtcXG59XFxuXFxuLmFwZXhjaGFydHMtcGFuLWljb24ge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjYyKTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDFweDtcXG4gIHRvcDogMHB4O1xcbn1cXG4uYXBleGNoYXJ0cy1wYW4taWNvbiBzdmcge1xcbiAgZmlsbDogI2ZmZjtcXG4gIHN0cm9rZTogIzZFODE5MjtcXG4gIHN0cm9rZS13aWR0aDogMjtcXG59XFxuLmFwZXhjaGFydHMtcGFuLWljb24uc2VsZWN0ZWQgc3ZnIHtcXG4gIHN0cm9rZTogIzAwOEZGQjtcXG59XFxuLmFwZXhjaGFydHMtcGFuLWljb246bm90KC5zZWxlY3RlZCk6aG92ZXIgc3ZnIHtcXG4gIHN0cm9rZTogIzMzMztcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbGJhciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxMTtcXG4gIHRvcDogMHB4O1xcbiAgcmlnaHQ6IDNweDtcXG4gIG1heC13aWR0aDogMTc2cHg7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIHBhZGRpbmc6IDBweCA2cHggMnB4IDZweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyOyBcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbGJhciBzdmcge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTAwJTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAzcHg7XFxuICByaWdodDogMTBweDtcXG4gIG9wYWNpdHk6IDA7XFxuICBtaW4td2lkdGg6IDExMHB4O1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmFwZXhjaGFydHMtbWVudS5vcGVuIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUtaXRlbSB7XFxuICBwYWRkaW5nOiA2cHggN3B4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uYXBleGNoYXJ0cy1tZW51LWl0ZW06aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gIC5hcGV4Y2hhcnRzLXRvb2xiYXIge1xcbiAgICAvKm9wYWNpdHk6IDA7Ki9cXG4gIH1cXG5cXG4gIC5hcGV4Y2hhcnRzLWNhbnZhczpob3ZlciAuYXBleGNoYXJ0cy10b29sYmFyIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH0gXFxufVxcblxcbi5hcGV4Y2hhcnRzLWRhdGFsYWJlbC5oaWRkZW4ge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFwZXhjaGFydHMtcGllLWxhYmVsLFxcbi5hcGV4Y2hhcnRzLWRhdGFsYWJlbCwgLmFwZXhjaGFydHMtZGF0YWxhYmVsLWxhYmVsLCAuYXBleGNoYXJ0cy1kYXRhbGFiZWwtdmFsdWUge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXBpZS1sYWJlbC1kZWxheSB7XFxuICBvcGFjaXR5OiAwO1xcbiAgYW5pbWF0aW9uLW5hbWU6IG9wYXF1ZTtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXG59XFxuXFxuLmFwZXhjaGFydHMtY2FudmFzIC5oaWRkZW4ge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXFxuLmFwZXhjaGFydHMtaGlkZSAuYXBleGNoYXJ0cy1zZXJpZXMtcG9pbnRzIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWFyZWEtc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzIC5hcGV4Y2hhcnRzLW1hcmtlci5uby1wb2ludGVyLWV2ZW50cyxcXG4uYXBleGNoYXJ0cy1saW5lLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXIubm8tcG9pbnRlci1ldmVudHMsIC5hcGV4Y2hhcnRzLXJhZGFyLXNlcmllcyBwYXRoLCAuYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMgcG9seWdvbiB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLyogbWFya2VycyAqL1xcblxcbi5hcGV4Y2hhcnRzLW1hcmtlciB7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuQGtleWZyYW1lcyBvcGFxdWUge1xcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxufVwiO1xuc3R5bGVJbmplY3QoY3NzKTtcblxuLypcbiAqIGNsYXNzTGlzdC5qczogQ3Jvc3MtYnJvd3NlciBmdWxsIGVsZW1lbnQuY2xhc3NMaXN0IGltcGxlbWVudGF0aW9uLlxuICogMS4yLjIwMTcxMjEwXG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogTGljZW5zZTogRGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluLlxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXG5pZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcbiAgLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxuICAvLyBJbmNsdWRpbmcgSUUgPCBFZGdlIG1pc3NpbmcgU1ZHRWxlbWVudC5jbGFzc0xpc3RcbiAgaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIikpKSB7XG4gICAgKGZ1bmN0aW9uICh2aWV3KSB7XG5cbiAgICAgIGlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCIsXG4gICAgICAgICAgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIixcbiAgICAgICAgICBlbGVtQ3RyUHJvdG8gPSB2aWV3LkVsZW1lbnRbcHJvdG9Qcm9wXSxcbiAgICAgICAgICBvYmpDdHIgPSBPYmplY3QsXG4gICAgICAgICAgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcbiAgICAgIH0sXG4gICAgICAgICAgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IC8vIFZlbmRvcnM6IHBsZWFzZSBhbGxvdyBjb250ZW50IGNvZGUgdG8gaW5zdGFudGlhdGUgRE9NRXhjZXB0aW9uc1xuICAgICAgLFxuICAgICAgICAgIERPTUV4ID0gZnVuY3Rpb24gRE9NRXgodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9LFxuICAgICAgICAgIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIGNoZWNrVG9rZW5BbmRHZXRJbmRleChjbGFzc0xpc3QsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeChcIlNZTlRBWF9FUlJcIiwgXCJUaGUgdG9rZW4gbXVzdCBub3QgYmUgZW1wdHkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9cXHMvLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4KFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCIsIFwiVGhlIHRva2VuIG11c3Qgbm90IGNvbnRhaW4gc3BhY2UgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xuICAgICAgfSxcbiAgICAgICAgICBDbGFzc0xpc3QgPSBmdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgICAgICB2YXIgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKSxcbiAgICAgICAgICAgIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gY2xhc3Nlcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMucHVzaChjbGFzc2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgICAgIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXSxcbiAgICAgICAgICBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiBjbGFzc0xpc3RHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xhc3NMaXN0KHRoaXMpO1xuICAgICAgfTsgLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuICAgICAgLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXG5cblxuICAgICAgRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xuICAgICAgfTtcblxuICAgICAgY2xhc3NMaXN0UHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIH5jaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4gKyBcIlwiKTtcbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuXG4gICAgICAgICAgaWYgKCF+Y2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKytpIDwgbCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2xhc3NMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgdXBkYXRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgaW5kZXg7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcbiAgICAgICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cbiAgICAgICAgICB3aGlsZSAofmluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pLFxuICAgICAgICAgICAgbWV0aG9kID0gcmVzdWx0ID8gZm9yY2UgIT09IHRydWUgJiYgXCJyZW1vdmVcIiA6IGZvcmNlICE9PSBmYWxzZSAmJiBcImFkZFwiO1xuXG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICB0aGlzW21ldGhvZF0odG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmb3JjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2xhc3NMaXN0UHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uICh0b2tlbiwgcmVwbGFjZW1lbnRfdG9rZW4pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRva2VuICsgXCJcIik7XG5cbiAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxLCByZXBsYWNlbWVudF90b2tlbik7XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG4gICAgICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXIsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcbiAgICAgICAgICAvLyBhZGRpbmcgdW5kZWZpbmVkIHRvIGZpZ2h0IHRoaXMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2lzc3Vlcy8zNlxuICAgICAgICAgIC8vIG1vZGVybmllIElFOC1NU1c3IG1hY2hpbmUgaGFzIElFOCA4LjAuNjAwMS4xODcwMiBhbmQgaXMgYWZmZWN0ZWRcbiAgICAgICAgICBpZiAoZXgubnVtYmVyID09PSB1bmRlZmluZWQgfHwgZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgICAgIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XG4gICAgICB9XG4gICAgfSkoc2VsZik7XG4gIH0gLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXG4gIC8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXG5cblxuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIik7XG4gICAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7IC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXG4gICAgLy8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXG5cbiAgICBpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XG4gICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gY3JlYXRlTWV0aG9kKG1ldGhvZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XG5cbiAgICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY3JlYXRlTWV0aG9kKCdhZGQnKTtcbiAgICAgIGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTsgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxuICAgIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cblxuICAgIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xuICAgICAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcblxuICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgICAgIGlmICgxIGluIGFyZ3VtZW50cyAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xuICAgICAgICAgIHJldHVybiBmb3JjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIHJlcGxhY2UoKSBwb2x5ZmlsbFxuXG5cbiAgICBpZiAoIShcInJlcGxhY2VcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKS5jbGFzc0xpc3QpKSB7XG4gICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAodG9rZW4sIHJlcGxhY2VtZW50X3Rva2VuKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgICAgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih0b2tlbiArIFwiXCIpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlLmFwcGx5KHRoaXMsIHRva2Vucyk7XG4gICAgICAgICAgdGhpcy5hZGQocmVwbGFjZW1lbnRfdG9rZW4pO1xuICAgICAgICAgIHRoaXMuYWRkLmFwcGx5KHRoaXMsIHRva2Vucy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGVzdEVsZW1lbnQgPSBudWxsO1xuICB9KSgpO1xufVxuXG4vKipcbiogRGV0ZWN0IEVsZW1lbnQgUmVzaXplXG4qXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9zZGVjaW1hL2phdmFzY3JpcHQtZGV0ZWN0LWVsZW1lbnQtcmVzaXplXG4qIFNlYmFzdGlhbiBEZWNpbWFcbipcbiogdmVyc2lvbjogMC41LjNcbioqL1xuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0eWxlc0NyZWF0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiByZXNldFRyaWdnZXJzKGVsZW1lbnQpIHtcbiAgICB2YXIgdHJpZ2dlcnMgPSBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXyxcbiAgICAgICAgZXhwYW5kID0gdHJpZ2dlcnMuZmlyc3RFbGVtZW50Q2hpbGQsXG4gICAgICAgIGNvbnRyYWN0ID0gdHJpZ2dlcnMubGFzdEVsZW1lbnRDaGlsZCxcbiAgICAgICAgZXhwYW5kQ2hpbGQgPSBleHBhbmQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgY29udHJhY3Quc2Nyb2xsTGVmdCA9IGNvbnRyYWN0LnNjcm9sbFdpZHRoO1xuICAgIGNvbnRyYWN0LnNjcm9sbFRvcCA9IGNvbnRyYWN0LnNjcm9sbEhlaWdodDtcbiAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9IGV4cGFuZC5vZmZzZXRXaWR0aCArIDEgKyAncHgnO1xuICAgIGV4cGFuZENoaWxkLnN0eWxlLmhlaWdodCA9IGV4cGFuZC5vZmZzZXRIZWlnaHQgKyAxICsgJ3B4JztcbiAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IGV4cGFuZC5zY3JvbGxXaWR0aDtcbiAgICBleHBhbmQuc2Nyb2xsVG9wID0gZXhwYW5kLnNjcm9sbEhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrVHJpZ2dlcnMoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFdpZHRoICE9IGVsZW1lbnQuX19yZXNpemVMYXN0X18ud2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgIT0gZWxlbWVudC5fX3Jlc2l6ZUxhc3RfXy5oZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgIHJlc2V0VHJpZ2dlcnModGhpcyk7XG4gICAgaWYgKHRoaXMuX19yZXNpemVSQUZfXykgY2FuY2VsRnJhbWUodGhpcy5fX3Jlc2l6ZVJBRl9fKTtcbiAgICB0aGlzLl9fcmVzaXplUkFGX18gPSByZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNoZWNrVHJpZ2dlcnMoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxhc3RfXy53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVMYXN0X18uaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgZm4uY2FsbChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHlsZXMoKSB7XG4gICAgaWYgKCFzdHlsZXNDcmVhdGVkKSB7XG4gICAgICAvLyBvcGFjaXR5OjAgd29ya3MgYXJvdW5kIGEgY2hyb21lIGJ1ZyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mjg2MzYwXG4gICAgICB2YXIgY3NzID0gKGFuaW1hdGlvbktleWZyYW1lcyB8fCAnJykgKyAnLnJlc2l6ZS10cmlnZ2VycyB7ICcgKyAoYW5pbWF0aW9uU3R5bGUgfHwgJycpICsgJ3Zpc2liaWxpdHk6IGhpZGRlbjsgb3BhY2l0eTogMDsgfSAnICsgJy5yZXNpemUtdHJpZ2dlcnMsIC5yZXNpemUtdHJpZ2dlcnMgPiBkaXYsIC5jb250cmFjdC10cmlnZ2VyOmJlZm9yZSB7IGNvbnRlbnQ6IFxcXCIgXFxcIjsgZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlOyBvdmVyZmxvdzogaGlkZGVuOyB9IC5yZXNpemUtdHJpZ2dlcnMgPiBkaXYgeyBiYWNrZ3JvdW5kOiAjZWVlOyBvdmVyZmxvdzogYXV0bzsgfSAuY29udHJhY3QtdHJpZ2dlcjpiZWZvcmUgeyB3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlOyB9JyxcbiAgICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgIH1cblxuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICBzdHlsZXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVxdWVzdEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMjApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gcmFmKGZuKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGNhbmNlbEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5jZWwgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBjYW5jZWwoaWQpO1xuICAgIH07XG4gIH0oKTtcbiAgLyogRGV0ZWN0IENTUyBBbmltYXRpb25zIHN1cHBvcnQgdG8gZGV0ZWN0IGVsZW1lbnQgZGlzcGxheS9yZS1hdHRhY2ggKi9cblxuXG4gIHZhciBhbmltYXRpb24gPSBmYWxzZSxcbiAgICAgIGtleWZyYW1lcHJlZml4ID0gJycsXG4gICAgICBhbmltYXRpb25zdGFydGV2ZW50ID0gJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICAgIGRvbVByZWZpeGVzID0gJ1dlYmtpdCBNb3ogTyBtcycuc3BsaXQoJyAnKSxcbiAgICAgIHN0YXJ0RXZlbnRzID0gJ3dlYmtpdEFuaW1hdGlvblN0YXJ0IGFuaW1hdGlvbnN0YXJ0IG9BbmltYXRpb25TdGFydCBNU0FuaW1hdGlvblN0YXJ0Jy5zcGxpdCgnICcpLFxuICAgICAgcGZ4ID0gJyc7XG4gIHtcbiAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmFrZWVsZW1lbnQnKTtcblxuICAgIGlmIChlbG0uc3R5bGUuYW5pbWF0aW9uTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmltYXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbG0uc3R5bGVbZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwZnggPSBkb21QcmVmaXhlc1tpXTtcbiAgICAgICAgICBrZXlmcmFtZXByZWZpeCA9ICctJyArIHBmeC50b0xvd2VyQ2FzZSgpICsgJy0nO1xuICAgICAgICAgIGFuaW1hdGlvbnN0YXJ0ZXZlbnQgPSBzdGFydEV2ZW50c1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgYW5pbWF0aW9uTmFtZSA9ICdyZXNpemVhbmltJztcbiAgdmFyIGFuaW1hdGlvbktleWZyYW1lcyA9ICdAJyArIGtleWZyYW1lcHJlZml4ICsgJ2tleWZyYW1lcyAnICsgYW5pbWF0aW9uTmFtZSArICcgeyBmcm9tIHsgb3BhY2l0eTogMDsgfSB0byB7IG9wYWNpdHk6IDA7IH0gfSAnO1xuICB2YXIgYW5pbWF0aW9uU3R5bGUgPSBrZXlmcmFtZXByZWZpeCArICdhbmltYXRpb246IDFtcyAnICsgYW5pbWF0aW9uTmFtZSArICc7ICc7XG5cbiAgd2luZG93LmFkZFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZuKSB7XG4gICAgaWYgKCFlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXykge1xuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT0gJ3N0YXRpYycpIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgY3JlYXRlU3R5bGVzKCk7XG4gICAgICBlbGVtZW50Ll9fcmVzaXplTGFzdF9fID0ge307XG4gICAgICBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18gPSBbXTtcbiAgICAgIChlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKS5jbGFzc05hbWUgPSAncmVzaXplLXRyaWdnZXJzJztcbiAgICAgIGVsZW1lbnQuX19yZXNpemVUcmlnZ2Vyc19fLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZXhwYW5kLXRyaWdnZXJcIj48ZGl2PjwvZGl2PjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNvbnRyYWN0LXRyaWdnZXJcIj48L2Rpdj4nO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXyk7XG4gICAgICByZXNldFRyaWdnZXJzKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAvKiBMaXN0ZW4gZm9yIGEgY3NzIGFuaW1hdGlvbiB0byBkZXRlY3QgZWxlbWVudCBkaXNwbGF5L3JlLWF0dGFjaCAqL1xuXG4gICAgICBhbmltYXRpb25zdGFydGV2ZW50ICYmIGVsZW1lbnQuX19yZXNpemVUcmlnZ2Vyc19fLmFkZEV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uc3RhcnRldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYW5pbWF0aW9uTmFtZSA9PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgcmVzZXRUcmlnZ2VycyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLnB1c2goZm4pO1xuICB9O1xuXG4gIHdpbmRvdy5yZW1vdmVSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBmbikge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18uc3BsaWNlKGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5pbmRleE9mKGZuKSwgMSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18gPSAhZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxud2luZG93LkFwZXggPSB7fTtcbi8qKlxuICpcbiAqIEBtb2R1bGUgQXBleENoYXJ0c1xuICoqL1xuXG52YXIgQXBleENoYXJ0cyQxID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXBleENoYXJ0cyhlbCwgb3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGV4Q2hhcnRzKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jdHggPSB0aGlzOyAvLyBQYXNzIHRoZSB1c2VyIHN1cHBsaWVkIG9wdGlvbnMgdG8gdGhlIEJhc2UgQ2xhc3Mgd2hlcmUgdGhlc2Ugb3B0aW9ucyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMuIFRoZSByZXR1cm5lZCBvYmplY3QgZnJvbSBCYXNlIENsYXNzIHdpbGwgYmVjb21lIHRoZSBjb25maWcgb2JqZWN0IGluIHRoZSBlbnRpcmUgY29kZWJhc2UuXG5cbiAgICB0aGlzLncgPSBuZXcgQmFzZShvcHRzKS5pbml0KCk7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMudy5nbG9iYWxzLmN1aWQgPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCk7XG4gICAgdGhpcy53Lmdsb2JhbHMuY2hhcnRJRCA9IHRoaXMudy5jb25maWcuY2hhcnQuaWQgPyB0aGlzLncuY29uZmlnLmNoYXJ0LmlkIDogdGhpcy53Lmdsb2JhbHMuY3VpZDtcbiAgICB0aGlzLmluaXRNb2R1bGVzKCk7XG4gICAgdGhpcy5jcmVhdGUgPSBVdGlscy5iaW5kKHRoaXMuY3JlYXRlLCB0aGlzKTtcbiAgICB0aGlzLndpbmRvd1Jlc2l6ZUhhbmRsZXIgPSB0aGlzLndpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBtZXRob2QgdXNlciB3aWxsIGNhbGwgdG8gcmVuZGVyIHRoZSBjaGFydC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQXBleENoYXJ0cywgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIG1haW4gbWV0aG9kXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9ubHkgZHJhdyBjaGFydCwgaWYgZWxlbWVudCBmb3VuZFxuICAgICAgICBpZiAoX3RoaXMuZWwgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIEFwZXguX2NoYXJ0SW5zdGFuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgQXBleC5fY2hhcnRJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXMudy5jb25maWcuY2hhcnQuaWQpIHtcbiAgICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogX3RoaXMudy5nbG9iYWxzLmNoYXJ0SUQsXG4gICAgICAgICAgICAgIGdyb3VwOiBfdGhpcy53LmNvbmZpZy5jaGFydC5ncm91cCxcbiAgICAgICAgICAgICAgY2hhcnQ6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHNldCB0aGUgbG9jYWxlIGhlcmVcblxuXG4gICAgICAgICAgX3RoaXMuc2V0TG9jYWxlKF90aGlzLncuY29uZmlnLmNoYXJ0LmRlZmF1bHRMb2NhbGUpO1xuXG4gICAgICAgICAgdmFyIGJlZm9yZU1vdW50ID0gX3RoaXMudy5jb25maWcuY2hhcnQuZXZlbnRzLmJlZm9yZU1vdW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmVmb3JlTW91bnQoX3RoaXMsIF90aGlzLncpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmZpcmVFdmVudCgnYmVmb3JlTW91bnQnLCBbX3RoaXMsIF90aGlzLnddKTtcblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdGhpcy53aW5kb3dSZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICB3aW5kb3cuYWRkUmVzaXplTGlzdGVuZXIoX3RoaXMuZWwucGFyZW50Tm9kZSwgX3RoaXMucGFyZW50UmVzaXplQ2FsbGJhY2suYmluZChfdGhpcykpO1xuXG4gICAgICAgICAgdmFyIGdyYXBoRGF0YSA9IF90aGlzLmNyZWF0ZShfdGhpcy53LmNvbmZpZy5zZXJpZXMsIHt9KTtcblxuICAgICAgICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm4gcmVzb2x2ZShfdGhpcyk7XG5cbiAgICAgICAgICBfdGhpcy5tb3VudChncmFwaERhdGEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShncmFwaERhdGEpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5tb3VudGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIF90aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5tb3VudGVkKF90aGlzLCBfdGhpcy53KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuZmlyZUV2ZW50KCdtb3VudGVkJywgW190aGlzLCBfdGhpcy53XSk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTsgLy8gaGFuZGxlIGVycm9yIGluIGNhc2Ugbm8gZGF0YSBvciBlbGVtZW50IG5vdCBmb3VuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdE1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE1vZHVsZXMoKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmFubm90YXRpb25zID0gbmV3IEFubm90YXRpb25zKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY29yZSA9IG5ldyBDb3JlKHRoaXMuZWwsIHRoaXMpO1xuICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQodGhpcyk7XG4gICAgICB0aGlzLmNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcyk7XG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcoe30pO1xuICAgICAgdGhpcy5jcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuICAgICAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IG5ldyBSZXNwb25zaXZlKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnRoZW1lID0gbmV3IFRoZW1lKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuZm9ybWF0dGVycyA9IG5ldyBGb3JtYXR0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMudGl0bGVTdWJ0aXRsZSA9IG5ldyBUaXRsZVN1YnRpdGxlKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgVG9vbGJhcih0aGlzLmN0eCk7XG4gICAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnpvb21QYW5TZWxlY3Rpb24gPSBuZXcgWm9vbVBhblNlbGVjdGlvbih0aGlzLmN0eCk7XG4gICAgICB0aGlzLncuZ2xvYmFscy50b29sdGlwID0gbmV3IFRvb2x0aXAodGhpcy5jdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobmFtZSQkMSwgaGFuZGxlcikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0ucHVzaChoYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0gPSBbaGFuZGxlcl07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lJCQxLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gdy5nbG9iYWxzLmV2ZW50c1tuYW1lJCQxXS5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVFdmVudChuYW1lJCQxLCBhcmdzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZXZlbnRzLmhhc093blByb3BlcnR5KG5hbWUkJDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhcmdzIHx8ICFhcmdzLmxlbmd0aCkge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBldnMgPSB3Lmdsb2JhbHMuZXZlbnRzW25hbWUkJDFdO1xuICAgICAgdmFyIGwgPSBldnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBldnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoc2VyLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMuaW5pdE1vZHVsZXMoKTtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgZ2wubm9EYXRhID0gZmFsc2U7XG4gICAgICBnbC5hbmltYXRpb25FbmRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXNwb25zaXZlLmNoZWNrUmVzcG9uc2l2ZUNvbmZpZyhvcHRzKTtcblxuICAgICAgaWYgKHRoaXMuZWwgPT09IG51bGwpIHtcbiAgICAgICAgZ2wuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlLnNldHVwRWxlbWVudHMoKTtcblxuICAgICAgaWYgKGdsLnN2Z1dpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiwgc2tpcCBkcmF3aW5nXG4gICAgICAgIGdsLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21ibyA9IENvcmVVdGlscy5jaGVja0NvbWJvU2VyaWVzKHNlcik7XG4gICAgICBnbC5jb21ib0NoYXJ0cyA9IGNvbWJvLmNvbWJvQ2hhcnRzO1xuICAgICAgZ2wuY29tYm9DaGFydHNIYXNCYXJzID0gY29tYm8uY29tYm9DaGFydHNIYXNCYXJzO1xuXG4gICAgICBpZiAoc2VyLmxlbmd0aCA9PT0gMCB8fCBzZXIubGVuZ3RoID09PSAxICYmIHNlclswXS5kYXRhICYmIHNlclswXS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcmllcy5oYW5kbGVOb0RhdGEoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuY29yZS5wYXJzZURhdGEoc2VyKTsgLy8gdGhpcyBpcyBhIGdvb2QgdGltZSB0byBzZXQgdGhlbWUgY29sb3JzIGZpcnN0XG5cbiAgICAgIHRoaXMudGhlbWUuaW5pdCgpOyAvLyBsYWJlbEZvcm1hdHRlcnMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgZGltZW5zaW9ucyBhcyBpbiBkaW1lbnNpb25zIHdlIG5lZWQgdGV4dCBsYWJlbHMgd2lkdGhcbiAgICAgIC8vIGFzIG1hcmtlcnMgYWNjZXB0cyBhcnJheSwgd2UgbmVlZCB0byBzZXR1cCBnbG9iYWwgbWFya2VycyBmb3IgZWFzaWVyIGFjY2Vzc1xuXG4gICAgICB2YXIgbWFya2VycyA9IG5ldyBNYXJrZXJzKHRoaXMpO1xuICAgICAgbWFya2Vycy5zZXRHbG9iYWxNYXJrZXJTaXplKCk7XG4gICAgICB0aGlzLmZvcm1hdHRlcnMuc2V0TGFiZWxGb3JtYXR0ZXJzKCk7XG4gICAgICB0aGlzLnRpdGxlU3VidGl0bGUuZHJhdygpOyAvLyBsZWdlbmQgaXMgY2FsY3VsYXRlZCBoZXJlIGJlZm9yZSBjb3JlQ2FsY3VsYXRpb25zIGJlY2F1c2UgaXQgYWZmZWN0cyB0aGUgcGxvdHRhYmxlIGFyZWFcblxuICAgICAgdGhpcy5sZWdlbmQuaW5pdCgpOyAvLyBjaGVjayB3aGV0aGVyIGluIG11bHRpcGxlIHNlcmllcywgYWxsIHNlcmllcyBzaGFyZSB0aGUgc2FtZSBYXG5cbiAgICAgIHRoaXMuc2VyaWVzLmhhc0FsbFNlcmllc0VxdWFsWCgpOyAvLyBjb3JlQ2FsY3VsYXRpb25zIHdpbGwgZ2l2ZSB0aGUgbWluL21heCByYW5nZSBhbmQgeWF4aXMvYXhpcyB2YWx1ZXMuIEl0IHNob3VsZCBiZSBjYWxsZWQgaGVyZSB0byBzZXQgc2VyaWVzIHZhcmlhYmxlIGZyb20gY29uZmlnIHRvIGdsb2JhbHNcblxuICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdGhpcy5jb3JlLmNvcmVDYWxjdWxhdGlvbnMoKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIC8vIGFzIHdlIGhhdmUgbWluWCBhbmQgbWF4WCB2YWx1ZXMsIGRldGVybWluZSB0aGUgZGVmYXVsdCBEYXRlVGltZUZvcm1hdCBmb3IgdGltZSBzZXJpZXNcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlcnMuc2V0TGFiZWxGb3JtYXR0ZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2UgbmVlZCB0byBnZW5lcmF0ZSB5YXhpcyBmb3IgaGVhdG1hcCBzZXBhcmF0ZWx5IGFzIHdlIGFyZSBub3Qgc2hvd2luZyBudW1lcmljcyB0aGVyZSwgYnV0IHNlcmllc05hbWVzLiBUaGVyZSBhcmUgc29tZSB0d2Vha3Mgd2hpY2ggYXJlIHJlcXVpcmVkIGZvciBoZWF0bWFwIHRvIGFsaWduIGxhYmVscyBjb3JyZWN0bHkgd2hpY2ggYXJlIGRvbmUgaW4gYmVsb3cgZnVuY3Rpb25cbiAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBjYWxjdXRpbmcgRGltZW50aW9ucyBwbG90Q29vcmRzKCkgbWV0aG9kIG9mIERpbWVuc2lvbnNcblxuXG4gICAgICB0aGlzLmZvcm1hdHRlcnMuaGVhdG1hcExhYmVsRm9ybWF0dGVycygpOyAvLyBXZSBnb3QgcGxvdHRhYmxlIGFyZWEgaGVyZSwgbmV4dCB0YXNrIHdvdWxkIGJlIHRvIGNhbGN1bGF0ZSBheGlzIGFyZWFzXG5cbiAgICAgIHRoaXMuZGltZW5zaW9ucy5wbG90Q29vcmRzKCk7XG4gICAgICB2YXIgeHlSYXRpb3MgPSB0aGlzLmNvcmUueHlTZXR0aW5ncygpO1xuICAgICAgdGhpcy5ncmlkLmNyZWF0ZUdyaWRNYXNrKCk7XG4gICAgICB2YXIgZWxHcmFwaCA9IHRoaXMuY29yZS5wbG90Q2hhcnRUeXBlKHNlciwgeHlSYXRpb3MpOyAvLyBhZnRlciBhbGwgdGhlIGRyYXdpbmcgY2FsY3VsYXRpb25zLCBzaGlmdCB0aGUgZ3JhcGhpY2FsIGFyZWEgKGFjdHVhbCBjaGFydHMvYmFycykgZXhjbHVkaW5nIGxlZ2VuZHNcblxuICAgICAgdGhpcy5jb3JlLnNoaWZ0R3JhcGhQb3NpdGlvbigpO1xuICAgICAgdmFyIGRpbSA9IHtcbiAgICAgICAgcGxvdDoge1xuICAgICAgICAgIGxlZnQ6IHcuZ2xvYmFscy50cmFuc2xhdGVYLFxuICAgICAgICAgIHRvcDogdy5nbG9iYWxzLnRyYW5zbGF0ZVksXG4gICAgICAgICAgd2lkdGg6IHcuZ2xvYmFscy5ncmlkV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxHcmFwaDogZWxHcmFwaCxcbiAgICAgICAgeHlSYXRpb3M6IHh5UmF0aW9zLFxuICAgICAgICBlbElubmVyOiB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLFxuICAgICAgICBkaW1lbnNpb25zOiBkaW1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIGdyYXBoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgdyA9IG1lLnc7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG5vIGRhdGEgdG8gZGlzcGxheVxuICAgICAgICBpZiAobWUuZWwgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm90IGVub3VnaCBkYXRhIHRvIGRpc3BsYXkgb3IgdGFyZ2V0IGVsZW1lbnQgbm90IGZvdW5kJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyYXBoRGF0YSA9PT0gbnVsbCB8fCB3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgbWUuc2VyaWVzLmhhbmRsZU5vRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY29yZS5kcmF3QXhpcyh3LmNvbmZpZy5jaGFydC50eXBlLCBncmFwaERhdGEueHlSYXRpb3MpO1xuICAgICAgICBtZS5ncmlkID0gbmV3IEdyaWQobWUpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgICBtZS5ncmlkLmRyYXdHcmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuYW5ub3RhdGlvbnMucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgIG1lLmFubm90YXRpb25zLmRyYXdBbm5vdGF0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYXBoRGF0YS5lbEdyYXBoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGdyYXBoRGF0YS5lbEdyYXBoLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChncmFwaERhdGEuZWxHcmFwaFtnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKGdyYXBoRGF0YS5lbEdyYXBoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgbWUuZ3JpZC5kcmF3R3JpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMucG9zaXRpb24gPT09ICdmcm9udCcpIHtcbiAgICAgICAgICBtZS5jcm9zc2hhaXJzLmRyYXdYQ3Jvc3NoYWlycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLmNyb3NzaGFpcnMucG9zaXRpb24gPT09ICdmcm9udCcpIHtcbiAgICAgICAgICBtZS5jcm9zc2hhaXJzLmRyYXdZQ3Jvc3NoYWlycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmFubm90YXRpb25zLnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgbWUuYW5ub3RhdGlvbnMuZHJhd0Fubm90YXRpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXcuZ2xvYmFscy5ub0RhdGEpIHtcbiAgICAgICAgICAvLyBkcmF3IHRvb2x0aXBzIGF0IHRoZSBlbmRcbiAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5lbmFibGVkICYmICF3Lmdsb2JhbHMubm9EYXRhKSB7XG4gICAgICAgICAgICBtZS53Lmdsb2JhbHMudG9vbHRpcC5kcmF3VG9vbHRpcChncmFwaERhdGEueHlSYXRpb3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyAmJiB3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCB8fCB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24gJiYgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLmVuYWJsZWQgfHwgdy5jb25maWcuY2hhcnQucGFuICYmIHcuY29uZmlnLmNoYXJ0LnBhbi5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIG1lLnpvb21QYW5TZWxlY3Rpb24uaW5pdCh7XG4gICAgICAgICAgICAgICAgeHlSYXRpb3M6IGdyYXBoRGF0YS54eVJhdGlvc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvb2xzID0gdy5jb25maWcuY2hhcnQudG9vbGJhci50b29scztcbiAgICAgICAgICAgIHRvb2xzLnpvb20gPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xzLnpvb21pbiA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHMuem9vbW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHMuc2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0b29scy5wYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xzLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnRvb2xiYXIuc2hvdyAmJiAhdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUudG9vbGJhci5jcmVhdGVUb29sYmFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLm1lbW9yeS5tZXRob2RzVG9FeGVjLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmbi5tZXRob2QoZm4ucGFyYW1zLCBmYWxzZSwgZm4uY29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKG1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclByZXZpb3VzUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJQcmV2aW91c1BhdGhzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocyA9IFtdO1xuICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcyA9IFtdO1xuICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzZXJzIHRvIHVwZGF0ZSBPcHRpb25zIGFmdGVyIHRoZSBjaGFydCBoYXMgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgbmV3IGNvbmZpZyBvYmplY3QgY2FuIGJlIHBhc3NlZCB3aGljaCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWRyYXcgLSBzaG91bGQgcmVkcmF3IGZyb20gYmVnaW5uaW5nIG9yIHNob3VsZCB1c2UgZXhpc3RpbmcgcGF0aHMgYW5kIHJlZHJhdyBmcm9tIHRoZXJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gc2hvdWxkIGFuaW1hdGUgb3Igbm90IG9uIHVwZGF0aW5nIE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zJCQxKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBhbmltYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxDb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKG9wdGlvbnMkJDEuc2VyaWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zJCQxLnNlcmllc1swXS5kYXRhKSB7XG4gICAgICAgICAgb3B0aW9ucyQkMS5zZXJpZXMgPSBvcHRpb25zJCQxLnNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCB3LmNvbmZpZy5zZXJpZXNbaV0sIHtcbiAgICAgICAgICAgICAgbmFtZTogcy5uYW1lID8gcy5uYW1lIDogdy5jb25maWcuc2VyaWVzW2ldLm5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6IHMudHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogcy5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyB1c2VyIHVwZGF0ZWQgdGhlIHNlcmllcyB2aWEgdXBkYXRlT3B0aW9ucygpIGZ1bmN0aW9uLlxuICAgICAgICAvLyBIZW5jZSwgd2UgbmVlZCB0byByZXNldCBheGlzIG1pbi9tYXggdG8gYXZvaWQgem9vbWluZyBpc3N1ZXNcblxuXG4gICAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIH0gLy8gdXNlciBoYXMgc2V0IHgtYXhpcyBtaW4vbWF4IGV4dGVybmFsbHkgLSBoZW5jZSB3ZSBuZWVkIHRvIGZvcmNlZnVsbHkgc2V0IHRoZSB4YXhpcyBtaW4vbWF4XG5cblxuICAgICAgaWYgKG9wdGlvbnMkJDEueGF4aXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMkJDEueGF4aXMubWluIHx8IG9wdGlvbnMkJDEueGF4aXMubWF4KSB7XG4gICAgICAgICAgdGhpcy5mb3JjZVhBeGlzVXBkYXRlKG9wdGlvbnMkJDEpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZpeGVzIGFwZXhjaGFydHMuanMjMzY5IGFuZCByZWFjdC1hcGV4Y2hhcnRzIzQ2ICovXG5cblxuICAgICAgICBpZiAob3B0aW9ucyQkMS54YXhpcy5jYXRlZ29yaWVzICYmIG9wdGlvbnMkJDEueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggJiYgdy5jb25maWcueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljKSB7XG4gICAgICAgICAgb3B0aW9ucyQkMSA9IERlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWMob3B0aW9ucyQkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jbGVhclByZXZpb3VzUGF0aHMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU9wdGlvbnMob3B0aW9ucyQkMSwgcmVkcmF3LCBhbmltYXRlLCBvdmVyd3JpdGVJbml0aWFsQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIE9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgbmV3IGNvbmZpZyBvYmplY3QgY2FuIGJlIHBhc3NlZCB3aGljaCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWRyYXcgLSBzaG91bGQgcmVkcmF3IGZyb20gYmVnaW5uaW5nIG9yIHNob3VsZCB1c2UgZXhpc3RpbmcgcGF0aHMgYW5kIHJlZHJhdyBmcm9tIHRoZXJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gc2hvdWxkIGFuaW1hdGUgb3Igbm90IG9uIHVwZGF0aW5nIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZUluaXRpYWxDb25maWcgLSBzaG91bGQgdXBkYXRlIHRoZSBpbml0aWFsIGNvbmZpZyBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVPcHRpb25zKG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciByZWRyYXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbENvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgY2hhcnRzID0gdGhpcy5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgIGNoYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgdyA9IGNoLnc7XG4gICAgICAgIHcuZ2xvYmFscy5zaG91bGRBbmltYXRlID0gYW5pbWF0ZTtcblxuICAgICAgICBpZiAoIXJlZHJhdykge1xuICAgICAgICAgIHcuZ2xvYmFscy5yZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIGNoLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMkJDEgJiYgX3R5cGVvZihvcHRpb25zJCQxKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaC5jb25maWcgPSBuZXcgQ29uZmlnKG9wdGlvbnMkJDEpO1xuICAgICAgICAgIG9wdGlvbnMkJDEgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhjaC5jb25maWcsIG9wdGlvbnMkJDEpO1xuICAgICAgICAgIHcuY29uZmlnID0gVXRpbHMuZXh0ZW5kKHcuY29uZmlnLCBvcHRpb25zJCQxKTtcblxuICAgICAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGZvcmdldCB0aGUgbGFzdFhBeGlzIGFuZCBsYXN0WUF4aXMgaXMgdXNlciBmb3JjZWZ1bGx5IG92ZXJ3cml0ZUluaXRpYWxDb25maWcuIElmIHdlIGRvIG5vdCBkbyB0aGlzLCBhbmQgbmV4dCB0aW1lIHdoZW4gdXNlciB6b29tcyB0aGUgY2hhcnQgYWZ0ZXIgc2V0dGluZyB5YXhpcy5taW4vbWF4IG9yIHhheGlzLm1pbi9tYXggLSB0aGUgc3RvcmVkIGxhc3RYQXhpcyB3aWxsIG5ldmVyIGFsbG93IHRoZSBjaGFydCB0byB1c2UgdGhlIHVwZGF0ZWQgbWluL21heCBieSB1c2VyLlxuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcyA9IFtdO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RZQXhpcyA9IFtdOyAvLyBBZnRlciBmb3JnZXR0aW5nIGxhc3RBeGVzLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIG5ldyBjb25maWcgaW4gaW5pdGlhbENvbmZpZy9pbml0aWFsU2VyaWVzXG5cbiAgICAgICAgICAgIHcuZ2xvYmFscy5pbml0aWFsQ29uZmlnID0gVXRpbHMuZXh0ZW5kKHt9LCB3LmNvbmZpZyk7XG4gICAgICAgICAgICB3Lmdsb2JhbHMuaW5pdGlhbFNlcmllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkody5jb25maWcuc2VyaWVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoLnVwZGF0ZShvcHRpb25zJCQxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNlcnMgdG8gdXBkYXRlIFNlcmllcyBhZnRlciB0aGUgY2hhcnQgaGFzIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gc2VyaWVzIC0gTmV3IHNlcmllcyB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNlcmllcygpIHtcbiAgICAgIHZhciBuZXdTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgb3ZlcndyaXRlSW5pdGlhbFNlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlLCBvdmVyd3JpdGVJbml0aWFsU2VyaWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzZXJzIHRvIGFwcGVuZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgdGhlIGNoYXJ0IGhhcyByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld1NlcmllIC0gTmV3IHNlcmllIHdoaWNoIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGV4aXN0aW5nIHNlcmllc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFNlcmllcyhuZXdTZXJpZSkge1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgbmV3U2VyaWVzID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuc2xpY2UoKTtcbiAgICAgIG5ld1Nlcmllcy5wdXNoKG5ld1NlcmllKTtcbiAgICAgIHRoaXMucmV2ZXJ0RGVmYXVsdEF4aXNNaW5NYXgoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTZXJpZXMobmV3U2VyaWVzLCBhbmltYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIFNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHNlcmllcyAtIE5ldyBzZXJpZXMgd2hpY2ggd2lsbCBvdmVycmlkZSB0aGUgZXhpc3RpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVNlcmllcyhuZXdTZXJpZXMsIGFuaW1hdGUpIHtcbiAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy53Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICB3Lmdsb2JhbHMuZGF0YUNoYW5nZWQgPSB0cnVlOyAvLyBpZiB1c2VyIGhhcyBjb2xsYXBzZWQgc29tZSBzZXJpZXMgd2l0aCBsZWdlbmQsIHdlIG5lZWQgdG8gY2xlYXIgdGhvc2VcblxuICAgICAgaWYgKHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleGlzdGluZ1NlcmllczsgLy8gYXhpcyBjaGFydHNcblxuICAgICAgaWYgKG5ld1Nlcmllc1swXS5kYXRhKSB7XG4gICAgICAgIGV4aXN0aW5nU2VyaWVzID0gbmV3U2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCB3LmNvbmZpZy5zZXJpZXNbaV0sIHtcbiAgICAgICAgICAgIG5hbWU6IHMubmFtZSA/IHMubmFtZSA6IHcuY29uZmlnLnNlcmllc1tpXS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogcy50eXBlLFxuICAgICAgICAgICAgZGF0YTogcy5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBleGlzdGluZ1NlcmllcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbi1heGlzIGNoYXJ0IChwaWUvcmFkaWFsYmFyKVxuICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpIHtcbiAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxDb25maWcuc2VyaWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh3LmNvbmZpZy5zZXJpZXMpKTtcbiAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHcuY29uZmlnLnNlcmllcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjaGFydHMgaW4gdGhlIHNhbWUgXCJncm91cFwiIChpbmNsdWRpbmcgdGhlIGluc3RhbmNlIHdoaWNoIGlzIGNhbGxlZCB1cG9uKSB0byBzeW5jIHRoZW0gd2hlbiB1c2VyIHpvb21zIGluL291dCBvciBwYW4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTeW5jZWRDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3luY2VkQ2hhcnRzKCkge1xuICAgICAgdmFyIGNoYXJ0R3JvdXBzID0gdGhpcy5nZXRHcm91cGVkQ2hhcnRzKCk7XG4gICAgICB2YXIgYWxsQ2hhcnRzID0gW3RoaXNdO1xuXG4gICAgICBpZiAoY2hhcnRHcm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGFsbENoYXJ0cyA9IFtdO1xuICAgICAgICBjaGFydEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIGFsbENoYXJ0cy5wdXNoKGNoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxDaGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjaGFydHMgaW4gdGhlIHNhbWUgXCJncm91cFwiIChleGNsdWRpbmcgdGhlIGluc3RhbmNlIHdoaWNoIGlzIGNhbGxlZCB1cG9uKSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlIG90aGVyIGNoYXJ0cyBvZiB0aGUgc2FtZSBncm91cCAoZWcuLCB0b29sdGlwIGhvdmVyaW5nKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JvdXBlZENoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcm91cGVkQ2hhcnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBBcGV4Ll9jaGFydEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIGlmIChjaC5ncm91cCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudy5jb25maWcuY2hhcnQuZ3JvdXAgPT09IGNoLmdyb3VwID8gY2guY2hhcnQgOiBfdGhpczI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzZXJzIHRvIGFwcGVuZCBEYXRhIHRvIHNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld0RhdGEgLSBOZXcgZGF0YSBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgc2VyaWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZERhdGEobmV3RGF0YSkge1xuICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgbWUudy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIG1lLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICB2YXIgbmV3U2VyaWVzID0gbWUudy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3RGF0YVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0RhdGFbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3U2VyaWVzW2ldLmRhdGEucHVzaChuZXdEYXRhW2ldLmRhdGFbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZS53LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXM7XG5cbiAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsU2VyaWVzKSB7XG4gICAgICAgIG1lLncuZ2xvYmFscy5pbml0aWFsU2VyaWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZS53LmNvbmZpZy5zZXJpZXMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucyQkMSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMzLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIGdyYXBoRGF0YSA9IF90aGlzMy5jcmVhdGUoX3RoaXMzLncuY29uZmlnLnNlcmllcywgb3B0aW9ucyQkMSk7XG5cbiAgICAgICAgaWYgKCFncmFwaERhdGEpIHJldHVybiByZXNvbHZlKF90aGlzMyk7XG5cbiAgICAgICAgX3RoaXMzLm1vdW50KGdyYXBoRGF0YSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMudy5jb25maWcuY2hhcnQuZXZlbnRzLnVwZGF0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF90aGlzMy53LmNvbmZpZy5jaGFydC5ldmVudHMudXBkYXRlZChfdGhpczMsIF90aGlzMy53KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCd1cGRhdGVkJywgW190aGlzMywgX3RoaXMzLnddKTtcblxuICAgICAgICAgIF90aGlzMy53Lmdsb2JhbHMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShfdGhpczMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VYQXhpc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JjZVhBeGlzVXBkYXRlKG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMkJDEueGF4aXMubWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3LmNvbmZpZy54YXhpcy5taW4gPSBvcHRpb25zJCQxLnhheGlzLm1pbjtcbiAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcy5taW4gPSBvcHRpb25zJCQxLnhheGlzLm1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zJCQxLnhheGlzLm1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdy5jb25maWcueGF4aXMubWF4ID0gb3B0aW9ucyQkMS54YXhpcy5tYXg7XG4gICAgICAgIHcuZ2xvYmFscy5sYXN0WEF4aXMubWF4ID0gb3B0aW9ucyQkMS54YXhpcy5tYXg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV2ZXJ0cyB0aGUgeWF4aXMgYW5kIHhheGlzIG1pbi9tYXggdmFsdWVzIHRvIHdoYXQgaXQgd2FzIHdoZW4gdGhlIGNoYXJ0IHdhcyBkZWZpbmVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZml4ZXMgYW4gaW1wb3J0YW50IGJ1ZyB3aGVyZSBhIHVzZXIgbWlnaHQgbG9hZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgem9vbWluZyBpbi9vdXQgb2YgcHJldmlvdXMgc2VyaWVzIHdoaWNoIHJlc3VsdGVkIGluIHdyb25nIG1pbi9tYXhcbiAgICAgKiBBbHNvLCB0aGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgaW50ZXJuYWxseSBvbiB6b29tL3BhbiAtIHRoZSByZXNldCBzaG91bGQgb25seSBoYXBwZW4gd2hlbiB1c2VyIGNhbGxzIHRoZSB1cGRhdGVTZXJpZXMoKSBmdW5jdGlvbiBleHRlcm5hbGx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnREZWZhdWx0QXhpc01pbk1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnREZWZhdWx0QXhpc01pbk1heCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5jb25maWcueGF4aXMubWluID0gdy5nbG9iYWxzLmxhc3RYQXhpcy5taW47XG4gICAgICB3LmNvbmZpZy54YXhpcy5tYXggPSB3Lmdsb2JhbHMubGFzdFhBeGlzLm1heDtcbiAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tZWQpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIGhhcyB6b29tZWQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBnZXQgdGhlIGxhc3RBeGlzIG1pbiBhbmQgbWF4XG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMubGFzdFlBeGlzW2luZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHlheGUubWluID0gdy5nbG9iYWxzLmxhc3RZQXhpc1tpbmRleF0ubWluO1xuICAgICAgICAgICAgeWF4ZS5tYXggPSB3Lmdsb2JhbHMubGFzdFlBeGlzW2luZGV4XS5tYXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBpZiAodGhpcy56b29tUGFuU2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuem9vbVBhblNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRvb2xiYXIpIHtcbiAgICAgICAgdGhpcy50b29sYmFyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jb3JlID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JpZCA9IG51bGw7XG4gICAgICB0aGlzLnNlcmllcyA9IG51bGw7XG4gICAgICB0aGlzLnJlc3BvbnNpdmUgPSBudWxsO1xuICAgICAgdGhpcy50aGVtZSA9IG51bGw7XG4gICAgICB0aGlzLmZvcm1hdHRlcnMgPSBudWxsO1xuICAgICAgdGhpcy50aXRsZVN1YnRpdGxlID0gbnVsbDtcbiAgICAgIHRoaXMubGVnZW5kID0gbnVsbDtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG51bGw7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jcm9zc2hhaXJzID0gbnVsbDtcbiAgICAgIHRoaXMuem9vbVBhblNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnRvb2xiYXIgPSBudWxsO1xuICAgICAgdGhpcy53Lmdsb2JhbHMudG9vbHRpcCA9IG51bGw7XG4gICAgICB0aGlzLmNsZWFyRG9tRWxlbWVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFNWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsU1ZHKGRyYXcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZHJhdy5lYWNoKGZ1bmN0aW9uIChpLCBjaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJyonKTtcbiAgICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgZHJhdy51bmdyb3VwKCk7XG4gICAgICAgIGRyYXcuY2xlYXIoKTtcbiAgICAgICAgcmVzb2x2ZSgnZG9uZScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyRG9tRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJEb21FbGVtZW50cygpIHtcbiAgICAgIHZhciBkb21FbHMgPSB0aGlzLncuZ2xvYmFscy5kb207XG5cbiAgICAgIGlmICh0aGlzLmVsICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgLSByZXNldHRpbmcgdGhlIHdob2xlIGNoYXJ0XG4gICAgICAgIHdoaWxlICh0aGlzLmVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRoaXMuZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5raWxsU1ZHKGRvbUVscy5QYXBlcik7XG4gICAgICBkb21FbHMuUGFwZXIucmVtb3ZlKCk7XG4gICAgICBkb21FbHMuZWxXcmFwID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbEdyYXBoaWNhbCA9IG51bGw7XG4gICAgICBkb21FbHMuZWxMZWdlbmRXcmFwID0gbnVsbDtcbiAgICAgIGRvbUVscy5iYXNlRWwgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JpZFJlY3QgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JpZFJlY3RNYXNrID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbEdyaWRSZWN0TWFya2VyTWFzayA9IG51bGw7XG4gICAgICBkb21FbHMuZWxEZWZzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgY2hhcnQgaW5zdGFuY2UgYnkgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIHdoaWNoIGFsc28gY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHRob3NlIGVsZW1lbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jbGVhcigpOyAvLyByZW1vdmUgdGhlIGNoYXJ0J3MgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIEFwZXguX2NoYXJ0SW5zdGFuY2VzXG5cbiAgICAgIHZhciBjaGFydElEID0gdGhpcy53LmNvbmZpZy5jaGFydC5pZDtcblxuICAgICAgaWYgKGNoYXJ0SUQpIHtcbiAgICAgICAgQXBleC5fY2hhcnRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgIGlmIChjLmlkID09PSBjaGFydElEKSB7XG4gICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlUmVzaXplTGlzdGVuZXIodGhpcy5lbC5wYXJlbnROb2RlLCB0aGlzLnBhcmVudFJlc2l6ZUNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gcHJvdmlkZSBkYXRhIGF0dHJzIGluIHRoZSBlbGVtZW50IGFuZCB0aGUgY2hhcnQgd2lsbCByZW5kZXIgYXV0b21hdGljYWxseSB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBzZWFyY2hpbmcgZm9yIHRoZSBlbGVtZW50cyBjb250YWluaW5nICdkYXRhLWFwZXhjaGFydHMnIGF0dHJpYnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNlcmllcyhzZXJpZXNOYW1lKSB7XG4gICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuc2VyaWVzLmdldFNlcmllc0J5TmFtZShzZXJpZXNOYW1lKTtcbiAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICB2YXIgaXNIaWRkZW4gPSB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkJyk7XG4gICAgICB0aGlzLmxlZ2VuZC50b2dnbGVEYXRhU2VyaWVzKHNlcmllc0NudCwgaXNIaWRkZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFRvZ2dsZVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRvZ2dsZVNlcmllcygpIHtcbiAgICAgIHRoaXMubGVnZW5kLnJlc2V0VG9nZ2xlRGF0YVNlcmllcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGNsaWNrYWJsZUFyZWEgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKHcuZ2xvYmFscy5jaGFydENsYXNzKTtcbiAgICAgIHZhciBldmVudExpc3QgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgICAgZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNsaWNrYWJsZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLndoaWNoID09PSAxKSA7IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnICYmIGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuY2xpY2soZSwgbWUsIHcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5maXJlRXZlbnQoJ2NsaWNrJywgW2UsIG1lLCB3XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb3JlLnNldHVwQnJ1c2hIYW5kbGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFhheGlzQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRYYXhpc0Fubm90YXRpb24ob3B0cykge1xuICAgICAgdmFyIHB1c2hUb01lbW9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIG1lLmFubm90YXRpb25zLmFkZFhheGlzQW5ub3RhdGlvbkV4dGVybmFsKG9wdHMsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRZYXhpc0Fubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5hZGRZYXhpc0Fubm90YXRpb25FeHRlcm5hbChvcHRzLCBwdXNoVG9NZW1vcnksIG1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50QW5ub3RhdGlvbihvcHRzKSB7XG4gICAgICB2YXIgcHVzaFRvTWVtb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgbWUuYW5ub3RhdGlvbnMuYWRkUG9pbnRBbm5vdGF0aW9uRXh0ZXJuYWwob3B0cywgcHVzaFRvTWVtb3J5LCBtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIG1lLmFubm90YXRpb25zLmNsZWFyQW5ub3RhdGlvbnMobWUpO1xuICAgIH0gLy8gVGhpcyBtZXRob2QgaXMgbmV2ZXIgdXNlZCBpbnRlcm5hbGx5IGFuZCB3aWxsIGJlIG9ubHkgY2FsbGVkIGV4dGVybmFsbHkgb24gdGhlIGNoYXJ0IGluc3RhbmNlLlxuICAgIC8vIEhlbmNlLCB3ZSBuZWVkIHRvIGtlZXAgYWxsIHRoZXNlIGVsZW1lbnRzIGluIG1lbW9yeSB3aGVuIHRoZSBjaGFydCBnZXRzIHVwZGF0ZWQgYW5kIHJlZHJhdyBhZ2FpblxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0KG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5hZGRUZXh0KG9wdGlvbnMkJDEsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGFydEFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhcnRBcmVhKCkge1xuICAgICAgdmFyIGVsID0gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1pbm5lcicpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbFhSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbFhSYW5nZShtaW5YLCBtYXhYKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxzWFJhbmdlKG1pblgsIG1heFgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIaWdoZXN0VmFsdWVJblNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIaWdoZXN0VmFsdWVJblNlcmllcygpIHtcbiAgICAgIHZhciBzZXJpZXNJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSQxKHRoaXMuY3R4KTtcbiAgICAgIHZhciBtaW5ZbWF4WSA9IHJhbmdlLmdldE1pbllNYXhZKHNlcmllc0luZGV4KTtcbiAgICAgIHJldHVybiBtaW5ZbWF4WS5oaWdoZXN0WTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG93ZXN0VmFsdWVJblNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb3dlc3RWYWx1ZUluU2VyaWVzKCkge1xuICAgICAgdmFyIHNlcmllc0luZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlJDEodGhpcy5jdHgpO1xuICAgICAgdmFyIG1pblltYXhZID0gcmFuZ2UuZ2V0TWluWU1heFkoc2VyaWVzSW5kZXgpO1xuICAgICAgcmV0dXJuIG1pblltYXhZLmxvd2VzdFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc1RvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc1RvdGFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLnNlcmllc1RvdGFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGVOYW1lKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRMb2NhbGVWYWx1ZXMobG9jYWxlTmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnJlbnRMb2NhbGVWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudExvY2FsZVZhbHVlcyhsb2NhbGVOYW1lKSB7XG4gICAgICB2YXIgbG9jYWxlcyA9IHRoaXMudy5jb25maWcuY2hhcnQubG9jYWxlczsgLy8gY2hlY2sgaWYgdXNlciBoYXMgc3BlY2lmaWVkIGxvY2FsZXMgaW4gZ2xvYmFsIEFwZXggdmFyaWFibGVcbiAgICAgIC8vIGlmIHllcyAtIHRoZW4gZXh0ZW5kIHRob3NlIHdpdGggbG9jYWwgY2hhcnQncyBsb2NhbGVcblxuICAgICAgaWYgKHdpbmRvdy5BcGV4LmNoYXJ0ICYmIHdpbmRvdy5BcGV4LmNoYXJ0LmxvY2FsZXMgJiYgd2luZG93LkFwZXguY2hhcnQubG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvY2FsZXMgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmxvY2FsZXMuY29uY2F0KHdpbmRvdy5BcGV4LmNoYXJ0LmxvY2FsZXMpO1xuICAgICAgfSAvLyBmaW5kIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXkgb2YgbG9jYWxlcyB3aGljaCB1c2VyIGhhcyBzZXQgKGVpdGhlciBieSBjaGFydC5kZWZhdWx0TG9jYWxlIG9yIGJ5IGNhbGxpbmcgc2V0TG9jYWxlKCkgbWV0aG9kLilcblxuXG4gICAgICB2YXIgc2VsZWN0ZWRMb2NhbGUgPSBsb2NhbGVzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5uYW1lID09PSBsb2NhbGVOYW1lO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChzZWxlY3RlZExvY2FsZSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBjb21wbGV0ZSBsb2NhbGUgb2JqZWN0IGJ5IGV4dGVuZGluZyBkZWZhdWx0cyBzbyB5b3UgZG9uJ3QgZ2V0IHVuZGVmaW5lZCBlcnJvcnMuXG4gICAgICAgIHZhciByZXQgPSBVdGlscy5leHRlbmQoZW4sIHNlbGVjdGVkTG9jYWxlKTsgLy8gc3RvcmUgdGhlc2UgbG9jYWxlIG9wdGlvbnMgaW4gZ2xvYmFsIHZhciBmb3IgZWFzZSBhY2Nlc3NcblxuICAgICAgICB0aGlzLncuZ2xvYmFscy5sb2NhbGUgPSByZXQub3B0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbG9jYWxlIG5hbWUgcHJvdmlkZWQuIFBsZWFzZSBtYWtlIHN1cmUgeW91IHNldCB0aGUgY29ycmVjdCBsb2NhbGUgbmFtZSBpbiBvcHRpb25zJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN2Z1VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdmdVcmwoKSB7XG4gICAgICB2YXIgZXhwID0gbmV3IEV4cG9ydHModGhpcy5jdHgpO1xuICAgICAgcmV0dXJuIGV4cC5zdmdVcmwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVVSSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhVVJJKCkge1xuICAgICAgdmFyIGV4cCA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcbiAgICAgIHJldHVybiBleHAuZGF0YVVSSSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXBlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXBlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uUGFwZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFJlc2l6ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcmVudFJlc2l6ZUNhbGxiYWNrKCkge1xuICAgICAgaWYgKHRoaXMudy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkKSB7XG4gICAgICAgIHRoaXMud2luZG93UmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aW5kb3cgcmVzaXplIGFuZCByZS1kcmF3IHRoZSB3aG9sZSBjaGFydC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpbmRvd1Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aW5kb3dSZXNpemUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudy5nbG9iYWxzLnJlc2l6ZVRpbWVyKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnJlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQudy5nbG9iYWxzLnJlc2l6ZWQgPSB0cnVlO1xuICAgICAgICBfdGhpczQudy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gZmFsc2U7IC8vIHdlIG5lZWQgdG8gcmVkcmF3IHRoZSB3aG9sZSBjaGFydCBvbiB3aW5kb3cgcmVzaXplICh3aXRoIGEgc21hbGwgZGVsYXkpLlxuXG4gICAgICAgIF90aGlzNC51cGRhdGUoKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaW5pdE9uTG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0T25Mb2FkKCkge1xuICAgICAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFwZXhjaGFydHNdJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGVsc1tpXTtcbiAgICAgICAgdmFyIG9wdGlvbnMkJDEgPSBKU09OLnBhcnNlKGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9ucycpKTtcbiAgICAgICAgdmFyIGFwZXhDaGFydCA9IG5ldyBBcGV4Q2hhcnRzKGVsLCBvcHRpb25zJCQxKTtcbiAgICAgICAgYXBleENoYXJ0LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgYWxsb3dzIHVzZXJzIHRvIGNhbGwgY2hhcnQgbWV0aG9kcyB3aXRob3V0IG5lY2Vzc2FyaWx5IGZyb20gdGhlXG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGNoYXJ0IGluIGNhc2UgdXNlciBoYXMgYXNzaWduZWQgY2hhcnRJRCB0byB0aGUgdGFyZ2V0dGVkIGNoYXJ0LlxuICAgICAqIFRoZSBjaGFydElEIGlzIHVzZWQgZm9yIG1hcHBpbmcgdGhlIGluc3RhbmNlIHN0b3JlZCBpbiBBcGV4Ll9jaGFydEluc3RhbmNlcyBnbG9iYWwgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlcyB3aGVuIHlvdSBkb24ndCBoYXZlIHJlZmVyZW5jZSBvZiB0aGUgY2hhcnQgaW5zdGFuY2VcbiAgICAgKiBlYXNpbHkgYW5kIG5lZWQgdG8gY2FsbCB0aGUgbWV0aG9kIGZyb20gYW55d2hlcmUuXG4gICAgICogRm9yIGVnLCBpbiBSZWFjdC9WdWUgYXBwbGljYXRpb25zIHdoZW4geW91IGhhdmUgbWFueSBwYXJlbnQvY2hpbGQgY29tcG9uZW50cyxcbiAgICAgKiBhbmQgbmVlZCBlYXN5IHJlZmVyZW5jZSB0byBvdGhlciBjaGFydHMgZm9yIHBlcmZvcm1pbmcgZHluYW1pYyBvcGVyYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRJRCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciB3aGljaCB3aWxsIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogb24gdGhhdCBjaGFydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIFRoZSBwYXJhbWV0ZXJzIHdoaWNoIGFyZSBhY2NlcHRlZCBpbiB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpbGwgYmUgcGFzc2VkIGhlcmUgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWMoY2hhcnRJRCwgZm4pIHtcbiAgICAgIHZhciBjaGFydCA9IHRoaXMuZ2V0Q2hhcnRCeUlEKGNoYXJ0SUQpO1xuICAgICAgaWYgKCFjaGFydCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0cyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG9wdHNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGZuKSB7XG4gICAgICAgIGNhc2UgJ3VwZGF0ZU9wdGlvbnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC51cGRhdGVPcHRpb25zLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndXBkYXRlU2VyaWVzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQudXBkYXRlU2VyaWVzLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYXBwZW5kRGF0YSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmFwcGVuZERhdGEuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRYYXhpc0Fubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRYYXhpc0Fubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRZYXhpc0Fubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRZYXhpc0Fubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRQb2ludEFubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRQb2ludEFubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjbGVhckFubm90YXRpb25zJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuY2xlYXJBbm5vdGF0aW9ucy5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZCh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYXJ0QnlJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFydEJ5SUQoY2hhcnRJRCkge1xuICAgICAgdmFyIGMgPSBBcGV4Ll9jaGFydEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBjaC5pZCA9PT0gY2hhcnRJRDtcbiAgICAgIH0pWzBdO1xuXG4gICAgICByZXR1cm4gYy5jaGFydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXBleENoYXJ0cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQXBleENoYXJ0cyQxO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apexcharts/dist/apexcharts.esm.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzI4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzYwMTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzUxMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzPzgyYjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/harmony-module.js\n");

/***/ }),

/***/ "./src/assetbundles/src/js/overview.js":
/*!*********************************************!*\
  !*** ./src/assetbundles/src/js/overview.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var apexcharts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apexcharts */ \"./node_modules/apexcharts/dist/apexcharts.esm.js\");\n/* global Craft */\n\nvar statPanels = document.getElementById('stat-panels'); //const ordersTableBody = document.querySelector('#stat-orders tbody');\n//const customersTableBody = document.querySelector('#stat-customers tbody');\n\nif (statPanels) {\n  fetchStatPanels(); //fetchOrderAndCustomerSummary();\n}\n\nfunction fetchStatPanels() {\n  Craft.postActionRequest('snipcart/overview/get-stats', {}, function (response, textStatus) {\n    if (textStatus === 'success' && typeof response.error === 'undefined') {\n      var ordersCount = document.getElementById('stat-ordersCount');\n      ordersCount.innerHTML = response.stats.ordersCount;\n      var ordersSales = document.getElementById('stat-ordersSales');\n      ordersSales.innerHTML = response.stats.ordersSales;\n      var averageOrdersValue = document.getElementById('stat-averageOrdersValue');\n      averageOrdersValue.innerHTML = response.stats.averageOrdersValue;\n      var newCustomers = document.getElementById('stat-newCustomers');\n      newCustomers.innerHTML = response.stats.customers.newCustomers;\n      var returningCustomers = document.getElementById('stat-returningCustomers');\n      returningCustomers.innerHTML = response.stats.customers.returningCustomers;\n      var averageCustomerValue = document.getElementById('stat-averageCustomerValue');\n      averageCustomerValue.innerHTML = response.stats.averageCustomerValue;\n    }\n  });\n}\n/*\nfunction fetchOrderAndCustomerSummary() {\n    Craft.postActionRequest(\n        'snipcart/overview/get-orders-customers',\n        {},\n        function(response, textStatus) {\n            if (textStatus === 'success' && typeof (response.error) === 'undefined') {\n\n                response.orders.items.forEach(function(order){\n                    const row = document.createElement('tr');\n\n                    row.setAttribute('data-id', order.token);\n                    row.setAttribute('data-name', order.email);\n\n                    const invoiceColumn = document.createElement('td');\n                    invoiceColumn.innerHTML = `<a href=\"${order.cpUrl}\">${order.invoiceNumber}</a>`;\n\n                    const dateColumn = document.createElement('td');\n                    dateColumn.innerHTML = order.creationDate;\n                    \n                    const nameColumn = document.createElement('td');\n                    nameColumn.innerHTML = order.billingAddressName;\n\n                    const totalColumn = document.createElement('td');\n                    totalColumn.innerHTML = order.finalGrandTotal;\n\n                    row.appendChild(invoiceColumn);\n                    row.appendChild(dateColumn);\n                    row.appendChild(nameColumn);\n                    row.appendChild(totalColumn);\n\n                    ordersTableBody.appendChild(row);\n                });\n\n                response.customers.items.forEach(function(customer){\n                    const row = document.createElement('tr');\n\n                    row.setAttribute('data-id', customer.token);\n                    row.setAttribute('data-name', customer.email);\n\n                    const nameColumn = document.createElement('td');\n                    nameColumn.innerHTML = `<a href=\"${customer.cpUrl}\">${customer.billingAddressName}</a>`;\n\n                    const ordersColumn = document.createElement('td');\n                    ordersColumn.innerHTML = customer.statistics.ordersCount;\n                    \n                    const totalColumn = document.createElement('td');\n                    totalColumn.innerHTML = customer.statistics.ordersAmount;\n\n                    row.appendChild(nameColumn);\n                    row.appendChild(ordersColumn);\n                    row.appendChild(totalColumn);\n\n                    customersTableBody.appendChild(row);\n                });\n            }\n        }\n    );\n}\n*/\n\n\nvar chartContainer = document.getElementById('overview-chart');\ninitChart();\n\nArray.prototype.max = function () {\n  return Math.max.apply(null, this);\n};\n\nfunction initChart() {\n  chartContainer.classList.add('spinner');\n  Craft.postActionRequest('snipcart/charts/get-combined-data', {\n    type: 'totalSales',\n    range: 'monthly'\n  }, function (response, textStatus) {\n    // TODO: gracefully handle error\n    chartContainer.classList.remove('spinner');\n\n    if (textStatus === 'success' && typeof response.error === 'undefined') {\n      var maxOrders = response.series[0].data.max(); //const maxSales = response.series[1].data.max();\n      //console.log(response);\n\n      var options = {\n        chart: {\n          fontFamily: \"system-ui, BlinkMacSystemFont, -apple-system, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif\",\n          height: 220,\n          type: 'line',\n          toolbar: {\n            show: true\n          },\n          animations: {\n            speed: 350,\n            easing: 'easeout',\n            animateGradually: {\n              enabled: false\n            }\n          }\n        },\n        colors: ['#8f98a3', '#0d78f2'],\n        dataLabels: {\n          enabled: false\n        },\n        fill: {\n          type: 'solid'\n        },\n        series: response.series,\n        xaxis: {\n          categories: response.columns,\n          labels: {\n            show: false,\n            formatter: function formatter(val) {\n              var date = new Date(val);\n              return date.getMonth() + '/' + date.getDate();\n            }\n          },\n          axisBorder: {\n            show: false\n          },\n          axisTicks: {\n            show: false\n          }\n        },\n        yaxis: [{\n          min: 0,\n          max: maxOrders * 2,\n          seriesName: 'Orders',\n          decimalsInFloat: 0,\n          axisBorder: {\n            show: false\n          },\n          axisTicks: {\n            show: true\n          },\n          labels: {\n            show: false\n          }\n        }, {\n          // min: 0,\n          // max: Math.ceil(maxSales),\n          seriesName: 'Sales',\n          forceNiceScale: true,\n          axisBorder: {\n            show: false\n          },\n          axisTicks: {\n            show: false\n          },\n          labels: {\n            show: true,\n            offsetX: -25,\n            style: {\n              color: '#8f98a3'\n            },\n            formatter: function formatter(val) {\n              if (response.formats.currencySymbol !== undefined) {\n                return response.formats.currencySymbol + val;\n              }\n\n              return val;\n            }\n          }\n        }],\n        tooltip: {\n          enabled: true,\n          x: {\n            show: false\n          },\n          y: {\n            show: false\n          }\n        },\n        grid: {\n          borderColor: '#e3e5e8',\n          strokeDashArray: 1,\n          padding: {\n            left: -15\n          }\n        },\n        stroke: {\n          width: 2,\n          show: true,\n          curve: 'smooth',\n          lineCap: 'round'\n        },\n        legend: {\n          horizontalAlign: 'right'\n        }\n      };\n      var chart = new apexcharts__WEBPACK_IMPORTED_MODULE_0__[\"default\"](chartContainer, options);\n      chart.render();\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRidW5kbGVzL3NyYy9qcy9vdmVydmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldGJ1bmRsZXMvc3JjL2pzL292ZXJ2aWV3LmpzPzhjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIENyYWZ0ICovXG5cbmltcG9ydCBBcGV4Q2hhcnRzIGZyb20gJ2FwZXhjaGFydHMnXG5cbmNvbnN0IHN0YXRQYW5lbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdC1wYW5lbHMnKTtcbi8vY29uc3Qgb3JkZXJzVGFibGVCb2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N0YXQtb3JkZXJzIHRib2R5Jyk7XG4vL2NvbnN0IGN1c3RvbWVyc1RhYmxlQm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGF0LWN1c3RvbWVycyB0Ym9keScpO1xuXG5pZiAoc3RhdFBhbmVscykge1xuICAgIGZldGNoU3RhdFBhbmVscygpO1xuICAgIC8vZmV0Y2hPcmRlckFuZEN1c3RvbWVyU3VtbWFyeSgpO1xufVxuXG5mdW5jdGlvbiBmZXRjaFN0YXRQYW5lbHMoKSB7XG4gICAgQ3JhZnQucG9zdEFjdGlvblJlcXVlc3QoXG4gICAgICAgICdzbmlwY2FydC9vdmVydmlldy9nZXQtc3RhdHMnLFxuICAgICAgICB7fSxcbiAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0U3RhdHVzID09PSAnc3VjY2VzcycgJiYgdHlwZW9mIChyZXNwb25zZS5lcnJvcikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJzQ291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdC1vcmRlcnNDb3VudCcpO1xuICAgICAgICAgICAgICAgIG9yZGVyc0NvdW50LmlubmVySFRNTCA9IHJlc3BvbnNlLnN0YXRzLm9yZGVyc0NvdW50O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJzU2FsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdC1vcmRlcnNTYWxlcycpO1xuICAgICAgICAgICAgICAgIG9yZGVyc1NhbGVzLmlubmVySFRNTCA9IHJlc3BvbnNlLnN0YXRzLm9yZGVyc1NhbGVzO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXZlcmFnZU9yZGVyc1ZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXQtYXZlcmFnZU9yZGVyc1ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgYXZlcmFnZU9yZGVyc1ZhbHVlLmlubmVySFRNTCA9IHJlc3BvbnNlLnN0YXRzLmF2ZXJhZ2VPcmRlcnNWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0N1c3RvbWVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0LW5ld0N1c3RvbWVycycpO1xuICAgICAgICAgICAgICAgIG5ld0N1c3RvbWVycy5pbm5lckhUTUwgPSByZXNwb25zZS5zdGF0cy5jdXN0b21lcnMubmV3Q3VzdG9tZXJzO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuaW5nQ3VzdG9tZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXQtcmV0dXJuaW5nQ3VzdG9tZXJzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuaW5nQ3VzdG9tZXJzLmlubmVySFRNTCA9IHJlc3BvbnNlLnN0YXRzLmN1c3RvbWVycy5yZXR1cm5pbmdDdXN0b21lcnM7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhdmVyYWdlQ3VzdG9tZXJWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0LWF2ZXJhZ2VDdXN0b21lclZhbHVlJyk7XG4gICAgICAgICAgICAgICAgYXZlcmFnZUN1c3RvbWVyVmFsdWUuaW5uZXJIVE1MID0gcmVzcG9uc2Uuc3RhdHMuYXZlcmFnZUN1c3RvbWVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG4vKlxuZnVuY3Rpb24gZmV0Y2hPcmRlckFuZEN1c3RvbWVyU3VtbWFyeSgpIHtcbiAgICBDcmFmdC5wb3N0QWN0aW9uUmVxdWVzdChcbiAgICAgICAgJ3NuaXBjYXJ0L292ZXJ2aWV3L2dldC1vcmRlcnMtY3VzdG9tZXJzJyxcbiAgICAgICAge30sXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dFN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHR5cGVvZiAocmVzcG9uc2UuZXJyb3IpID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub3JkZXJzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24ob3JkZXIpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBvcmRlci50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScsIG9yZGVyLmVtYWlsKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnZvaWNlQ29sdW1uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgaW52b2ljZUNvbHVtbi5pbm5lckhUTUwgPSBgPGEgaHJlZj1cIiR7b3JkZXIuY3BVcmx9XCI+JHtvcmRlci5pbnZvaWNlTnVtYmVyfTwvYT5gO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRlQ29sdW1uLmlubmVySFRNTCA9IG9yZGVyLmNyZWF0aW9uRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lQ29sdW1uLmlubmVySFRNTCA9IG9yZGVyLmJpbGxpbmdBZGRyZXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbENvbHVtbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ29sdW1uLmlubmVySFRNTCA9IG9yZGVyLmZpbmFsR3JhbmRUb3RhbDtcblxuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoaW52b2ljZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChkYXRlQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKG5hbWVDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodG90YWxDb2x1bW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyc1RhYmxlQm9keS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuY3VzdG9tZXJzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24oY3VzdG9tZXIpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBjdXN0b21lci50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScsIGN1c3RvbWVyLmVtYWlsKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lQ29sdW1uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUNvbHVtbi5pbm5lckhUTUwgPSBgPGEgaHJlZj1cIiR7Y3VzdG9tZXIuY3BVcmx9XCI+JHtjdXN0b21lci5iaWxsaW5nQWRkcmVzc05hbWV9PC9hPmA7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJzQ29sdW1uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJzQ29sdW1uLmlubmVySFRNTCA9IGN1c3RvbWVyLnN0YXRpc3RpY3Mub3JkZXJzQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbENvbHVtbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ29sdW1uLmlubmVySFRNTCA9IGN1c3RvbWVyLnN0YXRpc3RpY3Mub3JkZXJzQW1vdW50O1xuXG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChuYW1lQ29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKG9yZGVyc0NvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0b3RhbENvbHVtbik7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tZXJzVGFibGVCb2R5LmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufVxuKi9cblxuY29uc3QgY2hhcnRDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3ZlcnZpZXctY2hhcnQnKTtcblxuXG5pbml0Q2hhcnQoKTtcblxuQXJyYXkucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRDaGFydCgpIHtcbiAgICBjaGFydENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzcGlubmVyJyk7XG5cbiAgICBDcmFmdC5wb3N0QWN0aW9uUmVxdWVzdChcbiAgICAgICAgJ3NuaXBjYXJ0L2NoYXJ0cy9nZXQtY29tYmluZWQtZGF0YScsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0b3RhbFNhbGVzJyxcbiAgICAgICAgICAgIHJhbmdlOiAnbW9udGhseScsXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBncmFjZWZ1bGx5IGhhbmRsZSBlcnJvclxuICAgICAgICAgICAgY2hhcnRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc3Bpbm5lcicpO1xuXG4gICAgICAgICAgICBpZiAodGV4dFN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHR5cGVvZiAocmVzcG9uc2UuZXJyb3IpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heE9yZGVycyA9IHJlc3BvbnNlLnNlcmllc1swXS5kYXRhLm1heCgpO1xuICAgICAgICAgICAgICAgIC8vY29uc3QgbWF4U2FsZXMgPSByZXNwb25zZS5zZXJpZXNbMV0uZGF0YS5tYXgoKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAtYXBwbGUtc3lzdGVtLCAnU2Vnb2UgVUknLCAnUm9ib3RvJywgJ094eWdlbicsICdVYnVudHUnLCAnQ2FudGFyZWxsJywgJ0ZpcmEgU2FucycsICdEcm9pZCBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVlZDogMzUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVHcmFkdWFsbHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogWycjOGY5OGEzJywgJyMwZDc4ZjInXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHJlc3BvbnNlLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IHJlc3BvbnNlLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgJy8nICsgZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB5YXhpczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG1heE9yZGVycyAqIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogJ09yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHNJbkZsb2F0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heDogTWF0aC5jZWlsKG1heFNhbGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNOYW1lOiAnU2FsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlTmljZVNjYWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNUaWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiAtMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM4Zjk4YTMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmZvcm1hdHMuY3VycmVuY3lTeW1ib2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5mb3JtYXRzLmN1cnJlbmN5U3ltYm9sICsgdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZTNlNWU4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAtMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlOiAnc21vb3RoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDYXA6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWduOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hhcnQgPSBuZXcgQXBleENoYXJ0cyhcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBUEE7QUFlQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBWkE7QUFnQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVhBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQVhBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBekdBO0FBOEdBO0FBS0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assetbundles/src/js/overview.js\n");

/***/ })

/******/ });